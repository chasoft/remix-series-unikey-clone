var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require2() {
  return mod || (0, cb2[Object.keys(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    init_react();
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty2.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty2.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement10(type, config2, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            self2 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index2) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape2("" + element.key);
          }
          return index2.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c2) {
                return c2;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext9(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef4(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render.displayName == null) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare3) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare3 === void 0 ? null : compare3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type.displayName == null) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext16(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState5(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init2);
        }
        function useRef10(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect13(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect5(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback6(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo7(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame2 = componentFrameCache.get(fn);
            if (frame2 !== void 0) {
              return frame2;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
                c2--;
              }
              for (; s >= 1 && c2 >= 0; s--, c2--) {
                if (sampleLines[s] !== controlLines[c2]) {
                  if (s !== 1 || c2 !== 1) {
                    do {
                      s--;
                      c2--;
                      if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement10.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            new Map([[frozenObject, null]]);
            new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext9;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef4;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback6;
        exports.useContext = useContext16;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect13;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect5;
        exports.useMemo = useMemo7;
        exports.useReducer = useReducer;
        exports.useRef = useRef10;
        exports.useState = useState5;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/@remix-run/dev/compiler/shims/react.ts
var React;
var init_react = __esm({
  "node_modules/@remix-run/dev/compiler/shims/react.ts"() {
    React = __toModule(require_react());
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    init_react();
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValue = parts.shift().split("=");
      var name = nameValue.shift();
      var value = nameValue.join("=");
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      try {
        value = options2.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parse2(input, options2) {
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!input) {
        if (!options2.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options2.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!options2.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options2);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options2);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse2;
    module.exports.parse = parse2;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports, module) {
    init_react();
    "use strict";
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty2.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach2 = (array, callback) => {
      const length = array.length;
      let index2 = -1;
      while (++index2 < length) {
        callback(array[index2]);
      }
    };
    var fourHexEscape = (hex2) => {
      return "\\u" + ("0000" + hex2).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase)
        return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString3 = object.toString;
    var isArray3 = Array.isArray;
    var isBuffer2 = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject2 = (value) => {
      return toString3.call(value) == "[object Object]";
    };
    var isString3 = (value) => {
      return typeof value == "string" || toString3.call(value) == "[object String]";
    };
    var isNumber2 = (value) => {
      return typeof value == "number" || toString3.call(value) == "[object Number]";
    };
    var isFunction2 = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString3.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString3.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc2 = (argument, options2) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options2.indentLevel;
        indent = options2.indent.repeat(options2.indentLevel);
      };
      const defaults2 = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json2 = options2 && options2.json;
      if (json2) {
        defaults2.quotes = "double";
        defaults2.wrap = true;
      }
      options2 = extend(defaults2, options2);
      if (options2.quotes != "single" && options2.quotes != "double" && options2.quotes != "backtick") {
        options2.quotes = "single";
      }
      const quote = options2.quotes == "double" ? '"' : options2.quotes == "backtick" ? "`" : "'";
      const compact = options2.compact;
      const lowercaseHex = options2.lowercaseHex;
      let indent = options2.indent.repeat(options2.indentLevel);
      let oldIndent = "";
      const inline1 = options2.__inline1__;
      const inline2 = options2.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options2.numbers == "binary";
      const useOctNumbers = options2.numbers == "octal";
      const useDecNumbers = options2.numbers == "decimal";
      const useHexNumbers = options2.numbers == "hexadecimal";
      if (json2 && argument && isFunction2(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString3(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options2.__inline1__ = true;
            options2.__inline2__ = false;
          }
          return "new Map(" + jsesc2(Array.from(argument), options2) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc2(Array.from(argument), options2) + ")";
        }
        if (isBuffer2(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc2(Array.from(argument), options2) + ")";
        }
        if (isArray3(argument)) {
          result = [];
          options2.wrap = true;
          if (inline1) {
            options2.__inline1__ = false;
            options2.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach2(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options2.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent) + jsesc2(value, options2));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json2) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json2) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options2.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent) + jsesc2(key, options2) + ":" + (compact ? "" : " ") + jsesc2(value, options2));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options2.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index2, string) => {
        if (pair) {
          if (options2.minimal)
            return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options2.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex3 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex3 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json2 && !regexDigit.test(string.charAt(index2 + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options2.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options2.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex2 = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json2 || hex2.length > 2) {
          return fourHexEscape(hex2);
        }
        return "\\x" + ("00" + hex2).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options2.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--");
      }
      if (options2.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc2.version = "3.0.2";
    module.exports = jsesc2;
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index2) {
  for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    init_react();
    "use strict";
    EventHandlers.prototype = Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain3;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain3 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain3) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain3;
          er.domainThrown = false;
          domain3.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain3.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance2, performanceNow, startTime, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_react();
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance2 = globalThis.performance || {};
    performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_react();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned2 = false;
  function deprecated() {
    if (!warned2) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned2 = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_react();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b2, n, m) {
  var i = b2[n];
  b2[n] = b2[m];
  b2[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    init_react();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a2, b2) {
      if (!internalIsBuffer(a2) || !internalIsBuffer(b2)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a2 === b2)
        return 0;
      var x = a2.length;
      var y = b2.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a2[i] !== b2[i]) {
          x = a2[i];
          y = b2[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b2) {
      if (!internalIsBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_react();
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry2 = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry2;
      else
        this.head = entry2;
      this.tail = entry2;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry2 = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry2;
      this.head = entry2;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_react();
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c2 = buffer[buffer.length - i];
        if (i == 1 && c2 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c2 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c2 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options2, stream) {
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.readableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options2.encoding) {
    this.decoder = new StringDecoder(options2.encoding);
    this.encoding = options2.encoding;
  }
}
function Readable(options2) {
  if (!(this instanceof Readable))
    return new Readable(options2);
  this._readableState = new ReadableState(options2, this);
  this.readable = true;
  if (options2 && typeof options2.read === "function")
    this._read = options2.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c2 = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c2;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c2 = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c2;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    init_react();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    "use strict";
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb2) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb2;
  this.next = null;
}
function WritableState(options2, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.writableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options2.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options2);
  this._writableState = new WritableState(options2, this);
  this.writable = true;
  if (options2) {
    if (typeof options2.write === "function")
      this._write = options2.write;
    if (typeof options2.writev === "function")
      this._writev = options2.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb2) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb2, er);
}
function validChunk(stream, state, chunk, cb2) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb2, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb2) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb2);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb2);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb2) {
  state.writelen = len;
  state.writecb = cb2;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync2, er, cb2) {
  --state.pendingcb;
  if (sync2)
    nextTick(cb2, er);
  else
    cb2(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync2 = state.sync;
  var cb2 = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync2, er, cb2);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync2) {
      nextTick(afterWrite, stream, state, finished, cb2);
    } else {
      afterWrite(stream, state, finished, cb2);
    }
  }
}
function afterWrite(stream, state, finished, cb2) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb2();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry2;
    var count = 0;
    while (entry2) {
      buffer[count] = entry2;
      entry2 = entry2.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry2) {
      var chunk = entry2.chunk;
      var encoding = entry2.encoding;
      var cb2 = entry2.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb2);
      entry2 = entry2.next;
      if (state.writing) {
        break;
      }
    }
    if (entry2 === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry2;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb2) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb2) {
    if (state.finished)
      nextTick(cb2);
    else
      stream.once("finish", cb2);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry2 = _this.entry;
    _this.entry = null;
    while (entry2) {
      var cb2 = entry2.callback;
      state.pendingcb--;
      cb2(err);
      entry2 = entry2.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_react();
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb2) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb2 !== "function")
        cb2 = nop;
      if (state.ended)
        writeAfterEnd(this, cb2);
      else if (validChunk(this, state, chunk, cb2)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb2);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb2) {
      cb2(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb2) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb2 = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb2);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options2) {
  if (!(this instanceof Duplex))
    return new Duplex(options2);
  Readable.call(this, options2);
  Writable.call(this, options2);
  if (options2 && options2.readable === false)
    this.readable = false;
  if (options2 && options2.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options2 && options2.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_react();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb2 = ts.writecb;
  if (!cb2)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb2(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options2) {
  if (!(this instanceof Transform))
    return new Transform(options2);
  Duplex.call(this, options2);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_react();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb2) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb2) {
      var ts = this._transformState;
      ts.writecb = cb2;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform.call(this, options2);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_react();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb2) {
      cb2(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_react();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options2) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options2 || options2.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_react();
    var polyfill = (init_stream(), stream_exports);
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React19 = require_react();
        var _assign = require_object_assign();
        var stream = require_stream();
        var ReactVersion = "17.0.2";
        function formatProdErrorMessage(code) {
          var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;
          for (var i2 = 1; i2 < arguments.length; i2++) {
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
          }
          return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var ReactSharedInternals = React19.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var enableSuspenseServerRenderer = false;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame2 = componentFrameCache.get(fn);
            if (frame2 !== void 0) {
              return frame2;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
                c2--;
              }
              for (; s >= 1 && c2 >= 0; s--, c2--) {
                if (sampleLines[s] !== controlLines[c2]) {
                  if (s !== 1 || c2 !== 1) {
                    do {
                      s--;
                      c2--;
                      if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutInvalidateContextType = new Set();
        }
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function maskContext(type, context) {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        }
        function checkContextTypes(typeSpecs, values, location) {
          {
            checkPropTypes(typeSpecs, values, location, "Component");
          }
        }
        function validateContextBounds(context, threadID) {
          for (var i2 = context._threadCount | 0; i2 <= threadID; i2++) {
            context[i2] = context._currentValue2;
            context._threadCount = i2 + 1;
          }
        }
        function processContext(type, context, threadID, isClass) {
          if (isClass) {
            var contextType = type.contextType;
            {
              if ("contextType" in type) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
                  didWarnAboutInvalidateContextType.add(type);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              validateContextBounds(contextType, threadID);
              return contextType[threadID];
            }
            {
              var maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, maskedContext, "context");
                }
              }
              return maskedContext;
            }
          } else {
            {
              var _maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, _maskedContext, "context");
                }
              }
              return _maskedContext;
            }
          }
        }
        var nextAvailableThreadIDs = new Uint16Array(16);
        for (var i = 0; i < 15; i++) {
          nextAvailableThreadIDs[i] = i + 1;
        }
        nextAvailableThreadIDs[15] = 0;
        function growThreadCountAndReturnNextAvailable() {
          var oldArray = nextAvailableThreadIDs;
          var oldSize = oldArray.length;
          var newSize = oldSize * 2;
          if (!(newSize <= 65536)) {
            {
              throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
            }
          }
          var newArray = new Uint16Array(newSize);
          newArray.set(oldArray);
          nextAvailableThreadIDs = newArray;
          nextAvailableThreadIDs[0] = oldSize + 1;
          for (var _i = oldSize; _i < newSize - 1; _i++) {
            nextAvailableThreadIDs[_i] = _i + 1;
          }
          nextAvailableThreadIDs[newSize - 1] = 0;
          return oldSize;
        }
        function allocThreadID() {
          var nextID = nextAvailableThreadIDs[0];
          if (nextID === 0) {
            return growThreadCountAndReturnNextAvailable();
          }
          nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
          return nextID;
        }
        function freeThreadID(id2) {
          nextAvailableThreadIDs[id2] = nextAvailableThreadIDs[0];
          nextAvailableThreadIDs[0] = id2;
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape2;
          var html = "";
          var index2;
          var lastIndex = 0;
          for (index2 = match.index; index2 < str.length; index2++) {
            switch (str.charCodeAt(index2)) {
              case 34:
                escape2 = "&quot;";
                break;
              case 38:
                escape2 = "&amp;";
                break;
              case 39:
                escape2 = "&#x27;";
                break;
              case 60:
                escape2 = "&lt;";
                break;
              case 62:
                escape2 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index2) {
              html += str.substring(lastIndex, index2);
            }
            lastIndex = index2 + 1;
            html += escape2;
          }
          return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        function quoteAttributeValueForBrowser(value) {
          return '"' + escapeTextForBrowser(value) + '"';
        }
        function createMarkupForRoot() {
          return ROOT_ATTRIBUTE_NAME + '=""';
        }
        function createMarkupForProperty(name, value) {
          var propertyInfo = getPropertyInfo(name);
          if (name !== "style" && shouldIgnoreAttribute(name, propertyInfo, false)) {
            return "";
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
            return "";
          }
          if (propertyInfo !== null) {
            var attributeName = propertyInfo.attributeName;
            var type = propertyInfo.type;
            if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
              return attributeName + '=""';
            } else {
              if (propertyInfo.sanitizeURL) {
                value = "" + value;
                sanitizeURL(value);
              }
              return attributeName + "=" + quoteAttributeValueForBrowser(value);
            }
          } else if (isAttributeNameSafe(name)) {
            return name + "=" + quoteAttributeValueForBrowser(value);
          }
          return "";
        }
        function createMarkupForCustomAttribute(name, value) {
          if (!isAttributeNameSafe(name) || value == null) {
            return "";
          }
          return name + "=" + quoteAttributeValueForBrowser(value);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (!(currentlyRenderingComponent !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
            if (objectIs(nextDeps[i2], prevDeps[i2])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            {
              {
                throw Error("Rendered more hooks than during the previous render");
              }
            }
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          {
            isInHookUserCodeInDev = false;
          }
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext(context, observedBits) {
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return context[threadID];
        }
        function useContext16(context, observedBits) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          return context[threadID];
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState5(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(basicStateReducer, initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init2 !== void 0 ? init2(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo7(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef10(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect5(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
            {
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback6(callback, deps) {
          return useMemo7(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function useTransition2() {
          resolveCurrentlyRenderingComponent();
          var startTransition = function(callback) {
            callback();
          };
          return [startTransition, false];
        }
        function useOpaqueIdentifier() {
          return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
        }
        function noop2() {
        }
        var currentPartialRenderer = null;
        function setCurrentPartialRenderer(renderer) {
          currentPartialRenderer = renderer;
        }
        var Dispatcher = {
          readContext,
          useContext: useContext16,
          useMemo: useMemo7,
          useReducer,
          useRef: useRef10,
          useState: useState5,
          useLayoutEffect: useLayoutEffect5,
          useCallback: useCallback6,
          useImperativeHandle: noop2,
          useEffect: noop2,
          useDebugValue: noop2,
          useDeferredValue,
          useTransition: useTransition2,
          useOpaqueIdentifier,
          useMutableSource
        };
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var ariaProperties = {
          "aria-current": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var toArray = React19.Children.toArray;
        var currentDebugStacks = [];
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1;
        var prevGetCurrentStackImpl = null;
        var getCurrentServerStackImpl = function() {
          return "";
        };
        var describeStackFrame = function(element) {
          return "";
        };
        var validatePropertiesInDevelopment = function(type, props) {
        };
        var pushCurrentDebugStack = function(stack) {
        };
        var pushElementToDebugStack = function(element) {
        };
        var popCurrentDebugStack = function() {
        };
        var hasWarnedAboutUsingContextAsConsumer = false;
        {
          ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
          };
          describeStackFrame = function(element) {
            return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
          };
          pushCurrentDebugStack = function(stack) {
            currentDebugStacks.push(stack);
            if (currentDebugStacks.length === 1) {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
            }
          };
          pushElementToDebugStack = function(element) {
            var stack = currentDebugStacks[currentDebugStacks.length - 1];
            var frame2 = stack[stack.length - 1];
            frame2.debugElementStack.push(element);
          };
          popCurrentDebugStack = function() {
            currentDebugStacks.pop();
            if (currentDebugStacks.length === 0) {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              prevGetCurrentStackImpl = null;
            }
          };
          getCurrentServerStackImpl = function() {
            if (currentDebugStacks.length === 0) {
              return "";
            }
            var frames = currentDebugStacks[currentDebugStacks.length - 1];
            var stack = "";
            for (var i2 = frames.length - 1; i2 >= 0; i2--) {
              var frame2 = frames[i2];
              var debugElementStack = frame2.debugElementStack;
              for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
                stack += describeStackFrame(debugElementStack[ii]);
              }
            }
            return stack;
          };
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUndefinedDerivedState = {};
        var didWarnAboutUninitializedState = {};
        var valuePropNames = ["value", "defaultValue"];
        var newlineEatingTags = {
          listing: true,
          pre: true,
          textarea: true
        };
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        function validateDangerousTag(tag) {
          if (!validatedTagCache.hasOwnProperty(tag)) {
            if (!VALID_TAG_REGEX.test(tag)) {
              {
                throw Error("Invalid tag: " + tag);
              }
            }
            validatedTagCache[tag] = true;
          }
        }
        var styleNameCache = {};
        var processStyleName = function(styleName) {
          if (styleNameCache.hasOwnProperty(styleName)) {
            return styleNameCache[styleName];
          }
          var result = hyphenateStyleName(styleName);
          styleNameCache[styleName] = result;
          return result;
        };
        function createMarkupForStyles(styles) {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            var styleValue = styles[styleName];
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styleValue);
              }
            }
            if (styleValue != null) {
              serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentName(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function getNonChildrenInnerMarkup(props) {
          var innerHTML = props.dangerouslySetInnerHTML;
          if (innerHTML != null) {
            if (innerHTML.__html != null) {
              return innerHTML.__html;
            }
          } else {
            var content = props.children;
            if (typeof content === "string" || typeof content === "number") {
              return escapeTextForBrowser(content);
            }
          }
          return null;
        }
        function flattenTopLevelChildren(children) {
          if (!React19.isValidElement(children)) {
            return toArray(children);
          }
          var element = children;
          if (element.type !== REACT_FRAGMENT_TYPE) {
            return [element];
          }
          var fragmentChildren = element.props.children;
          if (!React19.isValidElement(fragmentChildren)) {
            return toArray(fragmentChildren);
          }
          var fragmentChildElement = fragmentChildren;
          return [fragmentChildElement];
        }
        function flattenOptionChildren(children) {
          if (children === void 0 || children === null) {
            return children;
          }
          var content = "";
          React19.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Only strings and numbers are supported as <option> children.");
              }
            }
          });
          return content;
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var STYLE = "style";
        var RESERVED_PROPS = {
          children: null,
          dangerouslySetInnerHTML: null,
          suppressContentEditableWarning: null,
          suppressHydrationWarning: null
        };
        function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
          var ret = "<" + tagVerbatim;
          var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
          for (var propKey in props) {
            if (!hasOwnProperty$2.call(props, propKey)) {
              continue;
            }
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            if (propKey === STYLE) {
              propValue = createMarkupForStyles(propValue);
            }
            var markup = null;
            if (isCustomComponent$1) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += " " + markup;
            }
          }
          if (makeStaticMarkup) {
            return ret;
          }
          if (isRootElement) {
            ret += " " + createMarkupForRoot();
          }
          return ret;
        }
        function validateRenderResult(child, type) {
          if (child === void 0) {
            {
              {
                throw Error((getComponentName(type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
              }
            }
          }
        }
        function resolve(child, context, threadID) {
          while (React19.isValidElement(child)) {
            var element = child;
            var Component = element.type;
            {
              pushElementToDebugStack(element);
            }
            if (typeof Component !== "function") {
              break;
            }
            processChild(element, Component);
          }
          function processChild(element2, Component2) {
            var isClass = shouldConstruct$1(Component2);
            var publicContext = processContext(Component2, context, threadID, isClass);
            var queue2 = [];
            var replace = false;
            var updater = {
              isMounted: function(publicInstance) {
                return false;
              },
              enqueueForceUpdate: function(publicInstance) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "forceUpdate");
                  return null;
                }
              },
              enqueueReplaceState: function(publicInstance, completeState) {
                replace = true;
                queue2 = [completeState];
              },
              enqueueSetState: function(publicInstance, currentPartialState) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "setState");
                  return null;
                }
                queue2.push(currentPartialState);
              }
            };
            var inst;
            if (isClass) {
              inst = new Component2(element2.props, publicContext, updater);
              if (typeof Component2.getDerivedStateFromProps === "function") {
                {
                  if (inst.state === null || inst.state === void 0) {
                    var componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUninitializedState[componentName]) {
                      error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName);
                      didWarnAboutUninitializedState[componentName] = true;
                    }
                  }
                }
                var partialState = Component2.getDerivedStateFromProps.call(null, element2.props, inst.state);
                {
                  if (partialState === void 0) {
                    var _componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                      error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName);
                      didWarnAboutUndefinedDerivedState[_componentName] = true;
                    }
                  }
                }
                if (partialState != null) {
                  inst.state = _assign({}, inst.state, partialState);
                }
              }
            } else {
              {
                if (Component2.prototype && typeof Component2.prototype.render === "function") {
                  var _componentName2 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutBadClass[_componentName2]) {
                    error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2);
                    didWarnAboutBadClass[_componentName2] = true;
                  }
                }
              }
              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              inst = Component2(element2.props, publicContext, updater);
              inst = finishHooks(Component2, element2.props, inst, publicContext);
              {
                if (inst != null && inst.render != null) {
                  var _componentName3 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutModulePatternComponent[_componentName3]) {
                    error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3);
                    didWarnAboutModulePatternComponent[_componentName3] = true;
                  }
                }
              }
              if (inst == null || inst.render == null) {
                child = inst;
                validateRenderResult(child, Component2);
                return;
              }
            }
            inst.props = element2.props;
            inst.context = publicContext;
            inst.updater = updater;
            var initialState = inst.state;
            if (initialState === void 0) {
              inst.state = initialState = null;
            }
            if (typeof inst.UNSAFE_componentWillMount === "function" || typeof inst.componentWillMount === "function") {
              if (typeof inst.componentWillMount === "function") {
                {
                  if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                    var _componentName4 = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                      warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", _componentName4);
                      didWarnAboutDeprecatedWillMount[_componentName4] = true;
                    }
                  }
                }
                if (typeof Component2.getDerivedStateFromProps !== "function") {
                  inst.componentWillMount();
                }
              }
              if (typeof inst.UNSAFE_componentWillMount === "function" && typeof Component2.getDerivedStateFromProps !== "function") {
                inst.UNSAFE_componentWillMount();
              }
              if (queue2.length) {
                var oldQueue = queue2;
                var oldReplace = replace;
                queue2 = null;
                replace = false;
                if (oldReplace && oldQueue.length === 1) {
                  inst.state = oldQueue[0];
                } else {
                  var nextState = oldReplace ? oldQueue[0] : inst.state;
                  var dontMutate = true;
                  for (var i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2];
                    var _partialState = typeof partial === "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                    if (_partialState != null) {
                      if (dontMutate) {
                        dontMutate = false;
                        nextState = _assign({}, nextState, _partialState);
                      } else {
                        _assign(nextState, _partialState);
                      }
                    }
                  }
                  inst.state = nextState;
                }
              } else {
                queue2 = null;
              }
            }
            child = inst.render();
            {
              if (child === void 0 && inst.render._isMockFunction) {
                child = null;
              }
            }
            validateRenderResult(child, Component2);
            var childContext;
            {
              if (typeof inst.getChildContext === "function") {
                var _childContextTypes = Component2.childContextTypes;
                if (typeof _childContextTypes === "object") {
                  childContext = inst.getChildContext();
                  for (var contextKey in childContext) {
                    if (!(contextKey in _childContextTypes)) {
                      {
                        throw Error((getComponentName(Component2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                      }
                    }
                  }
                } else {
                  {
                    error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component2) || "Unknown");
                  }
                }
              }
              if (childContext) {
                context = _assign({}, context, childContext);
              }
            }
          }
          return {
            child,
            context
          };
        }
        var ReactDOMServerRenderer = /* @__PURE__ */ function() {
          function ReactDOMServerRenderer2(children, makeStaticMarkup, options2) {
            var flatChildren = flattenTopLevelChildren(children);
            var topFrame = {
              type: null,
              domNamespace: Namespaces.html,
              children: flatChildren,
              childIndex: 0,
              context: emptyObject,
              footer: ""
            };
            {
              topFrame.debugElementStack = [];
            }
            this.threadID = allocThreadID();
            this.stack = [topFrame];
            this.exhausted = false;
            this.currentSelectValue = null;
            this.previousWasTextNode = false;
            this.makeStaticMarkup = makeStaticMarkup;
            this.suspenseDepth = 0;
            this.contextIndex = -1;
            this.contextStack = [];
            this.contextValueStack = [];
            this.uniqueID = 0;
            this.identifierPrefix = options2 && options2.identifierPrefix || "";
            {
              this.contextProviderStack = [];
            }
          }
          var _proto = ReactDOMServerRenderer2.prototype;
          _proto.destroy = function destroy() {
            if (!this.exhausted) {
              this.exhausted = true;
              this.clearProviders();
              freeThreadID(this.threadID);
            }
          };
          _proto.pushProvider = function pushProvider(provider) {
            var index2 = ++this.contextIndex;
            var context = provider.type._context;
            var threadID = this.threadID;
            validateContextBounds(context, threadID);
            var previousValue = context[threadID];
            this.contextStack[index2] = context;
            this.contextValueStack[index2] = previousValue;
            {
              this.contextProviderStack[index2] = provider;
            }
            context[threadID] = provider.props.value;
          };
          _proto.popProvider = function popProvider(provider) {
            var index2 = this.contextIndex;
            {
              if (index2 < 0 || provider !== this.contextProviderStack[index2]) {
                error("Unexpected pop.");
              }
            }
            var context = this.contextStack[index2];
            var previousValue = this.contextValueStack[index2];
            this.contextStack[index2] = null;
            this.contextValueStack[index2] = null;
            {
              this.contextProviderStack[index2] = null;
            }
            this.contextIndex--;
            context[this.threadID] = previousValue;
          };
          _proto.clearProviders = function clearProviders() {
            for (var index2 = this.contextIndex; index2 >= 0; index2--) {
              var context = this.contextStack[index2];
              var previousValue = this.contextValueStack[index2];
              context[this.threadID] = previousValue;
            }
          };
          _proto.read = function read2(bytes) {
            if (this.exhausted) {
              return null;
            }
            var prevPartialRenderer = currentPartialRenderer;
            setCurrentPartialRenderer(this);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            try {
              var out = [""];
              var suspended = false;
              while (out[0].length < bytes) {
                if (this.stack.length === 0) {
                  this.exhausted = true;
                  freeThreadID(this.threadID);
                  break;
                }
                var frame2 = this.stack[this.stack.length - 1];
                if (suspended || frame2.childIndex >= frame2.children.length) {
                  var footer = frame2.footer;
                  if (footer !== "") {
                    this.previousWasTextNode = false;
                  }
                  this.stack.pop();
                  if (frame2.type === "select") {
                    this.currentSelectValue = null;
                  } else if (frame2.type != null && frame2.type.type != null && frame2.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                    var provider = frame2.type;
                    this.popProvider(provider);
                  } else if (frame2.type === REACT_SUSPENSE_TYPE) {
                    this.suspenseDepth--;
                    var buffered = out.pop();
                    if (suspended) {
                      suspended = false;
                      var fallbackFrame = frame2.fallbackFrame;
                      if (!fallbackFrame) {
                        {
                          throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                        }
                      }
                      this.stack.push(fallbackFrame);
                      out[this.suspenseDepth] += "<!--$!-->";
                      continue;
                    } else {
                      out[this.suspenseDepth] += buffered;
                    }
                  }
                  out[this.suspenseDepth] += footer;
                  continue;
                }
                var child = frame2.children[frame2.childIndex++];
                var outBuffer = "";
                if (true) {
                  pushCurrentDebugStack(this.stack);
                  frame2.debugElementStack.length = 0;
                }
                try {
                  outBuffer += this.render(child, frame2.context, frame2.domNamespace);
                } catch (err) {
                  if (err != null && typeof err.then === "function") {
                    if (enableSuspenseServerRenderer) {
                      if (!(this.suspenseDepth > 0)) {
                        {
                          throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                        }
                      }
                      suspended = true;
                    } else {
                      if (true) {
                        {
                          throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                        }
                      }
                    }
                  } else {
                    throw err;
                  }
                } finally {
                  if (true) {
                    popCurrentDebugStack();
                  }
                }
                if (out.length <= this.suspenseDepth) {
                  out.push("");
                }
                out[this.suspenseDepth] += outBuffer;
              }
              return out[0];
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
              setCurrentPartialRenderer(prevPartialRenderer);
              resetHooksState();
            }
          };
          _proto.render = function render(child, context, parentNamespace) {
            if (typeof child === "string" || typeof child === "number") {
              var text = "" + child;
              if (text === "") {
                return "";
              }
              if (this.makeStaticMarkup) {
                return escapeTextForBrowser(text);
              }
              if (this.previousWasTextNode) {
                return "<!-- -->" + escapeTextForBrowser(text);
              }
              this.previousWasTextNode = true;
              return escapeTextForBrowser(text);
            } else {
              var nextChild;
              var _resolve = resolve(child, context, this.threadID);
              nextChild = _resolve.child;
              context = _resolve.context;
              if (nextChild === null || nextChild === false) {
                return "";
              } else if (!React19.isValidElement(nextChild)) {
                if (nextChild != null && nextChild.$$typeof != null) {
                  var $$typeof = nextChild.$$typeof;
                  if (!($$typeof !== REACT_PORTAL_TYPE)) {
                    {
                      throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                    }
                  }
                  {
                    {
                      throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                    }
                  }
                }
                var nextChildren = toArray(nextChild);
                var frame2 = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                {
                  frame2.debugElementStack = [];
                }
                this.stack.push(frame2);
                return "";
              }
              var nextElement = nextChild;
              var elementType = nextElement.type;
              if (typeof elementType === "string") {
                return this.renderDOM(nextElement, context, parentNamespace);
              }
              switch (elementType) {
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_FRAGMENT_TYPE: {
                  var _nextChildren = toArray(nextChild.props.children);
                  var _frame = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  {
                    _frame.debugElementStack = [];
                  }
                  this.stack.push(_frame);
                  return "";
                }
                case REACT_SUSPENSE_TYPE: {
                  {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support Suspense.");
                      }
                    }
                  }
                }
                case REACT_SCOPE_TYPE: {
                  {
                    {
                      throw Error("ReactDOMServer does not yet support scope components.");
                    }
                  }
                }
              }
              if (typeof elementType === "object" && elementType !== null) {
                switch (elementType.$$typeof) {
                  case REACT_FORWARD_REF_TYPE: {
                    var element = nextChild;
                    var _nextChildren5;
                    var componentIdentity = {};
                    prepareToUseHooks(componentIdentity);
                    _nextChildren5 = elementType.render(element.props, element.ref);
                    _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                    _nextChildren5 = toArray(_nextChildren5);
                    var _frame5 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren5,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame5.debugElementStack = [];
                    }
                    this.stack.push(_frame5);
                    return "";
                  }
                  case REACT_MEMO_TYPE: {
                    var _element = nextChild;
                    var _nextChildren6 = [React19.createElement(elementType.type, _assign({
                      ref: _element.ref
                    }, _element.props))];
                    var _frame6 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren6,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame6.debugElementStack = [];
                    }
                    this.stack.push(_frame6);
                    return "";
                  }
                  case REACT_PROVIDER_TYPE: {
                    var provider = nextChild;
                    var nextProps = provider.props;
                    var _nextChildren7 = toArray(nextProps.children);
                    var _frame7 = {
                      type: provider,
                      domNamespace: parentNamespace,
                      children: _nextChildren7,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame7.debugElementStack = [];
                    }
                    this.pushProvider(provider);
                    this.stack.push(_frame7);
                    return "";
                  }
                  case REACT_CONTEXT_TYPE: {
                    var reactContext = nextChild.type;
                    {
                      if (reactContext._context === void 0) {
                        if (reactContext !== reactContext.Consumer) {
                          if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                          }
                        }
                      } else {
                        reactContext = reactContext._context;
                      }
                    }
                    var _nextProps = nextChild.props;
                    var threadID = this.threadID;
                    validateContextBounds(reactContext, threadID);
                    var nextValue = reactContext[threadID];
                    var _nextChildren8 = toArray(_nextProps.children(nextValue));
                    var _frame8 = {
                      type: nextChild,
                      domNamespace: parentNamespace,
                      children: _nextChildren8,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame8.debugElementStack = [];
                    }
                    this.stack.push(_frame8);
                    return "";
                  }
                  case REACT_FUNDAMENTAL_TYPE: {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support the fundamental API.");
                      }
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var _element2 = nextChild;
                    var lazyComponent = nextChild.type;
                    var payload = lazyComponent._payload;
                    var init2 = lazyComponent._init;
                    var result = init2(payload);
                    var _nextChildren10 = [React19.createElement(result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame10 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren10,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame10.debugElementStack = [];
                    }
                    this.stack.push(_frame10);
                    return "";
                  }
                }
              }
              var info = "";
              {
                var owner = nextElement._owner;
                if (elementType === void 0 || typeof elementType === "object" && elementType !== null && Object.keys(elementType).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentName(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              {
                {
                  throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                }
              }
            }
          };
          _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
            var tag = element.type.toLowerCase();
            var namespace = parentNamespace;
            if (parentNamespace === Namespaces.html) {
              namespace = getIntrinsicNamespace(tag);
            }
            {
              if (namespace === Namespaces.html) {
                if (tag !== element.type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type);
                }
              }
            }
            validateDangerousTag(tag);
            var props = element.props;
            if (tag === "input") {
              {
                checkControlledValueProps("input", props);
                if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                  error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultChecked = true;
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                  error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultInputValue = true;
                }
              }
              props = _assign({
                type: void 0
              }, props, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: props.value != null ? props.value : props.defaultValue,
                checked: props.checked != null ? props.checked : props.defaultChecked
              });
            } else if (tag === "textarea") {
              {
                checkControlledValueProps("textarea", props);
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                  error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultTextareaValue = true;
                }
              }
              var initialValue = props.value;
              if (initialValue == null) {
                var defaultValue = props.defaultValue;
                var textareaChildren = props.children;
                if (textareaChildren != null) {
                  {
                    error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                  }
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(textareaChildren)) {
                    if (!(textareaChildren.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    textareaChildren = textareaChildren[0];
                  }
                  defaultValue = "" + textareaChildren;
                }
                if (defaultValue == null) {
                  defaultValue = "";
                }
                initialValue = defaultValue;
              }
              props = _assign({}, props, {
                value: void 0,
                children: "" + initialValue
              });
            } else if (tag === "select") {
              {
                checkControlledValueProps("select", props);
                for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                  var propName = valuePropNames[i2];
                  if (props[propName] == null) {
                    continue;
                  }
                  var isArray3 = Array.isArray(props[propName]);
                  if (props.multiple && !isArray3) {
                    error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                  } else if (!props.multiple && isArray3) {
                    error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                  }
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                  error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultSelectValue = true;
                }
              }
              this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
              props = _assign({}, props, {
                value: void 0
              });
            } else if (tag === "option") {
              var selected = null;
              var selectValue = this.currentSelectValue;
              var optionChildren = flattenOptionChildren(props.children);
              if (selectValue != null) {
                var value;
                if (props.value != null) {
                  value = props.value + "";
                } else {
                  value = optionChildren;
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                  for (var j = 0; j < selectValue.length; j++) {
                    if ("" + selectValue[j] === value) {
                      selected = true;
                      break;
                    }
                  }
                } else {
                  selected = "" + selectValue === value;
                }
                props = _assign({
                  selected: void 0,
                  children: void 0
                }, props, {
                  selected,
                  children: optionChildren
                });
              }
            }
            {
              validatePropertiesInDevelopment(tag, props);
            }
            assertValidProps(tag, props);
            var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
            var footer = "";
            if (omittedCloseTags.hasOwnProperty(tag)) {
              out += "/>";
            } else {
              out += ">";
              footer = "</" + element.type + ">";
            }
            var children;
            var innerMarkup = getNonChildrenInnerMarkup(props);
            if (innerMarkup != null) {
              children = [];
              if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === "\n") {
                out += "\n";
              }
              out += innerMarkup;
            } else {
              children = toArray(props.children);
            }
            var frame2 = {
              domNamespace: getChildNamespace(parentNamespace, element.type),
              type: tag,
              children,
              childIndex: 0,
              context,
              footer
            };
            {
              frame2.debugElementStack = [];
            }
            this.stack.push(frame2);
            this.previousWasTextNode = false;
            return out;
          };
          return ReactDOMServerRenderer2;
        }();
        function renderToString2(element, options2) {
          var renderer = new ReactDOMServerRenderer(element, false, options2);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToStaticMarkup(element, options2) {
          var renderer = new ReactDOMServerRenderer(element, true, options2);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
          _inheritsLoose(ReactMarkupReadableStream2, _Readable);
          function ReactMarkupReadableStream2(element, makeStaticMarkup, options2) {
            var _this;
            _this = _Readable.call(this, {}) || this;
            _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup, options2);
            return _this;
          }
          var _proto = ReactMarkupReadableStream2.prototype;
          _proto._destroy = function _destroy(err, callback) {
            this.partialRenderer.destroy();
            callback(err);
          };
          _proto._read = function _read(size) {
            try {
              this.push(this.partialRenderer.read(size));
            } catch (err) {
              this.destroy(err);
            }
          };
          return ReactMarkupReadableStream2;
        }(stream.Readable);
        function renderToNodeStream(element, options2) {
          return new ReactMarkupReadableStream(element, false, options2);
        }
        function renderToStaticNodeStream(element, options2) {
          return new ReactMarkupReadableStream(element, true, options2);
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString2;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_dom_server_node_development();
    }
  }
});

// node_modules/react-dom/server.js
var require_server = __commonJS({
  "node_modules/react-dom/server.js"(exports, module) {
    init_react();
    "use strict";
    module.exports = require_server_node();
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment3 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment3;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    init_react();
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    init_react();
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    init_react();
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    init_react();
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry2 = step.value;
                  if (entry2) {
                    if (!isNode(entry2[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    init_react();
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/nprogress/nprogress.js
var require_nprogress = __commonJS({
  "node_modules/nprogress/nprogress.js"(exports, module) {
    init_react();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.NProgress = factory();
      }
    })(exports, function() {
      var NProgress2 = {};
      NProgress2.version = "0.2.0";
      var Settings = NProgress2.settings = {
        minimum: 0.08,
        easing: "ease",
        positionUsing: "",
        speed: 200,
        trickle: true,
        trickleRate: 0.02,
        trickleSpeed: 800,
        showSpinner: true,
        barSelector: '[role="bar"]',
        spinnerSelector: '[role="spinner"]',
        parent: "body",
        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
      };
      NProgress2.configure = function(options2) {
        var key, value;
        for (key in options2) {
          value = options2[key];
          if (value !== void 0 && options2.hasOwnProperty(key))
            Settings[key] = value;
        }
        return this;
      };
      NProgress2.status = null;
      NProgress2.set = function(n) {
        var started = NProgress2.isStarted();
        n = clamp3(n, Settings.minimum, 1);
        NProgress2.status = n === 1 ? null : n;
        var progress2 = NProgress2.render(!started), bar = progress2.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
        progress2.offsetWidth;
        queue2(function(next) {
          if (Settings.positionUsing === "")
            Settings.positionUsing = NProgress2.getPositioningCSS();
          css(bar, barPositionCSS(n, speed, ease));
          if (n === 1) {
            css(progress2, {
              transition: "none",
              opacity: 1
            });
            progress2.offsetWidth;
            setTimeout(function() {
              css(progress2, {
                transition: "all " + speed + "ms linear",
                opacity: 0
              });
              setTimeout(function() {
                NProgress2.remove();
                next();
              }, speed);
            }, speed);
          } else {
            setTimeout(next, speed);
          }
        });
        return this;
      };
      NProgress2.isStarted = function() {
        return typeof NProgress2.status === "number";
      };
      NProgress2.start = function() {
        if (!NProgress2.status)
          NProgress2.set(0);
        var work = function() {
          setTimeout(function() {
            if (!NProgress2.status)
              return;
            NProgress2.trickle();
            work();
          }, Settings.trickleSpeed);
        };
        if (Settings.trickle)
          work();
        return this;
      };
      NProgress2.done = function(force) {
        if (!force && !NProgress2.status)
          return this;
        return NProgress2.inc(0.3 + 0.5 * Math.random()).set(1);
      };
      NProgress2.inc = function(amount) {
        var n = NProgress2.status;
        if (!n) {
          return NProgress2.start();
        } else {
          if (typeof amount !== "number") {
            amount = (1 - n) * clamp3(Math.random() * n, 0.1, 0.95);
          }
          n = clamp3(n + amount, 0, 0.994);
          return NProgress2.set(n);
        }
      };
      NProgress2.trickle = function() {
        return NProgress2.inc(Math.random() * Settings.trickleRate);
      };
      (function() {
        var initial = 0, current = 0;
        NProgress2.promise = function($promise) {
          if (!$promise || $promise.state() === "resolved") {
            return this;
          }
          if (current === 0) {
            NProgress2.start();
          }
          initial++;
          current++;
          $promise.always(function() {
            current--;
            if (current === 0) {
              initial = 0;
              NProgress2.done();
            } else {
              NProgress2.set((initial - current) / initial);
            }
          });
          return this;
        };
      })();
      NProgress2.render = function(fromStart) {
        if (NProgress2.isRendered())
          return document.getElementById("nprogress");
        addClass(document.documentElement, "nprogress-busy");
        var progress2 = document.createElement("div");
        progress2.id = "nprogress";
        progress2.innerHTML = Settings.template;
        var bar = progress2.querySelector(Settings.barSelector), perc = fromStart ? "-100" : toBarPerc(NProgress2.status || 0), parent = document.querySelector(Settings.parent), spinner;
        css(bar, {
          transition: "all 0 linear",
          transform: "translate3d(" + perc + "%,0,0)"
        });
        if (!Settings.showSpinner) {
          spinner = progress2.querySelector(Settings.spinnerSelector);
          spinner && removeElement(spinner);
        }
        if (parent != document.body) {
          addClass(parent, "nprogress-custom-parent");
        }
        parent.appendChild(progress2);
        return progress2;
      };
      NProgress2.remove = function() {
        removeClass(document.documentElement, "nprogress-busy");
        removeClass(document.querySelector(Settings.parent), "nprogress-custom-parent");
        var progress2 = document.getElementById("nprogress");
        progress2 && removeElement(progress2);
      };
      NProgress2.isRendered = function() {
        return !!document.getElementById("nprogress");
      };
      NProgress2.getPositioningCSS = function() {
        var bodyStyle = document.body.style;
        var vendorPrefix = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
        if (vendorPrefix + "Perspective" in bodyStyle) {
          return "translate3d";
        } else if (vendorPrefix + "Transform" in bodyStyle) {
          return "translate";
        } else {
          return "margin";
        }
      };
      function clamp3(n, min, max) {
        if (n < min)
          return min;
        if (n > max)
          return max;
        return n;
      }
      function toBarPerc(n) {
        return (-1 + n) * 100;
      }
      function barPositionCSS(n, speed, ease) {
        var barCSS;
        if (Settings.positionUsing === "translate3d") {
          barCSS = { transform: "translate3d(" + toBarPerc(n) + "%,0,0)" };
        } else if (Settings.positionUsing === "translate") {
          barCSS = { transform: "translate(" + toBarPerc(n) + "%,0)" };
        } else {
          barCSS = { "margin-left": toBarPerc(n) + "%" };
        }
        barCSS.transition = "all " + speed + "ms " + ease;
        return barCSS;
      }
      var queue2 = function() {
        var pending = [];
        function next() {
          var fn = pending.shift();
          if (fn) {
            fn(next);
          }
        }
        return function(fn) {
          pending.push(fn);
          if (pending.length == 1)
            next();
        };
      }();
      var css = function() {
        var cssPrefixes = ["Webkit", "O", "Moz", "ms"], cssProps = {};
        function camelCase(string) {
          return string.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match, letter) {
            return letter.toUpperCase();
          });
        }
        function getVendorProp(name) {
          var style = document.body.style;
          if (name in style)
            return name;
          var i = cssPrefixes.length, capName = name.charAt(0).toUpperCase() + name.slice(1), vendorName;
          while (i--) {
            vendorName = cssPrefixes[i] + capName;
            if (vendorName in style)
              return vendorName;
          }
          return name;
        }
        function getStyleProp(name) {
          name = camelCase(name);
          return cssProps[name] || (cssProps[name] = getVendorProp(name));
        }
        function applyCss(element, prop, value) {
          prop = getStyleProp(prop);
          element.style[prop] = value;
        }
        return function(element, properties) {
          var args = arguments, prop, value;
          if (args.length == 2) {
            for (prop in properties) {
              value = properties[prop];
              if (value !== void 0 && properties.hasOwnProperty(prop))
                applyCss(element, prop, value);
            }
          } else {
            applyCss(element, args[1], args[2]);
          }
        };
      }();
      function hasClass(element, name) {
        var list = typeof element == "string" ? element : classList(element);
        return list.indexOf(" " + name + " ") >= 0;
      }
      function addClass(element, name) {
        var oldList = classList(element), newList = oldList + name;
        if (hasClass(oldList, name))
          return;
        element.className = newList.substring(1);
      }
      function removeClass(element, name) {
        var oldList = classList(element), newList;
        if (!hasClass(element, name))
          return;
        newList = oldList.replace(" " + name + " ", " ");
        element.className = newList.substring(1, newList.length - 1);
      }
      function classList(element) {
        return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
      }
      function removeElement(element) {
        element && element.parentNode && element.parentNode.removeChild(element);
      }
      return NProgress2;
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js"(exports, module) {
    init_react();
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject2(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index2, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
          key = sourceKeys[index2];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number2) {
      return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
    }
    module.exports.isNothing = isNothing;
    module.exports.isObject = isObject2;
    module.exports.toArray = toArray;
    module.exports.repeat = repeat;
    module.exports.isNegativeZero = isNegativeZero;
    module.exports.extend = extend;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js"(exports, module) {
    init_react();
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString3(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module.exports = YAMLException;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString3(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module.exports = Mark;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js"(exports, module) {
    init_react();
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options2) {
      options2 = options2 || {};
      Object.keys(options2).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options2["kind"] || null;
      this.resolve = options2["resolve"] || function() {
        return true;
      };
      this.construct = options2["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options2["instanceOf"] || null;
      this.predicate = options2["predicate"] || null;
      this.represent = options2["represent"] || null;
      this.defaultStyle = options2["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module.exports = Type;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index2) {
        return exclude.indexOf(index2) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index2, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
        arguments[index2].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types2;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types2 = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types2 = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types2 = common.toArray(types2);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types2.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types2
      });
    };
    module.exports = Schema;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull2(object) {
      return object === null;
    }
    module.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull2,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean2(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean2,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var Type = require_type();
    function isHexCode(c2) {
      return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
    }
    function isOctCode(c2) {
      return 48 <= c2 && c2 <= 55;
    }
    function isDecCode(c2) {
      return 48 <= c2 && c2 <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index2 = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index2];
      if (ch === "-" || ch === "+") {
        ch = data[++index2];
      }
      if (ch === "0") {
        if (index2 + 1 === max)
          return true;
        ch = data[++index2];
        if (ch === "b") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index2 < max; index2++) {
          ch = data[index2];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data.charCodeAt(index2))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index2));
    }
    function constructYamlInteger(data) {
      var value = data, sign2 = 1, ch, base, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign2 = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign2 * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign2 * parseInt(value, 16);
        return sign2 * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign2 * value;
      }
      return sign2 * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign2, base, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign2 = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign2 * value;
      }
      return sign2 * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat2(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat2,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      include: [
        require_json()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports, module) {
    init_react();
    "use strict";
    var NodeBuffer;
    try {
      _require = __require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index2, length, pair, keys2, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys2 = Object.keys(pair);
        if (keys2.length !== 1)
          return false;
        result[index2] = [keys2[0], pair[keys2[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index2, length, pair, keys2, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        keys2 = Object.keys(pair);
        result[index2] = [keys2[0], pair[keys2[0]]];
      }
      return result;
    }
    module.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined2(object) {
      return typeof object === "undefined";
    }
    module.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined2,
      represent: representJavascriptUndefined
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null)
        return false;
      if (data.length === 0)
        return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp2(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp2,
      represent: representJavascriptRegExp
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports, module) {
    init_react();
    "use strict";
    var esprima;
    try {
      _require = __require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    var Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction2(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction2,
      represent: representJavascriptFunction
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c2) {
      return c2 === 10 || c2 === 13;
    }
    function is_WHITE_SPACE(c2) {
      return c2 === 9 || c2 === 32;
    }
    function is_WS_OR_EOL(c2) {
      return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
    }
    function is_FLOW_INDICATOR(c2) {
      return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
    }
    function fromHexCode(c2) {
      var lc;
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      lc = c2 | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c2) {
      if (c2 === 120) {
        return 2;
      }
      if (c2 === 117) {
        return 4;
      }
      if (c2 === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c2) {
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c2) {
      return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c2) {
      if (c2 <= 65535) {
        return String.fromCharCode(c2);
      }
      return String.fromCharCode((c2 - 65536 >> 10) + 55296, (c2 - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options2) {
      this.input = input;
      this.filename = options2["filename"] || null;
      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options2["onWarning"] || null;
      this.legacy = options2["legacy"] || false;
      this.json = options2["json"] || false;
      this.listener = options2["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle10, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle10 = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle10)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle10)) {
          throwError(state, 'there is a previously declared suffix for "' + handle10 + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle10] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index2, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
        key = sourceKeys[index2];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index2, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
          if (Array.isArray(keyNode[index2])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
            keyNode[index2] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
            mergeMappings(state, _result, valueNode[index2], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options2) {
      input = String(input);
      options2 = options2 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options2);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options2) {
      if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options2);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
        iterator(documents[index2]);
      }
    }
    function load(input, options2) {
      var documents = loadDocuments(input, options2);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, iterator, options2) {
      if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    function safeLoad(input, options2) {
      return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    module.exports.loadAll = loadAll;
    module.exports.load = load;
    module.exports.safeLoadAll = safeLoadAll;
    module.exports.safeLoad = safeLoad;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys2, index2, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys2 = Object.keys(map);
      for (index2 = 0, length = keys2.length; index2 < length; index2 += 1) {
        tag = keys2[index2];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle10, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle10 = "x";
        length = 2;
      } else if (character <= 65535) {
        handle10 = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle10 = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle10 + common.repeat("0", length - string.length) + string;
    }
    function State(options2) {
      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options2["indent"] || 2);
      this.noArrayIndent = options2["noArrayIndent"] || false;
      this.skipInvalid = options2["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
      this.sortKeys = options2["sortKeys"] || false;
      this.lineWidth = options2["lineWidth"] || 80;
      this.noRefs = options2["noRefs"] || false;
      this.noCompatMode = options2["noCompatMode"] || false;
      this.condenseFlow = options2["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index2, length, type;
      for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
        type = state.implicitTypes[index2];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c2) {
      return c2 === CHAR_SPACE || c2 === CHAR_TAB;
    }
    function isPrintable(c2) {
      return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
    }
    function isNsChar(c2) {
      return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c2, prev) {
      return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c2) {
      return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index2, length;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        if (writeNode(state, level, object[index2], false, false)) {
          if (index2 !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index2, length;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        if (writeNode(state, level + 1, object[index2], true, true)) {
          if (!compact || index2 !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (index2 !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (!compact || index2 !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index2, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
        type = typeList[index2];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block2, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block2) {
        block2 = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block2 && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block2 && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index2, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index2]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index2, length;
      if (object !== null && typeof object === "object") {
        index2 = objects.indexOf(object);
        if (index2 !== -1) {
          if (duplicatesIndexes.indexOf(index2) === -1) {
            duplicatesIndexes.push(index2);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
              inspectNode(object[index2], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
              inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options2) {
      options2 = options2 || {};
      var state = new State(options2);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options2) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    module.exports.dump = dump;
    module.exports.safeDump = safeDump;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js"(exports, module) {
    init_react();
    "use strict";
    var loader9 = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module.exports.Type = require_type();
    module.exports.Schema = require_schema();
    module.exports.FAILSAFE_SCHEMA = require_failsafe();
    module.exports.JSON_SCHEMA = require_json();
    module.exports.CORE_SCHEMA = require_core();
    module.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module.exports.load = loader9.load;
    module.exports.loadAll = loader9.loadAll;
    module.exports.safeLoad = loader9.safeLoad;
    module.exports.safeLoadAll = loader9.safeLoadAll;
    module.exports.dump = dumper.dump;
    module.exports.safeDump = dumper.safeDump;
    module.exports.YAMLException = require_exception();
    module.exports.MINIMAL_SCHEMA = require_failsafe();
    module.exports.SAFE_SCHEMA = require_default_safe();
    module.exports.DEFAULT_SCHEMA = require_default_full();
    module.exports.scan = deprecated("scan");
    module.exports.parse = deprecated("parse");
    module.exports.compose = deprecated("compose");
    module.exports.addConstructor = deprecated("addConstructor");
  }
});

// node_modules/front-matter/node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/index.js"(exports, module) {
    init_react();
    "use strict";
    var yaml = require_js_yaml();
    module.exports = yaml;
  }
});

// node_modules/front-matter/index.js
var require_front_matter = __commonJS({
  "node_modules/front-matter/index.js"(exports, module) {
    init_react();
    var parser2 = require_js_yaml2();
    var optionalByteOrderMark = "\\ufeff?";
    var platform2 = typeof process !== "undefined" ? process.platform : "";
    var pattern = "^(" + optionalByteOrderMark + "(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$" + (platform2 === "win32" ? "\\r?" : "") + "(?:\\n)?)";
    var regex = new RegExp(pattern, "m");
    module.exports = extractor;
    module.exports.test = test2;
    function extractor(string, options2) {
      string = string || "";
      var defaultOptions = { allowUnsafe: false };
      options2 = options2 instanceof Object ? __spreadValues(__spreadValues({}, defaultOptions), options2) : defaultOptions;
      options2.allowUnsafe = Boolean(options2.allowUnsafe);
      var lines = string.split(/(\r?\n)/);
      if (lines[0] && /= yaml =|---/.test(lines[0])) {
        return parse2(string, options2.allowUnsafe);
      } else {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
    }
    function computeLocation(match, body) {
      var line = 1;
      var pos = body.indexOf("\n");
      var offset = match.index + match[0].length;
      while (pos !== -1) {
        if (pos >= offset) {
          return line;
        }
        line++;
        pos = body.indexOf("\n", pos + 1);
      }
      return line;
    }
    function parse2(string, allowUnsafe) {
      var match = regex.exec(string);
      if (!match) {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
      var loader9 = allowUnsafe ? parser2.load : parser2.safeLoad;
      var yaml = match[match.length - 1].replace(/^\s+|\s+$/g, "");
      var attributes = loader9(yaml) || {};
      var body = string.replace(match[0], "");
      var line = computeLocation(match, string);
      return {
        attributes,
        body,
        bodyBegin: line,
        frontmatter: yaml
      };
    }
    function test2(string) {
      string = string || "";
      return regex.test(string);
    }
  }
});

// node_modules/framer-motion/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/framer-motion/node_modules/tslib/tslib.js"(exports, module) {
    init_react();
    var __extends3;
    var __assign3;
    var __rest3;
    var __decorate3;
    var __param3;
    var __metadata3;
    var __awaiter3;
    var __generator3;
    var __exportStar3;
    var __values3;
    var __read3;
    var __spread3;
    var __spreadArrays3;
    var __spreadArray3;
    var __await3;
    var __asyncGenerator3;
    var __asyncDelegator3;
    var __asyncValues3;
    var __makeTemplateObject3;
    var __importStar3;
    var __importDefault3;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __createBinding3;
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id2, v) {
          return exports2[id2] = previous ? previous(id2, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b2) {
        d.__proto__ = b2;
      } || function(d, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d[p] = b2[p];
      };
      __extends3 = function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign3 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest3 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate3 = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param3 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata3 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar3 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding3(o, m, p);
      };
      __createBinding3 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values3 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read3 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r2, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread3 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read3(arguments[i]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
          for (var a2 = arguments[i], j = 0, jl = a2.length; j < jl; j++, k++)
            r2[k] = a2[j];
        return r2;
      };
      __spreadArray3 = function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      __await3 = function(v) {
        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);
      };
      __asyncGenerator3 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a2, b2) {
                q.push([n, v, a2, b2]) > 1 || resume2(n, v);
              });
            };
        }
        function resume2(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r2) {
          r2.value instanceof __await3 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume2(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator3 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await3(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues3 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values3 === "function" ? __values3(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject3 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar3 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding3(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault3 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet3 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends3);
      exporter("__assign", __assign3);
      exporter("__rest", __rest3);
      exporter("__decorate", __decorate3);
      exporter("__param", __param3);
      exporter("__metadata", __metadata3);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar3);
      exporter("__createBinding", __createBinding3);
      exporter("__values", __values3);
      exporter("__read", __read3);
      exporter("__spread", __spread3);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__spreadArray", __spreadArray3);
      exporter("__await", __await3);
      exporter("__asyncGenerator", __asyncGenerator3);
      exporter("__asyncDelegator", __asyncDelegator3);
      exporter("__asyncValues", __asyncValues3);
      exporter("__makeTemplateObject", __makeTemplateObject3);
      exporter("__importStar", __importStar3);
      exporter("__importDefault", __importDefault3);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
    });
  }
});

// node_modules/popmotion/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "node_modules/popmotion/node_modules/tslib/tslib.js"(exports, module) {
    init_react();
    var __extends3;
    var __assign3;
    var __rest3;
    var __decorate3;
    var __param3;
    var __metadata3;
    var __awaiter3;
    var __generator3;
    var __exportStar3;
    var __values3;
    var __read3;
    var __spread3;
    var __spreadArrays3;
    var __spreadArray3;
    var __await3;
    var __asyncGenerator3;
    var __asyncDelegator3;
    var __asyncValues3;
    var __makeTemplateObject3;
    var __importStar3;
    var __importDefault3;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __createBinding3;
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id2, v) {
          return exports2[id2] = previous ? previous(id2, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b2) {
        d.__proto__ = b2;
      } || function(d, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d[p] = b2[p];
      };
      __extends3 = function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign3 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest3 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate3 = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param3 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata3 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar3 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding3(o, m, p);
      };
      __createBinding3 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values3 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read3 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r2, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread3 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read3(arguments[i]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
          for (var a2 = arguments[i], j = 0, jl = a2.length; j < jl; j++, k++)
            r2[k] = a2[j];
        return r2;
      };
      __spreadArray3 = function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      __await3 = function(v) {
        return this instanceof __await3 ? (this.v = v, this) : new __await3(v);
      };
      __asyncGenerator3 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a2, b2) {
                q.push([n, v, a2, b2]) > 1 || resume2(n, v);
              });
            };
        }
        function resume2(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r2) {
          r2.value instanceof __await3 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume2(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator3 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await3(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues3 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values3 === "function" ? __values3(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject3 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar3 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding3(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault3 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet3 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends3);
      exporter("__assign", __assign3);
      exporter("__rest", __rest3);
      exporter("__decorate", __decorate3);
      exporter("__param", __param3);
      exporter("__metadata", __metadata3);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar3);
      exporter("__createBinding", __createBinding3);
      exporter("__values", __values3);
      exporter("__read", __read3);
      exporter("__spread", __spread3);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__spreadArray", __spreadArray3);
      exporter("__await", __await3);
      exporter("__asyncGenerator", __asyncGenerator3);
      exporter("__asyncDelegator", __asyncDelegator3);
      exporter("__asyncValues", __asyncValues3);
      exporter("__makeTemplateObject", __makeTemplateObject3);
      exporter("__importStar", __importStar3);
      exporter("__importDefault", __importDefault3);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
    });
  }
});

// node_modules/@emotion/memoize/dist/memoize.esm.js
function memoize(fn) {
  var cache = {};
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var memoize_esm_default;
var init_memoize_esm = __esm({
  "node_modules/@emotion/memoize/dist/memoize.esm.js"() {
    init_react();
    memoize_esm_default = memoize;
  }
});

// node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js
var is_prop_valid_esm_exports = {};
__export(is_prop_valid_esm_exports, {
  default: () => is_prop_valid_esm_default
});
var reactPropsRegex, index, is_prop_valid_esm_default;
var init_is_prop_valid_esm = __esm({
  "node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js"() {
    init_react();
    init_memoize_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    index = memoize_esm_default(function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    });
    is_prop_valid_esm_default = index;
  }
});

// server.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/index.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/cookieSigning.js
init_react();
var encoder = new TextEncoder();
async function sign(value, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["sign"]);
  let data = encoder.encode(value);
  let signature = await crypto.subtle.sign("HMAC", key, data);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
  return value + "." + hash;
}
async function unsign(cookie, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["verify"]);
  let value = cookie.slice(0, cookie.lastIndexOf("."));
  let hash = cookie.slice(cookie.lastIndexOf(".") + 1);
  let data = encoder.encode(value);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data);
  return valid ? value : false;
}
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
function installGlobals() {
  self.sign = sign;
  self.unsign = unsign;
}

// node_modules/@remix-run/cloudflare-pages/esm/sessions/cloudflareKVSessionStorage.js
init_react();

// node_modules/@remix-run/server-runtime/esm/index.js
init_react();

// node_modules/@remix-run/server-runtime/esm/responses.js
init_react();
function json(data, init2 = {}) {
  let responseInit = init2;
  if (typeof init2 === "number") {
    responseInit = {
      status: init2
    };
  }
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), __spreadProps(__spreadValues({}, responseInit), {
    headers
  }));
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
var redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response) {
  return redirectStatusCodes.has(response.status);
}
function isCatchResponse(response) {
  return response.headers.get("X-Remix-Catch") != null;
}

// node_modules/@remix-run/server-runtime/esm/server.js
init_react();

// node_modules/@remix-run/server-runtime/esm/data.js
init_react();
async function callRouteAction({
  loadContext,
  match,
  request
}) {
  let action = match.route.module.action;
  if (!action) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide an \`action\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await action({
      request: stripDataParam(stripIndexParam(request)),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
async function callRouteLoader({
  loadContext,
  match,
  request
}) {
  let loader9 = match.route.module.loader;
  if (!loader9) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await loader9({
      request: stripDataParam(stripIndexParam(request.clone())),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
function stripIndexParam(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_data");
  return new Request(url.href, request);
}
function extractData(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}

// node_modules/@remix-run/server-runtime/esm/entry.js
init_react();
function createEntryMatches(matches, routes2) {
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: routes2[match.route.id]
  }));
}
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo, routeId) => {
    memo[routeId] = manifest[routeId].module;
    return memo;
  }, {});
}

// node_modules/@remix-run/server-runtime/esm/errors.js
init_react();
async function serializeError(error) {
  return {
    message: error.message,
    stack: error.stack
  };
}

// node_modules/@remix-run/server-runtime/esm/headers.js
init_react();
var import_set_cookie_parser = __toModule(require_set_cookie());
function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
  return matches.reduce((parentHeaders, match, index2) => {
    let routeModule = build.routes[match.route.id].module;
    let routeLoaderResponse = routeLoaderResponses[match.route.id];
    let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();
    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);
    cookies.forEach((cookie) => {
      childHeaders.append("Set-Cookie", cookie);
    });
  }
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
init_react();

// node_modules/react-router-dom/index.js
init_react();
var import_react2 = __toModule(require_react());

// node_modules/history/index.js
init_react();

// node_modules/@babel/runtime/helpers/esm/extends.js
init_react();

// node_modules/history/index.js
var r;
var B = r || (r = {});
B.Pop = "POP";
B.Push = "PUSH";
B.Replace = "REPLACE";
function I(b2) {
  var h = b2.pathname;
  h = h === void 0 ? "/" : h;
  var e = b2.search;
  e = e === void 0 ? "" : e;
  b2 = b2.hash;
  b2 = b2 === void 0 ? "" : b2;
  e && e !== "?" && (h += e.charAt(0) === "?" ? e : "?" + e);
  b2 && b2 !== "#" && (h += b2.charAt(0) === "#" ? b2 : "#" + b2);
  return h;
}
function J(b2) {
  var h = {};
  if (b2) {
    var e = b2.indexOf("#");
    0 <= e && (h.hash = b2.substr(e), b2 = b2.substr(0, e));
    e = b2.indexOf("?");
    0 <= e && (h.search = b2.substr(e), b2 = b2.substr(0, e));
    b2 && (h.pathname = b2);
  }
  return h;
}

// node_modules/react-router/index.js
init_react();
var import_react = __toModule(require_react());
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning(false, message) : void 0;
  }
}
var NavigationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = /* @__PURE__ */ (0, import_react.createContext)({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = r.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0, import_react.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = J(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = (0, import_react.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  true ? warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ (0, import_react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react.createElement)(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
function useHref(to) {
  !useInRouterContext() ? true ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0, import_react.useContext)(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  return (0, import_react.useContext)(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0, import_react.useCallback)(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options2.replace ? navigator.replace : navigator.push)(path, options2.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = /* @__PURE__ */ (0, import_react.createContext)(null);
function useOutlet(context) {
  let outlet = (0, import_react.useContext)(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ (0, import_react.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to) {
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0, import_react.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes2, locationArg) {
  !useInRouterContext() ? true ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    matches: parentMatches
  } = (0, import_react.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? J(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : void 0;
    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function matchRoutes(routes2, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? J(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes2.forEach((route, index2) => {
    let meta9 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta9.relativePath.startsWith("/")) {
      !meta9.relativePath.startsWith(parentPath) ? true ? invariant(false, 'Absolute route path "' + meta9.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : invariant(false) : void 0;
      meta9.relativePath = meta9.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta9.relativePath]);
    let routesMeta = parentsMeta.concat(meta9);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ? true ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta9) => meta9.childrenIndex), b2.routesMeta.map((meta9) => meta9.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n, i) => n === b2[i]);
  return siblings ? a2[a2.length - 1] - b2[b2.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta9 = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta9.relativePath,
      caseSensitive: meta9.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta9.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index2) => {
    return /* @__PURE__ */ (0, import_react.createElement)(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : /* @__PURE__ */ (0, import_react.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index2 + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')) : void 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    true ? warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")) : void 0;
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? J(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? J(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? J(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

// node_modules/react-router-dom/index.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0, import_react2.useState)({
    action: history.action,
    location: history.location
  });
  (0, import_react2.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0, import_react2.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var Link = /* @__PURE__ */ (0, import_react2.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ (0, import_react2.createElement)("a", _extends2({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = /* @__PURE__ */ (0, import_react2.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let location = useLocation();
  let path = useResolvedPath(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ (0, import_react2.createElement)(Link, _extends2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to);
  return (0, import_react2.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || I(location) === I(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/server-runtime/esm/mode.js
init_react();
var ServerMode;
(function(ServerMode2) {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
})(ServerMode || (ServerMode = {}));
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}

// node_modules/@remix-run/server-runtime/esm/routes.js
init_react();
function createRoutes(manifest, parentId) {
  return Object.keys(manifest).filter((key) => manifest[key].parentId === parentId).map((id2) => __spreadProps(__spreadValues({}, manifest[id2]), {
    children: createRoutes(manifest, id2)
  }));
}

// node_modules/@remix-run/server-runtime/esm/serverHandoff.js
init_react();
var import_jsesc = __toModule(require_jsesc());
function createServerHandoffString(serverHandoff) {
  return (0, import_jsesc.default)(serverHandoff, {
    isScriptContext: true
  });
}

// node_modules/@remix-run/server-runtime/esm/server.js
function createRequestHandler(build, platform2, mode) {
  let routes2 = createRoutes(build.routes);
  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;
  return async function requestHandler(request, loadContext) {
    let url = new URL(request.url);
    let matches = matchServerRoutes(routes2, url.pathname);
    let requestType = getRequestType(url, matches);
    let response;
    switch (requestType) {
      case "data":
        response = await handleDataRequest({
          request,
          loadContext,
          matches,
          handleDataRequest: build.entry.module.handleDataRequest,
          serverMode
        });
        break;
      case "document":
        response = await renderDocumentRequest({
          build,
          loadContext,
          matches,
          request,
          routes: routes2,
          serverMode
        });
        break;
      case "resource":
        response = await handleResourceRequest({
          request,
          loadContext,
          matches,
          serverMode
        });
        break;
    }
    if (request.method.toLowerCase() === "head") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
}
async function handleDataRequest({
  handleDataRequest: handleDataRequest2,
  loadContext,
  matches,
  request,
  serverMode
}) {
  if (!isValidRequestMethod(request)) {
    return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
  }
  let url = new URL(request.url);
  if (!matches) {
    return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
  }
  let response;
  let match;
  try {
    if (isActionRequest(request)) {
      match = getActionRequestMatch(url, matches);
      response = await callRouteAction({
        loadContext,
        match,
        request
      });
    } else {
      let routeId = url.searchParams.get("_data");
      if (!routeId) {
        return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
      }
      let tempMatch = matches.find((match2) => match2.route.id === routeId);
      if (!tempMatch) {
        return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
      }
      match = tempMatch;
      response = await callRouteLoader({
        loadContext,
        match,
        request
      });
    }
    if (isRedirectResponse(response)) {
      let headers = new Headers(response.headers);
      headers.set("X-Remix-Redirect", headers.get("Location"));
      headers.delete("Location");
      return new Response(null, {
        status: 204,
        headers
      });
    }
    if (handleDataRequest2) {
      response = await handleDataRequest2(response.clone(), {
        context: loadContext,
        params: match.params,
        request: request.clone()
      });
    }
    return response;
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    if (serverMode === ServerMode.Development) {
      return errorBoundaryError(error, 500);
    }
    return errorBoundaryError(new Error("Unexpected Server Error"), 500);
  }
}
async function renderDocumentRequest({
  build,
  loadContext,
  matches,
  request,
  routes: routes2,
  serverMode
}) {
  let url = new URL(request.url);
  let appState = {
    trackBoundaries: true,
    trackCatchBoundaries: true,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: void 0,
    catch: void 0
  };
  if (!isValidRequestMethod(request)) {
    matches = null;
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 405,
      statusText: "Method Not Allowed"
    };
  } else if (!matches) {
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 404,
      statusText: "Not Found"
    };
  }
  let actionStatus;
  let actionData;
  let actionMatch;
  let actionResponse;
  if (matches && isActionRequest(request)) {
    actionMatch = getActionRequestMatch(url, matches);
    try {
      actionResponse = await callRouteAction({
        loadContext,
        match: actionMatch,
        request
      });
      if (isRedirectResponse(actionResponse)) {
        return actionResponse;
      }
      actionStatus = {
        status: actionResponse.status,
        statusText: actionResponse.statusText
      };
      if (isCatchResponse(actionResponse)) {
        appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
        appState.trackCatchBoundaries = false;
        appState.catch = __spreadProps(__spreadValues({}, actionStatus), {
          data: await extractData(actionResponse)
        });
      } else {
        actionData = {
          [actionMatch.route.id]: await extractData(actionResponse)
        };
      }
    } catch (error) {
      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the action for route ${actionMatch.route.id}`);
      }
    }
  }
  let routeModules = createEntryRouteModules(build.routes);
  let matchesToLoad = matches || [];
  if (appState.catch) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "CatchBoundary");
  } else if (appState.error) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "ErrorBoundary");
  }
  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? callRouteLoader({
    loadContext,
    match,
    request
  }) : Promise.resolve(void 0)));
  let actionCatch = appState.catch;
  let actionError = appState.error;
  let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
  let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
  appState.catch = void 0;
  appState.error = void 0;
  let routeLoaderResponses = {};
  let loaderStatusCodes = [];
  let routeData = {};
  for (let index2 = 0; index2 < matchesToLoad.length; index2++) {
    let match = matchesToLoad[index2];
    let result = routeLoaderResults[index2];
    let error = result.status === "rejected" ? result.reason : void 0;
    let response = result.status === "fulfilled" ? result.value : void 0;
    let isRedirect = response ? isRedirectResponse(response) : false;
    let isCatch = response ? isCatchResponse(response) : false;
    if (appState.catch || appState.error) {
      break;
    }
    if (!actionCatch && !actionError && response && isRedirect) {
      return response;
    }
    if (match.route.module.CatchBoundary) {
      appState.catchBoundaryRouteId = match.route.id;
    }
    if (match.route.module.ErrorBoundary) {
      appState.loaderBoundaryRouteId = match.route.id;
    }
    if (error) {
      loaderStatusCodes.push(500);
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the data loader for route ${match.route.id}`);
      }
      break;
    } else if (response) {
      routeLoaderResponses[match.route.id] = response;
      loaderStatusCodes.push(response.status);
      if (isCatch) {
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: await extractData(response),
          status: response.status,
          statusText: response.statusText
        };
        break;
      } else {
        routeData[match.route.id] = await extractData(response);
      }
    }
  }
  if (!appState.catch) {
    appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
  }
  if (!appState.error) {
    appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
  }
  appState.catch = actionCatch || appState.catch;
  appState.error = actionError || appState.error;
  let renderableMatches = getRenderableMatches(matches, appState);
  if (!renderableMatches) {
    renderableMatches = [];
    let root = routes2[0];
    if (root !== null && root !== void 0 && root.module.CatchBoundary) {
      appState.catchBoundaryRouteId = "root";
      renderableMatches.push({
        params: {},
        pathname: "",
        route: routes2[0]
      });
    }
  }
  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
  let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
  let responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);
  let serverHandoff = {
    actionData,
    appState,
    matches: entryMatches,
    routeData
  };
  let entryContext = __spreadProps(__spreadValues({}, serverHandoff), {
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff)
  });
  let handleDocumentRequest = build.entry.module.default;
  try {
    return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
  } catch (error) {
    responseStatusCode = 500;
    appState.trackBoundaries = false;
    appState.error = await serializeError(error);
    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
    try {
      return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
    } catch (error2) {
      if (serverMode !== ServerMode.Test) {
        console.error(error2);
      }
      let message = "Unexpected Server Error";
      if (serverMode === ServerMode.Development) {
        message += `

${String(error2)}`;
      }
      return new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
  }
}
async function handleResourceRequest({
  loadContext,
  matches,
  request,
  serverMode
}) {
  let match = matches.slice(-1)[0];
  try {
    if (isActionRequest(request)) {
      return await callRouteAction({
        match,
        loadContext,
        request
      });
    } else {
      return await callRouteLoader({
        match,
        loadContext,
        request
      });
    }
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    let message = "Unexpected Server Error";
    if (serverMode === ServerMode.Development) {
      message += `

${String(error)}`;
    }
    return new Response(message, {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
}
function getRequestType(url, matches) {
  if (url.searchParams.has("_data")) {
    return "data";
  }
  if (!matches) {
    return "document";
  }
  let match = matches.slice(-1)[0];
  if (!match.route.module.default) {
    return "resource";
  }
  return "document";
}
function isActionRequest(request) {
  let method = request.method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function isHeadRequest(request) {
  return request.method.toLowerCase() === "head";
}
function isValidRequestMethod(request) {
  return request.method.toLowerCase() === "get" || isHeadRequest(request) || isActionRequest(request);
}
async function errorBoundaryError(error, status) {
  return json(await serializeError(error), {
    status,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function isIndexRequestUrl(url) {
  let indexRequest = false;
  for (let param of url.searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
function getActionRequestMatch(url, matches) {
  let match = matches.slice(-1)[0];
  if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
    return matches.slice(-2)[0];
  }
  return match;
}
function getDeepestRouteIdWithBoundary(matches, key) {
  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
  return matched ? matched.route.id : null;
}
function getMatchesUpToDeepestBoundary(matches, key) {
  let deepestBoundaryIndex = -1;
  matches.forEach((match, index2) => {
    if (match.route.module[key]) {
      deepestBoundaryIndex = index2;
    }
  });
  if (deepestBoundaryIndex === -1) {
    return [];
  }
  return matches.slice(0, deepestBoundaryIndex + 1);
}
function getRenderableMatches(matches, appState) {
  if (!matches) {
    return null;
  }
  if (!appState.catch && !appState.error) {
    return matches;
  }
  let lastRenderableIndex = -1;
  matches.forEach((match, index2) => {
    let id2 = match.route.id;
    if (appState.renderBoundaryRouteId === id2 || appState.loaderBoundaryRouteId === id2 || appState.catchBoundaryRouteId === id2) {
      lastRenderableIndex = index2;
    }
  });
  return matches.slice(0, lastRenderableIndex + 1);
}

// node_modules/@remix-run/cloudflare-pages/esm/worker.js
init_react();
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let platform2 = {};
  let handleRequest3 = createRequestHandler(build, platform2, mode);
  return (context) => {
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(context) : void 0;
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  const handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  });
  const handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone());
      response = response && response.status >= 200 && response.status < 400 ? new Response(response.body, response) : void 0;
    } catch {
    }
    if (!response) {
      response = await handleRequest3(context);
    }
    return response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (e) {
      if (e instanceof Error) {
        console.error(e);
        return new Response(e.message || e.toString(), {
          status: 500
        });
      }
      return new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// node_modules/@remix-run/cloudflare-pages/esm/index.js
installGlobals();

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  entry: () => entry,
  routes: () => routes
});
init_react();

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
init_react();
var import_server3 = __toModule(require_server());

// node_modules/remix/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/components.js
init_react();

// node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js
init_react();
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// node_modules/@remix-run/react/esm/components.js
var React3 = __toModule(require_react());

// node_modules/@remix-run/react/esm/errorBoundaries.js
init_react();
var import_react3 = __toModule(require_react());
var RemixErrorBoundary = class extends import_react3.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ import_react3.default.createElement(this.props.component, {
        error: this.state.error
      });
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error
}) {
  console.error(error);
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react3.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
var RemixCatchContext = /* @__PURE__ */ import_react3.default.createContext(void 0);
function useCatch() {
  return (0, import_react3.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component,
  children
}) {
  if (catchVal) {
    return /* @__PURE__ */ import_react3.default.createElement(RemixCatchContext.Provider, {
      value: catchVal
    }, /* @__PURE__ */ import_react3.default.createElement(Component, null));
  }
  return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}

// node_modules/@remix-run/react/esm/invariant.js
init_react();
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// node_modules/@remix-run/react/esm/links.js
init_react();

// node_modules/@remix-run/react/esm/routeModules.js
init_react();
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push(__spreadProps(__spreadValues({}, descriptor), {
        rel: "preload",
        as: "style"
      }));
    }
  }
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  return object != null && typeof object.rel === "string" && typeof object.href === "string";
}
async function getStylesheetPrefetchLinks(matches, routeModules) {
  let links2 = await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(match.route, routeModules);
    return mod.links ? mod.links() : [];
  }));
  return links2.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((_a) => {
    var _b = _a, {
      rel
    } = _b, attrs = __objRest(_b, [
      "rel"
    ]);
    return rel === "preload" ? __spreadValues({
      rel: "prefetch"
    }, attrs) : __spreadValues({
      rel: "prefetch",
      as: "style"
    }, attrs);
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {
  let path = parsePathPatch(page);
  let isNew = (match, index2) => {
    if (!currentMatches[index2])
      return true;
    return match.route.id !== currentMatches[index2].route.id;
  };
  let matchPathChanged = (match, index2) => {
    var _currentMatches$index;
    return currentMatches[index2].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index2].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index2].params["*"] !== match.params["*"];
  };
  let newMatches = mode === "data" && location.search !== path.search ? nextMatches.filter((match, index2) => {
    if (!match.route.hasLoader) {
      return false;
    }
    if (isNew(match, index2) || matchPathChanged(match, index2)) {
      return true;
    }
    if (match.route.shouldReload) {
      return match.route.shouldReload({
        params: match.params,
        prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),
        url: new URL(page, window.origin)
      });
    }
    return true;
  }) : nextMatches.filter((match, index2) => {
    return match.route.hasLoader && (isNew(match, index2) || matchPathChanged(match, index2));
  });
  return newMatches;
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path;
    let searchParams = new URLSearchParams(search);
    searchParams.set("_data", match.route.id);
    return `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let str = JSON.stringify(descriptor);
    if (!set.has(str)) {
      set.add(str);
      deduped.push(descriptor);
    }
    return deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = J(href);
  if (path.search === void 0)
    path.search = "";
  return path;
}

// node_modules/@remix-run/react/esm/markup.js
init_react();
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/esm/routes.js
init_react();
var React2 = __toModule(require_react());

// node_modules/@remix-run/react/esm/data.js
init_react();
function isCatchResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
async function fetchData(url, routeId, signal, submission) {
  url.searchParams.set("_data", routeId);
  let init2 = submission ? getActionInit(submission, signal) : {
    credentials: "same-origin",
    signal
  };
  let response = await fetch(url.href, init2);
  if (isErrorResponse(response)) {
    let data = await response.json();
    let error = new Error(data.message);
    error.stack = data.stack;
    return error;
  }
  return response;
}
async function extractData2(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission;
  let headers = void 0;
  let body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData) {
      invariant2(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
      body.append(key, value);
    }
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}

// node_modules/@remix-run/react/esm/transition.js
init_react();

// node_modules/@remix-run/react/esm/routeMatching.js
init_react();
function matchClientRoutes(routes2, location) {
  let matches = matchRoutes(routes2, location);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/react/esm/transition.js
var CatchValue = class {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText;
    this.data = data;
  }
};
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location) {
  return Boolean(location.state) && location.state.isRedirect;
}
function isLoaderRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loader";
}
function isActionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "action";
}
function isFetchActionRedirect(location) {
  return isRedirectLocation(location) && location.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loaderSubmission";
}
var TransitionRedirect = class {
  constructor(location) {
    this.location = typeof location === "string" ? location : location.pathname + location.search;
  }
};
var IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
};
var IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init2) {
  let {
    routes: routes2
  } = init2;
  let pendingNavigationController;
  let fetchControllers = new Map();
  let incrementingLoadId = 0;
  let navigationLoadId = -1;
  let fetchReloadIds = new Map();
  let matches = matchClientRoutes(routes2, init2.location);
  if (!matches) {
    matches = [{
      params: {},
      pathname: "",
      route: routes2[0]
    }];
  }
  let state = {
    location: init2.location,
    loaderData: init2.loaderData || {},
    actionData: init2.actionData,
    catch: init2.catch,
    error: init2.error,
    catchBoundaryId: init2.catchBoundaryId || null,
    errorBoundaryId: init2.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: new Map()
  };
  function update(updates) {
    state = Object.assign({}, state, updates);
    init2.onChange(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchReloadIds.delete(key);
    state.fetchers.delete(key);
  }
  async function send(event) {
    switch (event.type) {
      case "navigation": {
        let {
          action,
          location,
          submission
        } = event;
        let matches2 = matchClientRoutes(routes2, location);
        if (!matches2) {
          matches2 = [{
            params: {},
            pathname: "",
            route: routes2[0]
          }];
          await handleNotFoundNavigation(location, matches2);
        } else if (!submission && isHashChangeOnly(location)) {
          await handleHashChange(location, matches2);
        } else if (action === r.Pop) {
          await handleLoad(location, matches2);
        } else if (submission && isActionSubmission(submission)) {
          await handleActionSubmissionNavigation(location, submission, matches2);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderSubmissionNavigation(location, submission, matches2);
        } else if (isActionRedirectLocation(location)) {
          await handleActionRedirect(location, matches2);
        } else if (isLoaderSubmissionRedirectLocation(location)) {
          await handleLoaderSubmissionRedirect(location, matches2);
        } else if (isLoaderRedirectLocation(location)) {
          await handleLoaderRedirect(location, matches2);
        } else if (isFetchActionRedirect(location)) {
          await handleFetchActionRedirect(location, matches2);
        } else {
          await handleLoad(location, matches2);
        }
        navigationLoadId = -1;
        break;
      }
      case "fetcher": {
        let {
          key,
          submission,
          href
        } = event;
        let matches2 = matchClientRoutes(routes2, href);
        invariant2(matches2, "No matches found");
        let match = matches2.slice(-1)[0];
        if (fetchControllers.has(key))
          abortFetcher(key);
        if (submission && isActionSubmission(submission)) {
          await handleActionFetchSubmission(key, submission, match);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderFetchSubmission(href, key, submission, match);
        } else {
          await handleLoaderFetch(href, key, match);
        }
        break;
      }
      default: {
        throw new Error(`Unknown data event type: ${event.type}`);
      }
    }
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers) {
      controller.abort();
    }
  }
  async function handleActionFetchSubmission(key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callAction(submission, match, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "fetchAction"
      };
      init2.onRedirect(result.value.location, locationState);
      let doneFetcher2 = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher2);
      update({
        fetchers: new Map(state.fetchers)
      });
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let loadFetcher = {
      state: "loading",
      type: "actionReload",
      data: result.value,
      submission
    };
    state.fetchers.set(key, loadFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
    let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let matchesToLoad = state.nextMatches || state.matches;
    let hrefToLoad = createHref(state.transition.location || state.location);
    let results = await callLoaders(state, createUrl(hrefToLoad), matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
    if (controller.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    let redirect = findRedirect(results);
    if (redirect) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(redirect.location, locationState);
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult);
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    let abortedKeys = abortStaleFetchLoads(loadId);
    if (abortedKeys) {
      markFetchersDone(abortedKeys);
    }
    let yeetedNavigation = yeetStaleNavigationLoad(loadId);
    if (yeetedNavigation) {
      let {
        transition
      } = state;
      invariant2(transition.state === "loading", "Expected loading transition");
      update({
        location: transition.location,
        matches: state.nextMatches,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad),
        actionData: transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers)
      });
    } else {
      update({
        fetchers: new Map(state.fetchers),
        error,
        errorBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad)
      });
    }
  }
  function yeetStaleNavigationLoad(landedId) {
    let isLoadingNavigation = state.transition.state === "loading";
    if (isLoadingNavigation && navigationLoadId < landedId) {
      abortNormalNavigation();
      return true;
    }
    return false;
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id2] of fetchReloadIds) {
      if (id2 < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant2(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    return yeetedKeys.length ? yeetedKeys : false;
  }
  async function handleLoaderFetchSubmission(href, key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    fetchControllers.delete(key);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function handleLoaderFetch(href, key, match) {
    if (typeof AbortController === "undefined") {
      throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
    }
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (controller.signal.aborted)
      return;
    fetchControllers.delete(key);
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function maybeBailOnCatch(match, key, result) {
    if (isCatchResult(result)) {
      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers),
        catch: {
          data: result.value.data,
          status: result.value.status,
          statusText: result.value.statusText
        },
        catchBoundaryId
      });
      return true;
    }
    return false;
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      });
      return true;
    }
    return false;
  }
  async function handleNotFoundNavigation(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
    update({
      location,
      matches: matches2,
      catch: {
        data: null,
        status: 404,
        statusText: "Not Found"
      },
      catchBoundaryId,
      transition: IDLE_TRANSITION
    });
  }
  async function handleActionSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    let controller = new AbortController();
    pendingNavigationController = controller;
    if (!isIndexRequestAction(submission.action) && matches2[matches2.length - 1].route.id.endsWith("/index")) {
      matches2 = matches2.slice(0, -1);
    }
    let leafMatch = matches2.slice(-1)[0];
    let result = await callAction(submission, leafMatch, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "action"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (isCatchResult(result)) {
      let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], matches2, result);
      update({
        transition: IDLE_TRANSITION,
        catch: catchVal,
        catchBoundaryId
      });
      return;
    }
    let loadTransition = {
      state: "loading",
      type: "actionReload",
      submission,
      location
    };
    update({
      transition: loadTransition,
      actionData: {
        [leafMatch.route.id]: result.value
      }
    });
    await loadPageData(location, matches2, submission, leafMatch.route.id, result);
  }
  async function handleLoaderSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleHashChange(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    update({
      location,
      matches: matches2,
      transition: IDLE_TRANSITION
    });
  }
  async function handleLoad(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderSubmissionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "loaderSubmissionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleFetchActionRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "fetchActionRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleActionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "actionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  function isHashChangeOnly(location) {
    return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;
  }
  async function loadPageData(location, matches2, submission, submissionRouteId, actionResult) {
    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
    let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
    let controller = new AbortController();
    pendingNavigationController = controller;
    navigationLoadId = ++incrementingLoadId;
    let results = await callLoaders(state, createUrl(createHref(location)), matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId);
    if (controller.signal.aborted) {
      return;
    }
    let redirect = findRedirect(results);
    if (redirect) {
      if (state.transition.type === "actionReload") {
        let locationState = {
          isRedirect: true,
          type: "action"
        };
        init2.onRedirect(redirect.location, locationState);
      } else if (state.transition.type === "loaderSubmission") {
        let locationState = {
          isRedirect: true,
          type: "loaderSubmission"
        };
        init2.onRedirect(redirect.location, locationState);
      } else {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init2.onRedirect(redirect.location, locationState);
      }
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult);
    let abortedIds = abortStaleFetchLoads(navigationLoadId);
    if (abortedIds) {
      markFetchersDone(abortedIds);
    }
    update({
      location,
      matches: matches2,
      error,
      errorBoundaryId,
      catch: catchVal,
      catchBoundaryId,
      loaderData: makeLoaderData(state, results, matches2),
      actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
      transition: IDLE_TRANSITION,
      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
    });
  }
  function abortNormalNavigation() {
    var _pendingNavigationCon;
    (_pendingNavigationCon = pendingNavigationController) === null || _pendingNavigationCon === void 0 ? void 0 : _pendingNavigationCon.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant2(controller, `Expected fetch controller: ${key}`);
    controller.abort();
    fetchControllers.delete(key);
  }
  return {
    send,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
function isIndexRequestAction(action) {
  let indexRequest = false;
  let searchParams = new URLSearchParams(action.split("?", 2)[1] || "");
  for (let param of searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
async function callLoaders(state, url, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  let matchesToLoad = filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher);
  return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
}
async function callLoader(match, url, signal) {
  invariant2(match.route.loader, `Expected loader for ${match.route.id}`);
  try {
    let {
      params
    } = match;
    let value = await match.route.loader({
      params,
      url,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
async function callAction(submission, match, signal) {
  if (!match.route.action) {
    throw new Error(`Route "${match.route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
  }
  try {
    let value = await match.route.action({
      url: createUrl(submission.action),
      params: match.params,
      submission,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
function filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  if (submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = false;
    matches = matches.filter((match) => {
      if (foundProblematicRoute) {
        return false;
      }
      if (match.route.id === submissionRouteId) {
        foundProblematicRoute = true;
        return false;
      }
      return true;
    });
  }
  let isNew = (match, index2) => {
    if (!state.matches[index2])
      return true;
    return match.route.id !== state.matches[index2].route.id;
  };
  let matchPathChanged = (match, index2) => {
    var _state$matches$index$;
    return state.matches[index2].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index2].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index2].params["*"] !== match.params["*"];
  };
  let filterByRouteProps = (match, index2) => {
    if (!match.route.loader) {
      return false;
    }
    if (isNew(match, index2) || matchPathChanged(match, index2)) {
      return true;
    }
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return true;
  };
  let isInRootCatchBoundary = state.matches.length === 1;
  if (isInRootCatchBoundary) {
    return matches.filter((match) => !!match.route.loader);
  }
  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
    return matches.filter(filterByRouteProps);
  } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search) {
    return matches.filter(filterByRouteProps);
  }
  return matches.filter((match, index2, arr) => {
    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index2) {
      return false;
    }
    return match.route.loader && (isNew(match, index2) || matchPathChanged(match, index2));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location) {
  return location.pathname + location.search;
}
function findRedirect(results) {
  for (let result of results) {
    if (isRedirectResult(result)) {
      return result.value;
    }
  }
  return null;
}
async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  let loaderCatchResult;
  for (let result of results) {
    if (isCatchResult(result)) {
      loaderCatchResult = result;
      break;
    }
  }
  let extractCatchData = async (res) => ({
    status: res.status,
    statusText: res.statusText,
    data: res.data
  });
  if (actionCatchResult && loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(actionCatchResult.value), boundaryId];
  }
  if (loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(loaderCatchResult.value), boundaryId];
  }
  return [void 0, void 0];
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results) {
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.CatchBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.ErrorBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results) {
    newData[match.route.id] = value;
  }
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    if (value !== void 0) {
      loaderData[route.id] = value;
    }
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}

// node_modules/@remix-run/react/esm/routes.js
function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ React2.createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    if (children.length > 0)
      route.children = children;
    return route;
  });
}
function createShouldReload(route, routeModules) {
  let shouldReload = (arg) => {
    let module = routeModules[route.id];
    invariant2(module, `Expected route module to be loaded for ${route.id}`);
    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }
    return true;
  };
  return shouldReload;
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  await prefetchStyleLinks(routeModule);
  return routeModule;
}
function createLoader(route, routeModules) {
  let loader9 = async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect = await checkRedirect(result);
      if (redirect)
        return redirect;
      if (isCatchResponse2(result)) {
        throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
      }
      return extractData2(result);
    } else {
      await loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  };
  return loader9;
}
function createAction(route) {
  if (!route.hasAction)
    return void 0;
  let action = async ({
    url,
    signal,
    submission
  }) => {
    let result = await fetchData(url, route.id, signal, submission);
    if (result instanceof Error) {
      throw result;
    }
    let redirect = await checkRedirect(result);
    if (redirect)
      return redirect;
    if (isCatchResponse2(result)) {
      throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
    }
    return extractData2(result);
  };
  return action;
}
async function checkRedirect(response) {
  if (isRedirectResponse2(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
    if (url.origin !== window.location.origin) {
      await new Promise(() => {
        window.location.replace(url.href);
      });
    } else {
      return new TransitionRedirect(url.pathname + url.search);
    }
  }
  return null;
}

// node_modules/@remix-run/react/esm/components.js
var RemixEntryContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixEntryContext() {
  let context = React3.useContext(RemixEntryContext);
  invariant2(context, "You must render this element inside a <Remix> element");
  return context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = false
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext;
  let clientRoutes = React3.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
  let [clientState, setClientState] = React3.useState(entryComponentDidCatchEmulator);
  let [transitionManager] = React3.useState(() => {
    return createTransitionManager({
      routes: clientRoutes,
      actionData: documentActionData,
      loaderData: documentLoaderData,
      location: historyLocation,
      catch: entryComponentDidCatchEmulator.catch,
      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
      onRedirect: _navigator.replace,
      onChange: (state) => {
        setClientState({
          catch: state.catch,
          error: state.error,
          catchBoundaryRouteId: state.catchBoundaryId,
          loaderBoundaryRouteId: state.errorBoundaryId,
          renderBoundaryRouteId: null,
          trackBoundaries: false,
          trackCatchBoundaries: false
        });
      }
    });
  });
  let navigator = React3.useMemo(() => {
    let push = (to, state) => {
      return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
    };
    return __spreadProps(__spreadValues({}, _navigator), {
      push
    });
  }, [_navigator, transitionManager]);
  let {
    location,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  React3.useEffect(() => {
    let {
      location: location2
    } = transitionManager.getState();
    if (historyLocation === location2)
      return;
    transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ React3.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
    location,
    component: RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
    location,
    component: RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(Router, {
    navigationType: action,
    location,
    navigator,
    static: staticProp
  }, /* @__PURE__ */ React3.createElement(Routes2, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  error.stack = data.stack;
  return error;
}
function Routes2() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  let element = useRoutes(clientRoutes) || clientRoutes[0].element;
  return element;
}
var RemixRouteContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixRouteContext() {
  let context = React3.useContext(RemixRouteContext);
  invariant2(context, "You must render this element in a remix route element");
  return context;
}
function DefaultRouteComponent({
  id: id2
}) {
  throw new Error(`Route "${id2}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id: id2
}) {
  let location = useLocation();
  let {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  let data = routeData[id2];
  let {
    default: Component,
    CatchBoundary: CatchBoundary2,
    ErrorBoundary: ErrorBoundary2
  } = routeModules[id2];
  let element = Component ? /* @__PURE__ */ React3.createElement(Component, null) : /* @__PURE__ */ React3.createElement(DefaultRouteComponent, {
    id: id2
  });
  let context = {
    data,
    id: id2
  };
  if (CatchBoundary2) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id2 ? appState.catch : void 0;
    if (appState.trackCatchBoundaries) {
      appState.catchBoundaryRouteId = id2;
    }
    context = maybeServerCaught ? {
      id: id2,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
        return void 0;
      }
    } : {
      id: id2,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
      location,
      component: CatchBoundary2,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary2) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id2 || appState.loaderBoundaryRouteId === id2) ? deserializeError(appState.error) : void 0;
    if (appState.trackBoundaries) {
      appState.renderBoundaryRouteId = id2;
    }
    context = maybeServerRenderError ? {
      id: id2,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
        return void 0;
      }
    } : {
      id: id2,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
      location,
      component: ErrorBoundary2,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ React3.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = React3.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = React3.useState(false);
  let {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  React3.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
  }, [prefetch]);
  let setIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(true);
    }
  };
  let cancelIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(false);
    }
  };
  React3.useEffect(() => {
    if (maybePrefetch) {
      let id2 = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id2);
      };
    }
  }, [maybePrefetch]);
  return [shouldPrefetch, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
var NavLink2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(NavLink, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
var Link2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Link, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext();
  let links2 = React3.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, links2.map((link) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, _extends3({
    key: link.page
  }, link)) : /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.rel + link.href
  }, link))));
}
function PrefetchPageLinks(_a) {
  var _b = _a, {
    page
  } = _b, dataLinkProps = __objRest(_b, [
    "page"
  ]);
  let {
    clientRoutes
  } = useRemixEntryContext();
  let matches = React3.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
  if (!matches) {
    console.warn(`Tried to prefetch ${page} but no routes matched.`);
    return null;
  }
  return /* @__PURE__ */ React3.createElement(PrefetchPageLinksImpl, _extends3({
    page,
    matches
  }, dataLinkProps));
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext();
  let [styleLinks, setStyleLinks] = React3.useState([]);
  React3.useEffect(() => {
    let interrupted = false;
    getStylesheetPrefetchLinks(matches, routeModules).then((links2) => {
      if (!interrupted)
        setStyleLinks(links2);
    });
    return () => {
      interrupted = true;
    };
  }, [matches, routeModules]);
  return styleLinks;
}
function PrefetchPageLinksImpl(_a) {
  var _b = _a, {
    page,
    matches: nextMatches
  } = _b, linkProps = __objRest(_b, [
    "page",
    "matches"
  ]);
  let location = useLocation();
  let {
    matches,
    manifest
  } = useRemixEntryContext();
  let newMatchesForData = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "data"), [page, nextMatches, matches, location]);
  let newMatchesForAssets = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "assets"), [page, nextMatches, matches, location]);
  let dataHrefs = React3.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
  let moduleHrefs = React3.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  let location = useLocation();
  let meta9 = {};
  let parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id;
    let data = routeData[routeId];
    let params = match.params;
    let routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location
      }) : routeModule.meta;
      Object.assign(meta9, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, Object.entries(meta9).map(([name, value]) => {
    let isOpenGraphTag = name.startsWith("og:");
    return name === "title" ? /* @__PURE__ */ React3.createElement("title", {
      key: "title"
    }, value) : Array.isArray(value) ? value.map((content) => isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      property: name,
      content
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      name,
      content
    })) : isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      property: name,
      content: value
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      name,
      content: value
    });
  }));
}
var isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  React3.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = React3.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
    let routeModulesScript = `${matches.map((match, index2) => `import * as route${index2} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index2) => `${JSON.stringify(match.route.id)}:route${index2}`).join(",")}};`;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(contextScript)
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.url
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module"
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.entry.module,
      type: "module"
    })));
  }, []);
  let nextMatches = React3.useMemo(() => {
    if (pendingLocation) {
      let matches2 = matchClientRoutes(clientRoutes, pendingLocation);
      invariant2(matches2, `No routes match path "${pendingLocation.pathname}"`);
      return matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]);
  let routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1);
  let preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dedupe2(preloads).map((path) => /* @__PURE__ */ React3.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe2(array) {
  return [...new Set(array)];
}
var nextNavigationSubmission;
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  nextNavigationSubmission = void 0;
  return submission;
}
function useBeforeUnload(callback) {
  React3.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}
function useMatches() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  return React3.useMemo(() => matches.map((match) => {
    var _routeModules$match$r;
    let {
      pathname,
      params
    } = match;
    return {
      id: match.route.id,
      pathname,
      params,
      data: routeData[match.route.id],
      handle: (_routeModules$match$r = routeModules[match.route.id]) === null || _routeModules$match$r === void 0 ? void 0 : _routeModules$match$r.handle
    };
  }), [matches, routeData, routeModules]);
}
function useLoaderData() {
  return useRemixRouteContext().data;
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
var LiveReload = false ? () => null : function LiveReload2({
  port = Number(8002)
}) {
  return /* @__PURE__ */ React3.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
let protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
let host = location.hostname;
let socketPath = protocol + '//' + host + ':${port}/socket';

let ws = new WebSocket(socketPath);
ws.onmessage = message => {
  let event = JSON.parse(message.data);
  if (event.type === "LOG") {
    console.log(event.message);
  }
  if (event.type === "RELOAD") {
    console.log("\u{1F4BF} Reloading window ...");
    window.location.reload();
  }
};
ws.onerror = error => {
  console.log("Remix dev asset server web socket error:");
  console.error(error);
};
              `.trim()
    }
  });
};

// node_modules/@remix-run/react/esm/scroll-restoration.js
init_react();
var React4 = __toModule(require_react());
var STORAGE_KEY = "positions";
var positions = {};
if (typeof document !== "undefined") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  if (sessionPositions) {
    positions = JSON.parse(sessionPositions);
  }
}
function ScrollRestoration() {
  useScrollRestoration();
  React4.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []);
  useBeforeUnload(React4.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  return /* @__PURE__ */ React4.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
          let STORAGE_KEY = ${JSON.stringify(STORAGE_KEY)};
          if (!window.history.state || !window.history.state.key) {
            window.history.replaceState({ key: Math.random().toString(32).slice(2) }, null);
          }
          try {
            let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || '{}')
            let storedY = positions[window.history.state.key];
            if (typeof storedY === 'number') {
              window.scrollTo(0, storedY)
            }
          } catch(error) {
            console.error(error)
            sessionStorage.removeItem(STORAGE_KEY)
          }
        `
    }
  });
}
var hydrated = false;
function useScrollRestoration() {
  let location = useLocation();
  let transition = useTransition();
  let wasSubmissionRef = React4.useRef(false);
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
  React4.useEffect(() => {
    if (transition.location) {
      positions[location.key] = window.scrollY;
    }
  }, [transition, location]);
  useBeforeUnload(React4.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, []));
  if (typeof document !== "undefined") {
    React4.useLayoutEffect(() => {
      if (!hydrated) {
        hydrated = true;
        return;
      }
      let y = positions[location.key];
      if (y) {
        window.scrollTo(0, y);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (wasSubmissionRef.current === true) {
        wasSubmissionRef.current = false;
        return;
      }
      window.scrollTo(0, 0);
    }, [location]);
  }
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
}

// node_modules/@remix-run/react/esm/server.js
init_react();
var React5 = __toModule(require_react());
function RemixServer({
  context,
  url
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let location = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  };
  let staticNavigator = {
    createHref(to) {
      return typeof to === "string" ? to : I(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    },
    block() {
      throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
    }
  };
  return /* @__PURE__ */ React5.createElement(RemixEntry, {
    context,
    action: r.Pop,
    location,
    navigator: staticNavigator,
    static: true
  });
}

// app/entry.server.tsx
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  const markup = (0, import_server3.renderToString)(/* @__PURE__ */ React.createElement(RemixServer, {
    context: remixContext,
    url: request.url
  }));
  responseHeaders.set("Content-Type", "text/html");
  return new Response("<!DOCTYPE html>" + markup, {
    status: responseStatusCode,
    headers: responseHeaders
  });
}

// route:D:\projects\unikey.org\app\root.tsx
var root_exports = {};
__export(root_exports, {
  CatchBoundary: () => CatchBoundary,
  ErrorBoundary: () => ErrorBoundary,
  default: () => App,
  links: () => links,
  meta: () => meta
});
init_react();
var import_react5 = __toModule(require_react());
var import_prop_types = __toModule(require_prop_types());
var import_nprogress = __toModule(require_nprogress());

// node_modules/nprogress/nprogress.css
var nprogress_default = "/build/_assets/nprogress-JFUSETFZ.css";

// app/styles/app.css
var app_default = "/build/_assets/app-M5Q24Z45.css";

// route:D:\projects\unikey.org\app\root.tsx
var links = () => {
  return [
    { rel: "stylesheet", href: app_default },
    { rel: "stylesheet", href: nprogress_default }
  ];
};
var meta = () => {
  return { title: "Unikey - B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t" };
};
var menuItems = [
  { to: "/about", text: "Gi\u1EDBi thi\u1EC7u" },
  { to: "/blog", text: "Blog" },
  { to: "/linux", text: "Linux" },
  { to: "/apple", text: "Apple" },
  { to: "/support", text: "Tr\u1EE3 gi\xFAp" },
  { to: "/source", text: "M\xE3 ngu\u1ED3n" }
];
var activeNavLinkStyle = " text-red-500 ";
function Document({ children, title: title2 }) {
  const transition = useTransition();
  const matches = useMatches();
  import_react5.default.useEffect(() => {
    if (transition.state === "idle")
      import_nprogress.default.done();
    else
      import_nprogress.default.start();
  }, [transition.state]);
  return /* @__PURE__ */ import_react5.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react5.default.createElement("head", null, /* @__PURE__ */ import_react5.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react5.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1"
  }), /* @__PURE__ */ import_react5.default.createElement(Meta, null), title2 ? /* @__PURE__ */ import_react5.default.createElement("title", null, title2) : null, /* @__PURE__ */ import_react5.default.createElement(Links, null)), /* @__PURE__ */ import_react5.default.createElement("body", null, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "flex flex-col min-w-full min-h-screen"
  }, /* @__PURE__ */ import_react5.default.createElement("nav", {
    className: "py-10 px-10 bg-zinc-100"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "container flex justify-between max-w-screen-lg mx-auto"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "pr-10"
  }, /* @__PURE__ */ import_react5.default.createElement("a", {
    href: "/",
    className: "hover:no-underline"
  }, /* @__PURE__ */ import_react5.default.createElement("strong", null, "UniKey"))), /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "flex overflow-hidden"
  }, menuItems.map((menuItem) => {
    return /* @__PURE__ */ import_react5.default.createElement(NavLink2, {
      key: menuItem.to,
      to: menuItem.to,
      className: ({ isActive }) => "border-b-4 border-transparent hover:border-b-4 hover:border-red-500 hover:no-underline py-1 mx-4 font-semibold box-content whitespace-nowrap" + (isActive ? activeNavLinkStyle : "")
    }, menuItem.text);
  })))), /* @__PURE__ */ import_react5.default.createElement("main", {
    className: "mb-20"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "container px-10 max-w-screen-md mx-auto my-10"
  }, children)), /* @__PURE__ */ import_react5.default.createElement("footer", {
    className: "p-6 mt-auto bg-slate-500"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "container px-10 max-w-screen-lg mx-auto text-white"
  }, "\xA9 2021 Pham Kim Long."))), /* @__PURE__ */ import_react5.default.createElement(ScrollRestoration, null), /* @__PURE__ */ import_react5.default.createElement(Scripts, null), /* @__PURE__ */ import_react5.default.createElement(LiveReload, null)));
}
Document.propTypes = {
  children: import_prop_types.default.node,
  title: import_prop_types.default.string
};
function App() {
  return /* @__PURE__ */ import_react5.default.createElement(Document, null, /* @__PURE__ */ import_react5.default.createElement(Outlet, null));
}
function CatchBoundary() {
  const caught = useCatch();
  return /* @__PURE__ */ import_react5.default.createElement(Document, {
    title: `${caught.status} ${caught.statusText}`
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "error-container"
  }, /* @__PURE__ */ import_react5.default.createElement("h1", null, caught.status, " ", caught.statusText)));
}
function ErrorBoundary({ error }) {
  console.error(error);
  return /* @__PURE__ */ import_react5.default.createElement(Document, {
    title: "Uh-oh!"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "error-container"
  }, /* @__PURE__ */ import_react5.default.createElement("h1", null, "App Error"), /* @__PURE__ */ import_react5.default.createElement("pre", null, error.message)));
}
ErrorBoundary.propTypes = {
  error: import_prop_types.default.object
};

// route:D:\projects\unikey.org\app\routes\download.tsx
var download_exports = {};
__export(download_exports, {
  default: () => DownloadPage,
  handle: () => handle,
  loader: () => loader,
  meta: () => meta2
});
init_react();
var import_react35 = __toModule(require_react());

// app/utils/getPageData.ts
init_react();

// node_modules/marked/lib/marked.esm.js
init_react();
function getDefaults() {
  return {
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = /[&<>"']/g;
var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize2, base, href) {
  if (sanitize2) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain2 = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain2, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function merge(obj) {
  let i = 1, target, key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c2, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c2 && !invert) {
      suffLen++;
    } else if (currChar !== c2 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.substr(0, l - suffLen);
}
function findClosingBracket(str, b2) {
  if (str.indexOf(b2[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b2[0]) {
      level++;
    } else if (str[i] === b2[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title2 = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title: title2,
      text,
      tokens: lexer2.inlineTokens(text, [])
    };
    lexer2.state.inLink = false;
    return token;
  } else {
    return {
      type: "image",
      raw,
      href,
      title: title2,
      text: escape(text)
    };
  }
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim() : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *> ?/gm, "");
      return {
        type: "blockquote",
        raw: cap[0],
        tokens: this.lexer.blockTokens(text, []),
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0];
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            line = rawLine;
            if (this.options.pedantic) {
              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (nextBulletRegex.test(line)) {
              break;
            }
            if (line.search(/[^ ]/) >= indent || !line.trim()) {
              itemContents += "\n" + line.slice(indent);
            } else if (!blankLine) {
              itemContents += "\n" + line;
            } else {
              break;
            }
            if (!blankLine && !line.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        const spacers = list.items[i].tokens.filter((t) => t.type === "space");
        const hasMultipleLineBreaks = spacers.every((t) => {
          const chars = t.raw.split("");
          let lineBreaks = 0;
          for (const char of chars) {
            if (char === "\n") {
              lineBreaks += 1;
            }
            if (lineBreaks > 1) {
              return true;
            }
          }
          return false;
        });
        if (!list.loose && spacers.length && hasMultipleLineBreaks) {
          list.loose = true;
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        token.type = "paragraph";
        token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.tokens = [];
        this.lexer.inline(token.text, token.tokens);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      if (cap[3])
        cap[3] = cap[3].substring(1, cap[3].length - 1);
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      return {
        type: "def",
        tag,
        raw: cap[0],
        href: cap[2],
        title: cap[3]
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c2) => {
          return { text: c2 };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c2) => {
            return { text: c2 };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = [];
          this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = [];
            this.lexer.inlineTokens(row[k].text, row[k].tokens);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const token = {
        type: "paragraph",
        raw: cap[0],
        text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      const token = {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title2 = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title2 = link[3];
        }
      } else {
        title2 = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title2 ? title2.replace(this.rules.inline._escapes, "$1") : title2
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links2) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links2[link.toLowerCase()];
      if (!link || !link.href) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = src.slice(1, lLength + match.index + rLength);
          return {
            type: "em",
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text2,
            tokens: this.lexer.inlineTokens(text2, [])
          };
        }
        const text = src.slice(2, lLength + match.index + rLength - 1);
        return {
          type: "strong",
          raw: src.slice(0, lLength + match.index + rLength + 1),
          text,
          tokens: this.lexer.inlineTokens(text, [])
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2], [])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + text;
        } else {
          href = text;
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = merge({}, block);
block.gfm = merge({}, block.normal, {
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
});
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = merge({}, block.normal, {
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
});
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /\\\*|\\_/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = merge({}, inline);
inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
});
inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  static get rules() {
    return {
      block,
      inline
    };
  }
  static lex(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.lex(src);
  }
  static lexInline(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/^ +$/gm, "");
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens) {
    this.inlineQueue.push({ src, tokens });
  }
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links2 = Object.keys(this.tokens.links);
      if (links2.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links2.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return "<blockquote>\n" + quote + "</blockquote>\n";
  }
  html(html) {
    return html;
  }
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
    }
    return "<h" + level + ">" + text + "</h" + level + ">\n";
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text) {
    return "<li>" + text + "</li>\n";
  }
  checkbox(checked2) {
    return "<input " + (checked2 ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  paragraph(text) {
    return "<p>" + text + "</p>\n";
  }
  table(header, body) {
    if (body)
      body = "<tbody>" + body + "</tbody>";
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return "<tr>\n" + content + "</tr>\n";
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
    return tag + content + "</" + type + ">\n";
  }
  strong(text) {
    return "<strong>" + text + "</strong>";
  }
  em(text) {
    return "<em>" + text + "</em>";
  }
  codespan(text) {
    return "<code>" + text + "</code>";
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(text) {
    return "<del>" + text + "</del>";
  }
  link(href, title2, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + escape(href) + '"';
    if (title2) {
      out += ' title="' + title2 + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title2, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<img src="' + href + '" alt="' + text + '"';
    if (title2) {
      out += ' title="' + title2 + '"';
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var TextRenderer = class {
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title2, text) {
    return "" + text;
  }
  image(href, title2, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser = class {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  static parse(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parse(tokens);
  }
  static parseInline(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parseInline(tokens);
  }
  parse(tokens, top = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked2, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
          continue;
        }
        case "code": {
          out += this.renderer.code(token.text, token.lang, token.escaped);
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), { header: true, align: token.align[j] });
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: token.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked2 = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked2);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked2);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
function marked(src, opt, callback) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  if (typeof opt === "function") {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done2 = function(err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done2();
    }
    delete opt.highlight;
    if (!tokens.length)
      return done2();
    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === "code") {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done2(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done2();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done2();
    }
    return;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
}
marked.options = marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const opts = merge({}, ...args);
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  let hasExtensions;
  args.forEach((pack) => {
    if (pack.extensions) {
      hasExtensions = true;
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        pack.walkTokens.call(this, token);
        if (walkTokens2) {
          walkTokens2.call(this, token);
        }
      };
    }
    if (hasExtensions) {
      opts.extensions = extensions;
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  for (const token of tokens) {
    callback.call(marked, token);
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          marked.walkTokens(cell.tokens, callback);
        }
        for (const row of token.rows) {
          for (const cell of row) {
            marked.walkTokens(cell.tokens, callback);
          }
        }
        break;
      }
      case "list": {
        marked.walkTokens(token.items, callback);
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            marked.walkTokens(token[childTokens], callback);
          });
        } else if (token.tokens) {
          marked.walkTokens(token.tokens, callback);
        }
      }
    }
  }
};
marked.parseInline = function(src, opt) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked.parseInline(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  try {
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parseInline(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
};
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = Parser.parse;
var lexer = Lexer.lex;

// app/utils/getPageData.ts
var import_front_matter = __toModule(require_front_matter());
function getPageData(source) {
  const { attributes, body } = (0, import_front_matter.default)(source);
  const html = marked.parse(body);
  return { attributes, html };
}

// app/content/download.md.js
init_react();
var download_mdx = `---
title: Download UniKey
---
# Download UniKey

Tr\u01B0\u1EDBc khi ch\u1EA1y UniKey l\u1EA7n \u0111\u1EA7u ti\xEAn, b\u1EA1n h\xE3y xem h\u01B0\u1EDBng d\u1EABn v\u1EC1 vi\u1EC7c **ch\u1EE9ng th\u1EF1c UniKey v\u1EDBi ch\u1EEF k\xFD \u0111i\u1EC7n t\u1EED** \u0111\u1EC3 ch\u1EAFc ch\u1EAFn b\u1EA1n \u0111ang d\xF9ng b\u1EA3n UniKey s\u1EA1ch, xu\u1EA5t ph\xE1t t\u1EEB t\xE1c gi\u1EA3.

### UniKey 4.3 RC5

\u0110\xE2y l\xE0 phi\xEAn b\u1EA3n UniKey m\u1EDBi nh\u1EA5t.

* C\xE1c thay \u0111\u1ED5i c\u1EA3i ti\u1EBFn c\u1EE7a phi\xEAn b\u1EA3n n\xE0y: [Xem t\u1EA1i \u0111\xE2y](/)
* [UniKey 4.3 RC5, 64 bit, ZIP file](/): Build 200929. H\u1ED7 tr\u1EE3 Windows 64-bit.
* [UniKey 4.3 RC5, 32 bit, ZIP file](/): Build 200929. H\u1ED7 tr\u1EE3 Windows 32-bit v\xE0 64-bit.
* N\u1EBFu b\u1EA1n t\xECm th\u1EA5y l\u1ED7i trong UniKey, [xin h\xE3y b\xE1o l\u1ED7i t\u1EA1i \u0111\xE2y](/).

### UniKey 4.3 RC4

\u0110\xE2y l\xE0 phi\xEAn b\u1EA3n c\u0169, \u1ED5n \u0111\u1ECBnh, \u0111\u01B0\u1EE3c ph\xE1t h\xE0nh t\u1EEB th\xE1ng 7, n\u0103m 2018.

* [UniKey 4.3 RC4, 64 bit, ZIP file](/): Build 180714. H\u1ED7 tr\u1EE3 Windows 64-bit.
* [UniKey 4.3 RC4, 32 bit, ZIP file](/): Build 180714. H\u1ED7 tr\u1EE3 Windows 32-bit.

### UVConverter

UVConverter l\xE0 m\u1ED9t ch\u01B0\u01A1ng tr\xECnh d\xF2ng l\u1EC7nh \u0111a n\u0103ng d\xF9ng \u0111\u1EC3 chuy\u1EC3n \u0111\u1ED5i gi\u1EEFa c\xE1c b\u1EA3ng m\xE3 ti\u1EBFng Vi\u1EC7t kh\xE1c nhau.(Unicode, UTF8, TCVN3, VNI\u2026)

UVConverter c\xF3 c\xE1c phi\xEAn b\u1EA3n d\xE0nh cho Windows v\xE0 Linux.

[UVConverter 1.1.3b for Windows (12 KB)](/).
[UVConverter for Linux](/)

`;

// node_modules/framer-motion/dist/es/index.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/motion.mjs
init_react();

// node_modules/framer-motion/node_modules/tslib/modules/index.js
init_react();
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// node_modules/framer-motion/dist/es/motion/index.mjs
init_react();
var React8 = __toModule(require_react());
var import_react21 = __toModule(require_react());

// node_modules/framer-motion/dist/es/motion/features/use-features.mjs
init_react();
var React7 = __toModule(require_react());
var import_react7 = __toModule(require_react());

// node_modules/framer-motion/dist/es/motion/features/definitions.mjs
init_react();
var createDefinition = function(propNames) {
  return {
    isEnabled: function(props) {
      return propNames.some(function(name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features) {
  for (var key in features) {
    if (features[key] === null)
      continue;
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}

// node_modules/hey-listen/dist/hey-listen.es.js
init_react();
var warning2 = function() {
};
var invariant3 = function() {
};
if (true) {
  warning2 = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant3 = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/framer-motion/dist/es/context/LazyContext.mjs
init_react();
var import_react6 = __toModule(require_react());
var LazyContext = (0, import_react6.createContext)({ strict: false });

// node_modules/framer-motion/dist/es/motion/features/use-features.mjs
var featureNames = Object.keys(featureDefinitions);
var numFeatures = featureNames.length;
function useFeatures(props, visualElement2, preloadedFeatures) {
  var features = [];
  var lazyContext = (0, import_react7.useContext)(LazyContext);
  if (!visualElement2)
    return null;
  if (preloadedFeatures && lazyContext.strict) {
    invariant3(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
  }
  for (var i = 0; i < numFeatures; i++) {
    var name_1 = featureNames[i];
    var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;
    if (isEnabled(props) && Component) {
      features.push(React7.createElement(Component, __assign({ key: name_1 }, props, { visualElement: visualElement2 })));
    }
  }
  return features;
}

// node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
init_react();
var import_react8 = __toModule(require_react());
var MotionConfigContext = (0, import_react8.createContext)({
  transformPagePoint: function(p) {
    return p;
  },
  isStatic: false,
  reducedMotion: "never"
});

// node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
init_react();
var import_react9 = __toModule(require_react());
var MotionContext = (0, import_react9.createContext)({});
function useVisualElementContext() {
  return (0, import_react9.useContext)(MotionContext).visualElement;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
init_react();
var import_react13 = __toModule(require_react());

// node_modules/framer-motion/dist/es/context/PresenceContext.mjs
init_react();
var import_react10 = __toModule(require_react());
var PresenceContext = (0, import_react10.createContext)(null);

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
init_react();
var import_react11 = __toModule(require_react());

// node_modules/framer-motion/dist/es/utils/is-browser.mjs
init_react();
var isBrowser = typeof window !== "undefined";

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser ? import_react11.useLayoutEffect : import_react11.useEffect;

// node_modules/framer-motion/dist/es/utils/use-reduced-motion.mjs
init_react();
var import_react12 = __toModule(require_react());
var prefersReducedMotion = { current: null };
var hasDetected = false;
function initPrefersReducedMotion() {
  hasDetected = true;
  if (typeof window === "undefined")
    return;
  if (window.matchMedia) {
    var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
    var setReducedMotionPreferences = function() {
      return prefersReducedMotion.current = motionMediaQuery_1.matches;
    };
    motionMediaQuery_1.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function useReducedMotion() {
  !hasDetected && initPrefersReducedMotion();
  var _a = __read((0, import_react12.useState)(prefersReducedMotion.current), 1), shouldReduceMotion = _a[0];
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  var reducedMotionPreference = useReducedMotion();
  var reducedMotion = (0, import_react12.useContext)(MotionConfigContext).reducedMotion;
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
function useVisualElement(Component, visualState, props, createVisualElement) {
  var lazyContext = (0, import_react13.useContext)(LazyContext);
  var parent = useVisualElementContext();
  var presenceContext = (0, import_react13.useContext)(PresenceContext);
  var shouldReduceMotion = useReducedMotionConfig();
  var visualElementRef = (0, import_react13.useRef)(void 0);
  if (!createVisualElement)
    createVisualElement = lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,
      shouldReduceMotion
    });
  }
  var visualElement2 = visualElementRef.current;
  useIsomorphicLayoutEffect(function() {
    visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
  });
  (0, import_react13.useEffect)(function() {
    var _a;
    (_a = visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();
  });
  useIsomorphicLayoutEffect(function() {
    return function() {
      return visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.notifyUnmount();
    };
  }, []);
  return visualElement2;
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
init_react();
var import_react14 = __toModule(require_react());

// node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
init_react();
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
function useMotionRef(visualState, visualElement2, externalRef) {
  return (0, import_react14.useCallback)(function(instance) {
    var _a;
    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));
    if (visualElement2) {
      instance ? visualElement2.mount(instance) : visualElement2.unmount();
    }
    if (externalRef) {
      if (typeof externalRef === "function") {
        externalRef(instance);
      } else if (isRefObject(externalRef)) {
        externalRef.current = instance;
      }
    }
  }, [visualElement2]);
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
init_react();
var import_react15 = __toModule(require_react());

// node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
init_react();

// node_modules/framer-motion/dist/es/render/utils/variants.mjs
init_react();
function isVariantLabels(v) {
  return Array.isArray(v);
}
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
  var _a;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "function") {
    definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function resolveVariant(visualElement2, definition, custom) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a;
  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}

// node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate3 = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate3) ? animate3 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props) {
  var _a = getCurrentTreeVariants(props, (0, import_react15.useContext)(MotionContext)), initial = _a.initial, animate3 = _a.animate;
  return (0, import_react15.useMemo)(function() {
    return { initial, animate: animate3 };
  }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// node_modules/framer-motion/dist/es/projection/node/id.mjs
init_react();

// node_modules/framer-motion/dist/es/utils/use-constant.mjs
init_react();
var import_react16 = __toModule(require_react());
function useConstant(init2) {
  var ref = (0, import_react16.useRef)(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
init_react();

// node_modules/framesync/dist/es/index.mjs
init_react();

// node_modules/framesync/dist/es/on-next-frame.mjs
init_react();
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

// node_modules/framesync/dist/es/create-render-step.mjs
init_react();
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}

// node_modules/framesync/dist/es/index.mjs
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
var sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
var processStep = (stepId) => steps[stepId].process(frame);
var processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var getFrameData = () => frame;
var es_default = sync;

// node_modules/popmotion/dist/es/index.mjs
init_react();

// node_modules/popmotion/dist/es/animations/index.mjs
init_react();

// node_modules/popmotion/node_modules/tslib/modules/index.js
init_react();
var import_tslib4 = __toModule(require_tslib2());
var {
  __extends: __extends2,
  __assign: __assign2,
  __rest: __rest2,
  __decorate: __decorate2,
  __param: __param2,
  __metadata: __metadata2,
  __awaiter: __awaiter2,
  __generator: __generator2,
  __exportStar: __exportStar2,
  __createBinding: __createBinding2,
  __values: __values2,
  __read: __read2,
  __spread: __spread2,
  __spreadArrays: __spreadArrays2,
  __spreadArray: __spreadArray2,
  __await: __await2,
  __asyncGenerator: __asyncGenerator2,
  __asyncDelegator: __asyncDelegator2,
  __asyncValues: __asyncValues2,
  __makeTemplateObject: __makeTemplateObject2,
  __importStar: __importStar2,
  __importDefault: __importDefault2,
  __classPrivateFieldGet: __classPrivateFieldGet2,
  __classPrivateFieldSet: __classPrivateFieldSet2
} = import_tslib4.default;

// node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs
init_react();

// node_modules/popmotion/dist/es/animations/generators/spring.mjs
init_react();

// node_modules/popmotion/dist/es/animations/utils/find-spring.mjs
init_react();

// node_modules/popmotion/dist/es/utils/clamp.mjs
init_react();
var clamp = (min, max, v) => Math.min(Math.max(v, min), max);

// node_modules/popmotion/dist/es/animations/utils/find-spring.mjs
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning2(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/popmotion/dist/es/animations/generators/spring.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options2, keys2) {
  return keys2.some((key) => options2[key] !== void 0);
}
function getSpringOptions(options2) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options2);
  if (!isSpringType(options2, physicsKeys) && isSpringType(options2, durationKeys)) {
    const derived = findSpring(options2);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a) {
  var { from: from2 = 0, to = 1, restSpeed = 2, restDelta } = _a, options2 = __rest2(_a, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from2 };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options2);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from2;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from2) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      };
      resolveVelocity = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t) => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from2, to] = [to, from2];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a2, b2) => typeof a2 === "string" || typeof b2 === "string";
var zero = (_t) => 0;

// node_modules/popmotion/dist/es/animations/generators/keyframes.mjs
init_react();

// node_modules/popmotion/dist/es/utils/interpolate.mjs
init_react();

// node_modules/popmotion/dist/es/utils/progress.mjs
init_react();
var progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};

// node_modules/popmotion/dist/es/utils/mix.mjs
init_react();
var mix = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;

// node_modules/popmotion/dist/es/utils/mix-color.mjs
init_react();

// node_modules/style-value-types/dist/es/index.mjs
init_react();

// node_modules/style-value-types/dist/es/numbers/index.mjs
init_react();

// node_modules/style-value-types/dist/es/utils.mjs
init_react();
var clamp2 = (min, max) => (v) => Math.max(Math.min(v, max), min);
var sanitize = (v) => v % 1 ? Number(v.toFixed(5)) : v;
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString2(v) {
  return typeof v === "string";
}

// node_modules/style-value-types/dist/es/numbers/index.mjs
var number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
var alpha = Object.assign(Object.assign({}, number), { transform: clamp2(0, 1) });
var scale = Object.assign(Object.assign({}, number), { default: 1 });

// node_modules/style-value-types/dist/es/numbers/units.mjs
init_react();
var createUnitType = (unit) => ({
  test: (v) => isString2(v) && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });

// node_modules/style-value-types/dist/es/color/hsla.mjs
init_react();

// node_modules/style-value-types/dist/es/color/utils.mjs
init_react();
var isColorString = (type, testProp) => (v) => {
  return Boolean(isString2(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
};
var splitColor = (aName, bName, cName) => (v) => {
  if (!isString2(v))
    return v;
  const [a2, b2, c2, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/style-value-types/dist/es/color/hsla.mjs
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// node_modules/style-value-types/dist/es/color/rgba.mjs
init_react();
var clampRgbUnit = clamp2(0, 255);
var rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });
var rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/style-value-types/dist/es/color/hex.mjs
init_react();
function parseHex(v) {
  let r2 = "";
  let g = "";
  let b2 = "";
  let a2 = "";
  if (v.length > 5) {
    r2 = v.substr(1, 2);
    g = v.substr(3, 2);
    b2 = v.substr(5, 2);
    a2 = v.substr(7, 2);
  } else {
    r2 = v.substr(1, 1);
    g = v.substr(2, 1);
    b2 = v.substr(3, 1);
    a2 = v.substr(4, 1);
    r2 += r2;
    g += g;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// node_modules/style-value-types/dist/es/color/index.mjs
init_react();
var color = {
  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
  parse: (v) => {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return isString2(v) ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
  }
};

// node_modules/style-value-types/dist/es/complex/index.mjs
init_react();
var colorToken = "${c}";
var numberToken = "${n}";
function test(v) {
  var _a, _b, _c, _d;
  return isNaN(v) && isString2(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse(v) {
  if (typeof v === "number")
    v = `${v}`;
  const values = [];
  let numColors = 0;
  const colors = v.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v = v.replace(colorRegex, colorToken);
    values.push(...colors.map(color.parse));
  }
  const numbers = v.match(floatRegex);
  if (numbers) {
    v = v.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v };
}
function parse(v) {
  return analyse(v).values;
}
function createTransformer(v) {
  const { values, numColors, tokenised } = analyse(v);
  const numValues = values.length;
  return (v2) => {
    let output = tokenised;
    for (let i = 0; i < numValues; i++) {
      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v2[i]) : sanitize(v2[i]));
    }
    return output;
  };
}
var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
function getAnimatableNone(v) {
  const parsed = parse(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = { test, parse, createTransformer, getAnimatableNone };

// node_modules/style-value-types/dist/es/complex/filter.mjs
init_react();
var maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  let [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {
  const functions = v.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v;
} });

// node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs
init_react();
function hueToRgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}

// node_modules/popmotion/dist/es/utils/mix-color.mjs
var mixLinearColor = (from2, to, v) => {
  const fromExpo = from2 * from2;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = (v) => colorTypes.find((type) => type.test(v));
var notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;
var mixColor = (from2, to) => {
  let fromColorType = getColorType(from2);
  let toColorType = getColorType(to);
  invariant3(!!fromColorType, notAnimatable(from2));
  invariant3(!!toColorType, notAnimatable(to));
  let fromColor = fromColorType.parse(from2);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);
    return fromColorType.transform(blended);
  };
};

// node_modules/popmotion/dist/es/utils/mix-complex.mjs
init_react();

// node_modules/popmotion/dist/es/utils/inc.mjs
init_react();
var isNum = (v) => typeof v === "number";

// node_modules/popmotion/dist/es/utils/pipe.mjs
init_react();
var combineFunctions = (a2, b2) => (v) => b2(a2(v));
var pipe = (...transformers) => transformers.reduce(combineFunctions);

// node_modules/popmotion/dist/es/utils/mix-complex.mjs
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v) => mix(origin, target, v);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
var mixArray = (from2, to) => {
  const output = [...from2];
  const numValues = output.length;
  const blendValue = from2.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }
    return output;
  };
};
var mixObject = (origin, target) => {
  const output = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
};
function analyse2(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse2(origin);
  const targetStats = analyse2(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    warning2(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return (p) => `${p > 0 ? target : origin}`;
  }
};

// node_modules/popmotion/dist/es/utils/interpolate.mjs
var mixNumber = (from2, to) => (p) => mix(from2, to, p);
function detectMixerFactory(v) {
  if (typeof v === "number") {
    return mixNumber;
  } else if (typeof v === "string") {
    if (color.test(v)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v)) {
    return mixArray;
  } else if (typeof v === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from2, to], [mixer]) {
  return (v) => mixer(progress(from2, to, v));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v <= input[0]) {
      foundMixerIndex = true;
    } else if (v >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i = 1;
      for (; i < inputLength; i++) {
        if (input[i] > v || i === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant3(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant3(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}

// node_modules/popmotion/dist/es/easing/index.mjs
init_react();

// node_modules/popmotion/dist/es/easing/utils.mjs
init_react();
var reverseEasing = (easing) => (p) => 1 - easing(1 - p);
var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
var createExpoIn = (power) => (p) => Math.pow(p, power);
var createBackIn = (power) => (p) => p * p * ((power + 1) * p - power);
var createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p) => (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
};

// node_modules/popmotion/dist/es/easing/index.mjs
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var linear = (p) => p;
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = (p) => 1 - Math.sin(Math.acos(p));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = (p) => {
  if (p === 1 || p === 0)
    return p;
  const p2 = p * p;
  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;
};
var bounceIn = reverseEasing(bounceOut);
var bounceInOut = (p) => p < 0.5 ? 0.5 * (1 - bounceOut(1 - p * 2)) : 0.5 * bounceOut(p * 2 - 1) + 0.5;

// node_modules/popmotion/dist/es/animations/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o) => o * duration);
}
function keyframes({ from: from2 = 0, to = 1, ease, offset, duration = 300 }) {
  const state = { done: false, value: from2 };
  const values = Array.isArray(to) ? to : [from2, to];
  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t) => {
      state.value = interpolator(t);
      state.done = t >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}

// node_modules/popmotion/dist/es/animations/generators/decay.mjs
init_react();
function decay({ velocity = 0, from: from2 = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from2 };
  let amplitude = power * velocity;
  const ideal = from2 + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from2;
  return {
    next: (t) => {
      const delta = -amplitude * Math.exp(-t / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}

// node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs
var types = { keyframes, spring, decay };
function detectAnimationFromOptions(config2) {
  if (Array.isArray(config2.to)) {
    return keyframes;
  } else if (types[config2.type]) {
    return types[config2.type];
  }
  const keys2 = new Set(Object.keys(config2));
  if (keys2.has("ease") || keys2.has("duration") && !keys2.has("dampingRatio")) {
    return keyframes;
  } else if (keys2.has("dampingRatio") || keys2.has("stiffness") || keys2.has("mass") || keys2.has("damping") || keys2.has("restSpeed") || keys2.has("restDelta")) {
    return spring;
  }
  return keyframes;
}

// node_modules/popmotion/dist/es/animations/utils/elapsed.mjs
init_react();
function loopElapsed(elapsed, duration, delay = 0) {
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}

// node_modules/popmotion/dist/es/animations/index.mjs
var framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => es_default.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate(_a) {
  var _b, _c;
  var { from: from2, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options2 = __rest2(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options2;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options2.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options2);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from2, to)) {
    interpolateFromNumber = interpolate([0, 100], [from2, to], {
      clamp: false
    });
    from2 = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options2), { from: from2, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}

// node_modules/popmotion/dist/es/animations/inertia.mjs
init_react();

// node_modules/popmotion/dist/es/utils/velocity-per-second.mjs
init_react();
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// node_modules/popmotion/dist/es/animations/inertia.mjs
function inertia({ from: from2 = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  let currentAnimation;
  function isOutOfBounds(v) {
    return min !== void 0 && v < min || max !== void 0 && v > max;
  }
  function boundaryNearest(v) {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  }
  function startAnimation2(options2) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate(Object.assign(Object.assign({}, options2), {
      driver,
      onUpdate: (v) => {
        var _a;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
        (_a = options2.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options2, v);
      },
      onComplete,
      onStop
    }));
  }
  function startSpring(options2) {
    startAnimation2(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options2));
  }
  if (isOutOfBounds(from2)) {
    startSpring({ from: from2, velocity, to: boundaryNearest(from2) });
  } else {
    let target = power * velocity + from2;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = boundaryNearest(target);
    const heading = boundary === min ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = (v) => {
      prev = current;
      current = v;
      velocity = velocityPerSecond(v - prev, getFrameData().delta);
      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {
        startSpring({ from: v, to: boundary, velocity });
      }
    };
    startAnimation2({
      type: "decay",
      from: from2,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}

// node_modules/popmotion/dist/es/utils/distance.mjs
init_react();

// node_modules/popmotion/dist/es/utils/is-point.mjs
init_react();
var isPoint = (point) => point.hasOwnProperty("x") && point.hasOwnProperty("y");

// node_modules/popmotion/dist/es/utils/is-point-3d.mjs
init_react();
var isPoint3D = (point) => isPoint(point) && point.hasOwnProperty("z");

// node_modules/popmotion/dist/es/utils/distance.mjs
var distance1D = (a2, b2) => Math.abs(a2 - b2);
function distance(a2, b2) {
  if (isNum(a2) && isNum(b2)) {
    return distance1D(a2, b2);
  } else if (isPoint(a2) && isPoint(b2)) {
    const xDelta = distance1D(a2.x, b2.x);
    const yDelta = distance1D(a2.y, b2.y);
    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}

// node_modules/popmotion/dist/es/easing/cubic-bezier.mjs
init_react();
var a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
var b = (a1, a2) => 3 * a2 - 6 * a1;
var c = (a1) => 3 * a1;
var calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
var getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
var newtonIterations = 8;
var newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i = 0; i < newtonIterations; ++i) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}

// node_modules/framer-motion/dist/es/animation/animate.mjs
init_react();

// node_modules/framer-motion/dist/es/value/index.mjs
init_react();

// node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
init_react();

// node_modules/framer-motion/dist/es/utils/array.mjs
init_react();
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}

// node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
var SubscriptionManager = function() {
  function SubscriptionManager2() {
    this.subscriptions = [];
  }
  SubscriptionManager2.prototype.add = function(handler) {
    var _this = this;
    addUniqueItem(this.subscriptions, handler);
    return function() {
      return removeItem(_this.subscriptions, handler);
    };
  };
  SubscriptionManager2.prototype.notify = function(a2, b2, c2) {
    var numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (var i = 0; i < numSubscriptions; i++) {
        var handler = this.subscriptions[i];
        handler && handler(a2, b2, c2);
      }
    }
  };
  SubscriptionManager2.prototype.getSize = function() {
    return this.subscriptions.length;
  };
  SubscriptionManager2.prototype.clear = function() {
    this.subscriptions.length = 0;
  };
  return SubscriptionManager2;
}();

// node_modules/framer-motion/dist/es/value/index.mjs
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = function() {
  function MotionValue2(init2) {
    var _this = this;
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.updateSubscribers = new SubscriptionManager();
    this.velocityUpdateSubscribers = new SubscriptionManager();
    this.renderSubscribers = new SubscriptionManager();
    this.canTrackVelocity = false;
    this.updateAndNotify = function(v, render) {
      if (render === void 0) {
        render = true;
      }
      _this.prev = _this.current;
      _this.current = v;
      var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;
      if (_this.lastUpdated !== timestamp) {
        _this.timeDelta = delta;
        _this.lastUpdated = timestamp;
        es_default.postRender(_this.scheduleVelocityCheck);
      }
      if (_this.prev !== _this.current) {
        _this.updateSubscribers.notify(_this.current);
      }
      if (_this.velocityUpdateSubscribers.getSize()) {
        _this.velocityUpdateSubscribers.notify(_this.getVelocity());
      }
      if (render) {
        _this.renderSubscribers.notify(_this.current);
      }
    };
    this.scheduleVelocityCheck = function() {
      return es_default.postRender(_this.velocityCheck);
    };
    this.velocityCheck = function(_a) {
      var timestamp = _a.timestamp;
      if (timestamp !== _this.lastUpdated) {
        _this.prev = _this.current;
        _this.velocityUpdateSubscribers.notify(_this.getVelocity());
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init2;
    this.canTrackVelocity = isFloat(this.current);
  }
  MotionValue2.prototype.onChange = function(subscription) {
    return this.updateSubscribers.add(subscription);
  };
  MotionValue2.prototype.clearListeners = function() {
    this.updateSubscribers.clear();
  };
  MotionValue2.prototype.onRenderRequest = function(subscription) {
    subscription(this.get());
    return this.renderSubscribers.add(subscription);
  };
  MotionValue2.prototype.attach = function(passiveEffect) {
    this.passiveEffect = passiveEffect;
  };
  MotionValue2.prototype.set = function(v, render) {
    if (render === void 0) {
      render = true;
    }
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  };
  MotionValue2.prototype.get = function() {
    return this.current;
  };
  MotionValue2.prototype.getPrevious = function() {
    return this.prev;
  };
  MotionValue2.prototype.getVelocity = function() {
    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
  };
  MotionValue2.prototype.start = function(animation) {
    var _this = this;
    this.stop();
    return new Promise(function(resolve) {
      _this.hasAnimated = true;
      _this.stopAnimation = animation(resolve);
    }).then(function() {
      return _this.clearAnimation();
    });
  };
  MotionValue2.prototype.stop = function() {
    if (this.stopAnimation)
      this.stopAnimation();
    this.clearAnimation();
  };
  MotionValue2.prototype.isAnimating = function() {
    return !!this.stopAnimation;
  };
  MotionValue2.prototype.clearAnimation = function() {
    this.stopAnimation = null;
  };
  MotionValue2.prototype.destroy = function() {
    this.updateSubscribers.clear();
    this.renderSubscribers.clear();
    this.stop();
  };
  return MotionValue2;
}();
function motionValue(init2) {
  return new MotionValue(init2);
}

// node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
init_react();
var isMotionValue = function(value) {
  return Boolean(value !== null && typeof value === "object" && value.getVelocity);
};

// node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
init_react();

// node_modules/framer-motion/dist/es/utils/time-conversion.mjs
init_react();
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};

// node_modules/framer-motion/dist/es/animation/utils/easing.mjs
init_react();
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    invariant3(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant3(easingLookup[definition] !== void 0, "Invalid easing type '".concat(definition, "'"));
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};

// node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
init_react();
var isAnimatable = function(key, value) {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && complex.test(value) && !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
init_react();

// node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
init_react();
var isKeyframesTarget = function(v) {
  return Array.isArray(v);
};

// node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
};
var criticallyDampedSpring = function(to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes2 = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function(valueKey, to) {
  var transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes2;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return __assign({ to }, transitionFactory(to));
};

// node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
init_react();
var int = __assign(__assign({}, number), { transform: Math.round });

// node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  zIndex: int,
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
var defaultValueTypes = __assign(__assign({}, numberValueTypes), {
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
});
var getDefaultValueType = function(key) {
  return defaultValueTypes[key];
};

// node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
function getAnimatableNone2(key, value) {
  var _a;
  var defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
}

// node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
init_react();
var instantAnimationState = {
  current: false
};

// node_modules/framer-motion/dist/es/utils/resolve-value.mjs
init_react();
var isCustomValue = function(v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = function(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
function isTransitionDefined(_a) {
  _a.when;
  _a.delay;
  _a.delayChildren;
  _a.staggerChildren;
  _a.staggerDirection;
  _a.repeat;
  _a.repeatType;
  _a.repeatDelay;
  _a.from;
  var transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition).length;
}
var legacyRepeatWarning = false;
function convertTransitionToAnimationOptions(_a) {
  var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, ["ease", "times", "yoyo", "flip", "loop"]);
  var options2 = __assign({}, transition);
  if (times)
    options2["offset"] = times;
  if (transition.duration)
    options2["duration"] = secondsToMilliseconds(transition.duration);
  if (transition.repeatDelay)
    options2.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
  if (ease) {
    options2["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition.type === "tween")
    options2.type = "keyframes";
  if (yoyo || loop || flip) {
    warning2(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options2.repeatType = "reverse";
    } else if (loop) {
      options2.repeatType = "loop";
    } else if (flip) {
      options2.repeatType = "mirror";
    }
    options2.repeat = loop || yoyo || flip || transition.repeat;
  }
  if (transition.type !== "spring")
    options2.type = "keyframes";
  return options2;
}
function getDelayFromTransition(transition, key) {
  var _a, _b;
  var valueTransition = getValueTransition(transition, key) || {};
  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;
}
function hydrateKeyframes(options2) {
  if (Array.isArray(options2.to) && options2.to[0] === null) {
    options2.to = __spreadArray([], __read(options2.to), false);
    options2.to[0] = options2.from;
  }
  return options2;
}
function getPopmotionAnimationOptions(transition, options2, key) {
  var _a;
  if (Array.isArray(options2.to)) {
    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;
  }
  hydrateKeyframes(options2);
  if (!isTransitionDefined(transition)) {
    transition = __assign(__assign({}, transition), getDefaultTransition(key, options2.to));
  }
  return __assign(__assign({}, options2), convertTransitionToAnimationOptions(transition));
}
function getAnimation(key, value, target, transition, onComplete) {
  var _a;
  var valueTransition = getValueTransition(transition, key);
  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
  var isTargetAnimatable = isAnimatable(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone2(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  var isOriginAnimatable = isAnimatable(key, origin);
  warning2(isOriginAnimatable === isTargetAnimatable, "You are trying to animate ".concat(key, ' from "').concat(origin, '" to "').concat(target, '". ').concat(origin, " is not an animatable value - to enable this animation set ").concat(origin, " to a value animatable to ").concat(target, " via the `style` property."));
  function start() {
    var options2 = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v) {
        return value.set(v);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(__assign(__assign({}, options2), valueTransition)) : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options2, key)), { onUpdate: function(v) {
      var _a2;
      options2.onUpdate(v);
      (_a2 = valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, v);
    }, onComplete: function() {
      var _a2;
      options2.onComplete();
      (_a2 = valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    } }));
  }
  function set() {
    var _a2, _b;
    var finalTarget = resolveFinalValueInKeyframes(target);
    value.set(finalTarget);
    onComplete();
    (_a2 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, finalTarget);
    (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone2("", potentialUnitType);
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
function startAnimation(key, value, target, transition) {
  if (transition === void 0) {
    transition = {};
  }
  if (instantAnimationState.current) {
    transition = { type: false };
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key, value, target, transition, onComplete);
    var delay = getDelayFromTransition(transition, key);
    var start = function() {
      return controls = animation();
    };
    if (delay) {
      delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));
    } else {
      start();
    }
    return function() {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}

// node_modules/framer-motion/dist/es/animation/animate.mjs
function animate2(from2, to, transition) {
  if (transition === void 0) {
    transition = {};
  }
  var value = isMotionValue(from2) ? from2 : motionValue(from2);
  startAnimation("", value, to, transition);
  return {
    stop: function() {
      return value.stop();
    },
    isAnimating: function() {
      return value.isAnimating();
    }
  };
}

// node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
init_react();
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = function(value) {
  return typeof value === "string" ? parseFloat(value) : value;
};
var isPx = function(value) {
  return typeof value === "number" || px.test(value);
};
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  var _a, _b, _c, _d;
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(0, (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress2));
    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress2);
  }
  for (var i = 0; i < numBorders; i++) {
    var borderLabel = "border".concat(borders[i], "Radius");
    var followRadius = getRadius(follow, borderLabel);
    var leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  var _a;
  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min, max, easing) {
  return function(p) {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress(min, max, p));
  };
}

// node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
init_react();
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
init_react();

// node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
init_react();
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale(_a) {
  var scale2 = _a.scale, scaleX = _a.scaleX, scaleY = _a.scaleY;
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function hasTranslate(value) {
  return value && value !== "0%";
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a) {
  var x = _a.x, y = _a.y;
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {
  var _a, _b;
  if (isSharedTransition === void 0) {
    isSharedTransition = false;
  }
  var treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  var node;
  var delta;
  for (var i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")
      continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, _a) {
  var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  var originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys);
  transformAxis(box.y, transform, yKeys);
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
init_react();
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance(value, target) < maxDistance;
}
function calcAxisDelta(delta, source, target, origin) {
  if (origin === void 0) {
    origin = 0.5;
  }
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
init_react();
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin, boxScale, originAxis, sourceAxis) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  if (originAxis === void 0) {
    originAxis = axis;
  }
  if (sourceAxis === void 0) {
    sourceAxis = axis;
  }
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    var relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  var originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, _a, origin, sourceAxis) {
  var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
var xKeys2 = ["x", "scaleX", "originX"];
var yKeys2 = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/models.mjs
init_react();
var createAxisDelta = function() {
  return {
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  };
};
var createDelta = function() {
  return {
    x: createAxisDelta(),
    y: createAxisDelta()
  };
};
var createAxis = function() {
  return { min: 0, max: 0 };
};
var createBox = function() {
  return {
    x: createAxis(),
    y: createAxis()
  };
};

// node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
init_react();
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}

// node_modules/framer-motion/dist/es/projection/shared/stack.mjs
init_react();
var NodeStack = function() {
  function NodeStack2() {
    this.members = [];
  }
  NodeStack2.prototype.add = function(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  };
  NodeStack2.prototype.remove = function(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      var prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  };
  NodeStack2.prototype.relegate = function(node) {
    var indexOfNode = this.members.findIndex(function(member2) {
      return node === member2;
    });
    if (indexOfNode === 0)
      return false;
    var prevLead;
    for (var i = indexOfNode; i >= 0; i--) {
      var member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  };
  NodeStack2.prototype.promote = function(node, preserveFollowOpacity) {
    var _a;
    var prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        node.snapshot.isShared = true;
      }
      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {
        node.isLayoutDirty = true;
      }
      var crossfade = node.options.crossfade;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  };
  NodeStack2.prototype.exitAnimationComplete = function() {
    this.members.forEach(function(node) {
      var _a, _b, _c, _d, _e;
      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);
    });
  };
  NodeStack2.prototype.scheduleRender = function() {
    this.members.forEach(function(node) {
      node.instance && node.scheduleRender(false);
    });
  };
  NodeStack2.prototype.removeLeadSnapshot = function() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  };
  return NodeStack2;
}();

// node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
init_react();
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}

// node_modules/framer-motion/dist/es/projection/styles/transform.mjs
init_react();
var identityProjection = "translate3d(0px, 0px, 0) scale(1, 1)";
function buildProjectionTransform(delta, treeScale, latestTransform) {
  var xTranslate = delta.x.translate / treeScale.x;
  var yTranslate = delta.y.translate / treeScale.y;
  var transform = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, 0) ");
  if (latestTransform) {
    var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate)
      transform += "rotate(".concat(rotate, "deg) ");
    if (rotateX)
      transform += "rotateX(".concat(rotateX, "deg) ");
    if (rotateY)
      transform += "rotateY(".concat(rotateY, "deg) ");
  }
  transform += "scale(".concat(delta.x.scale, ", ").concat(delta.y.scale, ")");
  return transform === identityProjection ? "none" : transform;
}

// node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
init_react();
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

// node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
init_react();
var transformAxes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  return transformAxes.forEach(function(axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
function sortTransformProps(a2, b2) {
  return transformProps.indexOf(a2) - transformProps.indexOf(b2);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
var transformOriginProps = new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}

// node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
init_react();

// node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
init_react();
var compareByDepth = function(a2, b2) {
  return a2.depth - b2.depth;
};

// node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var FlatTree = function() {
  function FlatTree2() {
    this.children = [];
    this.isDirty = false;
  }
  FlatTree2.prototype.add = function(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  };
  FlatTree2.prototype.remove = function(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  };
  FlatTree2.prototype.forEach = function(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  };
  return FlatTree2;
}();

// node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
init_react();
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var animationTarget = 1e3;
var globalProjectionState = {
  hasAnimatedSinceResize: true,
  hasEverUpdated: false
};
function createProjectionNode(_a) {
  var attachResizeListener = _a.attachResizeListener, defaultParent = _a.defaultParent, measureScroll = _a.measureScroll, resetTransform = _a.resetTransform;
  return function() {
    function ProjectionNode(id2, latestValues, parent) {
      var _this = this;
      if (latestValues === void 0) {
        latestValues = {};
      }
      if (parent === void 0) {
        parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();
      }
      this.children = new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = new Map();
      this.potentialNodes = new Map();
      this.checkUpdateFailed = function() {
        if (_this.isUpdating) {
          _this.isUpdating = false;
          _this.clearAllSnapshots();
        }
      };
      this.updateProjection = function() {
        _this.nodes.forEach(resolveTargetDelta);
        _this.nodes.forEach(calcProjection);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = new Map();
      this.id = id2;
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? __spreadArray(__spreadArray([], __read(parent.path), false), [parent], false) : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      id2 && this.root.registerPotentialNode(id2, this);
      for (var i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    ProjectionNode.prototype.addEventListener = function(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    };
    ProjectionNode.prototype.notifyListeners = function(name) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray([], __read(args), false));
    };
    ProjectionNode.prototype.hasListeners = function(name) {
      return this.eventHandlers.has(name);
    };
    ProjectionNode.prototype.registerPotentialNode = function(id2, node) {
      this.potentialNodes.set(id2, node);
    };
    ProjectionNode.prototype.mount = function(instance, isLayoutDirty) {
      var _this = this;
      var _a2;
      if (isLayoutDirty === void 0) {
        isLayoutDirty = false;
      }
      if (this.instance)
        return;
      this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
      this.instance = instance;
      var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement2 = _b.visualElement;
      if (visualElement2 && !visualElement2.getInstance()) {
        visualElement2.mount(instance);
      }
      this.root.nodes.add(this);
      (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.children.add(this);
      this.id && this.root.potentialNodes.delete(this.id);
      if (isLayoutDirty && (layout || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        var unblockTimeout_1;
        var resizeUnblockUpdate_1 = function() {
          return _this.root.updateBlockedByResize = false;
        };
        attachResizeListener(instance, function() {
          _this.root.updateBlockedByResize = true;
          clearTimeout(unblockTimeout_1);
          unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            _this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement2 && (layoutId || layout)) {
        this.addEventListener("didUpdate", function(_a3) {
          var _b2, _c, _d, _e, _f;
          var delta = _a3.delta, hasLayoutChanged = _a3.hasLayoutChanged, hasRelativeTargetChanged = _a3.hasRelativeTargetChanged, newLayout = _a3.layout;
          if (_this.isTreeAnimationBlocked()) {
            _this.target = void 0;
            _this.relativeTarget = void 0;
            return;
          }
          var layoutTransition = (_c = (_b2 = _this.options.transition) !== null && _b2 !== void 0 ? _b2 : visualElement2.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;
          var onLayoutAnimationComplete = visualElement2.getProps().onLayoutAnimationComplete;
          var targetChanged = !_this.targetLayout || !boxEquals(_this.targetLayout, newLayout) || hasRelativeTargetChanged;
          var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {
            if (_this.resumeFrom) {
              _this.resumingFrom = _this.resumeFrom;
              _this.resumingFrom.resumingFrom = void 0;
            }
            _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            var animationOptions = __assign(__assign({}, getValueTransition(layoutTransition, "layout")), { onComplete: onLayoutAnimationComplete });
            if (visualElement2.shouldReduceMotion) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            _this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged && _this.animationProgress === 0) {
              _this.finishAnimation();
            }
            _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));
          }
          _this.targetLayout = newLayout;
        });
      }
    };
    ProjectionNode.prototype.unmount = function() {
      var _a2, _b;
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.remove(this);
      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
      this.instance = void 0;
      cancelSync.preRender(this.updateProjection);
    };
    ProjectionNode.prototype.blockUpdate = function() {
      this.updateManuallyBlocked = true;
    };
    ProjectionNode.prototype.unblockUpdate = function() {
      this.updateManuallyBlocked = false;
    };
    ProjectionNode.prototype.isUpdateBlocked = function() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    };
    ProjectionNode.prototype.isTreeAnimationBlocked = function() {
      var _a2;
      return this.isAnimationBlocked || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimationBlocked()) || false;
    };
    ProjectionNode.prototype.startUpdate = function() {
      var _a2;
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      (_a2 = this.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach(resetRotation);
    };
    ProjectionNode.prototype.willUpdate = function(shouldNotifyListeners) {
      var _a2, _b, _c;
      if (shouldNotifyListeners === void 0) {
        shouldNotifyListeners = true;
      }
      if (this.root.isUpdateBlocked()) {
        (_b = (_a2 = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a2);
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (var i = 0; i < this.path.length; i++) {
        var node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll();
      }
      var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;
      if (layoutId === void 0 && !layout)
        return;
      var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;
      this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    };
    ProjectionNode.prototype.didUpdate = function() {
      var updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating)
        return;
      this.isUpdating = false;
      if (this.potentialNodes.size) {
        this.potentialNodes.forEach(mountNodeEarly);
        this.potentialNodes.clear();
      }
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      flushSync.update();
      flushSync.preRender();
      flushSync.render();
    };
    ProjectionNode.prototype.clearAllSnapshots = function() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    };
    ProjectionNode.prototype.scheduleUpdateProjection = function() {
      es_default.preRender(this.updateProjection, false, true);
    };
    ProjectionNode.prototype.scheduleCheckAfterUnmount = function() {
      var _this = this;
      es_default.postRender(function() {
        if (_this.isLayoutDirty) {
          _this.root.didUpdate();
        } else {
          _this.root.checkUpdateFailed();
        }
      });
    };
    ProjectionNode.prototype.updateSnapshot = function() {
      if (this.snapshot || !this.instance)
        return;
      var measured = this.measure();
      var layout = this.removeTransform(this.removeElementScroll(measured));
      roundBox(layout);
      this.snapshot = {
        measured,
        layout,
        latestValues: {}
      };
    };
    ProjectionNode.prototype.updateLayout = function() {
      var _a2;
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (var i = 0; i < this.path.length; i++) {
          var node = this.path[i];
          node.updateScroll();
        }
      }
      var measured = this.measure();
      roundBox(measured);
      var prevLayout = this.layout;
      this.layout = {
        measured,
        actual: this.removeElementScroll(measured)
      };
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.actual);
      (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
    };
    ProjectionNode.prototype.updateScroll = function() {
      if (this.options.layoutScroll && this.instance) {
        this.scroll = measureScroll(this.instance);
      }
    };
    ProjectionNode.prototype.resetTransform = function() {
      var _a2;
      if (!resetTransform)
        return;
      var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      var transformTemplate = (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
      var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
      var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    };
    ProjectionNode.prototype.measure = function() {
      var visualElement2 = this.options.visualElement;
      if (!visualElement2)
        return createBox();
      var box = visualElement2.measureViewportBox();
      var scroll = this.root.scroll;
      if (scroll) {
        translateAxis(box.x, scroll.x);
        translateAxis(box.y, scroll.y);
      }
      return box;
    };
    ProjectionNode.prototype.removeElementScroll = function(box) {
      var boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (var i = 0; i < this.path.length; i++) {
        var node = this.path[i];
        var scroll_1 = node.scroll, options2 = node.options;
        if (node !== this.root && scroll_1 && options2.layoutScroll) {
          translateAxis(boxWithoutScroll.x, scroll_1.x);
          translateAxis(boxWithoutScroll.y, scroll_1.y);
        }
      }
      return boxWithoutScroll;
    };
    ProjectionNode.prototype.applyTransform = function(box, transformOnly) {
      if (transformOnly === void 0) {
        transformOnly = false;
      }
      var withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (var i = 0; i < this.path.length; i++) {
        var node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.x,
            y: -node.scroll.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    };
    ProjectionNode.prototype.removeTransform = function(box) {
      var _a2;
      var boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (var i = 0; i < this.path.length; i++) {
        var node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        var sourceBox = createBox();
        var nodeBox = node.measure();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a2 = node.snapshot) === null || _a2 === void 0 ? void 0 : _a2.layout, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    };
    ProjectionNode.prototype.setTargetDelta = function(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
    };
    ProjectionNode.prototype.setOptions = function(options2) {
      var _a2;
      this.options = __assign(__assign(__assign({}, this.options), options2), { crossfade: (_a2 = options2.crossfade) !== null && _a2 !== void 0 ? _a2 : true });
    };
    ProjectionNode.prototype.clearMeasurements = function() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    };
    ProjectionNode.prototype.resolveTargetDelta = function() {
      var _a2;
      var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
      if (!this.layout || !(layout || layoutId))
        return;
      if (!this.targetDelta && !this.relativeTarget) {
        this.relativeParent = this.getClosestProjectingParent();
        if (this.relativeParent && this.relativeParent.layout) {
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.target)) {
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.actual);
        } else {
          copyBoxInto(this.target, this.layout.actual);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.actual);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        this.relativeParent = this.getClosestProjectingParent();
        if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        }
      }
    };
    ProjectionNode.prototype.getClosestProjectingParent = function() {
      if (!this.parent || hasTransform(this.parent.latestValues))
        return void 0;
      if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    };
    ProjectionNode.prototype.calcProjection = function() {
      var _a2;
      var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
      this.isTreeAnimating = Boolean(((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout || layoutId))
        return;
      var lead = this.getLead();
      copyBoxInto(this.layoutCorrected, this.layout.actual);
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
      var target = lead.target;
      if (!target)
        return;
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      var prevTreeScaleX = this.treeScale.x;
      var prevTreeScaleY = this.treeScale.y;
      var prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    };
    ProjectionNode.prototype.hide = function() {
      this.isVisible = false;
    };
    ProjectionNode.prototype.show = function() {
      this.isVisible = true;
    };
    ProjectionNode.prototype.scheduleRender = function(notifyAll) {
      var _a2, _b, _c;
      if (notifyAll === void 0) {
        notifyAll = true;
      }
      (_b = (_a2 = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a2);
      notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    };
    ProjectionNode.prototype.setAnimationOrigin = function(delta, hasOnlyRelativeTargetChanged) {
      var _this = this;
      var _a2;
      if (hasOnlyRelativeTargetChanged === void 0) {
        hasOnlyRelativeTargetChanged = false;
      }
      var snapshot = this.snapshot;
      var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
      var mixedValues = __assign({}, this.latestValues);
      var targetDelta = createDelta();
      this.relativeTarget = this.relativeTargetOrigin = void 0;
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      var relativeLayout = createBox();
      var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;
      var isOnlyMember = (((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length) || 0) <= 1;
      var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      this.mixTargetDelta = function(latest) {
        var _a3;
        var progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        _this.setTargetDelta(targetDelta);
        if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a3 = _this.relativeParent) === null || _a3 === void 0 ? void 0 : _a3.layout)) {
          calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);
          mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress2);
        }
        if (isSharedLayoutAnimation) {
          _this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        _this.root.scheduleUpdateProjection();
        _this.scheduleRender();
        _this.animationProgress = progress2;
      };
      this.mixTargetDelta(0);
    };
    ProjectionNode.prototype.startAnimation = function(options2) {
      var _this = this;
      var _a2, _b;
      (_a2 = this.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      if (this.resumingFrom) {
        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
      }
      if (this.pendingAnimation) {
        cancelSync.update(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = es_default.update(function() {
        globalProjectionState.hasAnimatedSinceResize = true;
        _this.currentAnimation = animate2(0, animationTarget, __assign(__assign({}, options2), { onUpdate: function(latest) {
          var _a3;
          _this.mixTargetDelta(latest);
          (_a3 = options2.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(options2, latest);
        }, onComplete: function() {
          var _a3;
          (_a3 = options2.onComplete) === null || _a3 === void 0 ? void 0 : _a3.call(options2);
          _this.completeAnimation();
        } }));
        if (_this.resumingFrom) {
          _this.resumingFrom.currentAnimation = _this.currentAnimation;
        }
        _this.pendingAnimation = void 0;
      });
    };
    ProjectionNode.prototype.completeAnimation = function() {
      var _a2;
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    };
    ProjectionNode.prototype.finishAnimation = function() {
      var _a2;
      if (this.currentAnimation) {
        (_a2 = this.mixTargetDelta) === null || _a2 === void 0 ? void 0 : _a2.call(this, animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    };
    ProjectionNode.prototype.applyTransformsToTarget = function() {
      var _a2 = this.getLead(), targetWithTransforms = _a2.targetWithTransforms, target = _a2.target, layout = _a2.layout, latestValues = _a2.latestValues;
      if (!targetWithTransforms || !target || !layout)
        return;
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    };
    ProjectionNode.prototype.registerSharedNode = function(layoutId, node) {
      var _a2, _b, _c;
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      var stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      node.promote({
        transition: (_a2 = node.options.initialPromotionConfig) === null || _a2 === void 0 ? void 0 : _a2.transition,
        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)
      });
    };
    ProjectionNode.prototype.isLead = function() {
      var stack = this.getStack();
      return stack ? stack.lead === this : true;
    };
    ProjectionNode.prototype.getLead = function() {
      var _a2;
      var layoutId = this.options.layoutId;
      return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
    };
    ProjectionNode.prototype.getPrevLead = function() {
      var _a2;
      var layoutId = this.options.layoutId;
      return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
    };
    ProjectionNode.prototype.getStack = function() {
      var layoutId = this.options.layoutId;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    };
    ProjectionNode.prototype.promote = function(_a2) {
      var _b = _a2 === void 0 ? {} : _a2, needsReset = _b.needsReset, transition = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;
      var stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    };
    ProjectionNode.prototype.relegate = function() {
      var stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    };
    ProjectionNode.prototype.resetRotation = function() {
      var visualElement2 = this.options.visualElement;
      if (!visualElement2)
        return;
      var hasRotate = false;
      var resetValues = {};
      for (var i = 0; i < transformAxes.length; i++) {
        var axis = transformAxes[i];
        var key = "rotate" + axis;
        if (!visualElement2.getStaticValue(key)) {
          continue;
        }
        hasRotate = true;
        resetValues[key] = visualElement2.getStaticValue(key);
        visualElement2.setStaticValue(key, 0);
      }
      if (!hasRotate)
        return;
      visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
      for (var key in resetValues) {
        visualElement2.setStaticValue(key, resetValues[key]);
      }
      visualElement2.scheduleRender();
    };
    ProjectionNode.prototype.getProjectionStyles = function(styleProp) {
      var _a2, _b, _c, _d, _e, _f;
      if (styleProp === void 0) {
        styleProp = {};
      }
      var styles = {};
      if (!this.instance || this.isSVG)
        return styles;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles.visibility = "";
      }
      var transformTemplate = (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      var lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        var emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      var valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      var _g = this.projectionDelta, x = _g.x, y = _g.y;
      styles.transformOrigin = "".concat(x.origin * 100, "% ").concat(y.origin * 100, "% 0");
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : "" : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;
      }
      for (var key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;
        var corrected = correct(valuesToRender[key], lead);
        if (applyTo) {
          var num = applyTo.length;
          for (var i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    };
    ProjectionNode.prototype.clearSnapshot = function() {
      this.resumeFrom = this.snapshot = void 0;
    };
    ProjectionNode.prototype.resetTree = function() {
      this.root.nodes.forEach(function(node) {
        var _a2;
        return (_a2 = node.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    };
    return ProjectionNode;
  }();
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a, _b, _c, _d;
  var snapshot = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    var _e = node.layout, layout_1 = _e.actual, measuredLayout = _e.measured;
    if (node.options.animationType === "size") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        var length = calcLength(axisSnapshot);
        axisSnapshot.min = layout_1[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (node.options.animationType === "position") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        var length = calcLength(layout_1[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
      });
    }
    var layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout_1, snapshot.layout);
    var visualDelta = createDelta();
    if (snapshot.isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);
    } else {
      calcBoxDelta(visualDelta, layout_1, snapshot.layout);
    }
    var hasLayoutChanged = !isDeltaZero(layoutDelta);
    var hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      node.relativeParent = node.getClosestProjectingParent();
      if (node.relativeParent && !node.relativeParent.resumeFrom) {
        var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;
        if (parentSnapshot && parentLayout) {
          var relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);
          var relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout_1,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);
  }
  node.options.transition = void 0;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  var visualElement2 = node.options.visualElement;
  if (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.getProps().onBeforeLayoutMeasure) {
    visualElement2.notifyBeforeLayoutMeasure();
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mix(delta.translate, 0, p);
  output.scale = mix(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p) {
  output.min = mix(from2.min, to.min, p);
  output.max = mix(from2.max, to.max, p);
}
function mixBox(output, from2, to, p) {
  mixAxis(output.x, from2.x, to.x, p);
  mixAxis(output.y, from2.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, id2) {
  var searchNode = node.root;
  for (var i = node.path.length - 1; i >= 0; i--) {
    if (Boolean(node.path[i].instance)) {
      searchNode = node.path[i];
      break;
    }
  }
  var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  var element = searchElement.querySelector('[data-projection-id="'.concat(id2, '"]'));
  if (element)
    node.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}

// node_modules/framer-motion/dist/es/projection/node/id.mjs
var id = 1;
function useProjectionId() {
  return useConstant(function() {
    if (globalProjectionState.hasEverUpdated) {
      return id++;
    }
  });
}

// node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
init_react();
var import_react17 = __toModule(require_react());
var LayoutGroupContext = (0, import_react17.createContext)({});

// node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
init_react();
var import_react19 = __toModule(require_react());

// node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
init_react();
var import_react18 = __toModule(require_react());
var SwitchLayoutGroupContext = (0, import_react18.createContext)({});

// node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
function useProjection(projectionId, _a, visualElement2, ProjectionNodeConstructor) {
  var _b;
  var layoutId = _a.layoutId, layout = _a.layout, drag2 = _a.drag, dragConstraints = _a.dragConstraints, layoutScroll = _a.layoutScroll;
  var initialPromotionConfig = (0, import_react19.useContext)(SwitchLayoutGroupContext);
  if (!ProjectionNodeConstructor || !visualElement2 || (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.projection)) {
    return;
  }
  visualElement2.projection = new ProjectionNodeConstructor(projectionId, visualElement2.getLatestValues(), (_b = visualElement2.parent) === null || _b === void 0 ? void 0 : _b.projection);
  visualElement2.projection.setOptions({
    layoutId,
    layout,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement: visualElement2,
    scheduleRender: function() {
      return visualElement2.scheduleRender();
    },
    animationType: typeof layout === "string" ? layout : "both",
    initialPromotionConfig,
    layoutScroll
  });
}

// node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs
init_react();
var import_react20 = __toModule(require_react());
var VisualElementHandler = function(_super) {
  __extends(VisualElementHandler2, _super);
  function VisualElementHandler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VisualElementHandler2.prototype.getSnapshotBeforeUpdate = function() {
    this.updateProps();
    return null;
  };
  VisualElementHandler2.prototype.componentDidUpdate = function() {
  };
  VisualElementHandler2.prototype.updateProps = function() {
    var _a = this.props, visualElement2 = _a.visualElement, props = _a.props;
    if (visualElement2)
      visualElement2.setProps(props);
  };
  VisualElementHandler2.prototype.render = function() {
    return this.props.children;
  };
  return VisualElementHandler2;
}(import_react20.default.Component);

// node_modules/framer-motion/dist/es/motion/index.mjs
function createMotionComponent(_a) {
  var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, projectionNodeConstructor = _a.projectionNodeConstructor, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    var layoutId = useLayoutId(props);
    props = __assign(__assign({}, props), { layoutId });
    var config2 = (0, import_react21.useContext)(MotionConfigContext);
    var features = null;
    var context = useCreateMotionContext(props);
    var projectionId = config2.isStatic ? void 0 : useProjectionId();
    var visualState = useVisualState(props, config2.isStatic);
    if (!config2.isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, __assign(__assign({}, config2), props), createVisualElement);
      useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);
      features = useFeatures(props, context.visualElement, preloadedFeatures);
    }
    return React8.createElement(VisualElementHandler, { visualElement: context.visualElement, props: __assign(__assign({}, config2), props) }, features, React8.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config2.isStatic, context.visualElement)));
  }
  return (0, import_react21.forwardRef)(MotionComponent);
}
function useLayoutId(_a) {
  var _b;
  var layoutId = _a.layoutId;
  var layoutGroupId = (_b = (0, import_react21.useContext)(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}

// node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
init_react();
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig) {
    if (customMotionComponentConfig === void 0) {
      customMotionComponentConfig = {};
    }
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  var componentCache = new Map();
  return new Proxy(custom, {
    get: function(_target, key) {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}

// node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
init_react();

// node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
init_react();
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component) {
  if (typeof Component !== "string" || Component.includes("-")) {
    return false;
  } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/.test(Component)) {
    return true;
  }
  return false;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
init_react();
var import_react24 = __toModule(require_react());

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
init_react();
var import_react22 = __toModule(require_react());

// node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
init_react();
function isForcedMotionValue(key, _a) {
  var layout = _a.layout, layoutId = _a.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}

// node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
init_react();

// node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
init_react();
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a, _b, transformIsDefault, transformTemplate) {
  var transform = _a.transform, transformKeys2 = _a.transformKeys;
  var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys2[i];
    transformString += "".concat(translateAlias[key] || key, "(").concat(transform[key], ") ");
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a) {
  var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
  return "".concat(originX, " ").concat(originY, " ").concat(originZ);
}

// node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
init_react();
function isCSSVariable(key) {
  return key.startsWith("--");
}

// node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
init_react();
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, options2, transformTemplate) {
  var _a;
  var style = state.style, vars = state.vars, transform = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform2 = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latestValues) {
    var value = latestValues[key];
    if (isCSSVariable(key)) {
      vars[key] = value;
      continue;
    }
    var valueType = numberValueTypes[key];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform2 = true;
      transform[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin[key] = valueAsType;
      hasTransformOrigin = true;
    } else {
      style[key] = valueAsType;
    }
  }
  if (hasTransform2) {
    style.transform = buildTransform(state, options2, transformIsNone, transformTemplate);
  } else if (transformTemplate) {
    style.transform = transformTemplate({}, "");
  } else if (!latestValues.transform && style.transform) {
    style.transform = "none";
  }
  if (hasTransformOrigin) {
    style.transformOrigin = buildTransformOrigin(transformOrigin);
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
init_react();
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
function copyRawValuesOnly(target, source, props) {
  for (var key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues(_a, visualState, isStatic) {
  var transformTemplate = _a.transformTemplate;
  return (0, import_react22.useMemo)(function() {
    var state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    var vars = state.vars, style = state.style;
    return __assign(__assign({}, vars), style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  var styleProp = props.style || {};
  var style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  if (props.transformValues) {
    style = props.transformValues(style);
  }
  return style;
}
function useHTMLProps(props, visualState, isStatic) {
  var htmlProps = {};
  var style = useStyle(props, visualState, isStatic);
  if (Boolean(props.drag) && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : "pan-".concat(props.drag === "x" ? "y" : "x");
  }
  htmlProps.style = style;
  return htmlProps;
}

// node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
init_react();

// node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
init_react();
var validMotionProps = new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "layoutDependency",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "dragSnapToOrigin",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover",
  "whileInView",
  "onViewportEnter",
  "onViewportLeave",
  "viewport",
  "layoutScroll"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}

// node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = function(key) {
  return !isValidMotionProp(key);
};
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = function(key) {
    return key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  };
}
try {
  loadExternalIsValidProp((init_is_prop_valid_esm(), is_prop_valid_esm_exports).default);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
init_react();
var import_react23 = __toModule(require_react());

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
init_react();

// node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
init_react();
function calcOrigin(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return "".concat(pxOriginX, " ").concat(pxOriginY);
}

// node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
init_react();
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  attrs.pathLength = 1;
  var keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset);
  var pathLength = px.transform(length);
  var pathSpacing = px.transform(spacing);
  attrs[keys2.array] = "".concat(pathLength, " ").concat(pathSpacing);
}

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, _a, options2, transformTemplate) {
  var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state, latest, options2, transformTemplate);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs, style = state.style, dimensions = state.dimensions;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
init_react();
var createSvgRenderState = function() {
  return __assign(__assign({}, createHtmlRenderState()), { attrs: {} });
};

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
function useSVGProps(props, visualState) {
  var visualProps = (0, import_react23.useMemo)(function() {
    var state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);
    return __assign(__assign({}, state.attrs), { style: __assign({}, state.style) });
  }, [visualState]);
  if (props.style) {
    var rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = __assign(__assign({}, rawStyles), visualProps.style);
  }
  return visualProps;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps) {
  if (forwardMotionProps === void 0) {
    forwardMotionProps = false;
  }
  var useRender = function(Component, props, projectionId, ref, _a, isStatic) {
    var latestValues = _a.latestValues;
    var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    var visualProps = useVisualProps(props, latestValues, isStatic);
    var filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    var elementProps = __assign(__assign(__assign({}, filteredProps), visualProps), { ref });
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return (0, import_react24.createElement)(Component, elementProps);
  };
  return useRender;
}

// node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
init_react();

// node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
init_react();
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

// node_modules/framer-motion/dist/es/render/html/utils/render.mjs
init_react();
function renderHTML(element, _a, styleProp, projection) {
  var style = _a.style, vars = _a.vars;
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (var key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
init_react();
var camelCaseAttributes = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength"
]);

// node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState) {
  renderHTML(element, renderState);
  for (var key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
init_react();

// node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
init_react();
function scrapeMotionValuesFromProps(props) {
  var style = props.style;
  var newValues = {};
  for (var key in style) {
    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props) {
  var newValues = scrapeMotionValuesFromProps(props);
  for (var key in props) {
    if (isMotionValue(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
init_react();
var import_react25 = __toModule(require_react());

// node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
init_react();
function isAnimationControls(v) {
  return typeof v === "object" && typeof v.start === "function";
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState(_a, props, context, presenceContext) {
  var scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;
  var state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = function(instance) {
      return onMount(props, instance, state);
    };
  }
  return state;
}
var makeUseVisualState = function(config2) {
  return function(props, isStatic) {
    var context = (0, import_react25.useContext)(MotionContext);
    var presenceContext = (0, import_react25.useContext)(PresenceContext);
    return isStatic ? makeState(config2, props, context, presenceContext) : useConstant(function() {
      return makeState(config2, props, context, presenceContext);
    });
  };
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  var values = {};
  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;
  var motionValues = scrapeMotionValues(props);
  for (var key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  var initial = props.initial, animate3 = props.animate;
  var isControllingVariants = checkIfControllingVariants(props);
  var isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate3 !== null && animate3 !== void 0 ? animate3 : animate3 = context.animate;
  }
  var initialAnimationIsBlocked = blockInitialAnimation || initial === false;
  var variantToSet = initialAnimationIsBlocked ? animate3 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach(function(definition) {
      var resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      var transitionEnd = resolved.transitionEnd;
      resolved.transition;
      var target = __rest(resolved, ["transitionEnd", "transition"]);
      for (var key2 in target) {
        var valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          var index2 = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values[key2] = valueTarget;
        }
      }
      for (var key2 in transitionEnd)
        values[key2] = transitionEnd[key2];
    });
  }
  return values;
}

// node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: function(props, instance, _a) {
      var renderState = _a.renderState, latestValues = _a.latestValues;
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};

// node_modules/framer-motion/dist/es/render/html/config-motion.mjs
init_react();
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
function createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;
  var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return __assign(__assign({}, baseConfig), { preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement, projectionNodeConstructor, Component });
}

// node_modules/framer-motion/dist/es/motion/features/gestures.mjs
init_react();

// node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs
init_react();

// node_modules/framer-motion/dist/es/render/utils/types.mjs
init_react();
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));

// node_modules/framer-motion/dist/es/events/use-dom-event.mjs
init_react();
var import_react26 = __toModule(require_react());
function addDomEvent(target, eventName, handler, options2) {
  target.addEventListener(eventName, handler, options2);
  return function() {
    return target.removeEventListener(eventName, handler, options2);
  };
}
function useDomEvent(ref, eventName, handler, options2) {
  (0, import_react26.useEffect)(function() {
    var element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options2);
    }
  }, [ref, eventName, handler, options2]);
}

// node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs
function useFocusGesture(_a) {
  var whileFocus = _a.whileFocus, visualElement2 = _a.visualElement;
  var onFocus = function() {
    var _a2;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, true);
  };
  var onBlur = function() {
    var _a2;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, false);
  };
  useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
}

// node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs
init_react();

// node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs
init_react();
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}

// node_modules/framer-motion/dist/es/events/use-pointer-event.mjs
init_react();

// node_modules/framer-motion/dist/es/events/event-info.mjs
init_react();
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};

// node_modules/framer-motion/dist/es/events/utils.mjs
init_react();
var supportsPointerEvents = function() {
  return isBrowser && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser && window.onmousedown === null;
};

// node_modules/framer-motion/dist/es/events/use-pointer-event.mjs
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options2) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options2);
}
function usePointerEvent(ref, eventName, handler, options2) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options2);
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
init_react();
function createLock(name) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  var lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs
function createHoverEvent(visualElement2, isActive, callback) {
  return function(event, info) {
    var _a;
    if (!isMouseEvent(event) || isDragActive())
      return;
    (_a = visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);
    callback === null || callback === void 0 ? void 0 : callback(event, info);
  };
}
function useHoverGesture(_a) {
  var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement2 = _a.visualElement;
  usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0);
  usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0);
}

// node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
init_react();
var import_react28 = __toModule(require_react());

// node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
init_react();
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
init_react();
var import_react27 = __toModule(require_react());
function useUnmountEffect(callback) {
  return (0, import_react27.useEffect)(function() {
    return function() {
      return callback();
    };
  }, []);
}

// node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
function useTapGesture(_a) {
  var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement2 = _a.visualElement;
  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  var isPressing = (0, import_react28.useRef)(false);
  var cancelPointerEndListeners = (0, import_react28.useRef)(null);
  function removePointerEndListener() {
    var _a2;
    (_a2 = cancelPointerEndListeners.current) === null || _a2 === void 0 ? void 0 : _a2.call(cancelPointerEndListeners);
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    var _a2;
    removePointerEndListener();
    isPressing.current = false;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a2;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp), addPointerEvent(window, "pointercancel", onPointerCancel));
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, true);
    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
  }
  usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0);
  useUnmountEffect(removePointerEndListener);
}

// node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
init_react();
var import_react29 = __toModule(require_react());

// node_modules/framer-motion/dist/es/utils/warn-once.mjs
init_react();
var warned = new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}

// node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
init_react();
var observerCallbacks = new WeakMap();
var observers = new WeakMap();
var fireObserverCallback = function(entry2) {
  var _a;
  (_a = observerCallbacks.get(entry2.target)) === null || _a === void 0 ? void 0 : _a(entry2);
};
var fireAllObserverCallbacks = function(entries) {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver(_a) {
  var root = _a.root, options2 = __rest(_a, ["root"]);
  var lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  var rootObservers = observers.get(lookupRoot);
  var key = JSON.stringify(options2);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({ root }, options2));
  }
  return rootObservers[key];
}
function observeIntersection(element, options2, callback) {
  var rootInteresectionObserver = initIntersectionObserver(options2);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return function() {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}

// node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
function useViewport(_a) {
  var visualElement2 = _a.visualElement, whileInView = _a.whileInView, onViewportEnter = _a.onViewportEnter, onViewportLeave = _a.onViewportLeave, _b = _a.viewport, viewport = _b === void 0 ? {} : _b;
  var state = (0, import_react29.useRef)({
    hasEnteredView: false,
    isInView: false
  });
  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state.current.hasEnteredView)
    shouldObserve = false;
  var useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state.current, visualElement2, viewport);
}
var thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state, visualElement2, _a) {
  var root = _a.root, rootMargin = _a.margin, _b = _a.amount, amount = _b === void 0 ? "some" : _b, once3 = _a.once;
  (0, import_react29.useEffect)(function() {
    if (!shouldObserve)
      return;
    var options2 = {
      root: root === null || root === void 0 ? void 0 : root.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    var intersectionCallback = function(entry2) {
      var _a2;
      var isIntersecting = entry2.isIntersecting;
      if (state.isInView === isIntersecting)
        return;
      state.isInView = isIntersecting;
      if (once3 && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.InView, isIntersecting);
      var props = visualElement2.getProps();
      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback === null || callback === void 0 ? void 0 : callback(entry2);
    };
    return observeIntersection(visualElement2.getInstance(), options2, intersectionCallback);
  }, [shouldObserve, root, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state, visualElement2, _a) {
  var _b = _a.fallback, fallback = _b === void 0 ? true : _b;
  (0, import_react29.useEffect)(function() {
    if (!shouldObserve || !fallback)
      return;
    if (true) {
      warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
    }
    requestAnimationFrame(function() {
      var _a2;
      state.hasEnteredView = true;
      var onViewportEnter = visualElement2.getProps().onViewportEnter;
      onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);
      (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.InView, true);
    });
  }, [shouldObserve]);
}

// node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs
init_react();
var makeRenderlessComponent = function(hook) {
  return function(props) {
    hook(props);
    return null;
  };
};

// node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
init_react();
var import_react31 = __toModule(require_react());

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
init_react();
var import_react30 = __toModule(require_react());

// node_modules/framer-motion/dist/es/utils/use-id.mjs
init_react();
var counter = 0;
var incrementId = function() {
  return counter++;
};
var useId = function() {
  return useConstant(incrementId);
};

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
function usePresence() {
  var context = (0, import_react30.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;
  var id2 = useId();
  (0, import_react30.useEffect)(function() {
    return register(id2);
  }, []);
  var safeToRemove = function() {
    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id2);
  };
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
init_react();

// node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
init_react();
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}

// node_modules/framer-motion/dist/es/render/utils/animation.mjs
init_react();

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
init_react();

// node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
init_react();
var isNumericalString = function(v) {
  return /^\-?\d*\.?\d+$/.test(v);
};

// node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
init_react();
var isZeroValueString = function(v) {
  return /^0[^.\s]+$/.test(v);
};

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
init_react();
var testValueType = function(v) {
  return function(type) {
    return type.test(v);
  };
};

// node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
init_react();
var auto = {
  test: function(v) {
    return v === "auto";
  },
  parse: function(v) {
    return v;
  }
};

// node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = function(v) {
  return dimensionValueTypes.find(testValueType(v));
};

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes), false), [color, complex], false);
var findValueType = function(v) {
  return valueTypes.find(testValueType(v));
};

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
  _a.transition;
  var target = __rest(_a, ["transitionEnd", "transition"]);
  target = __assign(__assign({}, target), transitionEnd);
  for (var key in target) {
    var value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a, _b, _c;
  var _d;
  var newValueKeys = Object.keys(target).filter(function(key2) {
    return !visualElement2.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i = 0; i < numNewValues; i++) {
    var key = newValueKeys[i];
    var targetValue = target[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone2(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  var valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement2) {
  var _a, _b;
  var origin = {};
  for (var key in target) {
    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement2.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}

// node_modules/framer-motion/dist/es/render/utils/animation.mjs
function animateVisualElement(visualElement2, definition, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  visualElement2.notifyAnimationStart(definition);
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options2);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options2);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options2.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options2);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options2) {
  var _a;
  if (options2 === void 0) {
    options2 = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options2.custom);
  var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
  if (options2.transitionOverride) {
    transition = options2.transitionOverride;
  }
  var getAnimation2 = resolved ? function() {
    return animateTarget(visualElement2, resolved, options2);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options2);
  } : function() {
    return Promise.resolve();
  };
  var when = transition.when;
  if (when) {
    var _c = __read(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c[0], last = _c[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options2.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a) {
  var _b;
  var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
  var _e = visualElement2.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition = transitionOverride;
  var animations2 = [];
  var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
  for (var key in target) {
    var value = visualElement2.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var valueTransition = __assign({ delay }, transition);
    if (visualElement2.shouldReduceMotion && isTransformProp(key)) {
      valueTransition = __assign(__assign({}, valueTransition), { type: false, delay: 0 });
    }
    var animation = startAnimation(key, value, valueTarget, valueTransition);
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options2) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i) {
    if (i === void 0) {
      i = 0;
    }
    return i * staggerChildren;
  } : function(i) {
    if (i === void 0) {
      i = 0;
    }
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {
    animations2.push(animateVariant(child, variant, __assign(__assign({}, options2), { delay: delayChildren + generateStaggerDuration(i) })).then(function() {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function shouldBlockAnimation(_a, key) {
  var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder), false).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a) {
      var animation = _a.animation, options2 = _a.options;
      return animateVisualElement(visualElement2, animation, options2);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate3 = animateList(visualElement2);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate3 = makeAnimator(visualElement2);
  }
  function animateChanges(options2, changedActiveType) {
    var _a;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i2) {
      var type = reversePriorityOrder[i2];
      var typeState = state[type];
      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
      var propIsVariant = isVariantLabel(prop);
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = __assign({}, encounteredKeys);
      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === "boolean") {
        return "continue";
      }
      var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      var shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop) ? prop : [prop];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key2) {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (var key in allKeys) {
        var next = resolvedValues[key];
        var prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {
          return {
            animation,
            options: __assign({ type }, options2)
          };
        })), false));
      }
    };
    for (var i = 0; i < numAnimationTypes; i++) {
      _loop_1(i);
    }
    allAnimatedKeys = __assign({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key) {
        var fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate3(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options2) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    return animateChanges(options2, type);
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (isVariantLabels(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a;
  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.InView] = createTypeState(), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;
}

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: makeRenderlessComponent(function(_a) {
    var visualElement2 = _a.visualElement, animate3 = _a.animate;
    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
    if (isAnimationControls(animate3)) {
      (0, import_react31.useEffect)(function() {
        return animate3.subscribe(visualElement2);
      }, [animate3]);
    }
  }),
  exit: makeRenderlessComponent(function(props) {
    var custom = props.custom, visualElement2 = props.visualElement;
    var _a = __read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];
    var presenceContext = (0, import_react31.useContext)(PresenceContext);
    (0, import_react31.useEffect)(function() {
      var _a2, _b;
      visualElement2.isPresent = isPresent;
      var animation = (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });
      !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));
    }, [isPresent]);
  })
};

// node_modules/framer-motion/dist/es/motion/features/drag.mjs
init_react();

// node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
init_react();
var import_react32 = __toModule(require_react());

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
init_react();

// node_modules/framer-motion/dist/es/gestures/PanSession.mjs
init_react();
var PanSession = function() {
  function PanSession2(event, handlers, _a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = function() {
      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
        return;
      var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
      var isPanStarted = _this.startEvent !== null;
      var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      var point2 = info2.point;
      var timestamp2 = getFrameData().timestamp;
      _this.history.push(__assign(__assign({}, point2), { timestamp: timestamp2 }));
      var _a2 = _this.handlers, onStart = _a2.onStart, onMove = _a2.onMove;
      if (!isPanStarted) {
        onStart && onStart(_this.lastMoveEvent, info2);
        _this.startEvent = _this.lastMoveEvent;
      }
      onMove && onMove(_this.lastMoveEvent, info2);
    };
    this.handlePointerMove = function(event2, info2) {
      _this.lastMoveEvent = event2;
      _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
      if (isMouseEvent(event2) && event2.buttons === 0) {
        _this.handlePointerUp(event2, info2);
        return;
      }
      es_default.update(_this.updatePoint, true);
    };
    this.handlePointerUp = function(event2, info2) {
      _this.end();
      var _a2 = _this.handlers, onEnd = _a2.onEnd, onSessionEnd = _a2.onSessionEnd;
      var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
      if (_this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (isTouchEvent(event) && event.touches.length > 1)
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    var info = extractEventInfo(event);
    var initialInfo = transformPoint(info, this.transformPagePoint);
    var point = initialInfo.point;
    var timestamp = getFrameData().timestamp;
    this.history = [__assign(__assign({}, point), { timestamp })];
    var onSessionStart = handlers.onSessionStart;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  PanSession2.prototype.updateHandlers = function(handlers) {
    this.handlers = handlers;
  };
  PanSession2.prototype.end = function() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  };
  return PanSession2;
}();
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo(_a, history) {
  var point = _a.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
init_react();
function applyConstraints(point, _a, elastic) {
  var min = _a.min, max = _a.max;
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a = __read([max, min], 2), min = _a[0], max = _a[1];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin2(source, target) {
  var origin = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic) {
  if (dragElastic === void 0) {
    dragElastic = defaultElastic;
  }
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a;
  return typeof dragElastic === "number" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
}

// node_modules/framer-motion/dist/es/projection/utils/measure.mjs
init_react();

// node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
init_react();
function convertBoundingBoxToBox(_a) {
  var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox(_a) {
  var x = _a.x, y = _a.y;
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  var topLeft = transformPoint2({ x: point.left, y: point.top });
  var bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}

// node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  var viewportBox = measureViewportBox(element, transformPagePoint);
  var scroll = rootProjectionNode2.scroll;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.x);
    translateAxis(viewportBox.y, scroll.y);
  }
  return viewportBox;
}

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = new WeakMap();
var VisualElementDragControls = function() {
  function VisualElementDragControls2(visualElement2) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement2;
  }
  VisualElementDragControls2.prototype.start = function(originEvent, _a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c;
    if (this.visualElement.isPresent === false)
      return;
    var onSessionStart = function(event) {
      _this.stopAnimation();
      if (snapToCursor) {
        _this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    var onStart = function(event, info) {
      var _a2;
      var _b2 = _this.getProps(), drag2 = _b2.drag, dragPropagation = _b2.dragPropagation, onDragStart = _b2.onDragStart;
      if (drag2 && !dragPropagation) {
        if (_this.openGlobalLock)
          _this.openGlobalLock();
        _this.openGlobalLock = getGlobalLock(drag2);
        if (!_this.openGlobalLock)
          return;
      }
      _this.isDragging = true;
      _this.currentDirection = null;
      _this.resolveConstraints();
      if (_this.visualElement.projection) {
        _this.visualElement.projection.isAnimationBlocked = true;
        _this.visualElement.projection.target = void 0;
      }
      eachAxis(function(axis) {
        var _a3, _b3;
        var current = _this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          var measuredAxis = (_b3 = (_a3 = _this.visualElement.projection) === null || _a3 === void 0 ? void 0 : _a3.layout) === null || _b3 === void 0 ? void 0 : _b3.actual[axis];
          if (measuredAxis) {
            var length_1 = calcLength(measuredAxis);
            current = length_1 * (parseFloat(current) / 100);
          }
        }
        _this.originPoint[axis] = current;
      });
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
      (_a2 = _this.visualElement.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Drag, true);
    };
    var onMove = function(event, info) {
      var _a2 = _this.getProps(), dragPropagation = _a2.dragPropagation, dragDirectionLock = _a2.dragDirectionLock, onDirectionLock = _a2.onDirectionLock, onDrag = _a2.onDrag;
      if (!dragPropagation && !_this.openGlobalLock)
        return;
      var offset = info.offset;
      if (dragDirectionLock && _this.currentDirection === null) {
        _this.currentDirection = getCurrentDirection(offset);
        if (_this.currentDirection !== null) {
          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);
        }
        return;
      }
      _this.updateAxis("x", info.point, offset);
      _this.updateAxis("y", info.point, offset);
      _this.visualElement.syncRender();
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
    };
    var onSessionEnd = function(event, info) {
      return _this.stop(event, info);
    };
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  };
  VisualElementDragControls2.prototype.stop = function(event, info) {
    var isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    var velocity = info.velocity;
    this.startAnimation(velocity);
    var onDragEnd = this.getProps().onDragEnd;
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  };
  VisualElementDragControls2.prototype.cancel = function() {
    var _a, _b;
    this.isDragging = false;
    if (this.visualElement.projection) {
      this.visualElement.projection.isAnimationBlocked = false;
    }
    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
    this.panSession = void 0;
    var dragPropagation = this.getProps().dragPropagation;
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
  };
  VisualElementDragControls2.prototype.updateAxis = function(axis, _point, offset) {
    var drag2 = this.getProps().drag;
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    var axisValue = this.getAxisMotionValue(axis);
    var next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  };
  VisualElementDragControls2.prototype.resolveConstraints = function() {
    var _this = this;
    var _a = this.getProps(), dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;
    var layout = (this.visualElement.projection || {}).layout;
    var prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      eachAxis(function(axis) {
        if (_this.getAxisMotionValue(axis)) {
          _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);
        }
      });
    }
  };
  VisualElementDragControls2.prototype.resolveRefConstraints = function() {
    var _a = this.getProps(), constraints = _a.dragConstraints, onMeasureDragConstraints = _a.onMeasureDragConstraints;
    if (!constraints || !isRefObject(constraints))
      return false;
    var constraintsElement = constraints.current;
    invariant3(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    var projection = this.visualElement.projection;
    if (!projection || !projection.layout)
      return false;
    var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);
    if (onMeasureDragConstraints) {
      var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  };
  VisualElementDragControls2.prototype.startAnimation = function(velocity) {
    var _this = this;
    var _a = this.getProps(), drag2 = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, dragSnapToOrigin = _a.dragSnapToOrigin, onDragTransitionEnd = _a.onDragTransitionEnd;
    var constraints = this.constraints || {};
    var momentumAnimations = eachAxis(function(axis) {
      var _a2;
      if (!shouldDrag(axis, drag2, _this.currentDirection)) {
        return;
      }
      var transition = (_a2 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a2 !== void 0 ? _a2 : {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      var bounceStiffness = dragElastic ? 200 : 1e6;
      var bounceDamping = dragElastic ? 40 : 1e7;
      var inertia2 = __assign(__assign({ type: "inertia", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness, bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);
      return _this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  };
  VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition) {
    var axisValue = this.getAxisMotionValue(axis);
    return startAnimation(axis, axisValue, 0, transition);
  };
  VisualElementDragControls2.prototype.stopAnimation = function() {
    var _this = this;
    eachAxis(function(axis) {
      return _this.getAxisMotionValue(axis).stop();
    });
  };
  VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
    var _a, _b;
    var dragKey = "_drag" + axis.toUpperCase();
    var externalMotionValue = this.visualElement.getProps()[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);
  };
  VisualElementDragControls2.prototype.snapToCursor = function(point) {
    var _this = this;
    eachAxis(function(axis) {
      var drag2 = _this.getProps().drag;
      if (!shouldDrag(axis, drag2, _this.currentDirection))
        return;
      var projection = _this.visualElement.projection;
      var axisValue = _this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        var _a = projection.layout.actual[axis], min = _a.min, max = _a.max;
        axisValue.set(point[axis] - mix(min, max, 0.5));
      }
    });
  };
  VisualElementDragControls2.prototype.scalePositionWithinConstraints = function() {
    var _this = this;
    var _a;
    var _b = this.getProps(), drag2 = _b.drag, dragConstraints = _b.dragConstraints;
    var projection = this.visualElement.projection;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    var boxProgress = { x: 0, y: 0 };
    eachAxis(function(axis) {
      var axisValue = _this.getAxisMotionValue(axis);
      if (axisValue) {
        var latest = axisValue.get();
        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, _this.constraints[axis]);
      }
    });
    var transformTemplate = this.visualElement.getProps().transformTemplate;
    this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis(function(axis) {
      if (!shouldDrag(axis, drag2, null))
        return;
      var axisValue = _this.getAxisMotionValue(axis);
      var _a2 = _this.constraints[axis], min = _a2.min, max = _a2.max;
      axisValue.set(mix(min, max, boxProgress[axis]));
    });
  };
  VisualElementDragControls2.prototype.addListeners = function() {
    var _this = this;
    var _a;
    elementDragControls.set(this.visualElement, this);
    var element = this.visualElement.getInstance();
    var stopPointerListener = addPointerEvent(element, "pointerdown", function(event) {
      var _a2 = _this.getProps(), drag2 = _a2.drag, _b = _a2.dragListener, dragListener = _b === void 0 ? true : _b;
      drag2 && dragListener && _this.start(event);
    });
    var measureDragConstraints = function() {
      var dragConstraints = _this.getProps().dragConstraints;
      if (isRefObject(dragConstraints)) {
        _this.constraints = _this.resolveRefConstraints();
      }
    };
    var projection = this.visualElement.projection;
    var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    var stopResizeListener = addDomEvent(window, "resize", function() {
      _this.scalePositionWithinConstraints();
    });
    projection.addEventListener("didUpdate", function(_a2) {
      var delta = _a2.delta, hasLayoutChanged = _a2.hasLayoutChanged;
      if (_this.isDragging && hasLayoutChanged) {
        eachAxis(function(axis) {
          var motionValue2 = _this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          _this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        _this.visualElement.syncRender();
      }
    });
    return function() {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
    };
  };
  VisualElementDragControls2.prototype.getProps = function() {
    var props = this.visualElement.getProps();
    var _a = props.drag, drag2 = _a === void 0 ? false : _a, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c = props.dragPropagation, dragPropagation = _c === void 0 ? false : _c, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e = props.dragElastic, dragElastic = _e === void 0 ? defaultElastic : _e, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;
    return __assign(__assign({}, props), { drag: drag2, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum });
  };
  return VisualElementDragControls2;
}();
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
function useDrag(props) {
  var groupDragControls = props.dragControls, visualElement2 = props.visualElement;
  var dragControls = useConstant(function() {
    return new VisualElementDragControls(visualElement2);
  });
  (0, import_react32.useEffect)(function() {
    return groupDragControls && groupDragControls.subscribe(dragControls);
  }, [dragControls, groupDragControls]);
  (0, import_react32.useEffect)(function() {
    return dragControls.addListeners();
  }, [dragControls]);
}

// node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs
init_react();
var import_react33 = __toModule(require_react());
function usePanGesture(_a) {
  var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement2 = _a.visualElement;
  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  var panSession = (0, import_react33.useRef)(null);
  var transformPagePoint = (0, import_react33.useContext)(MotionConfigContext).transformPagePoint;
  var handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function(event, info) {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  (0, import_react33.useEffect)(function() {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(function() {
    return panSession.current && panSession.current.end();
  });
}

// node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
init_react();

// node_modules/framer-motion/dist/es/render/html/visual-element.mjs
init_react();

// node_modules/framer-motion/dist/es/render/index.mjs
init_react();

// node_modules/framer-motion/dist/es/render/utils/lifecycles.mjs
init_react();
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      names.forEach(function(name) {
        var _a;
        var on2 = "on" + name;
        var propListener = props[on2];
        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
        if (propListener) {
          propSubscriptions[name] = lifecycles[on2](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i) {
    lifecycles["on" + names[i]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i]] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, __spreadArray([], __read(args), false));
    };
  });
  return lifecycles;
}

// node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
init_react();
function updateMotionValuesFromProps(element, next, prev) {
  var _a;
  for (var key in next) {
    var nextValue = next[key];
    var prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        var existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));
      }
    }
  }
  for (var key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}

// node_modules/framer-motion/dist/es/render/index.mjs
var visualElement = function(_a) {
  var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox2 = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps;
  return function(_a2, options2) {
    var parent = _a2.parent, props = _a2.props, presenceId = _a2.presenceId, blockInitialAnimation = _a2.blockInitialAnimation, visualState = _a2.visualState, shouldReduceMotion = _a2.shouldReduceMotion;
    if (options2 === void 0) {
      options2 = {};
    }
    var isMounted = false;
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance;
    var lifecycles = createLifecycles();
    var values = new Map();
    var valueSubscriptions = new Map();
    var prevMotionValues = {};
    var baseTarget = __assign({}, latestValues);
    var removeFromVariantTree;
    function render() {
      if (!instance || !isMounted)
        return;
      triggerBuild();
      renderInstance(instance, renderState, props.style, element.projection);
    }
    function triggerBuild() {
      build(element, renderState, latestValues, options2, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function bindToMotionValue(key2, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key2] = latestValue;
        props.onUpdate && es_default.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);
      valueSubscriptions.set(key2, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps3(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element = __assign(__assign({
      treeType,
      current: null,
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: new Set(),
      presenceId,
      shouldReduceMotion,
      variantChildren: isVariantNode ? new Set() : void 0,
      isVisible: void 0,
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      blockInitialAnimation,
      isMounted: function() {
        return Boolean(instance);
      },
      mount: function(newInstance) {
        isMounted = true;
        instance = element.current = newInstance;
        if (element.projection) {
          element.projection.mount(newInstance);
        }
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
        }
        values.forEach(function(value2, key2) {
          return bindToMotionValue(key2, value2);
        });
        parent === null || parent === void 0 ? void 0 : parent.children.add(element);
        element.setProps(props);
      },
      unmount: function() {
        var _a3;
        (_a3 = element.projection) === null || _a3 === void 0 ? void 0 : _a3.unmount();
        cancelSync.update(update);
        cancelSync.render(render);
        valueSubscriptions.forEach(function(remove) {
          return remove();
        });
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
        lifecycles.clearAllListeners();
        instance = void 0;
        isMounted = false;
      },
      addVariantChild: function(child) {
        var _a3;
        var closestVariantNode = element.getClosestVariantNode();
        if (closestVariantNode) {
          (_a3 = closestVariantNode.variantChildren) === null || _a3 === void 0 ? void 0 : _a3.add(child);
          return function() {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element.getInstance(), other.getInstance());
      },
      getClosestVariantNode: function() {
        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      getLayoutId: function() {
        return props.layoutId;
      },
      getInstance: function() {
        return instance;
      },
      getStaticValue: function(key2) {
        return latestValues[key2];
      },
      setStaticValue: function(key2, value2) {
        return latestValues[key2] = value2;
      },
      getLatestValues: function() {
        return latestValues;
      },
      setVisibility: function(visibility) {
        if (element.isVisible === visibility)
          return;
        element.isVisible = visibility;
        element.scheduleRender();
      },
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element, target, props, canMutate);
      },
      measureViewportBox: function() {
        return measureViewportBox2(instance, props);
      },
      addValue: function(key2, value2) {
        if (element.hasValue(key2))
          element.removeValue(key2);
        values.set(key2, value2);
        latestValues[key2] = value2.get();
        bindToMotionValue(key2, value2);
      },
      removeValue: function(key2) {
        var _a3;
        values.delete(key2);
        (_a3 = valueSubscriptions.get(key2)) === null || _a3 === void 0 ? void 0 : _a3();
        valueSubscriptions.delete(key2);
        delete latestValues[key2];
        removeValueFromRenderState(key2, renderState);
      },
      hasValue: function(key2) {
        return values.has(key2);
      },
      getValue: function(key2, defaultValue) {
        var value2 = values.get(key2);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element.addValue(key2, value2);
        }
        return value2;
      },
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      readValue: function(key2) {
        var _a3;
        return (_a3 = latestValues[key2]) !== null && _a3 !== void 0 ? _a3 : readValueFromInstance(instance, key2, options2);
      },
      setBaseTarget: function(key2, value2) {
        baseTarget[key2] = value2;
      },
      getBaseTarget: function(key2) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key2);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key2];
      }
    }, lifecycles), {
      build: function() {
        triggerBuild();
        return renderState;
      },
      scheduleRender: function() {
        es_default.render(render, false, true);
      },
      syncRender: render,
      setProps: function(newProps) {
        if (newProps.transformTemplate || props.transformTemplate) {
          element.scheduleRender();
        }
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      getVariant: function(name) {
        var _a3;
        return (_a3 = props.variants) === null || _a3 === void 0 ? void 0 : _a3[name];
      },
      getDefaultTransition: function() {
        return props.transition;
      },
      getTransformPagePoint: function() {
        return props.transformPagePoint;
      },
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i = 0; i < numVariantProps; i++) {
          var name_1 = variantProps[i];
          var prop = props[name_1];
          if (isVariantLabel(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      }
    });
    return element;
  };
};
var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder), false);
var numVariantProps = variantProps.length;

// node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
init_react();

// node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
init_react();
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a = __read(match, 3), token = _a[1], fallback = _a[2];
  return [token, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  invariant3(depth <= maxDepth, 'Max CSS variable fallback depth detected in property "'.concat(current, '". This may indicate a circular fallback dependency.'));
  var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
  if (!token)
    return;
  var resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement2, _a, transitionEnd) {
  var _b;
  var target = __rest(_a, []);
  var element = visualElement2.getInstance();
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = __assign({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable2(current2))
      return;
    var resolved2 = getVariableValue(current2, element);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable2(current))
      continue;
    var resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
init_react();
var positionalKeys = new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v) {
  return v === number || v === px;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a) {
    var transform = _a.transform;
    if (transform === "none" || !transform)
      return 0;
    var matrix3d = transform.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  width: function(_a, _b) {
    var x = _a.x;
    var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? "0" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? "0" : _d;
    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);
  },
  height: function(_a, _b) {
    var y = _a.y;
    var _c = _b.paddingTop, paddingTop = _c === void 0 ? "0" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? "0" : _d;
    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);
  },
  top: function(_bbox, _a) {
    var top = _a.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a) {
    var left = _a.left;
    return parseFloat(left);
  },
  bottom: function(_a, _b) {
    var y = _a.y;
    var top = _b.top;
    return parseFloat(top) + (y.max - y.min);
  },
  right: function(_a, _b) {
    var x = _a.x;
    var left = _b.left;
    return parseFloat(left) + (x.max - x.min);
  },
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element);
  var display = elementComputedStyle.display;
  var origin = {};
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach(function(key) {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    setAndResetVelocity(value, origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = __assign({}, target);
  transitionEnd = __assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    var from2 = origin[key];
    var fromType = findDimensionValueType(from2);
    var to = target[key];
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      var fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex];
      fromType = findDimensionValueType(from2);
      for (var i = fromIndex; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
          invariant3(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant3(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
        if (from2 === 0) {
          value.set(toType.transform(from2));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};

// node_modules/framer-motion/dist/es/render/html/visual-element.mjs
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key) {
    if (isTransformProp(key)) {
      var defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle2(domElement);
      return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key) {
    var _a;
    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
  },
  measureViewportBox: function(element, _a) {
    var transformPagePoint = _a.transformPagePoint;
    return measureViewportBox(element, transformPagePoint);
  },
  resetTransform: function(element, domElement, props) {
    var transformTemplate = props.transformTemplate;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform: function(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key, _a) {
    var vars = _a.vars, style = _a.style;
    delete vars[key];
    delete style[key];
  },
  makeTargetAnimatable: function(element, _a, _b, isMounted) {
    var transformValues = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition || {}, element);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin);
      var parsed = parseDomVariant(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return __assign({ transition, transitionEnd }, target);
  },
  scrapeMotionValuesFromProps,
  build: function(element, renderState, latestValues, options2, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    buildHTMLStyles(renderState, latestValues, options2, props.transformTemplate);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);

// node_modules/framer-motion/dist/es/render/svg/visual-element.mjs
init_react();
var svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), { getBaseTarget: function(props, key) {
  return props[key];
}, readValueFromInstance: function(domElement, key) {
  var _a;
  if (isTransformProp(key)) {
    return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
  }
  key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
  return domElement.getAttribute(key);
}, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, build: function(_element, renderState, latestValues, options2, props) {
  buildSVGAttrs(renderState, latestValues, options2, props.transformTemplate);
}, render: renderSVG }));

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = function(Component, options2) {
  return isSVGComponent(Component) ? svgVisualElement(options2, { enableHardwareAcceleration: false }) : htmlVisualElement(options2, { enableHardwareAcceleration: true });
};

// node_modules/framer-motion/dist/es/motion/features/layout/index.mjs
init_react();

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
init_react();
var import_react34 = __toModule(require_react());

// node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
init_react();
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: function(latest, node) {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    var x = pixelsToPercent(latest, node.target.x);
    var y = pixelsToPercent(latest, node.target.y);
    return "".concat(x, "% ").concat(y, "%");
  }
};

// node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
init_react();
var varToken = "_$css";
var correctBoxShadow = {
  correct: function(latest, _a) {
    var treeScale = _a.treeScale, projectionDelta = _a.projectionDelta;
    var original = latest;
    var containsCSSVariables = latest.includes("var(");
    var cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, function(match) {
        cssVariables.push(match);
        return varToken;
      });
    }
    var shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    var template = complex.createTransformer(latest);
    var offset = typeof shadow[0] !== "number" ? 1 : 0;
    var xScale = projectionDelta.x.scale * treeScale.x;
    var yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    var averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    var output = template(shadow);
    if (containsCSSVariables) {
      var i_1 = 0;
      output = output.replace(varToken, function() {
        var cssVariable = cssVariables[i_1];
        i_1++;
        return cssVariable;
      });
    }
    return output;
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var MeasureLayoutWithContext = function(_super) {
  __extends(MeasureLayoutWithContext2, _super);
  function MeasureLayoutWithContext2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MeasureLayoutWithContext2.prototype.componentDidMount = function() {
    var _this = this;
    var _a = this.props, visualElement2 = _a.visualElement, layoutGroup = _a.layoutGroup, switchLayoutGroup = _a.switchLayoutGroup, layoutId = _a.layoutId;
    var projection = visualElement2.projection;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
        layoutGroup.group.add(projection);
      if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", function() {
        _this.safeToRemove();
      });
      projection.setOptions(__assign(__assign({}, projection.options), { onExitComplete: function() {
        return _this.safeToRemove();
      } }));
    }
    globalProjectionState.hasEverUpdated = true;
  };
  MeasureLayoutWithContext2.prototype.getSnapshotBeforeUpdate = function(prevProps) {
    var _this = this;
    var _a = this.props, layoutDependency = _a.layoutDependency, visualElement2 = _a.visualElement, drag2 = _a.drag, isPresent = _a.isPresent;
    var projection = visualElement2.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        es_default.postRender(function() {
          var _a2;
          if (!((_a2 = projection.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length)) {
            _this.safeToRemove();
          }
        });
      }
    }
    return null;
  };
  MeasureLayoutWithContext2.prototype.componentDidUpdate = function() {
    var projection = this.props.visualElement.projection;
    if (projection) {
      projection.root.didUpdate();
      if (!projection.currentAnimation && projection.isLead()) {
        this.safeToRemove();
      }
    }
  };
  MeasureLayoutWithContext2.prototype.componentWillUnmount = function() {
    var _a = this.props, visualElement2 = _a.visualElement, layoutGroup = _a.layoutGroup, promoteContext = _a.switchLayoutGroup;
    var projection = visualElement2.projection;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  };
  MeasureLayoutWithContext2.prototype.safeToRemove = function() {
    var safeToRemove = this.props.safeToRemove;
    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
  };
  MeasureLayoutWithContext2.prototype.render = function() {
    return null;
  };
  return MeasureLayoutWithContext2;
}(import_react34.default.Component);
function MeasureLayout(props) {
  var _a = __read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];
  var layoutGroup = (0, import_react34.useContext)(LayoutGroupContext);
  return import_react34.default.createElement(MeasureLayoutWithContext, __assign({}, props, { layoutGroup, switchLayoutGroup: (0, import_react34.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove }));
}
var defaultScaleCorrectors = {
  borderRadius: __assign(__assign({}, correctBorderRadius), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// node_modules/framer-motion/dist/es/motion/features/layout/index.mjs
var layoutFeatures = {
  measureLayout: MeasureLayout
};

// node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
init_react();

// node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
init_react();
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: function(ref, notify) {
    ref.addEventListener("resize", notify, { passive: true });
    return function() {
      return ref.removeEventListener("resize", notify);
    };
  },
  measureScroll: function() {
    return {
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    };
  }
});

// node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: function(instance) {
    return {
      x: instance.scrollLeft,
      y: instance.scrollTop
    };
  },
  defaultParent: function() {
    if (!rootProjectionNode.current) {
      var documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: function(instance, value) {
    instance.style.transform = value !== null && value !== void 0 ? value : "none";
  }
});

// node_modules/framer-motion/dist/es/render/dom/motion.mjs
var featureBundle = __assign(__assign(__assign(__assign({}, animations), gestureAnimations), drag), layoutFeatures);
var motion = /* @__PURE__ */ createMotionProxy(function(Component, config2) {
  return createDomMotionConfig(Component, config2, featureBundle, createDomVisualElement, HTMLProjectionNode);
});

// app/utils/motionVariants.js
init_react();
var pageMotion = {
  hidden: {
    y: -100,
    opacity: 0
  },
  visible: {
    y: 0,
    opacity: 1,
    transition: { ease: "easeOut" }
  }
};

// route:D:\projects\unikey.org\app\routes\download.tsx
var handle = {
  breadcrumb: () => /* @__PURE__ */ import_react35.default.createElement(Link2, {
    to: "/download"
  }, "Download")
};
var meta2 = () => {
  return { title: "Download UniKey | Unikey" };
};
var loader = () => {
  return getPageData(download_mdx);
};
function DownloadPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react35.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react35.default.createElement("div", {
    className: "prose max-w-screen-lg",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\support.tsx
var support_exports = {};
__export(support_exports, {
  default: () => SupportPage,
  handle: () => handle2,
  loader: () => loader2,
  meta: () => meta3
});
init_react();
var import_react36 = __toModule(require_react());

// app/content/support.md.js
init_react();
var support_mdx = `---
title: Tr\u1EE3 gi\xFAp
---
# Tr\u1EE3 gi\xFAp

### D\u1EF1 \xE1n UniKey

C\xE1c th\u1EA3o lu\u1EADn, c\xE1c phi\xEAn b\u1EA3n UniKey v\xE0 m\xE3 ngu\u1ED3n \u0111\u01B0\u1EE3c \u0111\u1EB7t t\u1EA1i website d\u1EF1 \xE1n: [UniKey Project](/)

N\u1EBFu g\u1EB7p l\u1ED7i v\u1EDBi UniKey b\u1EA1n c\xF3 th\u1EC3, [b\xE1o l\u1ED7i t\u1EA1i \u0111\xE2y](/).

### C\xE1c ch\xFA \xFD

1. X\xE1c th\u1EF1c UniKey

	\u0110\u1EC3 x\xE1c \u0111\u1ECBnh UniKey b\u1EA1n \u0111ang d\xF9ng c\xF3 ngu\u1ED3n g\u1ED1c s\u1EA1ch, kh\xF4ng b\u1ECB s\u1EEDa \u0111\u1ED5i, h\xE3y [ki\u1EC3m tra ch\u1EEF k\u1EF9 s\u1ED1 c\u1EE7a Unikey](/)

2. T\u1EF1 \u0111\u1ED9ng ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n adminstrator

	T\xF9y ch\u1ECDn Kh\u1EDFi \u0111\u1ED9ng c\xF9ng Windows trong UniKey kh\xF4ng c\xF3 t\xE1c d\u1EE5ng \u0111\u1EC3 ch\u1EA1y v\u1EDBi quy\u1EC1n administrator. B\u1EA1n c\u1EA7n ph\u1EA3i d\xF9ng Task Scheduler. Xem h\u01B0\u1EDBng d\u1EABn: [Ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n administrator](/)

### H\u01B0\u1EDBng d\u1EABn s\u1EED d\u1EE5ng

[H\u01B0\u1EDBng d\u1EABn s\u1EED d\u1EE5ng UniKey](/): T\xE0i li\u1EC7u n\xE0y \u0111\xE3 c\xF3 nhi\u1EC1u ph\u1EA7n \u0111\xE3 l\u1EA1c h\u1EADu. R\u1EA5t ti\u1EBFc t\xF4i ch\u01B0a c\xF3 th\u1EDDi gian c\u1EADp nh\u1EADt t\xE0i li\u1EC7u n\xE0y.

[FAQ: C\xE1c c\xE2u h\u1ECFi th\u01B0\u1EDDng g\u1EB7p v\u1EC1 UniKey](/).

### C\xE1c b\u1ED9 font ch\u1EEF ti\u1EBFng Vi\u1EC7t

D\u01B0\u1EDBi \u0111\xE2y l\xE0 c\xE1c b\u1ED9 font ch\u1EEF c\u0169, ra \u0111\u1EDDi t\u1EEB tr\u01B0\u1EDBc khi c\xF3 c\xE1c b\u1ED9 font unicode c\xF3 h\u1ED7 tr\u1EE3 ti\u1EBFng Vi\u1EC7t. B\u1EA1n ch\u1EC9 n\xEAn d\xF9ng c\xE1c font n\xE0y khi c\xF3 l\xFD do th\u1EF1c s\u1EF1 c\u1EA7n thi\u1EBFt. Trong \u0111a s\u1ED1 tr\u01B0\u1EDDng h\u1EE3p, h\xE3y d\xF9ng c\xE1c b\u1ED9 font unicode.

[TCVN-ABC fonts (2.5 MB)](/)

[VNI fonts (300 KB)](/)
`;

// route:D:\projects\unikey.org\app\routes\support.tsx
var handle2 = {
  breadcrumb: () => /* @__PURE__ */ import_react36.default.createElement(Link2, {
    to: "/support"
  }, "Tr\u1EE3 gi\xFAp")
};
var meta3 = () => {
  return { title: "Tr\u1EE3 gi\xFAp | Unikey" };
};
var loader2 = () => {
  return getPageData(support_mdx);
};
function SupportPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react36.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react36.default.createElement("div", {
    className: "prose prose-a:text-blue-600",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\source.tsx
var source_exports = {};
__export(source_exports, {
  default: () => SourcePage,
  handle: () => handle3,
  loader: () => loader3,
  meta: () => meta4
});
init_react();
var import_react37 = __toModule(require_react());

// app/content/source.md.js
init_react();
var source_mdx = `---
title: UniKey Source Code
---
# UniKey Source Code

All source code in this page is released under the terms of [the GNU General Public License](/). By downloading UniKey source code, you agree with all the terms of this license.

### UniKey Vietnamese Input Method

* In 2001, I released the source code of the core engine UniKey Vietnamese Input Method together with the x-unikey linux package. Since then, the UniKey engine has been integrated to different keyboard input programs in various platforms: Linux, [macOS and iOS](/), FreeBSD. The core engine is still pretty much unchanged in the latest version of UniKey for Windows. You can get the engine source code in the original x-unikey linux package.

	[x-unikey source code](/)

* For educational purposes, I have also released the full UniKey 3.6 (for Windows) source code. Please note that, UniKey 3.6was built with an old version of the UniKey Input Engine. You cand find the latest engine source code in the x-unikey package above.

	[UniKey 3.62 050711 - source code](/)

### UVConverter

UVConverter is a universal command-line Vietnamese encoding converter that supports 13 different charsets/encodings (Unicode, UTF8, TCVN3, VNI\u2026). UVConverter can be built in Windows, Linux, Mac OS X.

* Tar.gz format (for Linux, Mac OS X): [UVConverter 1.1.3b](/)
* Zip format (for Windows): [UVConverter 1.1.3b](/)

`;

// route:D:\projects\unikey.org\app\routes\source.tsx
var handle3 = {
  breadcrumb: () => /* @__PURE__ */ import_react37.default.createElement(Link2, {
    to: "/source"
  }, "UniKey Source Code")
};
var meta4 = () => {
  return { title: "UniKey Source Code | Unikey" };
};
var loader3 = () => {
  return getPageData(source_mdx);
};
function SourcePage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react37.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react37.default.createElement("div", {
    className: "prose max-w-screen-lg",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\about.tsx
var about_exports = {};
__export(about_exports, {
  default: () => AboutPage,
  handle: () => handle4,
  loader: () => loader4,
  meta: () => meta5
});
init_react();
var import_react38 = __toModule(require_react());

// app/content/about.md.js
init_react();
var about_mdx = `---
title: Gi\u1EDBi thi\u1EC7u UniKey
---
# Gi\u1EDBi thi\u1EC7u UniKey

UniKey \u0111\u01B0\u1EE3c c\xF4ng b\u1ED1 l\u1EA7n \u0111\u1EA7u ti\xEAn v\xE0o n\u0103m 1999. Ngay t\u1EEB khi ra \u0111\u1EDDi, UniKey \u0111\xE3 \u0111\u01B0\u1EE3c ng\u01B0\u1EDDi d\xF9ng \u0111\xF3n nh\u1EADn r\u1EA5t t\xEDch c\u1EF1c nh\u1EDD t\xEDnh \u0111\u01A1n gi\u1EA3n, ti\u1EC7n d\u1EE5ng, t\u1ED1c \u0111\u1ED9, tin c\u1EADy. UniKey nhanh ch\xF3ng tr\u1EDF th\xE0nh ch\u01B0\u01A1ng tr\xECnh g\xF5 ti\u1EBFng Vi\u1EC7t t\u1ED1t nh\u1EA5t, ph\u1ED5 bi\u1EBFn nh\u1EA5t tr\xEAn Windows. Hi\u1EC7n nay UniKey c\xF3 m\u1EB7t h\u1EA7u nh\u01B0 tr\xEAn t\u1EA5t c\u1EA3 c\xE1c m\xE1y t\xEDnh ch\u1EA1y Windows c\u1EE7a ng\u01B0\u1EDDi Vi\u1EC7t.

**UniKey Vietnamese Input Method**, module ch\xEDnh x\u1EED l\xFD ti\u1EBFng Vi\u1EC7t (g\u1ED3m c\xE1c ph\u01B0\u01A1ng ph\xE1p g\xF5, thu\u1EADt to\xE1n chuy\u1EC3n \u0111\u1ED5i ti\u1EBFng Vi\u1EC7t) trong UniKey, \u0111\u01B0\u1EE3c open-source t\u1EEB n\u0103m 2001. B\u1EA3n open-source c\u1EE7a UniKey ch\u1EA1y tr\xEAn X-Window (Linux) \u0111\u01B0\u1EE3c c\xF4ng b\u1ED1 t\u1EEB n\u0103m 2001, d\u01B0\u1EDBi t\xEAn **x-unikey**. **x-unikey** l\xE0 m\u1ED9t trong nh\u1EEFng ch\u01B0\u01A1ng tr\xECnh g\xF5 ti\u1EBFng Vi\u1EC7t \u0111\u1EA7u ti\xEAn tr\xEAn Linux. T\u1EEB source code x-unikey, UniKey Input Engine \u0111\xE3 \u0111\u01B0\u1EE3c s\u1EED d\u1EE5ng v\xE0 t\xEDch h\u1EE3p v\xE0o c\xE1c b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t tr\xEAn Linux sau n\xE0y. B\u1ED9 g\xF5 ph\u1ED5 bi\u1EBFn nh\u1EA5t d\xF9ng l\xF5i UniKey tr\xEAn Linux hi\u1EC7n nay l\xE0 ibus-unikey (do L\xEA Qu\u1ED1c Tu\u1EA5n ph\xE1t tri\u1EC3n).

T\u1EEB n\u0103m 2006, t\xE1c gi\u1EA3 UniKey \u0111\xE3 cho ph\xE9p Apple d\xF9ng source code x-unikey trong c\xE1c s\u1EA3n ph\u1EA9m c\u1EE7a Apple theo c\xE1c \u0111i\u1EC1u kho\u1EA3n c\u1EE7a gi\u1EA5y ph\xE9p The MIT license. T\u1EEB phi\xEAn b\u1EA3n Tiger, b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n tr\xEAn Mac OS X \u0111\xE3 b\u1EAFt \u0111\u1EA7u d\xF9ng l\xF5i UniKey. \u0110\u1EBFn n\u0103m 2010, phi\xEAn b\u1EA3n iOS 4.0 c\u0169ng t\xEDch h\u1EE3p l\xF5i UniKey. \u0110\u1EBFn nay t\u1EA5t c\u1EA3 c\xE1c thi\u1EBFt b\u1ECB iPhone, iPad \u0111\u1EC1u \u0111ang s\u1EED d\u1EE5ng UniKey cho b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n.

UniKey \u0111\u01B0\u1EE3c ph\xE1t tri\u1EC3n b\u1EDFi *Ph\u1EA1m Kim Long*. Website ch\xEDnh th\u1EE9c duy nh\u1EA5t c\u1EE7a UniKey l\xE0 [http://unikey.org](http://unikey.org). T\xE1c gi\u1EA3 kh\xF4ng ch\u1ECBu tr\xE1ch nhi\u1EC7m v\u1EC1 b\u1EA5t c\u1EE9 website n\xE0o kh\xE1c cung c\u1EA5p c\xE1c ph\u1EA7n m\u1EC1m UniKey.
`;

// route:D:\projects\unikey.org\app\routes\about.tsx
var handle4 = {
  breadcrumb: () => /* @__PURE__ */ import_react38.default.createElement(Link2, {
    to: "/about"
  })
};
var meta5 = () => {
  return { title: "Gi\u1EDBi thi\u1EC7u Unikey | Unikey" };
};
var loader4 = () => {
  return getPageData(about_mdx);
};
function AboutPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react38.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react38.default.createElement("div", {
    className: "prose max-w-screen-lg",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\apple.tsx
var apple_exports = {};
__export(apple_exports, {
  default: () => ApplePage,
  handle: () => handle5,
  loader: () => loader5,
  meta: () => meta6
});
init_react();
var import_react39 = __toModule(require_react());

// app/content/apple.md.js
init_react();
var apple_mdx = `---
title: UniKey cho macOS v\xE0 iOS
---
# UniKey cho macOS v\xE0 iOS

T\u1EEB n\u0103m 2006, t\xF4i \u0111\xE3 cho ph\xE9p Apple d\xF9ng source code **x-unikey** (phi\xEAn b\u1EA3n UniKey cho Linux, c\xF3 ch\u1EE9a module l\xF5i **Unikey Vietnamese Input Method**) trong c\xE1c s\u1EA3n ph\u1EA9m c\u1EE7a Apple theo c\xE1c \u0111i\u1EC1u kho\u1EA3n c\u1EE7a gi\u1EA5y ph\xE9p The MIT license. T\u1EEB phi\xEAn b\u1EA3n MacOS X Leopard, b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n tr\xEAn Mac OS X \u0111\xE3 b\u1EAFt \u0111\u1EA7u d\xF9ng l\xF5i UniKey. \u0110\u1EBFn n\u0103m 2010, phi\xEAn b\u1EA3n iOS 4.0 c\u0169ng t\xEDch h\u1EE3p l\xF5i UniKey. \u0110\u1EBFn nay t\u1EA5t c\u1EA3 c\xE1c thi\u1EBFt b\u1ECB iPhone, iPad \u0111\u1EC1u \u0111ang s\u1EED d\u1EE5ng UniKey cho b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n tr\xEAn m\xE1y.

B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t trong macOS c\xF3 t\xEAn Simple Telex s\u1EED d\u1EE5ng l\xF5i **Unikey Vietnamese Input Method**

![Telex in MacOS](/img/macos-telex.png)

Trong iOS, x\xE1c nh\u1EADn c\u1EE7a Apple v\u1EC1 vi\u1EC7c d\xF9ng UniKey c\xF3 th\u1EC3 t\xECm th\u1EA5y trong *C\xE0i \u0111\u1EB7t - C\xE0i \u0111\u1EB7t chung - Gi\u1EDBi thi\u1EC7u - Ph\xE1p l\xFD - Th\xF4ng b\xE1o ph\xE1p l\xFD*

![iOS Legal Notice](/img/ios-legal.jpg)

`;

// route:D:\projects\unikey.org\app\routes\apple.tsx
var handle5 = {
  breadcrumb: () => /* @__PURE__ */ import_react39.default.createElement(Link2, {
    to: "/apple"
  }, "UniKey cho macOS v\xE0 iOS")
};
var meta6 = () => {
  return { title: "UniKey cho macOS v\xE0 iOS | Unikey" };
};
var loader5 = () => {
  return getPageData(apple_mdx);
};
function ApplePage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react39.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react39.default.createElement("div", {
    className: "prose max-w-screen-lg",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index,
  handle: () => handle6,
  loader: () => loader6
});
init_react();
var import_react40 = __toModule(require_react());

// app/content/index.md.js
init_react();
var index_mdx = `---
title: UniKey - B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t
---
# UniKey - B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t

Unikey l\xE0 ch\u01B0\u01A1ng tr\xECnh b\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t ph\u1ED5 bi\u1EBFn nh\u1EA5t tr\xEAn Windows. Ph\u1EA7n l\xF5i x\u1EED l\xFD ti\u1EBFng Vi\u1EC7t UniKey Input Engine c\u0169ng \u0111\u01B0\u1EE3c s\u1EED d\u1EE5ng trong c\xE1c ch\u01B0\u01A1ng tr\xECnh b\xE0n ph\xEDm m\u1EB7c \u0111\u1ECBnh c\u1EE7a c\xE1c h\u1EC7 \u0111i\u1EC1u h\xE0nh Linux, Mac OS X v\xE0 \u0111\u1EB7c bi\u1EC7t l\xE0 t\u1EA5t c\u1EA3 c\xE1c thi\u1EBFt b\u1ECB d\xF9ng iOS (iPhone, iPad). UniKey Input Engine c\xF3 m\xE3 ngu\u1ED3n m\u1EDF theo gi\u1EA5y ph\xE9p GNU General Public License.

Unikey.org l\xE0 website ch\xEDnh th\u1EE9c duy nh\u1EA5t c\u1EE7a ph\u1EA7n m\u1EC1m UniKey. T\xE1c gi\u1EA3 kh\xF4ng ch\u1ECBu tr\xE1ch nhi\u1EC7m v\u1EC1 t\u1EA5t c\u1EA3 c\xE1c website kh\xE1c l\u1EA5y t\xEAn ho\u1EB7c ph\xE2n ph\u1ED1i s\u1EA3n ph\u1EA9m UniKey.

## Tin t\u1EE9c

---

* Ng\xE0y 15/10/2020:

	* Ph\xE1t h\xE0nh [UniKey 4.3 RC5](/) h\u1ED7 tr\u1EE3 tr\xECnh duy\u1EC7t Edge m\u1EDBi t\u1ED1t h\u01A1n.

* Ng\xE0y 14/7/2018:

	* Ph\xE1t h\xE0nh [UniKey 4.3 RC4](/) s\u1EEDa m\u1ED9t l\u1ED7i kh\xF4ng g\xF5 \u0111\u01B0\u1EE3c trong m\u1ED9t s\u1ED1 app (console, game, UWP apps).

* Ng\xE0y 2/7/2018:

	* Ph\xE1t h\xE0nh [UniKey 4.3 RC3](/) s\u1EEDa \u0111\u01B0\u1EE3c l\u1ED7i v\u1EDBi Excel v\xE0 c\xE1c tr\xECnh duy\u1EC7t (Chrome, Edge, Firefox, Internet Explorer).

	* Ch\xFA \xFD: B\u1EA3n 4.2 RC2 ph\xE1t h\xE0nh ng\xE0y 1/7/2018 c\xF3 l\u1ED7i v\u1EDBi Edge. L\u1ED7i n\xE0y \u0111\xE3 \u0111\u01B0\u1EE3c s\u1EEDa ngay trong b\u1EA3n 4.3 RC3.

* Ng\xE0y 23/6/2018:

	* Ph\xE1t h\xE0nh UniKey 4.3 RC1
	
	* K\u1EC3 t\u1EEB phi\xEAn b\u1EA3n 4.3, c\xE1c b\u1EA3n UniKey \u0111\u01B0\u1EE3c ph\xE1t h\xE0nh \u0111i k\xE8m v\u1EDBi ch\u1EEF k\xFD s\u1ED1 c\xF3 ch\u1EE9ng th\u1EF1c \u0111\u1EC3 ch\u1ED1ng ph\u1EA7n m\u1EC1m gi\u1EA3 m\u1EA1o. Xem th\xEAm th\xF4ng tin t\u1EA1i [Ch\u1EE9ng th\u1EF1c UniKey](/).

## C\xE1c t\xEDnh n\u0103ng

---

UniKey h\u1ED7 tr\u1EE3:

* T\u1EA5t c\u1EA3 c\xE1c b\u1EA3ng m\xE3 ph\u1ED5 bi\u1EBFn:

	* Unicode, TCVN (ABC)

	* VIQR, VNI, VPS, VISCII, BK HCM1, BK HCM2,\u2026

	* Unicode UTF-8, Unicode NCR - for Web editors.

* 2 ph\u01B0\u01A1ng ph\xE1p g\xF5 th\xF4ng d\u1EE5ng: TELEX, VNI

* Cho ph\xE9p t\u1EF1 \u0111\u1ECBnh ngh\u0129a ki\u1EC3u g\xF5

* Cho ph\xE9p g\xF5 t\u1EAFt v\xE0 \u0111\u1ECBnh ngh\u0129a b\u1EA3ng g\xF5 t\u1EAFt.

* Ch\u1EA1y tr\xEAn t\u1EA5t c\u1EA3 c\xE1c phi\xEAn b\u1EA3n Windows: 10, 8, 7, Vista, 2000, XP, 9x.

UniKey r\u1EA5t g\u1ECDn nh\u1EB9, kh\xF4ng c\u1EA7n c\xE0i \u0111\u1EB7t.

`;

// route:D:\projects\unikey.org\app\routes\index.tsx
var handle6 = {
  breadcrumb: () => /* @__PURE__ */ import_react40.default.createElement(Link2, {
    to: "/"
  }, "Trang ch\u1EE7")
};
var loader6 = () => {
  return getPageData(index_mdx);
};
function Index() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react40.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react40.default.createElement("div", {
    className: "prose max-w-screen-lg prose-a:no-underline prose-a:text-blue-600 hover:prose-a:underline",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\linux.tsx
var linux_exports = {};
__export(linux_exports, {
  default: () => LinuxPage,
  handle: () => handle7,
  loader: () => loader7,
  meta: () => meta7
});
init_react();
var import_react41 = __toModule(require_react());

// app/content/linux.md.js
init_react();
var linux_mdx = `---
title: UniKey Software for Linux
---
# UniKey Software for Linux

## X-Unikey

X-Unikey is Unikey ported to Linux and FreeBSD. X-Unikey lets you type Vietnamese in X Window environment. It has been tested with many popular programs, such as OpenOffice, emacs, vim, QT applications, GTK applications\u2026 X-Unikey has all the features of the Windows version, except that its GUI is still too simplified. All options are set through configuration file or keyboard shortcuts.

### Download X-Unikey

* Source code: [x-unikey 1.0.4](/)

### X-Unikey User Manual in Vietnamese

(User Manual in English is provided in the above packages)

* [X-Unikey Manual, HTML](/), edited by Pham Thanh Long.
* [X-Unikey Manual, PDF](/), LaTeX typesetting by Phan Vinh Thinh.

## UVConverter

UVConverter is a universal command-line Vietnamese encoding converter which supports all popular charsets/encodings (Unicode, UTF8, TCVN3, VNI\u2026). UVConverter is available in Windows, Linux, and Mac OS X.

* [UVConverter 1.1.3b for Windows (12 KB)](/).
* [UVConverter 1.1.3b - Source code](/).

## X-Chat Autovn Plugin

Autovn is a plugin for X-Chat that automatically converts all messages from VIQR encoding to UTF-8 encoding.

* [Autovn 0.2b (1/3/2004)- source code](/)

## Pine Vietnamese HOWTO

This HOWTO shows how Pine can be setup to read and write Vietnamese emails. One special feature is the ability to automatically convert back and forth between VIQR and Unicode charsets as you read or send emails. Emails received in VIQR charset can be viewed as if they were written in unicode!

* [Click here to read](/)

All software in this page are released under the terms of the GNU General Public License.
`;

// route:D:\projects\unikey.org\app\routes\linux.tsx
var handle7 = {
  breadcrumb: () => /* @__PURE__ */ import_react41.default.createElement(Link2, {
    to: "/linux"
  }, "UniKey Software for Linux")
};
var meta7 = () => {
  return { title: "UniKey Software for Linux | Unikey" };
};
var loader7 = () => {
  return getPageData(linux_mdx);
};
function LinuxPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react41.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react41.default.createElement("div", {
    className: "prose max-w-screen-lg",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\blog.tsx
var blog_exports = {};
__export(blog_exports, {
  default: () => BlogPage,
  handle: () => handle8,
  meta: () => meta8
});
init_react();
var import_react42 = __toModule(require_react());
var handle8 = {
  breadcrumb: () => /* @__PURE__ */ import_react42.default.createElement(Link2, {
    to: "/blog"
  }, "Blog")
};
var meta8 = () => {
  return { title: "Blog | Unikey" };
};
function BlogPage() {
  return /* @__PURE__ */ import_react42.default.createElement(motion.div, {
    className: "prose max-w-screen-lg",
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react42.default.createElement(Link2, {
    to: "/blog"
  }, /* @__PURE__ */ import_react42.default.createElement("h1", {
    className: "no-underline"
  }, "Blog")), /* @__PURE__ */ import_react42.default.createElement(Outlet, null));
}

// route:D:\projects\unikey.org\app\routes\blog\$slug.tsx
var slug_exports = {};
__export(slug_exports, {
  default: () => BlogDetails,
  handle: () => handle9,
  loader: () => loader8
});
init_react();
var import_react43 = __toModule(require_react());

// app/utils/getBlogData.ts
init_react();
var import_front_matter2 = __toModule(require_front_matter());

// app/content/blog/index.js
init_react();

// app/content/blog/md_2020_10_15.js
init_react();
var md_2020_10_15 = `---
title: blog1-blog-1blog
---
## UniKey 4.3 RC5 Release

* Ng\xE0y 15/10/2020: Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC5 s\u1EEDa m\u1ED9t s\u1ED1 l\u1ED7i nh\u1ECF.
* Th\xEAm t\xF9y ch\u1ECDn b\u1EADt/t\u1EAFt ti\u1EBFng khi chuy\u1EC3n ng\xF4n ng\u1EEF.

T\u01B0\u01A1ng th\xEDch t\u1ED1t h\u01A1n v\u1EDBi tr\xECnh duy\u1EC7t Edge m\u1EDBi c\u1EE7a Windows.

[Download UniKey 4.3 RC5](/)
`;

// app/content/blog/md_2018_07_14.js
init_react();
var md_2018_07_14 = `---
title: blog1-blog-1blog
---
## UniKey 4.3 RC4 Release

Ng\xE0y 14/7/2018: Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC4 s\u1EEDa m\u1ED9t s\u1ED1 l\u1ED7i nh\u1ECF.

* S\u1EEDa l\u1ED7i kh\xF4ng g\xF5 \u0111\u01B0\u1EE3c trong m\u1ED9t s\u1ED1 \u1EE9ng d\u1EE5ng (console, games, UWP Universal Windows Platform).
* S\u1EEDa l\u1ED7i kh\xF4ng x\xF3a/thay h\u1EBFt ch\u1EEF trong Opera (\u0111\xE3 s\u1EEDa l\u1ED7i n\xE0y cho Excel, Chrome, Firefox, Edge, IE t\u1EEB b\u1EA3n RC3).

[Download UniKey 4.3 RC4](/)
`;

// app/content/blog/md_2018_07_02.js
init_react();
var md_2018_07_02 = `---
title: blog1-blog-1blog
---
## UniKey 4.3 RC3 Release

Ng\xE0y 2/7/2018: Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC3 - s\u1EEDa c\xE1c l\u1ED7i v\u1EDBi browsers (Chrome, Edge, Firefox) v\xE0 Excel.

\u0110\xE3 s\u1EEDa \u0111\u01B0\u1EE3c l\u1ED7i kh\xF4ng x\xF3a/thay h\u1EBFt ch\u1EEF khi c\xF3 t\u1EEB g\u1EE3i \xFD trong trong c\xE1c ch\u01B0\u01A1ng tr\xECnh:

* [sang] + [s] = [sa\xE1ng]
* \u0110\xE3 s\u1EEDa ho\xE0n to\xE0n cho Excel, Chrome, Firefox, Edge, Internet Explorer.

Ch\xFA \xFD: B\u1EA3n 4.3 RC2 ph\xE1t h\xE0nh ng\xE0y 1/7/2018 c\xF3 l\u1ED7i kh\xF4ng g\xF5 \u0111\u01B0\u1EE3c trong Edge. B\u1EA3n 4.3 RC3 \u0111\xE3 kh\u1EAFc ph\u1EE5c l\u1ED7i n\xE0y.

[Download UniKey 4.3 RC3](/)
`;

// app/content/blog/md_2018_06_23.js
init_react();
var md_2018_06_23 = `---
title: blog1-blog-1blog
---
## UniKey 4.3 Release

Ng\xE0y 23/6/2018: Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC1 v\u1EDBi nh\u1EEFng c\u1EADp nh\u1EADt quan tr\u1ECDng.

G\u1EAFn ch\u1EEF k\xFD \u0111i\u1EC7n t\u1EED c\xF3 ch\u1EE9ng th\u1EF1c trong ch\u01B0\u01A1ng tr\xECnh UniKeyNT.exe. K\u1EC3 t\u1EEB phi\xEAn b\u1EA3n n\xE0y, c\xE1c b\u1EA1n lu\xF4n c\xF3 th\u1EC3 ki\u1EC3m tra \u0111\u1EC3 ch\u1EAFc ch\u1EAFn m\xECnh d\xF9ng UniKey s\u1EA1ch, kh\xF4ng b\u1ECB s\u1EEDa \u0111\u1ED5i. Xem h\u01B0\u1EDBng d\u1EABn v\u1EC1 ch\u1EE9ng th\u1EF1c UniKey t\u1EA1i \u0111\xE2y.

* S\u1EEDa l\u1ED7i kh\xF4ng g\xF5 \u0111\u01B0\u1EE3c ti\u1EBFng Vi\u1EC7t trong m\u1ED9t s\u1ED1 trang web tr\xEAn tr\xECnh duy\u1EC7t Edge.
* S\u1EEDa l\u1ED7i x\xF3a b\u1EA3ng g\xF5 t\u1EAFt.
* C\u1EA3i ti\u1EBFn t\xEDnh n\u0103ng g\xF5 t\u1EAFt:
	* T\u0103ng k\xEDch th\u01B0\u1EDBc t\u1ED1i \u0111a b\u1EA3ng g\xF5 t\u1EAFt l\xEAn 8000 m\u1EE5c.
	* Th\xEAm t\xF9y ch\u1ECDn b\u1EADt/t\u1EAFt t\xEDnh n\u0103ng t\u1EF1 \u0111\u1ED9ng \u0111\u1ED5i ch\u1EEF hoa/th\u01B0\u1EDDng khi g\xF5 t\u1EAFt.

[Download UniKey 4.3 RC1](/)
`;

// app/content/blog/md_2018_06_06.js
init_react();
var md_2018_06_06 = `---
title: blog1-blog-1blog
---
##T\u1EF1 \u0111\u1ED9ng ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n admin

C\xE1c b\u01B0\u1EDBc \u0111\u1EC3 ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n administrator b\u1EB1ng c\xE1ch d\xF9ng Task Scheduler

1. T\u1EAFt \u201CKh\u1EDFi \u0111\u1ED9ng c\xF9ng Windows\u201D trong UniKey. Sau \u0111\xF3 t\u1EAFt UniKey.
2. Ch\u1EA1y Task Scheduler (b\u1EA5m n\xFAt Start, sau \u0111\xF3 g\xF5 Task Scheduler).
3. T\u1EA1o basic task v\u1EDBi c\xE1c l\u1EF1a ch\u1ECDn sau:
	* Trigger: When I log on
	* Action: Start a program. Sau \u0111\xF3 ch\u1ECDn \u0111\u01B0\u1EDDng d\u1EABn \u0111\u1EBFn UniKeyNT.exe
	* Finish. Sau \u0111\xF3 ch\u1ECDn ti\u1EBFp Properties c\u1EE7a Task \u0111\u1EC3 th\xEAm c\xE1c th\xF4ng s\u1ED1 sau:
	* General: Run with highest privileges.
	* Triggers - Edit: Ch\u1ECDn \u201CDelay task for: 30 seconds\u201D (N\u1EBFu kh\xF4ng ch\u1ECDn ph\u1EA7n n\xE0y th\xEC UniKey s\u1EBD \u0111\u01B0\u1EE3c kh\u1EDFi \u0111\u1ED9ng m\xE0 kh\xF4ng c\xF3 icon \u1EDF g\xF3c).
	* Condition: N\u1EBFu l\xE0 m\xE1y laptop th\xEC B\u1ECE l\u1EF1a ch\u1ECDn \u201CStart the task only if the computer is on AC power\u201D.

Logout, sau \u0111\xF3 login, UniKey s\u1EBD \u0111\u01B0\u1EE3c ch\u1EA1y v\u1EDBi quy\u1EC1n admin 30 gi\xE2y sau khi login.
`;

// app/content/blog/md_2018_05_30.js
init_react();
var md_2018_05_30 = `---
title: blog1-blog-1blog
---
## Ch\u1EE9ng th\u1EF1c UniKey

K\u1EC3 t\u1EEB phi\xEAn b\u1EA3n 4.3 RC1, c\xE1c b\u1EA3n release c\u1EE7a UniKey \u0111\u01B0\u1EE3c g\u1EAFn ch\u1EE9ng th\u1EF1c ch\u1EEF k\xFD s\u1ED1.

Ch\u1EEF k\xFD s\u1ED1 s\u1EBD gi\xFAp:

* UniKey kh\xF4ng b\u1ECB h\u1EC7 th\u1ED1ng ki\u1EC3m tra Windows Defender SmartScreen c\u1EA3nh b\xE1o nh\u1EA7m l\xE0 ph\u1EA7n m\u1EC1m \u0111\u1ED9c h\u1EA1i.
* B\u1EA1n lu\xF4n c\xF3 th\u1EC3 ki\u1EC3m tra \u0111\u1EC3 c\xF3 th\u1EC3 ch\u1EAFc ch\u1EAFn ch\u01B0\u01A1ng tr\xECnh \u0111\xFAng l\xE0 do t\xE1c gi\u1EA3 Ph\u1EA1m Kim Long cung c\u1EA5p v\xE0 kh\xF4ng b\u1ECB thay \u0111\u1ED5i.

##C\u1EA3nh b\xE1o SmartScreen c\u1EE7a Windows Defender

M\u1EB7c d\xF9 UniKey \u0111\xE3 \u0111\u01B0\u1EE3c g\u1EAFn ch\u1EEF k\xFD s\u1ED1, m\u1ED7i khi m\u1ED9t phi\xEAn b\u1EA3n UniKey m\u1EDBi \u0111\u01B0\u1EE3c c\xF4ng b\u1ED1 ch\u01B0a l\xE2u, b\u1EA1n v\u1EABn c\xF3 th\u1EC3 g\u1EB7p c\u1EA3nh b\xE1o SmartScreen khi ch\u1EA1y UniKey nh\u01B0 sau:

![smartscreen](/img/certificate/smartscreen.png)

Khi g\u1EB7p m\xE0n h\xECnh tr\xEAn, b\u1EA1n b\u1EA5m v\xE0o n\xFAt \u201CMore Info\u201D nh\u01B0 h\xECnh tr\xEAn. Khi \u0111\xF3 SmartScreen s\u1EBD hi\u1EC7n \u0111\u1EA7y \u0111\u1EE7 th\xF4ng tin xu\u1EA5t x\u1EE9 c\u1EE7a UniKey nh\u01B0 sau:

![smartscreen-ok](/img/certificate/smartscreen-ok.png)

N\u1EBFu b\u1EA1n th\u1EA5y d\xF2ng ch\u1EEF **Publisher: PHAM KIM LONG**, t\u1EE9c l\xE0 b\u1EA1n \u0111ang d\xF9ng b\u1EA3n UniKey s\u1EA1ch, xu\u1EA5t ph\xE1t t\u1EEB t\xE1c gi\u1EA3.

N\u1EBFu b\u1EA1n th\u1EA5y d\xF2ng ch\u1EEF **Publisher: Unknown publisher** nh\u01B0 d\u01B0\u1EDBi \u0111\xE2y th\xEC \u0111\u1EEBng s\u1EED d\u1EE5ng, v\xEC \u0111\xF3 r\u1EA5t c\xF3 th\u1EC3 l\xE0 m\u1ED9t phi\xEAn b\u1EA3n \u0111\xE3 b\u1ECB c\xE0i m\xE3 \u0111\u1ED9c, ho\u1EB7c l\xE0 m\u1ED9t ch\u01B0\u01A1ng tr\xECnh kh\xF4ng r\xF5 ngu\u1ED3n g\u1ED1c.

![smartscreen-unknown](/img/certificate/smartscreen-unknown.png)

**L\u01B0u \xFD**

V\u1EDBi m\u1ED7i b\u1EA3n UniKey c\xF3 g\u1EAFn ch\u1EE9ng th\u1EF1c ch\u1EEF k\xFD s\u1ED1, sau khi c\xF3 s\u1ED1 l\u01B0\u1EE3t download \u0111\u1EE7 l\u1EDBn, Windows s\u1EBD ghi nh\u1EADn v\xE0 \u201Cnh\u1EDB\u201D phi\xEAn b\u1EA3n s\u1EA1ch c\u1EE7a UniKey v\xE0 s\u1EBD kh\xF4ng hi\u1EC7n c\u1EA3nh b\xE1o c\u1EE7a SmartScreen nh\u01B0 \u1EDF tr\xEAn n\u1EEFa (v\u1EDBi \u0111i\u1EC1u ki\u1EC7n b\u1EA3n download l\xE0 nguy\xEAn b\u1EA3n, kh\xF4ng b\u1ECB ai kh\xE1c thay \u0111\u1ED5i). N\u1EBFu kh\xF4ng g\u1EB7p c\u1EA3nh b\xE1o, c\xE1c b\u1EA1n c\xF3 th\u1EC3 y\xEAn t\xE2m s\u1EED d\u1EE5ng UniKey.

## C\xE1ch ki\u1EC3m tra ch\u1EE9ng th\u1EF1c ch\u1EEF k\xFD s\u1ED1 c\u1EE7a UniKey

\u0110\u1EC3 ki\u1EC3m ch\u1EE9ng UniKey xu\u1EA5t ph\xE1t t\u1EEB t\xE1c gi\u1EA3, kh\xF4ng b\u1ECB s\u1EEDa \u0111\u1ED5i, c\xE1c b\u1EA1n l\xE0m nh\u01B0 sau:

* Trong Windows Explorer, b\u1EA5m chu\u1ED9t ph\u1EA3i v\xE0o file UniKeyNT.exe, ch\u1ECDn Properties, sau \u0111\xF3 ch\u1ECDn tab Digital Signatures.

	![properties1](/img/certificate/properties-1.png)

* B\u1EA5m v\xE0o n\xFAt Details:

	![properties2](/img/certificate/properties-2.png)

* B\u1EA5m v\xE0o n\xFAt View Certificate:

	![properties3](/img/certificate/properties-3.png)

`;

// app/content/blog/index.js
var blogList = [
  {
    date: "15 Oct 2020",
    title: "UniKey 4.3 RC5 Release",
    description: "Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC5 s\u1EEDa m\u1ED9t s\u1ED1 l\u1ED7i nh\u1ECF",
    slug: "UniKey-4.3-RC5-Release",
    content: md_2020_10_15
  },
  {
    date: "14 Jul 2018",
    title: "UniKey 4.3 RC4 Release",
    description: "Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC4 s\u1EEDa m\u1ED9t s\u1ED1 l\u1ED7i nh\u1ECF",
    slug: "UniKey-4.3-RC4-Release",
    content: md_2018_07_14
  },
  {
    date: "02 Jul 2018",
    title: "UniKey 4.3 RC3 Release",
    description: "Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC3 - s\u1EEDa c\xE1c l\u1ED7i v\u1EDBi browsers (Chrome, Edge, Firefox) v\xE0 Excel",
    slug: "UniKey-4.3-RC3-Release",
    content: md_2018_07_02
  },
  {
    date: "23 Jun 2018",
    title: "UniKey 4.3 Release",
    description: "Ph\xE1t h\xE0nh b\u1EA3n 4.3 RC1 v\u1EDBi nh\u1EEFng c\u1EADp nh\u1EADt quan tr\u1ECDng",
    slug: "UniKey-4.3-Release",
    content: md_2018_06_23
  },
  {
    date: "09 Jun 2018",
    title: "T\u1EF1 \u0111\u1ED9ng ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n admin",
    description: "C\xE1c b\u01B0\u1EDBc \u0111\u1EC3 ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n administrator b\u1EB1ng c\xE1ch d\xF9ng Task Scheduler",
    slug: "tu-dong-chay-Unikey-voi-quyen-admin",
    content: md_2018_06_06
  },
  {
    date: "30 May 2018",
    title: "Ch\u1EE9ng th\u1EF1c UniKey",
    description: "K\u1EC3 t\u1EEB phi\xEAn b\u1EA3n 4.3 RC1, c\xE1c b\u1EA3n release c\u1EE7a UniKey \u0111\u01B0\u1EE3c g\u1EAFn ch\u1EE9ng th\u1EF1c ch\u1EEF k\xFD s\u1ED1.",
    slug: "chung-thuc-UniKey",
    content: md_2018_05_30
  }
];

// app/utils/getBlogData.ts
function getBlogData(slug) {
  const blogItem = blogList.filter((blogItem2) => blogItem2.slug === slug);
  const { attributes, body } = (0, import_front_matter2.default)(blogItem[0].content);
  const html = marked.parse(body);
  return { attributes, html };
}

// route:D:\projects\unikey.org\app\routes\blog\$slug.tsx
var handle9 = {
  breadcrumb: () => ""
};
var loader8 = async ({ params }) => {
  return getBlogData(params.slug);
};
function BlogDetails() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react43.default.createElement(motion.div, {
    variants: pageMotion,
    initial: "hidden",
    animate: "visible"
  }, /* @__PURE__ */ import_react43.default.createElement("div", {
    className: "prose max-w-screen-lg prose-a:no-underline prose-a:text-blue-600 hover:prose-a:underline",
    dangerouslySetInnerHTML: { __html: html }
  }));
}

// route:D:\projects\unikey.org\app\routes\blog\index.tsx
var blog_exports2 = {};
__export(blog_exports2, {
  default: () => BlogPageIndex
});
init_react();
var import_react44 = __toModule(require_react());
function BlogPageIndex() {
  return /* @__PURE__ */ import_react44.default.createElement(import_react44.default.Fragment, null, /* @__PURE__ */ import_react44.default.createElement("ul", null, blogList.map((blogItem) => /* @__PURE__ */ import_react44.default.createElement("li", {
    key: blogItem.slug
  }, /* @__PURE__ */ import_react44.default.createElement(Link2, {
    to: `/blog/${blogItem.slug}`
  }, blogItem.title), /* @__PURE__ */ import_react44.default.createElement("span", {
    className: "block"
  }, blogItem.description)))));
}

// server-assets-manifest:@remix-run/dev/assets-manifest
init_react();
var assets_manifest_default = { "version": "6c02c997", "entry": { "module": "/build/entry.client-TY25M3E6.js", "imports": ["/build/_shared/chunk-6HI2IN44.js"] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "module": "/build/root-XS7ZMBYA.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": true, "hasErrorBoundary": true }, "routes/about": { "id": "routes/about", "parentId": "root", "path": "about", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/about-5SP3UGN5.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/apple": { "id": "routes/apple", "parentId": "root", "path": "apple", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/apple-KDVHKASC.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/blog": { "id": "routes/blog", "parentId": "root", "path": "blog", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/blog-EWPP2T6F.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/blog/$slug": { "id": "routes/blog/$slug", "parentId": "routes/blog", "path": ":slug", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/blog/$slug-Q6OCCVFE.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/blog/index": { "id": "routes/blog/index", "parentId": "routes/blog", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/blog/index-K3XPFD5M.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/download": { "id": "routes/download", "parentId": "root", "path": "download", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/download-ZIWSJKRN.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/index": { "id": "routes/index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/index-W2NMYROA.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/linux": { "id": "routes/linux", "parentId": "root", "path": "linux", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/linux-NSFVFQLL.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/source": { "id": "routes/source", "parentId": "root", "path": "source", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/source-JJZEIQ6I.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/support": { "id": "routes/support", "parentId": "root", "path": "support", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/support-R3KGQTIV.js", "imports": ["/build/_shared/chunk-WBITAMZB.js"], "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false } }, "url": "/build/manifest-6C02C997.js" };

// server-entry-module:@remix-run/dev/server-build
var entry = { module: entry_server_exports };
var routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/download": {
    id: "routes/download",
    parentId: "root",
    path: "download",
    index: void 0,
    caseSensitive: void 0,
    module: download_exports
  },
  "routes/support": {
    id: "routes/support",
    parentId: "root",
    path: "support",
    index: void 0,
    caseSensitive: void 0,
    module: support_exports
  },
  "routes/source": {
    id: "routes/source",
    parentId: "root",
    path: "source",
    index: void 0,
    caseSensitive: void 0,
    module: source_exports
  },
  "routes/about": {
    id: "routes/about",
    parentId: "root",
    path: "about",
    index: void 0,
    caseSensitive: void 0,
    module: about_exports
  },
  "routes/apple": {
    id: "routes/apple",
    parentId: "root",
    path: "apple",
    index: void 0,
    caseSensitive: void 0,
    module: apple_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: routes_exports
  },
  "routes/linux": {
    id: "routes/linux",
    parentId: "root",
    path: "linux",
    index: void 0,
    caseSensitive: void 0,
    module: linux_exports
  },
  "routes/blog": {
    id: "routes/blog",
    parentId: "root",
    path: "blog",
    index: void 0,
    caseSensitive: void 0,
    module: blog_exports
  },
  "routes/blog/$slug": {
    id: "routes/blog/$slug",
    parentId: "routes/blog",
    path: ":slug",
    index: void 0,
    caseSensitive: void 0,
    module: slug_exports
  },
  "routes/blog/index": {
    id: "routes/blog/index",
    parentId: "routes/blog",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: blog_exports2
  }
};

// server.js
var handleRequest2 = createPagesFunctionHandler({
  build: server_build_exports,
  mode: "development",
  getLoadContext: (context) => context.env
});
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @remix-run/cloudflare-pages v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vZGV2L2NvbXBpbGVyL3NoaW1zL3JlYWN0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvanNlc2MvanNlc2MuanMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpldmVudHMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpwcm9jZXNzIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9pbmhlcml0cy5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnV0aWwiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpidWZmZXIiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9idWZmZXItbGlzdC5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnN0cmluZ19kZWNvZGVyIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6c3RyZWFtIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6c3RyZWFtIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvY29tbW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbWFyay5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3N0ci5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2VxLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL251bGwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Jvb2wuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvZmxvYXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvanNvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS90aW1lc3RhbXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL29tYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL3JlZ2V4cC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvZnVuY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuZXNtLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9pcy1wcm9wLXZhbGlkL2Rpc3QvaXMtcHJvcC12YWxpZC5lc20uanMiLCAiLi4vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL2dsb2JhbHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vY29va2llU2lnbmluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9zZXNzaW9ucy9jbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3Jlc3BvbnNlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9kYXRhLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9lbnRyeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZXJyb3JzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9oZWFkZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yb3V0ZU1hdGNoaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwgIi4uLy4uL3BhY2thZ2VzL3JlYWN0LXJvdXRlci9pbmRleC50c3giLCAiLi4vLi4vcGFja2FnZXMvcmVhY3Qtcm91dGVyLWRvbS9pbmRleC50c3giLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL21vZGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3JvdXRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vc2VydmVySGFuZG9mZi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS93b3JrZXIuanMiLCAic2VydmVyLWVudHJ5LW1vZHVsZTpAcmVtaXgtcnVuL2Rldi9zZXJ2ZXItYnVpbGQiLCAiLi4vYXBwL2VudHJ5LnNlcnZlci50c3giLCAiLi4vbm9kZV9tb2R1bGVzL3JlbWl4L2VzbS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2NvbXBvbmVudHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2Vycm9yQm91bmRhcmllcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vaW52YXJpYW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9saW5rcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vcm91dGVNb2R1bGVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9tYXJrdXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vZGF0YS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vdHJhbnNpdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vcm91dGVNYXRjaGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vc2Nyb2xsLXJlc3RvcmF0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9zZXJ2ZXIuanMiLCAicm91dGU6RDpcXHByb2plY3RzXFx1bmlrZXkub3JnXFxhcHBcXHJvb3QudHN4IiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb3V0ZXNcXGRvd25sb2FkLnRzeCIsICIuLi9hcHAvdXRpbHMvZ2V0UGFnZURhdGEudHMiLCAiLi4vbm9kZV9tb2R1bGVzL21hcmtlZC9saWIvbWFya2VkLmVzbS5qcyIsICIuLi9hcHAvY29udGVudC9kb3dubG9hZC5tZC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2luZGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9ub2RlX21vZHVsZXMvdHNsaWIvbW9kdWxlcy9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9pbmRleC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdXNlLWZlYXR1cmVzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9kZWZpbml0aW9ucy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2hleS1saXN0ZW4vZGlzdC9oZXktbGlzdGVuLmVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9MYXp5Q29udGV4dC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLWJyb3dzZXIubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLXJlZHVjZWQtbW90aW9uLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtbW90aW9uLXJlZi5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1yZWYtb2JqZWN0Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L3V0aWxzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy92YXJpYW50cy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvaWQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9jcmVhdGUtcHJvamVjdGlvbi1ub2RlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvaW5kZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXN5bmMvZGlzdC9lcy9vbi1uZXh0LWZyYW1lLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvY3JlYXRlLXJlbmRlci1zdGVwLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvaW5kZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2luZGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL25vZGVfbW9kdWxlcy90c2xpYi9tb2R1bGVzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL3V0aWxzL2RldGVjdC1hbmltYXRpb24tZnJvbS1vcHRpb25zLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9nZW5lcmF0b3JzL3NwcmluZy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvdXRpbHMvZmluZC1zcHJpbmcubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9jbGFtcC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9rZXlmcmFtZXMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pbnRlcnBvbGF0ZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL3Byb2dyZXNzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4LWNvbG9yLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9pbmRleC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvbnVtYmVycy9pbmRleC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvdXRpbHMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL251bWJlcnMvdW5pdHMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL2hzbGEubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL3V0aWxzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9yZ2JhLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9oZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL2luZGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2luZGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2ZpbHRlci5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2hzbGEtdG8tcmdiYS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC1jb21wbGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaW5jLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcGlwZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy9pbmRleC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy91dGlscy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9kZWNheS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvdXRpbHMvZWxhcHNlZC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvaW5lcnRpYS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL3ZlbG9jaXR5LXBlci1zZWNvbmQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9kaXN0YW5jZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXBvaW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtcG9pbnQtM2QubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9lYXNpbmcvY3ViaWMtYmV6aWVyLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL2luZGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2FycmF5Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvdHJhbnNpdGlvbnMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdGltZS1jb252ZXJzaW9uLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9lYXNpbmcubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGFibGUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2RlZmF1bHQtdHJhbnNpdGlvbnMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWtleWZyYW1lcy10YXJnZXQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9hbmltYXRhYmxlLW5vbmUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9kZWZhdWx0cy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL251bWJlci5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3R5cGUtaW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pbnN0YW50LXRyYW5zaXRpb24tc3RhdGUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcmVzb2x2ZS12YWx1ZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2FuaW1hdGlvbi9taXgtdmFsdWVzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29weS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWFwcGx5Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvaGFzLXRyYW5zZm9ybS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1yZW1vdmUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9tb2RlbHMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS91dGlscy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3NoYXJlZC9zdGFjay5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3RyYW5zZm9ybS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL2VhY2gtYXhpcy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy90cmFuc2Zvcm0ubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2ZsYXQtdHJlZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvY29tcGFyZS1ieS1kZXB0aC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9yZXNvbHZlLW1vdGlvbi12YWx1ZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdXNlLXByb2plY3Rpb24ubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Td2l0Y2hMYXlvdXRHcm91cENvbnRleHQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL1Zpc3VhbEVsZW1lbnRIYW5kbGVyLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLXByb3h5Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY3JlYXRlLWNvbmZpZy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLXN2Zy1jb21wb25lbnQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy9sb3dlcmNhc2UtZWxlbWVudHMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91c2UtcmVuZGVyLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3VzZS1wcm9wcy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvaXMtZm9yY2VkLW1vdGlvbi12YWx1ZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC1zdHlsZXMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtdHJhbnNmb3JtLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZ2V0LWFzLXR5cGUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2ZpbHRlci1wcm9wcy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdmFsaWQtcHJvcC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3VzZS1wcm9wcy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2J1aWxkLWF0dHJzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvdHJhbnNmb3JtLW9yaWdpbi5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3BhdGgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvY29uZmlnLW1vdGlvbi5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3JlbmRlci5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvcmVuZGVyLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvY2FtZWwtY2FzZS1hdHRycy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvY29uZmlnLW1vdGlvbi5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZ2VzdHVyZXMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLWZvY3VzLWdlc3R1cmUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3R5cGVzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy91c2UtZG9tLWV2ZW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1ob3Zlci1nZXN0dXJlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2V2ZW50LXR5cGUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy9ldmVudC1pbmZvLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy91dGlscy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2xvY2subWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXRhcC1nZXN0dXJlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLXVubW91bnQtZWZmZWN0Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy92aWV3cG9ydC91c2Utdmlld3BvcnQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvd2Fybi1vbmNlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy92aWV3cG9ydC9vYnNlcnZlcnMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL21ha2UtcmVuZGVybGVzcy1jb21wb25lbnQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pZC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLXN0YXRlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3NoYWxsb3ctY29tcGFyZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLW51bWVyaWNhbC1zdHJpbmcubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtemVyby12YWx1ZS1zdHJpbmcubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9maW5kLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGltZW5zaW9ucy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3Rlc3QubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90eXBlLWF1dG8ubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2RyYWcubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL1Zpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvUGFuU2Vzc2lvbi5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2NvbnN0cmFpbnRzLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvbWVhc3VyZS5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2NvbnZlcnNpb24ubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXBhbi1nZXN0dXJlLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vY3JlYXRlLXZpc3VhbC1lbGVtZW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3Zpc3VhbC1lbGVtZW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9pbmRleC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvbGlmZWN5Y2xlcy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvbW90aW9uLXZhbHVlcy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL3BhcnNlLWRvbS12YXJpYW50Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY3NzLXZhcmlhYmxlcy1jb252ZXJzaW9uLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvdW5pdC1jb252ZXJzaW9uLm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdmlzdWFsLWVsZW1lbnQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9pbmRleC5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L01lYXN1cmVMYXlvdXQubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtYm9yZGVyLXJhZGl1cy5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3gtc2hhZG93Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL0RvY3VtZW50UHJvamVjdGlvbk5vZGUubWpzIiwgIi4uL2FwcC91dGlscy9tb3Rpb25WYXJpYW50cy5qcyIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxzdXBwb3J0LnRzeCIsICIuLi9hcHAvY29udGVudC9zdXBwb3J0Lm1kLmpzIiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb3V0ZXNcXHNvdXJjZS50c3giLCAiLi4vYXBwL2NvbnRlbnQvc291cmNlLm1kLmpzIiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb3V0ZXNcXGFib3V0LnRzeCIsICIuLi9hcHAvY29udGVudC9hYm91dC5tZC5qcyIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxhcHBsZS50c3giLCAiLi4vYXBwL2NvbnRlbnQvYXBwbGUubWQuanMiLCAicm91dGU6RDpcXHByb2plY3RzXFx1bmlrZXkub3JnXFxhcHBcXHJvdXRlc1xcaW5kZXgudHN4IiwgIi4uL2FwcC9jb250ZW50L2luZGV4Lm1kLmpzIiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb3V0ZXNcXGxpbnV4LnRzeCIsICIuLi9hcHAvY29udGVudC9saW51eC5tZC5qcyIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxibG9nLnRzeCIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxibG9nXFwkc2x1Zy50c3giLCAiLi4vYXBwL3V0aWxzL2dldEJsb2dEYXRhLnRzIiwgIi4uL2FwcC9jb250ZW50L2Jsb2cvaW5kZXguanMiLCAiLi4vYXBwL2NvbnRlbnQvYmxvZy9tZF8yMDIwXzEwXzE1LmpzIiwgIi4uL2FwcC9jb250ZW50L2Jsb2cvbWRfMjAxOF8wN18xNC5qcyIsICIuLi9hcHAvY29udGVudC9ibG9nL21kXzIwMThfMDdfMDIuanMiLCAiLi4vYXBwL2NvbnRlbnQvYmxvZy9tZF8yMDE4XzA2XzIzLmpzIiwgIi4uL2FwcC9jb250ZW50L2Jsb2cvbWRfMjAxOF8wNl8wNi5qcyIsICIuLi9hcHAvY29udGVudC9ibG9nL21kXzIwMThfMDVfMzAuanMiLCAicm91dGU6RDpcXHByb2plY3RzXFx1bmlrZXkub3JnXFxhcHBcXHJvdXRlc1xcYmxvZ1xcaW5kZXgudHN4IiwgInNlcnZlci1hc3NldHMtbWFuaWZlc3Q6QHJlbWl4LXJ1bi9kZXYvYXNzZXRzLW1hbmlmZXN0Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwgIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4yJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCB7IFJlYWN0IH07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICBkZWNvZGVWYWx1ZXM6IHRydWUsXG4gIG1hcDogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IHNldENvb2tpZVZhbHVlLnNwbGl0KFwiO1wiKS5maWx0ZXIoaXNOb25FbXB0eVN0cmluZyk7XG4gIHZhciBuYW1lVmFsdWUgPSBwYXJ0cy5zaGlmdCgpLnNwbGl0KFwiPVwiKTtcbiAgdmFyIG5hbWUgPSBuYW1lVmFsdWUuc2hpZnQoKTtcbiAgdmFyIHZhbHVlID0gbmFtZVZhbHVlLmpvaW4oXCI9XCIpOyAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCA9LCBqb2luZWQgYnkgYSBcIj1cIiBpZiB0aGVyZSB3YXMgbW9yZSB0aGFuIG9uZSBwYXJ0XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIHRyeSB7XG4gICAgdmFsdWUgPSBvcHRpb25zLmRlY29kZVZhbHVlcyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTsgLy8gZGVjb2RlIGNvb2tpZSB2YWx1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgK1xuICAgICAgICB2YWx1ZSArXG4gICAgICAgIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgZVxuICAgICk7XG4gIH1cblxuICB2YXIgY29va2llID0ge1xuICAgIG5hbWU6IG5hbWUsIC8vIGdyYWIgZXZlcnl0aGluZyBiZWZvcmUgdGhlIGZpcnN0ID1cbiAgICB2YWx1ZTogdmFsdWUsXG4gIH07XG5cbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIHZhciBzaWRlcyA9IHBhcnQuc3BsaXQoXCI9XCIpO1xuICAgIHZhciBrZXkgPSBzaWRlcy5zaGlmdCgpLnRyaW1MZWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdmFsdWUgPSBzaWRlcy5qb2luKFwiPVwiKTtcbiAgICBpZiAoa2V5ID09PSBcImV4cGlyZXNcIikge1xuICAgICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwibWF4LWFnZVwiKSB7XG4gICAgICBjb29raWUubWF4QWdlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgY29va2llLnNlY3VyZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaHR0cG9ubHlcIikge1xuICAgICAgY29va2llLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzYW1lc2l0ZVwiKSB7XG4gICAgICBjb29raWUuc2FtZVNpdGUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29va2llW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb29raWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIWlucHV0KSB7XG4gICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgaWYgKGlucHV0LmhlYWRlcnMgJiYgaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl0pIHtcbiAgICAvLyBmYXN0LXBhdGggZm9yIG5vZGUuanMgKHdoaWNoIGF1dG9tYXRpY2FsbHkgbm9ybWFsaXplcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXItY2FzZVxuICAgIGlucHV0ID0gaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl07XG4gIH0gZWxzZSBpZiAoaW5wdXQuaGVhZGVycykge1xuICAgIC8vIHNsb3ctcGF0aCBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gc2VlICMyNVxuICAgIHZhciBzY2ggPVxuICAgICAgaW5wdXQuaGVhZGVyc1tcbiAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQuaGVhZGVycykuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSBcInNldC1jb29raWVcIjtcbiAgICAgICAgfSlcbiAgICAgIF07XG4gICAgLy8gd2FybiBpZiBjYWxsZWQgb24gYSByZXF1ZXN0LWxpa2Ugb2JqZWN0IHdpdGggYSBjb29raWUgaGVhZGVyIHJhdGhlciB0aGFuIGEgc2V0LWNvb2tpZSBoZWFkZXIgLSBzZWUgIzM0LCAzNlxuICAgIGlmICghc2NoICYmIGlucHV0LmhlYWRlcnMuY29va2llICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIldhcm5pbmc6IHNldC1jb29raWUtcGFyc2VyIGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGNhbGxlZCBvbiBhIHJlcXVlc3Qgb2JqZWN0LiBJdCBpcyBkZXNpZ25lZCB0byBwYXJzZSBTZXQtQ29va2llIGhlYWRlcnMgZnJvbSByZXNwb25zZXMsIG5vdCBDb29raWUgaGVhZGVycyBmcm9tIHJlcXVlc3RzLiBTZXQgdGhlIG9wdGlvbiB7c2lsZW50OiB0cnVlfSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlucHV0ID0gc2NoO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IFtpbnB1dF07XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucylcbiAgICA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG5cbiAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb29raWVzID0ge307XG4gICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5yZWR1Y2UoZnVuY3Rpb24gKGNvb2tpZXMsIHN0cikge1xuICAgICAgdmFyIGNvb2tpZSA9IHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICBjb29raWVzW2Nvb2tpZS5uYW1lXSA9IGNvb2tpZTtcbiAgICAgIHJldHVybiBjb29raWVzO1xuICAgIH0sIGNvb2tpZXMpO1xuICB9XG59XG5cbi8qXG4gIFNldC1Db29raWUgaGVhZGVyIGZpZWxkLXZhbHVlcyBhcmUgc29tZXRpbWVzIGNvbW1hIGpvaW5lZCBpbiBvbmUgc3RyaW5nLiBUaGlzIHNwbGl0cyB0aGVtIHdpdGhvdXQgY2hva2luZyBvbiBjb21tYXNcbiAgdGhhdCBhcmUgd2l0aGluIGEgc2luZ2xlIHNldC1jb29raWUgZmllbGQtdmFsdWUsIHN1Y2ggYXMgaW4gdGhlIEV4cGlyZXMgcG9ydGlvbi5cblxuICBUaGlzIGlzIHVuY29tbW9uLCBidXQgZXhwbGljaXRseSBhbGxvd2VkIC0gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tNC4yXG4gIE5vZGUuanMgZG9lcyB0aGlzIGZvciBldmVyeSBoZWFkZXIgKmV4Y2VwdCogc2V0LWNvb2tpZSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9kNWUzNjNiNzdlYmFmMWNhZjY3Y2Q3NTI4MjI0YjY1MWM4NjgxNWMxL2xpYi9faHR0cF9pbmNvbWluZy5qcyNMMTI4XG4gIFJlYWN0IE5hdGl2ZSdzIGZldGNoIGRvZXMgdGhpcyBmb3IgKmV2ZXJ5KiBoZWFkZXIsIGluY2x1ZGluZyBzZXQtY29va2llLlxuXG4gIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2oyb2JqYy9jb21taXQvMTY4MjBmZGJjOGY3NmNhMGMzMzQ3MjgxMGNlMGNiMDNkMjBlZmUyNVxuICBDcmVkaXRzIHRvOiBodHRwczovL2dpdGh1Yi5jb20vdG9tYmFsbCBmb3Igb3JpZ2luYWwgYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJ1c2FydCBmb3IgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuKi9cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvb2tpZXNTdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNvb2tpZXNTdHJpbmc7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb29raWVzU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciBjaDtcbiAgdmFyIGxhc3RDb21tYTtcbiAgdmFyIG5leHRTdGFydDtcbiAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgcG9zICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcblxuICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgfVxuXG4gIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgLy8gJywnIGlzIGEgY29va2llIHNlcGFyYXRvciBpZiB3ZSBoYXZlIGxhdGVyIGZpcnN0ICc9Jywgbm90ICc7JyBvciAnLCdcbiAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICBwb3MgKz0gMTtcblxuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICBuZXh0U3RhcnQgPSBwb3M7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1cnJlbnRseSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAvLyB3ZSBmb3VuZCBjb29raWVzIHNlcGFyYXRvclxuICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgLy8gcG9zIGlzIGluc2lkZSB0aGUgbmV4dCBjb29raWUsIHNvIGJhY2sgdXAgYW5kIHJldHVybiBpdC5cbiAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gcGFyYW0gJywnIG9yIHBhcmFtIHNlcGFyYXRvciAnOycsXG4gICAgICAgICAgLy8gd2UgY29udGludWUgZnJvbSB0aGF0IGNvbW1hXG4gICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBjb29raWVzU3RyaW5nLmxlbmd0aCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMuc3BsaXRDb29raWVzU3RyaW5nID0gc3BsaXRDb29raWVzU3RyaW5nO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb2JqZWN0ID0ge307XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGZvck93biA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG5cdGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuXHRcdFx0Y2FsbGJhY2soa2V5LCBvYmplY3Rba2V5XSk7XG5cdFx0fVxuXHR9XG59O1xuXG5jb25zdCBleHRlbmQgPSAoZGVzdGluYXRpb24sIHNvdXJjZSkgPT4ge1xuXHRpZiAoIXNvdXJjZSkge1xuXHRcdHJldHVybiBkZXN0aW5hdGlvbjtcblx0fVxuXHRmb3JPd24oc291cmNlLCAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdGRlc3RpbmF0aW9uW2tleV0gPSB2YWx1ZTtcblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cbmNvbnN0IGZvckVhY2ggPSAoYXJyYXksIGNhbGxiYWNrKSA9PiB7XG5cdGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0bGV0IGluZGV4ID0gLTE7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y2FsbGJhY2soYXJyYXlbaW5kZXhdKTtcblx0fVxufTtcblxuY29uc3QgZm91ckhleEVzY2FwZSA9IChoZXgpID0+IHtcblx0cmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgaGV4KS5zbGljZSgtNCk7XG59XG5cbmNvbnN0IGhleGFkZWNpbWFsID0gKGNvZGUsIGxvd2VyY2FzZSkgPT4ge1xuXHRsZXQgaGV4YWRlY2ltYWwgPSBjb2RlLnRvU3RyaW5nKDE2KTtcblx0aWYgKGxvd2VyY2FzZSkgcmV0dXJuIGhleGFkZWNpbWFsO1xuXHRyZXR1cm4gaGV4YWRlY2ltYWwudG9VcHBlckNhc2UoKTtcbn07XG5cbmNvbnN0IHRvU3RyaW5nID0gb2JqZWN0LnRvU3RyaW5nO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc0J1ZmZlciA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xufTtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG5cdC8vIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsZSBjaGVjaywgYnV0IGl0XHUyMDE5cyBnb29kIGVub3VnaCBmb3Igd2hhdCB3ZSBuZWVkLlxuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59O1xuY29uc3QgaXNTdHJpbmcgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuXHRcdHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcblx0XHR0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbn07XG5jb25zdCBpc01hcCA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTWFwXSc7XG59O1xuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFNldF0nO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjc2luZ2xlXG5jb25zdCBzaW5nbGVFc2NhcGVzID0ge1xuXHQnXFxcXCc6ICdcXFxcXFxcXCcsXG5cdCdcXGInOiAnXFxcXGInLFxuXHQnXFxmJzogJ1xcXFxmJyxcblx0J1xcbic6ICdcXFxcbicsXG5cdCdcXHInOiAnXFxcXHInLFxuXHQnXFx0JzogJ1xcXFx0J1xuXHQvLyBgXFx2YCBpcyBvbWl0dGVkIGludGVudGlvbmFsbHksIGJlY2F1c2UgaW4gSUUgPCA5LCAnXFx2JyA9PSAndicuXG5cdC8vICdcXHYnOiAnXFxcXHgwQidcbn07XG5jb25zdCByZWdleFNpbmdsZUVzY2FwZSA9IC9bXFxcXFxcYlxcZlxcblxcclxcdF0vO1xuXG5jb25zdCByZWdleERpZ2l0ID0gL1swLTldLztcbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZSA9IC9bXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLztcblxuY29uc3QgZXNjYXBlRXZlcnl0aGluZ1JlZ2V4ID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKXwoW1xcdUQ4MDAtXFx1REZGRl0pfChbJ1wiYF0pfFteXS9nO1xuY29uc3QgZXNjYXBlTm9uQXNjaWlSZWdleCA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSl8KFtcXHVEODAwLVxcdURGRkZdKXwoWydcImBdKXxbXiAhIy0mXFwoLVxcW1xcXS1fYS1+XS9nO1xuXG5jb25zdCBqc2VzYyA9IChhcmd1bWVudCwgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBpbmNyZWFzZUluZGVudGF0aW9uID0gKCkgPT4ge1xuXHRcdG9sZEluZGVudCA9IGluZGVudDtcblx0XHQrK29wdGlvbnMuaW5kZW50TGV2ZWw7XG5cdFx0aW5kZW50ID0gb3B0aW9ucy5pbmRlbnQucmVwZWF0KG9wdGlvbnMuaW5kZW50TGV2ZWwpXG5cdH07XG5cdC8vIEhhbmRsZSBvcHRpb25zXG5cdGNvbnN0IGRlZmF1bHRzID0ge1xuXHRcdCdlc2NhcGVFdmVyeXRoaW5nJzogZmFsc2UsXG5cdFx0J21pbmltYWwnOiBmYWxzZSxcblx0XHQnaXNTY3JpcHRDb250ZXh0JzogZmFsc2UsXG5cdFx0J3F1b3Rlcyc6ICdzaW5nbGUnLFxuXHRcdCd3cmFwJzogZmFsc2UsXG5cdFx0J2VzNic6IGZhbHNlLFxuXHRcdCdqc29uJzogZmFsc2UsXG5cdFx0J2NvbXBhY3QnOiB0cnVlLFxuXHRcdCdsb3dlcmNhc2VIZXgnOiBmYWxzZSxcblx0XHQnbnVtYmVycyc6ICdkZWNpbWFsJyxcblx0XHQnaW5kZW50JzogJ1xcdCcsXG5cdFx0J2luZGVudExldmVsJzogMCxcblx0XHQnX19pbmxpbmUxX18nOiBmYWxzZSxcblx0XHQnX19pbmxpbmUyX18nOiBmYWxzZVxuXHR9O1xuXHRjb25zdCBqc29uID0gb3B0aW9ucyAmJiBvcHRpb25zLmpzb247XG5cdGlmIChqc29uKSB7XG5cdFx0ZGVmYXVsdHMucXVvdGVzID0gJ2RvdWJsZSc7XG5cdFx0ZGVmYXVsdHMud3JhcCA9IHRydWU7XG5cdH1cblx0b3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cdGlmIChcblx0XHRvcHRpb25zLnF1b3RlcyAhPSAnc2luZ2xlJyAmJlxuXHRcdG9wdGlvbnMucXVvdGVzICE9ICdkb3VibGUnICYmXG5cdFx0b3B0aW9ucy5xdW90ZXMgIT0gJ2JhY2t0aWNrJ1xuXHQpIHtcblx0XHRvcHRpb25zLnF1b3RlcyA9ICdzaW5nbGUnO1xuXHR9XG5cdGNvbnN0IHF1b3RlID0gb3B0aW9ucy5xdW90ZXMgPT0gJ2RvdWJsZScgP1xuXHRcdCdcIicgOlxuXHRcdChvcHRpb25zLnF1b3RlcyA9PSAnYmFja3RpY2snID9cblx0XHRcdCdgJyA6XG5cdFx0XHQnXFwnJ1xuXHRcdCk7XG5cdGNvbnN0IGNvbXBhY3QgPSBvcHRpb25zLmNvbXBhY3Q7XG5cdGNvbnN0IGxvd2VyY2FzZUhleCA9IG9wdGlvbnMubG93ZXJjYXNlSGV4O1xuXHRsZXQgaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQucmVwZWF0KG9wdGlvbnMuaW5kZW50TGV2ZWwpO1xuXHRsZXQgb2xkSW5kZW50ID0gJyc7XG5cdGNvbnN0IGlubGluZTEgPSBvcHRpb25zLl9faW5saW5lMV9fO1xuXHRjb25zdCBpbmxpbmUyID0gb3B0aW9ucy5fX2lubGluZTJfXztcblx0Y29uc3QgbmV3TGluZSA9IGNvbXBhY3QgPyAnJyA6ICdcXG4nO1xuXHRsZXQgcmVzdWx0O1xuXHRsZXQgaXNFbXB0eSA9IHRydWU7XG5cdGNvbnN0IHVzZUJpbk51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2JpbmFyeSc7XG5cdGNvbnN0IHVzZU9jdE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ29jdGFsJztcblx0Y29uc3QgdXNlRGVjTnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnZGVjaW1hbCc7XG5cdGNvbnN0IHVzZUhleE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2hleGFkZWNpbWFsJztcblxuXHRpZiAoanNvbiAmJiBhcmd1bWVudCAmJiBpc0Z1bmN0aW9uKGFyZ3VtZW50LnRvSlNPTikpIHtcblx0XHRhcmd1bWVudCA9IGFyZ3VtZW50LnRvSlNPTigpO1xuXHR9XG5cblx0aWYgKCFpc1N0cmluZyhhcmd1bWVudCkpIHtcblx0XHRpZiAoaXNNYXAoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoYXJndW1lbnQuc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnbmV3IE1hcCgpJztcblx0XHRcdH1cblx0XHRcdGlmICghY29tcGFjdCkge1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMV9fID0gdHJ1ZTtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTJfXyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICduZXcgTWFwKCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc1NldChhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5zaXplID09IDApIHtcblx0XHRcdFx0cmV0dXJuICduZXcgU2V0KCknO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICduZXcgU2V0KCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc0J1ZmZlcihhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ0J1ZmZlci5mcm9tKFtdKSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ0J1ZmZlci5mcm9tKCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc0FycmF5KGFyZ3VtZW50KSkge1xuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0aWYgKGlubGluZTEpIHtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTFfXyA9IGZhbHNlO1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICghaW5saW5lMikge1xuXHRcdFx0XHRpbmNyZWFzZUluZGVudGF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRmb3JFYWNoKGFyZ3VtZW50LCAodmFsdWUpID0+IHtcblx0XHRcdFx0aXNFbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoaW5saW5lMikge1xuXHRcdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHQoY29tcGFjdCB8fCBpbmxpbmUyID8gJycgOiBpbmRlbnQpICtcblx0XHRcdFx0XHRqc2VzYyh2YWx1ZSwgb3B0aW9ucylcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzRW1wdHkpIHtcblx0XHRcdFx0cmV0dXJuICdbXSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5saW5lMikge1xuXHRcdFx0XHRyZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ1snICsgbmV3TGluZSArIHJlc3VsdC5qb2luKCcsJyArIG5ld0xpbmUpICsgbmV3TGluZSArXG5cdFx0XHRcdChjb21wYWN0ID8gJycgOiBvbGRJbmRlbnQpICsgJ10nO1xuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoanNvbikge1xuXHRcdFx0XHQvLyBTb21lIG51bWJlciB2YWx1ZXMgKGUuZy4gYEluZmluaXR5YCkgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04uXG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlRGVjTnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VIZXhOdW1iZXJzKSB7XG5cdFx0XHRcdGxldCBoZXhhZGVjaW1hbCA9IGFyZ3VtZW50LnRvU3RyaW5nKDE2KTtcblx0XHRcdFx0aWYgKCFsb3dlcmNhc2VIZXgpIHtcblx0XHRcdFx0XHRoZXhhZGVjaW1hbCA9IGhleGFkZWNpbWFsLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICcweCcgKyBoZXhhZGVjaW1hbDtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VCaW5OdW1iZXJzKSB7XG5cdFx0XHRcdHJldHVybiAnMGInICsgYXJndW1lbnQudG9TdHJpbmcoMik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlT2N0TnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gJzBvJyArIGFyZ3VtZW50LnRvU3RyaW5nKDgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzT2JqZWN0KGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGpzb24pIHtcblx0XHRcdFx0Ly8gRm9yIHNvbWUgdmFsdWVzIChlLmcuIGB1bmRlZmluZWRgLCBgZnVuY3Rpb25gIG9iamVjdHMpLFxuXHRcdFx0XHQvLyBgSlNPTi5zdHJpbmdpZnkodmFsdWUpYCByZXR1cm5zIGB1bmRlZmluZWRgICh3aGljaCBpc25cdTIwMTl0IHZhbGlkXG5cdFx0XHRcdC8vIEpTT04pIGluc3RlYWQgb2YgYCdudWxsJ2AuXG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudCkgfHwgJ251bGwnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdFx0fSBlbHNlIHsgLy8gaXRcdTIwMTlzIGFuIG9iamVjdFxuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0aW5jcmVhc2VJbmRlbnRhdGlvbigpO1xuXHRcdFx0Zm9yT3duKGFyZ3VtZW50LCAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpc0VtcHR5ID0gZmFsc2U7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdChjb21wYWN0ID8gJycgOiBpbmRlbnQpICtcblx0XHRcdFx0XHRqc2VzYyhrZXksIG9wdGlvbnMpICsgJzonICtcblx0XHRcdFx0XHQoY29tcGFjdCA/ICcnIDogJyAnKSArXG5cdFx0XHRcdFx0anNlc2ModmFsdWUsIG9wdGlvbnMpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0VtcHR5KSB7XG5cdFx0XHRcdHJldHVybiAne30nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICd7JyArIG5ld0xpbmUgKyByZXN1bHQuam9pbignLCcgKyBuZXdMaW5lKSArIG5ld0xpbmUgK1xuXHRcdFx0XHQoY29tcGFjdCA/ICcnIDogb2xkSW5kZW50KSArICd9Jztcblx0XHR9XG5cdH1cblxuXHRjb25zdCByZWdleCA9IG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZyA/IGVzY2FwZUV2ZXJ5dGhpbmdSZWdleCA6IGVzY2FwZU5vbkFzY2lpUmVnZXg7XG5cdHJlc3VsdCA9IGFyZ3VtZW50LnJlcGxhY2UocmVnZXgsIChjaGFyLCBwYWlyLCBsb25lLCBxdW90ZUNoYXIsIGluZGV4LCBzdHJpbmcpID0+IHtcblx0XHRpZiAocGFpcikge1xuXHRcdFx0aWYgKG9wdGlvbnMubWluaW1hbCkgcmV0dXJuIHBhaXI7XG5cdFx0XHRjb25zdCBmaXJzdCA9IHBhaXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdGNvbnN0IHNlY29uZCA9IHBhaXIuY2hhckNvZGVBdCgxKTtcblx0XHRcdGlmIChvcHRpb25zLmVzNikge1xuXHRcdFx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0XHRcdFx0Y29uc3QgY29kZVBvaW50ID0gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcblx0XHRcdFx0Y29uc3QgaGV4ID0gaGV4YWRlY2ltYWwoY29kZVBvaW50LCBsb3dlcmNhc2VIZXgpO1xuXHRcdFx0XHRyZXR1cm4gJ1xcXFx1eycgKyBoZXggKyAnfSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXhhZGVjaW1hbChmaXJzdCwgbG93ZXJjYXNlSGV4KSkgKyBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKHNlY29uZCwgbG93ZXJjYXNlSGV4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxvbmUpIHtcblx0XHRcdHJldHVybiBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKGxvbmUuY2hhckNvZGVBdCgwKSwgbG93ZXJjYXNlSGV4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0Y2hhciA9PSAnXFwwJyAmJlxuXHRcdFx0IWpzb24gJiZcblx0XHRcdCFyZWdleERpZ2l0LnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCArIDEpKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuICdcXFxcMCc7XG5cdFx0fVxuXG5cdFx0aWYgKHF1b3RlQ2hhcikge1xuXHRcdFx0aWYgKHF1b3RlQ2hhciA9PSBxdW90ZSB8fCBvcHRpb25zLmVzY2FwZUV2ZXJ5dGhpbmcpIHtcblx0XHRcdFx0cmV0dXJuICdcXFxcJyArIHF1b3RlQ2hhcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBxdW90ZUNoYXI7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ2V4U2luZ2xlRXNjYXBlLnRlc3QoY2hhcikpIHtcblx0XHRcdC8vIG5vIG5lZWQgZm9yIGEgYGhhc093blByb3BlcnR5YCBjaGVjayBoZXJlXG5cdFx0XHRyZXR1cm4gc2luZ2xlRXNjYXBlc1tjaGFyXTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5taW5pbWFsICYmICFyZWdleFdoaXRlc3BhY2UudGVzdChjaGFyKSkge1xuXHRcdFx0cmV0dXJuIGNoYXI7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGV4ID0gaGV4YWRlY2ltYWwoY2hhci5jaGFyQ29kZUF0KDApLCBsb3dlcmNhc2VIZXgpO1xuXHRcdGlmIChqc29uIHx8IGhleC5sZW5ndGggPiAyKSB7XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBoZXgpLnNsaWNlKC0yKTtcblx0fSk7XG5cblx0aWYgKHF1b3RlID09ICdgJykge1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXCRcXHsvZywgJ1xcXFwkeycpO1xuXHR9XG5cdGlmIChvcHRpb25zLmlzU2NyaXB0Q29udGV4dCkge1xuXHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9ldGFnb1xuXHRcdHJlc3VsdCA9IHJlc3VsdFxuXHRcdFx0LnJlcGxhY2UoLzxcXC8oc2NyaXB0fHN0eWxlKS9naSwgJzxcXFxcLyQxJylcblx0XHRcdC5yZXBsYWNlKC88IS0tL2csIGpzb24gPyAnXFxcXHUwMDNDIS0tJyA6ICdcXFxceDNDIS0tJyk7XG5cdH1cblx0aWYgKG9wdGlvbnMud3JhcCkge1xuXHRcdHJlc3VsdCA9IHF1b3RlICsgcmVzdWx0ICsgcXVvdGU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmpzZXNjLnZlcnNpb24gPSAnMy4wLjInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzZXNjO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGRvbWFpbjtcblxuLy8gVGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHRvIHN0b3JlIGV2ZW50IGhhbmRsZXJzLiBJbnN0YW50aWF0aW5nIHRoaXMgaXNcbi8vIGZhc3RlciB0aGFuIGV4cGxpY2l0bHkgY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgdG8gZ2V0IGEgXCJjbGVhblwiIGVtcHR5XG4vLyBvYmplY3QgKHRlc3RlZCB3aXRoIHY4IHY0LjkpLlxuZnVuY3Rpb24gRXZlbnRIYW5kbGVycygpIHt9XG5FdmVudEhhbmRsZXJzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlcjtcbmV4cG9ydCB7RXZlbnRFbWl0dGVyfTtcblxuLy8gbm9kZWpzIG9kZGl0eVxuLy8gcmVxdWlyZSgnZXZlbnRzJykgPT09IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlclxuXG5FdmVudEVtaXR0ZXIudXNpbmdEb21haW5zID0gZmFsc2U7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZG9tYWluID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRvbWFpbiA9IG51bGw7XG4gIGlmIChFdmVudEVtaXR0ZXIudXNpbmdEb21haW5zKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIGRvbWFpbiwgdGhlbiBhdHRhY2ggdG8gaXQuXG4gICAgaWYgKGRvbWFpbi5hY3RpdmUgJiYgISh0aGlzIGluc3RhbmNlb2YgZG9tYWluLkRvbWFpbikpIHtcbiAgICAgIHRoaXMuZG9tYWluID0gZG9tYWluLmFjdGl2ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzLCBkb21haW47XG4gIHZhciBuZWVkRG9tYWluRXhpdCA9IGZhbHNlO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGRvbWFpbiA9IHRoaXMuZG9tYWluO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZG9tYWluKSB7XG4gICAgICBpZiAoIWVyKVxuICAgICAgICBlciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudCcpO1xuICAgICAgZXIuZG9tYWluRW1pdHRlciA9IHRoaXM7XG4gICAgICBlci5kb21haW4gPSBkb21haW47XG4gICAgICBlci5kb21haW5UaHJvd24gPSBmYWxzZTtcbiAgICAgIGRvbWFpbi5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICBpZiAobmVlZERvbWFpbkV4aXQpXG4gICAgZG9tYWluLmV4aXQoKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyB0eXBlICsgJyBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBlbWl0V2FybmluZyh3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZW1pdFdhcm5pbmcoZSkge1xuICB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nID8gY29uc29sZS53YXJuKGUpIDogY29uc29sZS5sb2coZSk7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBnKCkge1xuICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgcmV0dXJuIGc7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IChsaXN0Lmxpc3RlbmVyICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbGlzdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5OyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9IHdoaWxlIChsaXN0ZW5lcnNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHZhciBldmxpc3RlbmVyO1xuICB2YXIgcmV0O1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIHtcbiAgICBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICghZXZsaXN0ZW5lcilcbiAgICAgIHJldCA9IFtdO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0ID0gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl07XG4gICAgZWxzZVxuICAgICAgcmV0ID0gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIGkpIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCAiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG4vLyBiYXNlZCBvZmYgaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS1wcm9jZXNzL2Jsb2IvbWFzdGVyL2Jyb3dzZXIuanNcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG52YXIgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbmlmICh0eXBlb2YgZ2xvYmFsLnNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbn1cbmlmICh0eXBlb2YgZ2xvYmFsLmNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbn1cblxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuZnVuY3Rpb24gbmV4dFRpY2soZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn1cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG52YXIgdGl0bGUgPSAnYnJvd3Nlcic7XG52YXIgcGxhdGZvcm0gPSAnYnJvd3Nlcic7XG52YXIgYnJvd3NlciA9IHRydWU7XG52YXIgZW52ID0ge307XG52YXIgYXJndiA9IFtdO1xudmFyIHZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnZhciB2ZXJzaW9ucyA9IHt9O1xudmFyIHJlbGVhc2UgPSB7fTtcbnZhciBjb25maWcgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBvbiA9IG5vb3A7XG52YXIgYWRkTGlzdGVuZXIgPSBub29wO1xudmFyIG9uY2UgPSBub29wO1xudmFyIG9mZiA9IG5vb3A7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBub29wO1xudmFyIHJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG52YXIgZW1pdCA9IG5vb3A7XG5cbmZ1bmN0aW9uIGJpbmRpbmcobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuZnVuY3Rpb24gY3dkICgpIHsgcmV0dXJuICcvJyB9XG5mdW5jdGlvbiBjaGRpciAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1mdW5jdGlvbiB1bWFzaygpIHsgcmV0dXJuIDA7IH1cblxuLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3VtYXZpcy9icm93c2VyLXByb2Nlc3MtaHJ0aW1lL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG52YXIgcGVyZm9ybWFuY2UgPSBnbG9iYWwucGVyZm9ybWFuY2UgfHwge307XG52YXIgcGVyZm9ybWFuY2VOb3cgPVxuICBwZXJmb3JtYW5jZS5ub3cgICAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1vek5vdyAgICAgfHxcbiAgcGVyZm9ybWFuY2UubXNOb3cgICAgICB8fFxuICBwZXJmb3JtYW5jZS5vTm93ICAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLndlYmtpdE5vdyAgfHxcbiAgZnVuY3Rpb24oKXsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgfTtcblxuLy8gZ2VuZXJhdGUgdGltZXN0YW1wIG9yIGRlbHRhXG4vLyBzZWUgaHR0cDovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfaHJ0aW1lXG5mdW5jdGlvbiBocnRpbWUocHJldmlvdXNUaW1lc3RhbXApe1xuICB2YXIgY2xvY2t0aW1lID0gcGVyZm9ybWFuY2VOb3cuY2FsbChwZXJmb3JtYW5jZSkqMWUtMztcbiAgdmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKGNsb2NrdGltZSk7XG4gIHZhciBuYW5vc2Vjb25kcyA9IE1hdGguZmxvb3IoKGNsb2NrdGltZSUxKSoxZTkpO1xuICBpZiAocHJldmlvdXNUaW1lc3RhbXApIHtcbiAgICBzZWNvbmRzID0gc2Vjb25kcyAtIHByZXZpb3VzVGltZXN0YW1wWzBdO1xuICAgIG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFsxXTtcbiAgICBpZiAobmFub3NlY29uZHM8MCkge1xuICAgICAgc2Vjb25kcy0tO1xuICAgICAgbmFub3NlY29uZHMgKz0gMWU5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3NlY29uZHMsbmFub3NlY29uZHNdXG59XG5cbnZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuZnVuY3Rpb24gdXB0aW1lKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICB2YXIgZGlmID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gIHJldHVybiBkaWYgLyAxMDAwO1xufVxuXG52YXIgYnJvd3NlciQxID0ge1xuICBuZXh0VGljazogbmV4dFRpY2ssXG4gIHRpdGxlOiB0aXRsZSxcbiAgYnJvd3NlcjogYnJvd3NlcixcbiAgZW52OiBlbnYsXG4gIGFyZ3Y6IGFyZ3YsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIHZlcnNpb25zOiB2ZXJzaW9ucyxcbiAgb246IG9uLFxuICBhZGRMaXN0ZW5lcjogYWRkTGlzdGVuZXIsXG4gIG9uY2U6IG9uY2UsXG4gIG9mZjogb2ZmLFxuICByZW1vdmVMaXN0ZW5lcjogcmVtb3ZlTGlzdGVuZXIsXG4gIHJlbW92ZUFsbExpc3RlbmVyczogcmVtb3ZlQWxsTGlzdGVuZXJzLFxuICBlbWl0OiBlbWl0LFxuICBiaW5kaW5nOiBiaW5kaW5nLFxuICBjd2Q6IGN3ZCxcbiAgY2hkaXI6IGNoZGlyLFxuICB1bWFzazogdW1hc2ssXG4gIGhydGltZTogaHJ0aW1lLFxuICBwbGF0Zm9ybTogcGxhdGZvcm0sXG4gIHJlbGVhc2U6IHJlbGVhc2UsXG4gIGNvbmZpZzogY29uZmlnLFxuICB1cHRpbWU6IHVwdGltZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYnJvd3NlciQxO1xuZXhwb3J0IHsgYWRkTGlzdGVuZXIsIGFyZ3YsIGJpbmRpbmcsIGJyb3dzZXIsIGNoZGlyLCBjb25maWcsIGN3ZCwgZW1pdCwgZW52LCBocnRpbWUsIG5leHRUaWNrLCBvZmYsIG9uLCBvbmNlLCBwbGF0Zm9ybSwgcmVsZWFzZSwgcmVtb3ZlQWxsTGlzdGVuZXJzLCByZW1vdmVMaXN0ZW5lciwgdGl0bGUsIHVtYXNrLCB1cHRpbWUsIHZlcnNpb24sIHZlcnNpb25zIH07XG4iLCAiXG52YXIgaW5oZXJpdHM7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpe1xuICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBpbmhlcml0cztcbiIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCBwcm9jZXNzIGZyb20gJ3Byb2Nlc3MnO1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnbG9nKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IDA7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBpbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlcihtYXliZUJ1Zikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG1heWJlQnVmKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0IGZ1bmN0aW9uIGxvZygpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xufVxuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnLi9pbmhlcml0cyc7XG5leHBvcnQge2luaGVyaXRzfVxuXG5leHBvcnQgZnVuY3Rpb24gX2V4dGVuZChvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbmhlcml0czogaW5oZXJpdHMsXG4gIF9leHRlbmQ6IF9leHRlbmQsXG4gIGxvZzogbG9nLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNFcnJvcjogaXNFcnJvcixcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNSZWdFeHA6IGlzUmVnRXhwLFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzU3ltYm9sOiBpc1N5bWJvbCxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBpc051bGxPclVuZGVmaW5lZCxcbiAgaXNOdWxsOiBpc051bGwsXG4gIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICBpc0FycmF5OiBpc0FycmF5LFxuICBpbnNwZWN0OiBpbnNwZWN0LFxuICBkZXByZWNhdGU6IGRlcHJlY2F0ZSxcbiAgZm9ybWF0OiBmb3JtYXQsXG4gIGRlYnVnbG9nOiBkZWJ1Z2xvZ1xufVxuIiwgInZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2Mztcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuO1xuXG4gIHZhciBMID0gMDtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMik7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9PSc7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSk7XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPSc7XG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dCk7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIHJlYWQgKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG07XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSAtNztcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn1cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHJ1ZTtcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xudmFyIF9rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpO1xuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyOyAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgcmV0dXJuIGFyclxufTtcblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59O1xuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZTtcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufTtcblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKTtcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbCk7XG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTU7XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGg7IC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5O1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKTtcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pO1xuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwO1xuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cbkJ1ZmZlci5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuZnVuY3Rpb24gaW50ZXJuYWxJc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpO1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXJcbn07XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDA7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dO1xuICBiW25dID0gYlttXTtcbiAgYlttXSA9IGk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMik7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7XG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICc7XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDtcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwO1xuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwO1xuICBlbmQgPj4+PSAwO1xuICB0aGlzU3RhcnQgPj4+PSAwO1xuICB0aGlzRW5kID4+Pj0gMDtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcbiAgdmFyIHkgPSBlbmQgLSBzdGFydDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpO1xuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTtcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldO1xuICAgICAgeSA9IHRhcmdldENvcHlbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMDtcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDtcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7XG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkY7IC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDE7XG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDI7XG4gICAgICBhcnJMZW5ndGggLz0gMjtcbiAgICAgIHZhbExlbmd0aCAvPSAyO1xuICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufTtcblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDA7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufTtcblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICB2YXIgcmVzID0gW107XG5cbiAgdmFyIGkgPSBzdGFydDtcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldO1xuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsO1xuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMTtcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJyc7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgc3RhcnQgPSB+fnN0YXJ0O1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW47XG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICB2YXIgbmV3QnVmO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufTtcblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF07XG4gIHZhciBtdWwgPSAxO1xuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGg7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldO1xuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAxXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4O1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgc3ViID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgc3ViID0gMDtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAxXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCk7XG4gIH1cbiAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDA7XG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgaTtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGxlblxufTtcblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NTtcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDtcblxuICBpZiAoIXZhbCkgdmFsID0gMDtcblxuICB2YXIgaTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gaW50ZXJuYWxJc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpO1xuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59O1xuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZztcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTtcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5O1xuICB2YXIgY29kZVBvaW50O1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsbztcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhpID0gYyA+PiA4O1xuICAgIGxvID0gYyAlIDI1NjtcbiAgICBieXRlQXJyYXkucHVzaChsbyk7XG4gICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gdG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuLy8gdGhlIGZvbGxvd2luZyBpcyBmcm9tIGlzLWJ1ZmZlciwgYWxzbyBieSBGZXJvc3MgQWJvdWtoYWRpamVoIGFuZCB3aXRoIHNhbWUgbGlzZW5jZVxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoISFvYmouX2lzQnVmZmVyIHx8IGlzRmFzdEJ1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopKVxufVxuXG5mdW5jdGlvbiBpc0Zhc3RCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Zhc3RCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5leHBvcnQgeyBCdWZmZXIsIElOU1BFQ1RfTUFYX0JZVEVTLCBTbG93QnVmZmVyLCBpc0J1ZmZlciwgX2tNYXhMZW5ndGggYXMga01heExlbmd0aCB9O1xuIiwgImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJMaXN0O1xuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgLS10aGlzLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gIH1yZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKHApIHtcbiAgICBwLmRhdGEuY29weShyZXQsIGkpO1xuICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuIiwgIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG5leHBvcnQgZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7aW5oZXJpdHMsIGRlYnVnbG9nfSBmcm9tICd1dGlsJztcbmltcG9ydCBCdWZmZXJMaXN0IGZyb20gJy4vYnVmZmVyLWxpc3QnO1xuaW1wb3J0IHtTdHJpbmdEZWNvZGVyfSBmcm9tICdzdHJpbmdfZGVjb2Rlcic7XG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5cbnZhciBkZWJ1ZyA9IGRlYnVnbG9nKCdzdHJlYW0nKTtcbmluaGVyaXRzKFJlYWRhYmxlLCBFdmVudEVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pXG4gICAgICBlbWl0dGVyLm9uKGV2ZW50LCBmbik7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSlcbiAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7XG4gICAgZWxzZVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQgKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgUmVhZGFibGU7XG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIG5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBuZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgbmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKGxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgc3JjLmxpc3RlbmVycygnZGF0YScpLmxlbmd0aCkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBuZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgbmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwgIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuXG5pbXBvcnQge2luaGVyaXRzLCBkZXByZWNhdGV9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbmltcG9ydCB7RXZlbnRFbWl0dGVyfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vZHVwbGV4JztcbmltcG9ydCB7bmV4dFRpY2t9IGZyb20gJ3Byb2Nlc3MnO1xuaW5oZXJpdHMoV3JpdGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7XG4gICAgZ2V0OiBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICB9KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgV3JpdGFibGU7XG5leHBvcnQgZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIG5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG4gIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxuICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3dcbiAgLy8gaWYgaXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBuZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIG5leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgICAgbmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBuZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn1cbiIsICJcbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5pbXBvcnQge1JlYWRhYmxlfSBmcm9tICcuL3JlYWRhYmxlJztcbmltcG9ydCB7V3JpdGFibGV9IGZyb20gJy4vd3JpdGFibGUnO1xuXG5cbmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cbmV4cG9ydCBkZWZhdWx0IER1cGxleDtcbmV4cG9ydCBmdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBuZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG4iLCAiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5cbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL2R1cGxleCc7XG5cblxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybTtcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsICJcbmltcG9ydCB7VHJhbnNmb3JtfSBmcm9tICcuL3RyYW5zZm9ybSc7XG5cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5leHBvcnQgZGVmYXVsdCBQYXNzVGhyb3VnaDtcbmV4cG9ydCBmdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsICJpbXBvcnQgRUUgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJztcbmltcG9ydCB7UmVhZGFibGV9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJztcbmltcG9ydCB7V3JpdGFibGV9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJztcbmltcG9ydCB7VHJhbnNmb3JtfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtQYXNzVGhyb3VnaH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnO1xuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSBSZWFkYWJsZTtcblN0cmVhbS5Xcml0YWJsZSA9IFdyaXRhYmxlO1xuU3RyZWFtLkR1cGxleCA9IER1cGxleDtcblN0cmVhbS5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSBQYXNzVGhyb3VnaDtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmVhbTtcbmV4cG9ydCB7UmVhZGFibGUsV3JpdGFibGUsRHVwbGV4LFRyYW5zZm9ybSxQYXNzVGhyb3VnaCxTdHJlYW19XG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCAiXG5jb25zdCBwb2x5ZmlsbCA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbmlmIChwb2x5ZmlsbCAmJiBwb2x5ZmlsbC5kZWZhdWx0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbC5kZWZhdWx0XG4gICAgZm9yIChsZXQgayBpbiBwb2x5ZmlsbCkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0c1trXSA9IHBvbHlmaWxsW2tdXG4gICAgfVxufSBlbHNlIGlmIChwb2x5ZmlsbCkgIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsXG59XG5cblxuIiwgIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjInO1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscyB3aXRoXG4vLyB0ZW1wbGF0ZSBsaXRlcmFsIHN0cmluZ3MuIFRoZSBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgY29kZXNcbi8vIGR1cmluZyBidWlsZC5cbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICB2YXIgdXJsID0gJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdXJsICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBcIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIiArIGNvZGUgKyBcIjsgdmlzaXQgXCIgKyB1cmwgKyBcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciBcIiArICd1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsICcgKyAnaGVscGZ1bCB3YXJuaW5ncy4nO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlciA9IGZhbHNlO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG5cbntcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xufVxuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCkge1xuICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xuXG4gIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gIH1cblxuICByZXR1cm4gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XG4gIHtcbiAgICBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sICdDb21wb25lbnQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpIHtcbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc2xvdHMgaW4gdGhpcyBjb250ZXh0IHRvIHN0b3JlIHRoaXMgdGhyZWFkSUQsXG4gIC8vIGZpbGwgaXQgaW4gd2l0aG91dCBsZWF2aW5nIGFueSBob2xlcyB0byBlbnN1cmUgdGhhdCB0aGUgVk0gb3B0aW1pemVzXG4gIC8vIHRoaXMgYXMgbm9uLWhvbGV5IGluZGV4IHByb3BlcnRpZXMuXG4gIC8vIChOb3RlOiBJZiBgcmVhY3RgIHBhY2thZ2UgaXMgPCAxNi42LCBfdGhyZWFkQ291bnQgaXMgdW5kZWZpbmVkLilcbiAgZm9yICh2YXIgaSA9IGNvbnRleHQuX3RocmVhZENvdW50IHwgMDsgaSA8PSB0aHJlYWRJRDsgaSsrKSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgZGVmYXVsdFZhbHVlIHdoaWNoIG1pZ2h0IG5vdCBiZVxuICAgIC8vIHRydWUgaWYgd2UncmUgcmVuZGVyaW5nIGluc2lkZSBhIHNlY29uZGFyeSByZW5kZXJlciBidXQgdGhleSBhcmVcbiAgICAvLyBzZWNvbmRhcnkgYmVjYXVzZSB0aGVzZSB1c2UgY2FzZXMgYXJlIHZlcnkgcmFyZS5cbiAgICBjb250ZXh0W2ldID0gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IGkgKyAxO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29udGV4dCh0eXBlLCBjb250ZXh0LCB0aHJlYWRJRCwgaXNDbGFzcykge1xuICBpZiAoaXNDbGFzcykge1xuICAgIHZhciBjb250ZXh0VHlwZSA9IHR5cGUuY29udGV4dFR5cGU7XG5cbiAgICB7XG4gICAgICBpZiAoJ2NvbnRleHRUeXBlJyBpbiB0eXBlKSB7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gLy8gQWxsb3cgbnVsbCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25cbiAgICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyh0eXBlKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQodHlwZSk7XG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcgKyAnVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gJyArICdUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnICsgJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gPENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0VHlwZSwgdGhyZWFkSUQpO1xuICAgICAgcmV0dXJuIGNvbnRleHRUeXBlW3RocmVhZElEXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbWFza2VkQ29udGV4dCA9IG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIGNoZWNrQ29udGV4dFR5cGVzKHR5cGUuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB2YXIgX21hc2tlZENvbnRleHQgPSBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICBjaGVja0NvbnRleHRUeXBlcyh0eXBlLmNvbnRleHRUeXBlcywgX21hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9tYXNrZWRDb250ZXh0O1xuICAgIH1cbiAgfVxufVxuXG52YXIgbmV4dEF2YWlsYWJsZVRocmVhZElEcyA9IG5ldyBVaW50MTZBcnJheSgxNik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW2ldID0gaSArIDE7XG59XG5cbm5leHRBdmFpbGFibGVUaHJlYWRJRHNbMTVdID0gMDtcblxuZnVuY3Rpb24gZ3Jvd1RocmVhZENvdW50QW5kUmV0dXJuTmV4dEF2YWlsYWJsZSgpIHtcbiAgdmFyIG9sZEFycmF5ID0gbmV4dEF2YWlsYWJsZVRocmVhZElEcztcbiAgdmFyIG9sZFNpemUgPSBvbGRBcnJheS5sZW5ndGg7XG4gIHZhciBuZXdTaXplID0gb2xkU2l6ZSAqIDI7XG5cbiAgaWYgKCEobmV3U2l6ZSA8PSAweDEwMDAwKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIk1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgUmVhY3QgcmVuZGVyZXJzIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBub3QgcHJvcGVybHkgZGVzdHJveWluZyB0aGUgUmVhZGFibGUgcHJvdmlkZWQgYnkgUmVhY3QuIEVuc3VyZSB0aGF0IHlvdSBjYWxsIC5kZXN0cm95KCkgb24gaXQgaWYgeW91IG5vIGxvbmdlciB3YW50IHRvIHJlYWQgZnJvbSBpdCwgYW5kIGRpZCBub3QgcmVhZCB0byB0aGUgZW5kLiBJZiB5b3UgdXNlIC5waXBlKCkgdGhpcyBzaG91bGQgYmUgYXV0b21hdGljLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQxNkFycmF5KG5ld1NpemUpO1xuICBuZXdBcnJheS5zZXQob2xkQXJyYXkpO1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzID0gbmV3QXJyYXk7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBvbGRTaXplICsgMTtcblxuICBmb3IgKHZhciBfaSA9IG9sZFNpemU7IF9pIDwgbmV3U2l6ZSAtIDE7IF9pKyspIHtcbiAgICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW19pXSA9IF9pICsgMTtcbiAgfVxuXG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbbmV3U2l6ZSAtIDFdID0gMDtcbiAgcmV0dXJuIG9sZFNpemU7XG59XG5cbmZ1bmN0aW9uIGFsbG9jVGhyZWFkSUQoKSB7XG4gIHZhciBuZXh0SUQgPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdO1xuXG4gIGlmIChuZXh0SUQgPT09IDApIHtcbiAgICByZXR1cm4gZ3Jvd1RocmVhZENvdW50QW5kUmV0dXJuTmV4dEF2YWlsYWJsZSgpO1xuICB9XG5cbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbbmV4dElEXTtcbiAgcmV0dXJuIG5leHRJRDtcbn1cbmZ1bmN0aW9uIGZyZWVUaHJlYWRJRChpZCkge1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW2lkXSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF07XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBpZDtcbn1cblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwOyAvLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgZmlsdGVyIGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cblxudmFyIFNUUklORyA9IDE7IC8vIEEgc3RyaW5nIGF0dHJpYnV0ZSB0aGF0IGFjY2VwdHMgYm9vbGVhbnMgaW4gUmVhY3QuIEluIEhUTUwsIHRoZXNlIGFyZSBjYWxsZWRcbi8vIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgd2l0aCBcInRydWVcIiBhbmQgXCJmYWxzZVwiIGFzIHBvc3NpYmxlIHZhbHVlcy5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwidHJ1ZVwiIHN0cmluZy5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcImZhbHNlXCIgc3RyaW5nLlxuXG52YXIgQk9PTEVBTklTSF9TVFJJTkcgPSAyOyAvLyBBIHJlYWwgYm9vbGVhbiBhdHRyaWJ1dGUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cblxudmFyIEJPT0xFQU4gPSAzOyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cblxudmFyIE9WRVJMT0FERURfQk9PTEVBTiA9IDQ7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIE5VTUVSSUMgPSA1OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG52YXIgUk9PVF9BVFRSSUJVVEVfTkFNRSA9ICdkYXRhLXJlYWN0cm9vdCc7XG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuXG4gIHtcbiAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQ7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6IC8vICRGbG93SXNzdWUgc3ltYm9sIGlzIHBlcmZlY3RseSB2YWxpZCBoZXJlXG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAhcHJvcGVydHlJbmZvLmFjY2VwdHNCb29sZWFucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgIHJldHVybiBwcmVmaXggIT09ICdkYXRhLScgJiYgcHJlZml4ICE9PSAnYXJpYS0nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcblxuICAgIHN3aXRjaCAocHJvcGVydHlJbmZvLnR5cGUpIHtcbiAgICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcblxuICAgICAgY2FzZSBPVkVSTE9BREVEX0JPT0xFQU46XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG5cbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKTtcblxuICAgICAgY2FzZSBQT1NJVElWRV9OVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSkge1xuICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgdHlwZSwgbXVzdFVzZVByb3BlcnR5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVOYW1lc3BhY2UsIHNhbml0aXplVVJMLCByZW1vdmVFbXB0eVN0cmluZykge1xuICB0aGlzLmFjY2VwdHNCb29sZWFucyA9IHR5cGUgPT09IEJPT0xFQU5JU0hfU1RSSU5HIHx8IHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgdGhpcy5tdXN0VXNlUHJvcGVydHkgPSBtdXN0VXNlUHJvcGVydHk7XG4gIHRoaXMucHJvcGVydHlOYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zYW5pdGl6ZVVSTCA9IHNhbml0aXplVVJMO1xuICB0aGlzLnJlbW92ZUVtcHR5U3RyaW5nID0gcmVtb3ZlRW1wdHlTdHJpbmc7XG59IC8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbi8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4vLyBuYW1lIHdhcm5pbmdzLlxuXG5cbnZhciBwcm9wZXJ0aWVzID0ge307IC8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuXG52YXIgcmVzZXJ2ZWRQcm9wcyA9IFsnY2hpbGRyZW4nLCAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLCAvLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnLCAnaW5uZXJIVE1MJywgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLCAnc3R5bGUnXTtcbnJlc2VydmVkUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuXG5bWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnY2xhc3NOYW1lJywgJ2NsYXNzJ10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmWzFdO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblxuWydhdXRvUmV2ZXJzZScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZvY3VzYWJsZScsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcy5cblxuWydhbGxvd0Z1bGxTY3JlZW4nLCAnYXN5bmMnLCAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywgJ2F1dG9QbGF5JywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLCAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJywgJ2Zvcm1Ob1ZhbGlkYXRlJywgJ2hpZGRlbicsICdsb29wJywgJ25vTW9kdWxlJywgJ25vVmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c0lubGluZScsICdyZWFkT25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzY29wZWQnLCAnc2VhbWxlc3MnLCAvLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuXG5bJ2NoZWNrZWQnLCAvLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywgJ211dGVkJywgJ3NlbGVjdGVkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCB0cnVlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblxuWydjYXB0dXJlJywgJ2Rvd25sb2FkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBPVkVSTE9BREVEX0JPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuXG5bJ2NvbHMnLCAncm93cycsICdzaXplJywgJ3NwYW4nIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFBPU0lUSVZFX05VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuXG5bJ3Jvd1NwYW4nLCAnc3RhcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE5VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7XG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG5cbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xufTsgLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZywgbmFtZXNwYWNpbmcsXG4vLyBvciBib29sZWFuIHZhbHVlIGFzc2lnbm1lbnQuIFJlZ3VsYXIgYXR0cmlidXRlcyB0aGF0IGp1c3QgYWNjZXB0IHN0cmluZ3Ncbi8vIGFuZCBoYXZlIHRoZSBzYW1lIG5hbWVzIGFyZSBvbWl0dGVkLCBqdXN0IGxpa2UgaW4gdGhlIEhUTUwgYXR0cmlidXRlIGZpbHRlci5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwaW5nIHRoZSBNRE4gZG9jdW1lbnRhdGlvbi5cblxuXG5bJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3htbG5zOnhsaW5rJywgJ3gtaGVpZ2h0JyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuXG5bJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXR0cmlidXRlIGV4aXN0cyBib3RoIGluIEhUTUwgYW5kIFNWRy5cbi8vIFRoZSBhdHRyaWJ1dGUgbmFtZSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBTVkcgc28gd2UgY2FuJ3QganVzdCB1c2Vcbi8vIHRoZSBSZWFjdCBuYW1lIGxpa2Ugd2UgZG8gZm9yIGF0dHJpYnV0ZXMgdGhhdCBleGlzdCBvbmx5IGluIEhUTUwuXG5cblsndGFiSW5kZXgnLCAnY3Jvc3NPcmlnaW4nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXR0cmlidXRlcyBhY2NlcHQgVVJMcy4gVGhlc2UgbXVzdCBub3QgYWxsb3cgamF2YXNjcmlwdDogVVJMUy5cbi8vIFRoZXNlIHdpbGwgYWxzbyBuZWVkIHRvIGFjY2VwdCBUcnVzdGVkIFR5cGVzIG9iamVjdCBpbiB0aGUgZnV0dXJlLlxuXG52YXIgeGxpbmtIcmVmID0gJ3hsaW5rSHJlZic7XG5wcm9wZXJ0aWVzW3hsaW5rSHJlZl0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd4bGlua0hyZWYnLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbid4bGluazpocmVmJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO1xuWydzcmMnLCAnaHJlZicsICdhY3Rpb24nLCAnZm9ybUFjdGlvbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbiAgdHJ1ZSk7XG59KTtcblxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm4gJiYgaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdCh1cmwpKSB7XG4gICAgICBkaWRXYXJuID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHVybCkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcbi8qKlxuICogRXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIEhUTUwgZW50aXRpZXMgaW4gYSBnaXZlbiBodG1sIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBIVE1MIHN0cmluZyB0byBlc2NhcGUgZm9yIGxhdGVyIGluc2VydGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM5OlxuICAgICAgICAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yUm9vdCgpIHtcbiAgcmV0dXJuIFJPT1RfQVRUUklCVVRFX05BTUUgKyAnPVwiXCInO1xufVxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5zYW5pdGl6ZVVSTCkge1xuICAgICAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIHNhbml0aXplVVJMKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xudmFyIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2sgaXMgYSByZS1yZW5kZXJlZCBob29rXG5cbnZhciBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgZHVyaW5nIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHJlbmRlciBwYXNzLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBMYXppbHkgY3JlYXRlZCBtYXAgb2YgcmVuZGVyLXBoYXNlIHVwZGF0ZXNcblxudmFyIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7IC8vIENvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cblxudmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTtcbnZhciBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldjtcblxuZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpIHtcbiAgaWYgKCEoY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPiAwKSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXJcIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBpZiAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IGNvbXBvbmVudElkZW50aXR5O1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG59XG5mdW5jdGlvbiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgcmVmT3JDb250ZXh0KSB7XG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgZnVuY3Rpb24gY29tcG9uZW50IHRvIHByZXZlbnQgaG9va3MgZnJvbVxuICAvLyBiZWluZyB1c2VkIGluIGNsYXNzZXMuXG4gIHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVXBkYXRlcyB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhleSBhcmUgc3RvcmVkIGluXG4gICAgLy8gdGhlIGByZW5kZXJQaGFzZVVwZGF0ZXNgIG1hcC4gQ2FsbCB0aGUgY29tcG9uZW50IGFnYWluLCByZXVzaW5nIHRoZVxuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9va3MgYW5kIGFwcGx5aW5nIHRoZSBhZGRpdGlvbmFsIHVwZGF0ZXMgb24gdG9wLiBLZWVwXG4gICAgLy8gcmVzdGFydGluZyB1bnRpbCBubyBtb3JlIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZC5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTsgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIH1cblxuICByZXNldEhvb2tzU3RhdGUoKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufSAvLyBSZXNldCB0aGUgaW50ZXJuYWwgaG9va3Mgc3RhdGUgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHJlbmRlcmluZyBhIGNvbXBvbmVudFxuXG5mdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB2YXIgdGhyZWFkSUQgPSBjdXJyZW50UGFydGlhbFJlbmRlcmVyLnRocmVhZElEO1xuICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuXG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbnRleHRbdGhyZWFkSURdO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gIH1cblxuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHZhciB0aHJlYWRJRCA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIudGhyZWFkSUQ7XG4gIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG4gIHJldHVybiBjb250ZXh0W3RocmVhZElEXTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIsIC8vIHVzZVJlZHVjZXIgaGFzIGEgc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgbGF6eSB1c2VTdGF0ZSBpbml0aWFsaXplcnNcbiAgaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB7XG4gICAgaWYgKHJlZHVjZXIgIT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgICAvLyBjdXJyZW50IGhvb2suXG4gICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlO1xuICAgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXJlIHN0b3JlZCBpbiBhIG1hcCBvZiBxdWV1ZSAtPiBsaW5rZWQgbGlzdFxuICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGB1c2VTdGF0ZWAuXG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgdmFyIF9xdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX2Rpc3BhdGNoID0gX3F1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsIF9xdWV1ZSk7XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBfZGlzcGF0Y2hdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuXG4gICAge1xuICAgICAgT2JqZWN0LnNlYWwocmVmKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG5cbiAgICBlcnJvcigndXNlTGF5b3V0RWZmZWN0IGRvZXMgbm90aGluZyBvbiB0aGUgc2VydmVyLCBiZWNhdXNlIGl0cyBlZmZlY3QgY2Fubm90ICcgKyBcImJlIGVuY29kZWQgaW50byB0aGUgc2VydmVyIHJlbmRlcmVyJ3Mgb3V0cHV0IGZvcm1hdC4gVGhpcyB3aWxsIGxlYWQgXCIgKyAndG8gYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBpbml0aWFsLCBub24taHlkcmF0ZWQgVUkgYW5kIHRoZSBpbnRlbmRlZCAnICsgJ1VJLiBUbyBhdm9pZCB0aGlzLCB1c2VMYXlvdXRFZmZlY3Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiAnICsgJ2NvbXBvbmVudHMgdGhhdCByZW5kZXIgZXhjbHVzaXZlbHkgb24gdGhlIGNsaWVudC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3VzZWxheW91dGVmZmVjdC1zc3IgZm9yIGNvbW1vbiBmaXhlcy4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAoIShudW1iZXJPZlJlUmVuZGVycyA8IFJFX1JFTkRFUl9MSU1JVCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuc2V0KHF1ZXVlLCB1cGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgIHdoaWxlIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICAgIH1cblxuICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH0sIGRlcHMpO1xufSAvLyBUT0RPIERlY2lkZSBvbiBob3cgdG8gaW1wbGVtZW50IHRoaXMgaG9vayBmb3Igc2VydmVyIHJlbmRlcmluZy5cbi8vIElmIGEgbXV0YXRpb24gb2NjdXJzIGR1cmluZyByZW5kZXIsIGNvbnNpZGVyIHRyaWdnZXJpbmcgYSBTdXNwZW5zZSBib3VuZGFyeVxuLy8gYW5kIGZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlxuXG5mdW5jdGlvbiB1c2VNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcblxuICB2YXIgc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcblxuICByZXR1cm4gW3N0YXJ0VHJhbnNpdGlvbiwgZmFsc2VdO1xufVxuXG5mdW5jdGlvbiB1c2VPcGFxdWVJZGVudGlmaWVyKCkge1xuICByZXR1cm4gKGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIuaWRlbnRpZmllclByZWZpeCB8fCAnJykgKyAnUjonICsgKGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIudW5pcXVlSUQrKykudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFBhcnRpYWxSZW5kZXJlcihyZW5kZXJlcikge1xuICBjdXJyZW50UGFydGlhbFJlbmRlcmVyID0gcmVuZGVyZXI7XG59XG52YXIgRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDb250ZXh0OiB1c2VDb250ZXh0LFxuICB1c2VNZW1vOiB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICB1c2VSZWY6IHVzZVJlZixcbiAgdXNlU3RhdGU6IHVzZVN0YXRlLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVzZUxheW91dEVmZmVjdCxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICAvLyB1c2VJbXBlcmF0aXZlSGFuZGxlIGlzIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wLFxuICAvLyBFZmZlY3RzIGFyZSBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZUVmZmVjdDogbm9vcCxcbiAgLy8gRGVidWdnaW5nIGVmZmVjdFxuICB1c2VEZWJ1Z1ZhbHVlOiBub29wLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB1c2VEZWZlcnJlZFZhbHVlLFxuICB1c2VUcmFuc2l0aW9uOiB1c2VUcmFuc2l0aW9uLFxuICB1c2VPcGFxdWVJZGVudGlmaWVyOiB1c2VPcGFxdWVJZGVudGlmaWVyLFxuICAvLyBTdWJzY3JpcHRpb25zIGFyZSBub3Qgc2V0dXAgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2Vcbn07XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59OyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cblxuICAgIGlmICghKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmNoZWNrZWQgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cblxufTtcblxuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cblxuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIHRhZyArIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG5cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbiAgdmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nOyAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgY2FtZWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAgICAvLyAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gICAgLy8gaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgJ21zLScpKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkRm9ySW5maW5pdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9O1xuXG4gIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlJDEgPSB3YXJuVmFsaWRTdHlsZTtcblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkMS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgY29ycmVjdE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICBlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG5cblxuICAgIGlmIChldmVudFJlZ2lzdHJ5ICE9IG51bGwpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0gZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEOyAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuXG5cbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuXG5cbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbnZhciB0b0FycmF5ID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheTsgLy8gVGhpcyBpcyBvbmx5IHVzZWQgaW4gREVWLlxuLy8gRWFjaCBlbnRyeSBpcyBgdGhpcy5zdGFja2AgZnJvbSBhIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyZXIgaW5zdGFuY2UuXG4vLyAoVGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgYmVjYXVzZSBSZWFjdERPTVNlcnZlciBpcyByZWVudHJhbnQpLlxuLy8gRWFjaCBzdGFjayBpcyBhbiBhcnJheSBvZiBmcmFtZXMgd2hpY2ggbWF5IGNvbnRhaW4gbmVzdGVkIHN0YWNrcyBvZiBlbGVtZW50cy5cblxudmFyIGN1cnJlbnREZWJ1Z1N0YWNrcyA9IFtdO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxO1xudmFyIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gbnVsbDtcblxudmFyIGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnJztcbn07XG5cbnZhciBkZXNjcmliZVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gJyc7XG59O1xuXG52YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge307XG5cbnZhciBwdXNoQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHt9O1xuXG52YXIgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2sgPSBmdW5jdGlvbiAoZWxlbWVudCkge307XG5cbnZhciBwb3BDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gZmFsc2U7XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIG51bGwpO1xuICB9O1xuXG4gIGRlc2NyaWJlU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgbnVsbCk7XG4gIH07XG5cbiAgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgY3VycmVudERlYnVnU3RhY2tzLnB1c2goc3RhY2spO1xuXG4gICAgaWYgKGN1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFdlIGFyZSBlbnRlcmluZyBhIHNlcnZlciByZW5kZXJlci5cbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBwcmV2aW91cyAoZS5nLiBjbGllbnQpIGdsb2JhbCBzdGFjayBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjaztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsO1xuICAgIH1cbiAgfTtcblxuICBwdXNoRWxlbWVudFRvRGVidWdTdGFjayA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gRm9yIHRoZSBpbm5lcm1vc3QgZXhlY3V0aW5nIFJlYWN0RE9NU2VydmVyIGNhbGwsXG4gICAgdmFyIHN0YWNrID0gY3VycmVudERlYnVnU3RhY2tzW2N1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggLSAxXTsgLy8gVGFrZSB0aGUgaW5uZXJtb3N0IGV4ZWN1dGluZyBmcmFtZSAoZS5nLiA8Rm9vPiksXG5cbiAgICB2YXIgZnJhbWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTsgLy8gYW5kIHJlY29yZCB0aGF0IGl0IGhhcyBvbmUgbW9yZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBpdC5cblxuICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrLnB1c2goZWxlbWVudCk7IC8vIFdlIG9ubHkgbmVlZCB0aGlzIGJlY2F1c2Ugd2UgdGFpbC1vcHRpbWl6ZSBzaW5nbGUtZWxlbWVudFxuICAgIC8vIGNoaWxkcmVuIGFuZCBkaXJlY3RseSBoYW5kbGUgdGhlbSBpbiBhbiBpbm5lciBsb29wIGluc3RlYWQgb2ZcbiAgICAvLyBjcmVhdGluZyBzZXBhcmF0ZSBmcmFtZXMgZm9yIHRoZW0uXG4gIH07XG5cbiAgcG9wQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudERlYnVnU3RhY2tzLnBvcCgpO1xuXG4gICAgaWYgKGN1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFdlIGFyZSBleGl0aW5nIHRoZSBzZXJ2ZXIgcmVuZGVyZXIuXG4gICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyAoZS5nLiBjbGllbnQpIGdsb2JhbCBzdGFjayBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcbiAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gUmVhY3RET01TZXJ2ZXIgaXMgcmVlbnRyYW50IHNvIHRoZXJlIG1heSBiZSBtdWx0aXBsZSBjYWxscyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIFRha2UgdGhlIGZyYW1lcyBmcm9tIHRoZSBpbm5lcm1vc3QgY2FsbCB3aGljaCBpcyB0aGUgbGFzdCBpbiB0aGUgYXJyYXkuXG5cblxuICAgIHZhciBmcmFtZXMgPSBjdXJyZW50RGVidWdTdGFja3NbY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGZyYW1lIGluIHRoZSBzdGFjayBmcm9tIHRoZSBpbm5lcm1vc3Qgb25lLlxuXG4gICAgZm9yICh2YXIgaSA9IGZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldOyAvLyBFdmVyeSBmcmFtZSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgZGVidWcgZWxlbWVudCBzdGFjayBlbnRyeSBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugc2luZ2xlLWNoaWxkIG5lc3RpbmcgZG9lc24ndCBjcmVhdGUgbWF0ZXJpYWxpemVkIGZyYW1lcy5cbiAgICAgIC8vIEluc3RlYWQgaXQgd291bGQgcHVzaCB0aGVtIHRocm91Z2ggYHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrKClgLlxuXG4gICAgICB2YXIgZGVidWdFbGVtZW50U3RhY2sgPSBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjaztcblxuICAgICAgZm9yICh2YXIgaWkgPSBkZWJ1Z0VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIHN0YWNrICs9IGRlc2NyaWJlU3RhY2tGcmFtZShkZWJ1Z0VsZW1lbnRTdGFja1tpaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxudmFyIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSB7fTtcbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gIGxpc3Rpbmc6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWVcbn07IC8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG5cbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCF2YWxpZGF0ZWRUYWdDYWNoZS5oYXNPd25Qcm9wZXJ0eSh0YWcpKSB7XG4gICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgdGFnOiBcIiArIHRhZyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbnZhciBzdHlsZU5hbWVDYWNoZSA9IHt9O1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgaWYgKHN0eWxlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICByZXR1cm4gc3R5bGVOYW1lQ2FjaGVbc3R5bGVOYW1lXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbiAgc3R5bGVOYW1lQ2FjaGVbc3R5bGVOYW1lXSA9IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclN0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgdmFyIGRlbGltaXRlciA9ICcnO1xuXG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG5cbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgKGlzQ3VzdG9tUHJvcGVydHkgPyBzdHlsZU5hbWUgOiBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkpICsgJzonO1xuICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiBnZXRDb21wb25lbnROYW1lKF9jb25zdHJ1Y3RvcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKCclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldE5vbkNoaWxkcmVuSW5uZXJNYXJrdXAocHJvcHMpIHtcbiAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG4gIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBpbm5lckhUTUwuX19odG1sO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblRvcExldmVsQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICByZXR1cm4gdG9BcnJheShjaGlsZHJlbik7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNoaWxkcmVuO1xuXG4gIGlmIChlbGVtZW50LnR5cGUgIT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICByZXR1cm4gW2VsZW1lbnRdO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50Q2hpbGRyZW4gPSBlbGVtZW50LnByb3BzLmNoaWxkcmVuO1xuXG4gIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZnJhZ21lbnRDaGlsZHJlbikpIHtcbiAgICByZXR1cm4gdG9BcnJheShmcmFnbWVudENoaWxkcmVuKTtcbiAgfVxuXG4gIHZhciBmcmFnbWVudENoaWxkRWxlbWVudCA9IGZyYWdtZW50Q2hpbGRyZW47XG4gIHJldHVybiBbZnJhZ21lbnRDaGlsZEVsZW1lbnRdO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgY29udGVudCA9ICcnOyAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gJiYgdHlwZW9mIGNoaWxkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29udGVudDtcbn1cblxudmFyIGhhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGwsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogbnVsbFxufTtcblxuZnVuY3Rpb24gY3JlYXRlT3BlblRhZ01hcmt1cCh0YWdWZXJiYXRpbSwgdGFnTG93ZXJjYXNlLCBwcm9wcywgbmFtZXNwYWNlLCBtYWtlU3RhdGljTWFya3VwLCBpc1Jvb3RFbGVtZW50KSB7XG4gIHZhciByZXQgPSAnPCcgKyB0YWdWZXJiYXRpbTtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50JDEgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWdMb3dlcmNhc2UsIHByb3BzKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSQyLmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgcHJvcFZhbHVlID0gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cCA9IG51bGw7XG5cbiAgICBpZiAoaXNDdXN0b21Db21wb25lbnQkMSkge1xuICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBtYXJrdXAgPSBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAobWFya3VwKSB7XG4gICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgIH1cbiAgfSAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgLy8gYnl0ZXMuXG5cblxuICBpZiAobWFrZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoaXNSb290RWxlbWVudCkge1xuICAgIHJldCArPSAnICcgKyBjcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgdHlwZSkge1xuICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnKSArIFwiKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShjaGlsZCwgY29udGV4dCwgdGhyZWFkSUQpIHtcbiAgd2hpbGUgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgIC8vIFNhZmUgYmVjYXVzZSB3ZSBqdXN0IGNoZWNrZWQgaXQncyBhbiBlbGVtZW50LlxuICAgIHZhciBlbGVtZW50ID0gY2hpbGQ7XG4gICAgdmFyIENvbXBvbmVudCA9IGVsZW1lbnQudHlwZTtcblxuICAgIHtcbiAgICAgIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcm9jZXNzQ2hpbGQoZWxlbWVudCwgQ29tcG9uZW50KTtcbiAgfSAvLyBFeHRyYSBjbG9zdXJlIHNvIHF1ZXVlIGFuZCByZXBsYWNlIGNhbiBiZSBjYXB0dXJlZCBwcm9wZXJseVxuXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0NoaWxkKGVsZW1lbnQsIENvbXBvbmVudCkge1xuICAgIHZhciBpc0NsYXNzID0gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KTtcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHByb2Nlc3NDb250ZXh0KENvbXBvbmVudCwgY29udGV4dCwgdGhyZWFkSUQsIGlzQ2xhc3MpO1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciByZXBsYWNlID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgICAgIHJlcGxhY2UgPSB0cnVlO1xuICAgICAgICBxdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY3VycmVudFBhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5wdXNoKGN1cnJlbnRQYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGluc3Q7XG5cbiAgICBpZiAoaXNDbGFzcykge1xuICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQoZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlcik7XG5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGluc3Quc3RhdGUgPT09IG51bGwgfHwgaW5zdC5zdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICcgKyAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArICdhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJyArICdUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuJywgY29tcG9uZW50TmFtZSwgaW5zdC5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLmNhbGwobnVsbCwgZWxlbWVudC5wcm9wcywgaW5zdC5zdGF0ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGVbX2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgIGVycm9yKCclcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuICcgKyAnWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGVbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICBpbnN0LnN0YXRlID0gX2Fzc2lnbih7fSwgaW5zdC5zdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW19jb21wb25lbnROYW1lMl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgICAgIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgIGluc3QgPSBDb21wb25lbnQoZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlcik7XG4gICAgICBpbnN0ID0gZmluaXNoSG9va3MoQ29tcG9uZW50LCBlbGVtZW50LnByb3BzLCBpbnN0LCBwdWJsaWNDb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICAvLyBTdXBwb3J0IGZvciBtb2R1bGUgY29tcG9uZW50cyBpcyBkZXByZWNhdGVkIGFuZCBpcyByZW1vdmVkIGJlaGluZCBhIGZsYWcuXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuICAgICAgICBpZiAoaW5zdCAhPSBudWxsICYmIGluc3QucmVuZGVyICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZTMsIF9jb21wb25lbnROYW1lMywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgdGhlIGZsYWcgaXMgb24sIGV2ZXJ5dGhpbmcgaXMgYXNzdW1lZCB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UgYWxzbyBkbyB0aGUgdW5mb3J0dW5hdGUgZHluYW1pYyBjaGVja3MuXG5cblxuICAgICAgaWYgKCBpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBjaGlsZCA9IGluc3Q7XG4gICAgICAgIHZhbGlkYXRlUmVuZGVyUmVzdWx0KGNoaWxkLCBDb21wb25lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5wcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuXG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICggaW5zdC5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtfY29tcG9uZW50TmFtZTRdKSB7XG4gICAgICAgICAgICAgIHdhcm4oIC8vIGtlZXAgdGhpcyB3YXJuaW5nIGluIHN5bmMgd2l0aCBSZWFjdFN0cmljdE1vZGVXYXJuaW5nLmpzXG4gICAgICAgICAgICAgICdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgZnJvbSBjb21wb25lbnRXaWxsTW91bnQgdG8gY29tcG9uZW50RGlkTW91bnQgKHByZWZlcnJlZCBpbiBtb3N0IGNhc2VzKSAnICsgJ29yIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtfY29tcG9uZW50TmFtZTRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgYW55IGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgZ0RTRlAuXG5cblxuICAgICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgICAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGFueSBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGdEU0ZQLlxuICAgICAgICBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdmFyIG9sZFJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICAgIHJlcGxhY2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAob2xkUmVwbGFjZSAmJiBvbGRRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpbnN0LnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3Quc3RhdGU7XG4gICAgICAgICAgdmFyIGRvbnRNdXRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IG9sZFJlcGxhY2UgPyAxIDogMDsgaSA8IG9sZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldO1xuXG4gICAgICAgICAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCkgOiBwYXJ0aWFsO1xuXG4gICAgICAgICAgICBpZiAoX3BhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChkb250TXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgZG9udE11dGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIG5leHRTdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2Fzc2lnbihuZXh0U3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gaW5zdC5yZW5kZXIoKTtcblxuICAgIHtcbiAgICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICBjaGlsZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIENvbXBvbmVudCk7XG4gICAgdmFyIGNoaWxkQ29udGV4dDtcblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdC5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9jaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgICAgICBpZiAodHlwZW9mIF9jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gX2NoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBfYXNzaWduKHt9LCBjb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2hpbGQ6IGNoaWxkLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbn1cblxudmFyIFJlYWN0RE9NU2VydmVyUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiB0eXBlIHRoaXMgbW9yZSBzdHJpY3RseTpcbiAgLy8gREVWLW9ubHlcbiAgZnVuY3Rpb24gUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihjaGlsZHJlbiwgbWFrZVN0YXRpY01hcmt1cCwgb3B0aW9ucykge1xuICAgIHZhciBmbGF0Q2hpbGRyZW4gPSBmbGF0dGVuVG9wTGV2ZWxDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgdmFyIHRvcEZyYW1lID0ge1xuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIC8vIEFzc3VtZSBhbGwgdHJlZXMgc3RhcnQgaW4gdGhlIEhUTUwgbmFtZXNwYWNlIChub3QgdG90YWxseSB0cnVlLCBidXRcbiAgICAgIC8vIHRoaXMgaXMgd2hhdCB3ZSBkaWQgaGlzdG9yaWNhbGx5KVxuICAgICAgZG9tTmFtZXNwYWNlOiBOYW1lc3BhY2VzLmh0bWwsXG4gICAgICBjaGlsZHJlbjogZmxhdENoaWxkcmVuLFxuICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgIGNvbnRleHQ6IGVtcHR5T2JqZWN0LFxuICAgICAgZm9vdGVyOiAnJ1xuICAgIH07XG5cbiAgICB7XG4gICAgICB0b3BGcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMudGhyZWFkSUQgPSBhbGxvY1RocmVhZElEKCk7XG4gICAgdGhpcy5zdGFjayA9IFt0b3BGcmFtZV07XG4gICAgdGhpcy5leGhhdXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgdGhpcy5tYWtlU3RhdGljTWFya3VwID0gbWFrZVN0YXRpY01hcmt1cDtcbiAgICB0aGlzLnN1c3BlbnNlRGVwdGggPSAwOyAvLyBDb250ZXh0IChuZXcgQVBJKVxuXG4gICAgdGhpcy5jb250ZXh0SW5kZXggPSAtMTtcbiAgICB0aGlzLmNvbnRleHRTdGFjayA9IFtdO1xuICAgIHRoaXMuY29udGV4dFZhbHVlU3RhY2sgPSBbXTsgLy8gdXNlT3BhcXVlSWRlbnRpZmllciBJRFxuXG4gICAgdGhpcy51bmlxdWVJRCA9IDA7XG4gICAgdGhpcy5pZGVudGlmaWVyUHJlZml4ID0gb3B0aW9ucyAmJiBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggfHwgJyc7XG5cbiAgICB7XG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrID0gW107XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuZXhoYXVzdGVkKSB7XG4gICAgICB0aGlzLmV4aGF1c3RlZCA9IHRydWU7XG4gICAgICB0aGlzLmNsZWFyUHJvdmlkZXJzKCk7XG4gICAgICBmcmVlVGhyZWFkSUQodGhpcy50aHJlYWRJRCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOb3RlOiBXZSB1c2UganVzdCB0d28gc3RhY2tzIHJlZ2FyZGxlc3Mgb2YgaG93IG1hbnkgY29udGV4dCBwcm92aWRlcnMgeW91IGhhdmUuXG4gICAqIFByb3ZpZGVycyBhcmUgYWx3YXlzIHBvcHBlZCBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0byBob3cgdGhleSB3ZXJlIHB1c2hlZFxuICAgKiBzbyB3ZSBhbHdheXMga25vdyBvbiB0aGUgd2F5IGRvd24gd2hpY2ggcHJvdmlkZXIgeW91J2xsIGVuY291bnRlciBuZXh0IG9uIHRoZSB3YXkgdXAuXG4gICAqIE9uIHRoZSB3YXkgZG93biwgd2UgcHVzaCB0aGUgY3VycmVudCBwcm92aWRlciwgYW5kIGl0cyBjb250ZXh0IHZhbHVlICpiZWZvcmUqXG4gICAqIHdlIG11dGF0ZWQgaXQsIG9udG8gdGhlIHN0YWNrcy4gVGhlcmVmb3JlLCBvbiB0aGUgd2F5IHVwLCB3ZSBhbHdheXMga25vdyB3aGljaFxuICAgKiBwcm92aWRlciBuZWVkcyB0byBiZSBcInJlc3RvcmVkXCIgdG8gd2hpY2ggdmFsdWUuXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEyOTg1I2lzc3VlY29tbWVudC0zOTYzMDEyNDhcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHVzaFByb3ZpZGVyID0gZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gKyt0aGlzLmNvbnRleHRJbmRleDtcbiAgICB2YXIgY29udGV4dCA9IHByb3ZpZGVyLnR5cGUuX2NvbnRleHQ7XG4gICAgdmFyIHRocmVhZElEID0gdGhpcy50aHJlYWRJRDtcbiAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gY29udGV4dFt0aHJlYWRJRF07IC8vIFJlbWVtYmVyIHdoaWNoIHZhbHVlIHRvIHJlc3RvcmUgdGhpcyBjb250ZXh0IHRvIG9uIG91ciB3YXkgdXAuXG5cbiAgICB0aGlzLmNvbnRleHRTdGFja1tpbmRleF0gPSBjb250ZXh0O1xuICAgIHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdID0gcHJldmlvdXNWYWx1ZTtcblxuICAgIHtcbiAgICAgIC8vIE9ubHkgdXNlZCBmb3IgcHVzaC9wb3AgbWlzbWF0Y2ggd2FybmluZ3MuXG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSA9IHByb3ZpZGVyO1xuICAgIH0gLy8gTXV0YXRlIHRoZSBjdXJyZW50IHZhbHVlLlxuXG5cbiAgICBjb250ZXh0W3RocmVhZElEXSA9IHByb3ZpZGVyLnByb3BzLnZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5wb3BQcm92aWRlciA9IGZ1bmN0aW9uIHBvcFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0SW5kZXg7XG5cbiAgICB7XG4gICAgICBpZiAoaW5kZXggPCAwIHx8IHByb3ZpZGVyICE9PSB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSkge1xuICAgICAgICBlcnJvcignVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRTdGFja1tpbmRleF07XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XTsgLy8gXCJIaWRlXCIgdGhlc2UgbnVsbCBhc3NpZ25tZW50cyBmcm9tIEZsb3cgYnkgdXNpbmcgYGFueWBcbiAgICAvLyBiZWNhdXNlIGNvbmNlcHR1YWxseSB0aGV5IGFyZSBkZWxldGlvbnMtLWFzIGxvbmcgYXMgd2VcbiAgICAvLyBwcm9taXNlIHRvIG5ldmVyIGFjY2VzcyB2YWx1ZXMgYmV5b25kIGB0aGlzLmNvbnRleHRJbmRleGAuXG5cbiAgICB0aGlzLmNvbnRleHRTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHRJbmRleC0tOyAvLyBSZXN0b3JlIHRvIHRoZSBwcmV2aW91cyB2YWx1ZSB3ZSBzdG9yZWQgYXMgd2Ugd2VyZSB3YWxraW5nIGRvd24uXG4gICAgLy8gV2UndmUgYWxyZWFkeSB2ZXJpZmllZCB0aGF0IHRoaXMgY29udGV4dCBoYXMgYmVlbiBleHBhbmRlZCB0byBhY2NvbW1vZGF0ZVxuICAgIC8vIHRoaXMgdGhyZWFkIGlkLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGl0IGFnYWluLlxuXG4gICAgY29udGV4dFt0aGlzLnRocmVhZElEXSA9IHByZXZpb3VzVmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyUHJvdmlkZXJzID0gZnVuY3Rpb24gY2xlYXJQcm92aWRlcnMoKSB7XG4gICAgLy8gUmVzdG9yZSBhbnkgcmVtYWluaW5nIHByb3ZpZGVycyBvbiB0aGUgc3RhY2sgdG8gcHJldmlvdXMgdmFsdWVzXG4gICAgZm9yICh2YXIgaW5kZXggPSB0aGlzLmNvbnRleHRJbmRleDsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRTdGFja1tpbmRleF07XG4gICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdO1xuICAgICAgY29udGV4dFt0aGlzLnRocmVhZElEXSA9IHByZXZpb3VzVmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZWFkID0gZnVuY3Rpb24gcmVhZChieXRlcykge1xuICAgIGlmICh0aGlzLmV4aGF1c3RlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByZXZQYXJ0aWFsUmVuZGVyZXIgPSBjdXJyZW50UGFydGlhbFJlbmRlcmVyO1xuICAgIHNldEN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIodGhpcyk7XG4gICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBEaXNwYXRjaGVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIE1hcmt1cCBnZW5lcmF0ZWQgd2l0aGluIDxTdXNwZW5zZT4gZW5kcyB1cCBidWZmZXJlZCB1bnRpbCB3ZSBrbm93XG4gICAgICAvLyBub3RoaW5nIGluIHRoYXQgYm91bmRhcnkgc3VzcGVuZGVkXG4gICAgICB2YXIgb3V0ID0gWycnXTtcbiAgICAgIHZhciBzdXNwZW5kZWQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKG91dFswXS5sZW5ndGggPCBieXRlcykge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmV4aGF1c3RlZCA9IHRydWU7XG4gICAgICAgICAgZnJlZVRocmVhZElEKHRoaXMudGhyZWFkSUQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChzdXNwZW5kZWQgfHwgZnJhbWUuY2hpbGRJbmRleCA+PSBmcmFtZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZm9vdGVyID0gZnJhbWUuZm9vdGVyO1xuXG4gICAgICAgICAgaWYgKGZvb3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgIT0gbnVsbCAmJiBmcmFtZS50eXBlLnR5cGUgIT0gbnVsbCAmJiBmcmFtZS50eXBlLnR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGZyYW1lLnR5cGU7XG4gICAgICAgICAgICB0aGlzLnBvcFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuc2VEZXB0aC0tO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkID0gb3V0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoc3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbmRlZCA9IGZhbHNlOyAvLyBJZiByZW5kZXJpbmcgd2FzIHN1c3BlbmRlZCBhdCB0aGlzIGJvdW5kYXJ5LCByZW5kZXIgdGhlIGZhbGxiYWNrRnJhbWVcblxuICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tGcmFtZSA9IGZyYW1lLmZhbGxiYWNrRnJhbWU7XG5cbiAgICAgICAgICAgICAgaWYgKCFmYWxsYmFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodHJ1ZSA/IFwiUmVhY3RET01TZXJ2ZXIgZGlkIG5vdCBmaW5kIGFuIGludGVybmFsIGZhbGxiYWNrIGZyYW1lIGZvciBTdXNwZW5zZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgOiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwMykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmYWxsYmFja0ZyYW1lKTtcbiAgICAgICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gJzwhLS0kIS0tPic7IC8vIFNraXAgZmx1c2hpbmcgb3V0cHV0IHNpbmNlIHdlJ3JlIHN3aXRjaGluZyB0byB0aGUgZmFsbGJhY2tcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IGJ1ZmZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gRmx1c2ggb3V0cHV0XG5cblxuICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IGZvb3RlcjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IGZyYW1lLmNoaWxkcmVuW2ZyYW1lLmNoaWxkSW5kZXgrK107XG4gICAgICAgIHZhciBvdXRCdWZmZXIgPSAnJztcblxuICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgIHB1c2hDdXJyZW50RGVidWdTdGFjayh0aGlzLnN0YWNrKTsgLy8gV2UncmUgc3RhcnRpbmcgd29yayBvbiB0aGlzIGZyYW1lLCBzbyByZXNldCBpdHMgaW5uZXIgc3RhY2suXG5cbiAgICAgICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvdXRCdWZmZXIgKz0gdGhpcy5yZW5kZXIoY2hpbGQsIGZyYW1lLmNvbnRleHQsIGZyYW1lLmRvbU5hbWVzcGFjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCAmJiB0eXBlb2YgZXJyLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgIGlmICghKHRoaXMuc3VzcGVuc2VEZXB0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodHJ1ZSA/IFwiQSBSZWFjdCBjb21wb25lbnQgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuXFxuQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byBwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS5cIiA6IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBTdXNwZW5zZS5cIiA6IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjk0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgIHBvcEN1cnJlbnREZWJ1Z1N0YWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dC5sZW5ndGggPD0gdGhpcy5zdXNwZW5zZURlcHRoKSB7XG4gICAgICAgICAgb3V0LnB1c2goJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gb3V0QnVmZmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0WzBdO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgc2V0Q3VycmVudFBhcnRpYWxSZW5kZXJlcihwcmV2UGFydGlhbFJlbmRlcmVyKTtcbiAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNoaWxkLCBjb250ZXh0LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgdGV4dCA9ICcnICsgY2hpbGQ7XG5cbiAgICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1ha2VTdGF0aWNNYXJrdXApIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmV2aW91c1dhc1RleHROb2RlKSB7XG4gICAgICAgIHJldHVybiAnPCEtLSAtLT4nICsgZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IHRydWU7XG4gICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0Q2hpbGQ7XG5cbiAgICAgIHZhciBfcmVzb2x2ZSA9IHJlc29sdmUoY2hpbGQsIGNvbnRleHQsIHRoaXMudGhyZWFkSUQpO1xuXG4gICAgICBuZXh0Q2hpbGQgPSBfcmVzb2x2ZS5jaGlsZDtcbiAgICAgIGNvbnRleHQgPSBfcmVzb2x2ZS5jb250ZXh0O1xuXG4gICAgICBpZiAobmV4dENoaWxkID09PSBudWxsIHx8IG5leHRDaGlsZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV4dENoaWxkKSkge1xuICAgICAgICBpZiAobmV4dENoaWxkICE9IG51bGwgJiYgbmV4dENoaWxkLiQkdHlwZW9mICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDYXRjaCB1bmV4cGVjdGVkIHNwZWNpYWwgdHlwZXMgZWFybHkuXG4gICAgICAgICAgdmFyICQkdHlwZW9mID0gbmV4dENoaWxkLiQkdHlwZW9mO1xuXG4gICAgICAgICAgaWYgKCEoJCR0eXBlb2YgIT09IFJFQUNUX1BPUlRBTF9UWVBFKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiBSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2F0Y2gtYWxsIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBpZiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KCkgc3VwcG9ydHMgc29tZSBuZXcgdHlwZS5cblxuXG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIGVsZW1lbnQtbGlrZSBvYmplY3QgdHlwZTogXCIgKyAkJHR5cGVvZi50b1N0cmluZygpICsgXCIuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0b0FycmF5KG5leHRDaGlsZCk7XG4gICAgICAgIHZhciBmcmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgfTtcblxuICAgICAgICB7XG4gICAgICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChmcmFtZSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gLy8gU2FmZSBiZWNhdXNlIHdlIGp1c3QgY2hlY2tlZCBpdCdzIGFuIGVsZW1lbnQuXG5cblxuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkO1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbmV4dEVsZW1lbnQudHlwZTtcblxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRE9NKG5leHRFbGVtZW50LCBjb250ZXh0LCBwYXJlbnROYW1lc3BhY2UpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGVsZW1lbnRUeXBlKSB7XG4gICAgICAgIC8vIFRPRE86IExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3Jrc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGN1cnJlbnRseSBhc3N1bWUgdGhhdCBldmVyeSBpbnN0YW5jZSBvZiBMZWdhY3lIaWRkZW4gaXNcbiAgICAgICAgLy8gYWNjb21wYW5pZWQgYnkgYSBob3N0IGNvbXBvbmVudCB3cmFwcGVyLiBJbiB0aGUgaGlkZGVuIG1vZGUsIHRoZSBob3N0XG4gICAgICAgIC8vIGNvbXBvbmVudCBpcyBnaXZlbiBhIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZVxuICAgICAgICAvLyBpbml0aWFsIEhUTUwgaXMgbm90IHZpc2libGUuIFRvIHN1cHBvcnQgdGhlIHVzZSBvZiBMZWdhY3lIaWRkZW4gYXMgYVxuICAgICAgICAvLyB0cnVlIGZyYWdtZW50LCB3aXRob3V0IGFuIGV4dHJhIERPTSBub2RlLCB3ZSB3b3VsZCBoYXZlIHRvIGhpZGUgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgSFRNTCBpbiBzb21lIG90aGVyIHdheS5cbiAgICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuID0gdG9BcnJheShuZXh0Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICB2YXIgX2ZyYW1lID0ge1xuICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2ZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgU3VzcGVuc2UuXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50VHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBuZXh0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW41O1xuXG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICAgICAgICAgICAgICBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSk7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW41ID0gZWxlbWVudFR5cGUucmVuZGVyKGVsZW1lbnQucHJvcHMsIGVsZW1lbnQucmVmKTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSBmaW5pc2hIb29rcyhlbGVtZW50VHlwZS5yZW5kZXIsIGVsZW1lbnQucHJvcHMsIF9uZXh0Q2hpbGRyZW41LCBlbGVtZW50LnJlZik7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW41ID0gdG9BcnJheShfbmV4dENoaWxkcmVuNSk7XG4gICAgICAgICAgICAgIHZhciBfZnJhbWU1ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW41LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU1KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZWxlbWVudCA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW42ID0gW1JlYWN0LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUudHlwZSwgX2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgcmVmOiBfZWxlbWVudC5yZWZcbiAgICAgICAgICAgICAgfSwgX2VsZW1lbnQucHJvcHMpKV07XG4gICAgICAgICAgICAgIHZhciBfZnJhbWU2ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW42LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTYuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU2KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSBwcm92aWRlci5wcm9wcztcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjcgPSB0b0FycmF5KG5leHRQcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTcgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW43LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTcuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMucHVzaFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTcpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWN0Q29udGV4dCA9IG5leHRDaGlsZC50eXBlOyAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbiAgICAgICAgICAgICAgLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbiAgICAgICAgICAgICAgLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4gICAgICAgICAgICAgIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4gICAgICAgICAgICAgIC8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4gICAgICAgICAgICAgIC8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuICAgICAgICAgICAgICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChyZWFjdENvbnRleHQuX2NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4gICAgICAgICAgICAgICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG4gICAgICAgICAgICAgICAgICBpZiAocmVhY3RDb250ZXh0ICE9PSByZWFjdENvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWFjdENvbnRleHQgPSByZWFjdENvbnRleHQuX2NvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0UHJvcHMgPSBuZXh0Q2hpbGQucHJvcHM7XG4gICAgICAgICAgICAgIHZhciB0aHJlYWRJRCA9IHRoaXMudGhyZWFkSUQ7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhyZWFjdENvbnRleHQsIHRocmVhZElEKTtcbiAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHJlYWN0Q29udGV4dFt0aHJlYWRJRF07XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW44ID0gdG9BcnJheShfbmV4dFByb3BzLmNoaWxkcmVuKG5leHRWYWx1ZSkpO1xuXG4gICAgICAgICAgICAgIHZhciBfZnJhbWU4ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG5leHRDaGlsZCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjgsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lOC5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTgpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEU6XG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHRoZSBmdW5kYW1lbnRhbCBBUEkuXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX2VsZW1lbnQyID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IG5leHRDaGlsZC50eXBlOyAvLyBBdHRlbXB0IHRvIGluaXRpYWxpemUgbGF6eSBjb21wb25lbnQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZVxuICAgICAgICAgICAgICAvLyBzdXNwZW5zZSBzZXJ2ZXItc2lkZSByZW5kZXJlciBpcyBlbmFibGVkIHNvIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgLy8gcmVzb2x2ZWQgY29uc3RydWN0b3JzIGFyZSBzdXBwb3J0ZWQuXG5cbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbml0KHBheWxvYWQpO1xuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjEwID0gW1JlYWN0LmNyZWF0ZUVsZW1lbnQocmVzdWx0LCBfYXNzaWduKHtcbiAgICAgICAgICAgICAgICByZWY6IF9lbGVtZW50Mi5yZWZcbiAgICAgICAgICAgICAgfSwgX2VsZW1lbnQyLnByb3BzKSldO1xuICAgICAgICAgICAgICB2YXIgX2ZyYW1lMTAgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjEwLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTEwLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lMTApO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAge1xuICAgICAgICB2YXIgb3duZXIgPSBuZXh0RWxlbWVudC5fb3duZXI7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlbGVtZW50VHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuXG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArIChlbGVtZW50VHlwZSA9PSBudWxsID8gZWxlbWVudFR5cGUgOiB0eXBlb2YgZWxlbWVudFR5cGUpICsgXCIuXCIgKyBpbmZvICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlckRPTSA9IGZ1bmN0aW9uIHJlbmRlckRPTShlbGVtZW50LCBjb250ZXh0LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgICB2YXIgdGFnID0gZWxlbWVudC50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IE5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgbmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgICBpZiAodGFnICE9PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIGVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICAgIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ2lucHV0JywgcHJvcHMpO1xuXG4gICAgICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRDaGVja2VkKSB7XG4gICAgICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICAgIH0sIHByb3BzLCB7XG4gICAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICB2YWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBjaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUpIHtcbiAgICAgICAgICBlcnJvcignVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAgICAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7IC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG5cbiAgICAgICAgdmFyIHRleHRhcmVhQ2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICBpZiAodGV4dGFyZWFDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0YXJlYUNoaWxkcmVuKSkge1xuICAgICAgICAgICAgaWYgKCEodGV4dGFyZWFDaGlsZHJlbi5sZW5ndGggPD0gMSkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIjx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRhcmVhQ2hpbGRyZW4gPSB0ZXh0YXJlYUNoaWxkcmVuWzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgdGV4dGFyZWFDaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGNoaWxkcmVuOiAnJyArIGluaXRpYWxWYWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3NlbGVjdCcsIHByb3BzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuXG4gICAgICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLicsIHByb3BOYW1lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4nLCBwcm9wTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUpIHtcbiAgICAgICAgICBlcnJvcignU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnb3B0aW9uJykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICAgIHZhciBzZWxlY3RWYWx1ZSA9IHRoaXMuY3VycmVudFNlbGVjdFZhbHVlO1xuICAgICAgdmFyIG9wdGlvbkNoaWxkcmVuID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gb3B0aW9uQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbal0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgICAgICB9LCBwcm9wcywge1xuICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICBjaGlsZHJlbjogb3B0aW9uQ2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHByb3BzKTtcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpO1xuICAgIHZhciBvdXQgPSBjcmVhdGVPcGVuVGFnTWFya3VwKGVsZW1lbnQudHlwZSwgdGFnLCBwcm9wcywgbmFtZXNwYWNlLCB0aGlzLm1ha2VTdGF0aWNNYXJrdXAsIHRoaXMuc3RhY2subGVuZ3RoID09PSAxKTtcbiAgICB2YXIgZm9vdGVyID0gJyc7XG5cbiAgICBpZiAob21pdHRlZENsb3NlVGFncy5oYXNPd25Qcm9wZXJ0eSh0YWcpKSB7XG4gICAgICBvdXQgKz0gJy8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICc+JztcbiAgICAgIGZvb3RlciA9ICc8LycgKyBlbGVtZW50LnR5cGUgKyAnPic7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuO1xuICAgIHZhciBpbm5lck1hcmt1cCA9IGdldE5vbkNoaWxkcmVuSW5uZXJNYXJrdXAocHJvcHMpO1xuXG4gICAgaWYgKGlubmVyTWFya3VwICE9IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuID0gW107XG5cbiAgICAgIGlmIChuZXdsaW5lRWF0aW5nVGFncy5oYXNPd25Qcm9wZXJ0eSh0YWcpICYmIGlubmVyTWFya3VwLmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgICAgb3V0ICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICBvdXQgKz0gaW5uZXJNYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuID0gdG9BcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lID0ge1xuICAgICAgZG9tTmFtZXNwYWNlOiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIGVsZW1lbnQudHlwZSksXG4gICAgICB0eXBlOiB0YWcsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGZvb3RlcjogZm9vdGVyXG4gICAgfTtcblxuICAgIHtcbiAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKGZyYW1lKTtcbiAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHJldHVybiBSZWFjdERPTVNlcnZlclJlbmRlcmVyO1xufSgpO1xuXG4vKipcbiAqIFJlbmRlciBhIFJlYWN0RWxlbWVudCB0byBpdHMgaW5pdGlhbCBIVE1MLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gdGhlXG4gKiBzZXJ2ZXIuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0cmluZ1xuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgZmFsc2UsIG9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgdmFyIG1hcmt1cCA9IHJlbmRlcmVyLnJlYWQoSW5maW5pdHkpO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH0gZmluYWxseSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICB9XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gcmVuZGVyVG9TdHJpbmcsIGV4Y2VwdCB0aGlzIGRvZXNuJ3QgY3JlYXRlIGV4dHJhIERPTSBhdHRyaWJ1dGVzXG4gKiBzdWNoIGFzIGRhdGEtcmVhY3QtaWQgdGhhdCBSZWFjdCB1c2VzIGludGVybmFsbHkuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0YXRpY21hcmt1cFxuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbWFya3VwID0gcmVuZGVyZXIucmVhZChJbmZpbml0eSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSBmaW5hbGx5IHtcbiAgICByZW5kZXJlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWRhYmxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0sIF9SZWFkYWJsZSk7XG5cbiAgZnVuY3Rpb24gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCBtYWtlU3RhdGljTWFya3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgLy8gQ2FsbHMgdGhlIHN0cmVhbS5SZWFkYWJsZShvcHRpb25zKSBjb25zdHJ1Y3Rvci4gQ29uc2lkZXIgZXhwb3NpbmcgYnVpbHQtaW5cbiAgICAvLyBmZWF0dXJlcyBsaWtlIGhpZ2hXYXRlck1hcmsgaW4gdGhlIGZ1dHVyZS5cbiAgICBfdGhpcyA9IF9SZWFkYWJsZS5jYWxsKHRoaXMsIHt9KSB8fCB0aGlzO1xuICAgIF90aGlzLnBhcnRpYWxSZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIG1ha2VTdGF0aWNNYXJrdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wYXJ0aWFsUmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG5cbiAgX3Byb3RvLl9yZWFkID0gZnVuY3Rpb24gX3JlYWQoc2l6ZSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5wYXJ0aWFsUmVuZGVyZXIucmVhZChzaXplKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW07XG59KHN0cmVhbS5SZWFkYWJsZSk7XG4vKipcbiAqIFJlbmRlciBhIFJlYWN0RWxlbWVudCB0byBpdHMgaW5pdGlhbCBIVE1MLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gdGhlXG4gKiBzZXJ2ZXIuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b25vZGVzdHJlYW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmRlclRvTm9kZVN0cmVhbShlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCBmYWxzZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gcmVuZGVyVG9Ob2RlU3RyZWFtLCBleGNlcHQgdGhpcyBkb2Vzbid0IGNyZWF0ZSBleHRyYSBET00gYXR0cmlidXRlc1xuICogc3VjaCBhcyBkYXRhLXJlYWN0LWlkIHRoYXQgUmVhY3QgdXNlcyBpbnRlcm5hbGx5LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdGF0aWNub2Rlc3RyZWFtXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIHRydWUsIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnJlbmRlclRvTm9kZVN0cmVhbSA9IHJlbmRlclRvTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtID0gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IHJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLm5vZGUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2VydmVyLm5vZGUnKTtcbiIsICIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsICIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsICIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsICIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwgIi8qIE5Qcm9ncmVzcywgKGMpIDIwMTMsIDIwMTQgUmljbyBTdGEuIENydXogLSBodHRwOi8vcmljb3N0YWNydXouY29tL25wcm9ncmVzc1xuICogQGxpY2Vuc2UgTUlUICovXG5cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5OUHJvZ3Jlc3MgPSBmYWN0b3J5KCk7XG4gIH1cblxufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gIHZhciBOUHJvZ3Jlc3MgPSB7fTtcblxuICBOUHJvZ3Jlc3MudmVyc2lvbiA9ICcwLjIuMCc7XG5cbiAgdmFyIFNldHRpbmdzID0gTlByb2dyZXNzLnNldHRpbmdzID0ge1xuICAgIG1pbmltdW06IDAuMDgsXG4gICAgZWFzaW5nOiAnZWFzZScsXG4gICAgcG9zaXRpb25Vc2luZzogJycsXG4gICAgc3BlZWQ6IDIwMCxcbiAgICB0cmlja2xlOiB0cnVlLFxuICAgIHRyaWNrbGVSYXRlOiAwLjAyLFxuICAgIHRyaWNrbGVTcGVlZDogODAwLFxuICAgIHNob3dTcGlubmVyOiB0cnVlLFxuICAgIGJhclNlbGVjdG9yOiAnW3JvbGU9XCJiYXJcIl0nLFxuICAgIHNwaW5uZXJTZWxlY3RvcjogJ1tyb2xlPVwic3Bpbm5lclwiXScsXG4gICAgcGFyZW50OiAnYm9keScsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiYmFyXCIgcm9sZT1cImJhclwiPjxkaXYgY2xhc3M9XCJwZWdcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwic3Bpbm5lclwiIHJvbGU9XCJzcGlubmVyXCI+PGRpdiBjbGFzcz1cInNwaW5uZXItaWNvblwiPjwvZGl2PjwvZGl2PidcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiAgICAgTlByb2dyZXNzLmNvbmZpZ3VyZSh7XG4gICAqICAgICAgIG1pbmltdW06IDAuMVxuICAgKiAgICAgfSk7XG4gICAqL1xuICBOUHJvZ3Jlc3MuY29uZmlndXJlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBTZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIExhc3QgbnVtYmVyLlxuICAgKi9cblxuICBOUHJvZ3Jlc3Muc3RhdHVzID0gbnVsbDtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJvZ3Jlc3MgYmFyIHN0YXR1cywgd2hlcmUgYG5gIGlzIGEgbnVtYmVyIGZyb20gYDAuMGAgdG8gYDEuMGAuXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3Muc2V0KDAuNCk7XG4gICAqICAgICBOUHJvZ3Jlc3Muc2V0KDEuMCk7XG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zZXQgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHN0YXJ0ZWQgPSBOUHJvZ3Jlc3MuaXNTdGFydGVkKCk7XG5cbiAgICBuID0gY2xhbXAobiwgU2V0dGluZ3MubWluaW11bSwgMSk7XG4gICAgTlByb2dyZXNzLnN0YXR1cyA9IChuID09PSAxID8gbnVsbCA6IG4pO1xuXG4gICAgdmFyIHByb2dyZXNzID0gTlByb2dyZXNzLnJlbmRlcighc3RhcnRlZCksXG4gICAgICAgIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHNwZWVkICAgID0gU2V0dGluZ3Muc3BlZWQsXG4gICAgICAgIGVhc2UgICAgID0gU2V0dGluZ3MuZWFzaW5nO1xuXG4gICAgcHJvZ3Jlc3Mub2Zmc2V0V2lkdGg7IC8qIFJlcGFpbnQgKi9cblxuICAgIHF1ZXVlKGZ1bmN0aW9uKG5leHQpIHtcbiAgICAgIC8vIFNldCBwb3NpdGlvblVzaW5nIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc2V0XG4gICAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJycpIFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPSBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MoKTtcblxuICAgICAgLy8gQWRkIHRyYW5zaXRpb25cbiAgICAgIGNzcyhiYXIsIGJhclBvc2l0aW9uQ1NTKG4sIHNwZWVkLCBlYXNlKSk7XG5cbiAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgIC8vIEZhZGUgb3V0XG4gICAgICAgIGNzcyhwcm9ncmVzcywgeyBcbiAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZScsIFxuICAgICAgICAgIG9wYWNpdHk6IDEgXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2FsbCAnICsgc3BlZWQgKyAnbXMgbGluZWFyJywgXG4gICAgICAgICAgICBvcGFjaXR5OiAwIFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBOUHJvZ3Jlc3MucmVtb3ZlKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfSwgc3BlZWQpO1xuICAgICAgICB9LCBzcGVlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KG5leHQsIHNwZWVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE5Qcm9ncmVzcy5pc1N0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIE5Qcm9ncmVzcy5zdGF0dXMgPT09ICdudW1iZXInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93cyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHNldHRpbmcgdGhlIHN0YXR1cyB0byAwJSwgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBnbyBiYWNrd2FyZHMuXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICpcbiAgICovXG4gIE5Qcm9ncmVzcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgTlByb2dyZXNzLnNldCgwKTtcblxuICAgIHZhciB3b3JrID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIU5Qcm9ncmVzcy5zdGF0dXMpIHJldHVybjtcbiAgICAgICAgTlByb2dyZXNzLnRyaWNrbGUoKTtcbiAgICAgICAgd29yaygpO1xuICAgICAgfSwgU2V0dGluZ3MudHJpY2tsZVNwZWVkKTtcbiAgICB9O1xuXG4gICAgaWYgKFNldHRpbmdzLnRyaWNrbGUpIHdvcmsoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGlzIGlzIHRoZSAqc29ydCBvZiogdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDEwMCUsIHdpdGggdGhlXG4gICAqIGRpZmZlcmVuY2UgYmVpbmcgYGRvbmUoKWAgbWFrZXMgc29tZSBwbGFjZWJvIGVmZmVjdCBvZiBzb21lIHJlYWxpc3RpYyBtb3Rpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuZG9uZSgpO1xuICAgKlxuICAgKiBJZiBgdHJ1ZWAgaXMgcGFzc2VkLCBpdCB3aWxsIHNob3cgdGhlIHByb2dyZXNzIGJhciBldmVuIGlmIGl0cyBoaWRkZW4uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuZG9uZSh0cnVlKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLmRvbmUgPSBmdW5jdGlvbihmb3JjZSkge1xuICAgIGlmICghZm9yY2UgJiYgIU5Qcm9ncmVzcy5zdGF0dXMpIHJldHVybiB0aGlzO1xuXG4gICAgcmV0dXJuIE5Qcm9ncmVzcy5pbmMoMC4zICsgMC41ICogTWF0aC5yYW5kb20oKSkuc2V0KDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIGJ5IGEgcmFuZG9tIGFtb3VudC5cbiAgICovXG5cbiAgTlByb2dyZXNzLmluYyA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIHZhciBuID0gTlByb2dyZXNzLnN0YXR1cztcblxuICAgIGlmICghbikge1xuICAgICAgcmV0dXJuIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgYW1vdW50ID0gKDEgLSBuKSAqIGNsYW1wKE1hdGgucmFuZG9tKCkgKiBuLCAwLjEsIDAuOTUpO1xuICAgICAgfVxuXG4gICAgICBuID0gY2xhbXAobiArIGFtb3VudCwgMCwgMC45OTQpO1xuICAgICAgcmV0dXJuIE5Qcm9ncmVzcy5zZXQobik7XG4gICAgfVxuICB9O1xuXG4gIE5Qcm9ncmVzcy50cmlja2xlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE5Qcm9ncmVzcy5pbmMoTWF0aC5yYW5kb20oKSAqIFNldHRpbmdzLnRyaWNrbGVSYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIGFsbCBzdXBwbGllZCBqUXVlcnkgcHJvbWlzZXMgYW5kXG4gICAqIGluY3JlYXNlcyB0aGUgcHJvZ3Jlc3MgYXMgdGhlIHByb21pc2VzIHJlc29sdmUuXG4gICAqXG4gICAqIEBwYXJhbSAkcHJvbWlzZSBqUVVlcnkgUHJvbWlzZVxuICAgKi9cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbml0aWFsID0gMCwgY3VycmVudCA9IDA7XG5cbiAgICBOUHJvZ3Jlc3MucHJvbWlzZSA9IGZ1bmN0aW9uKCRwcm9taXNlKSB7XG4gICAgICBpZiAoISRwcm9taXNlIHx8ICRwcm9taXNlLnN0YXRlKCkgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWwrKztcbiAgICAgIGN1cnJlbnQrKztcblxuICAgICAgJHByb21pc2UuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJyZW50LS07XG4gICAgICAgIGlmIChjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgICBpbml0aWFsID0gMDtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBOUHJvZ3Jlc3Muc2V0KChpbml0aWFsIC0gY3VycmVudCkgLyBpbml0aWFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSByZW5kZXJzIHRoZSBwcm9ncmVzcyBiYXIgbWFya3VwIGJhc2VkIG9uIHRoZSBgdGVtcGxhdGVgXG4gICAqIHNldHRpbmcuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5yZW5kZXIgPSBmdW5jdGlvbihmcm9tU3RhcnQpIHtcbiAgICBpZiAoTlByb2dyZXNzLmlzUmVuZGVyZWQoKSkgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcblxuICAgIGFkZENsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ25wcm9ncmVzcy1idXN5Jyk7XG4gICAgXG4gICAgdmFyIHByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJvZ3Jlc3MuaWQgPSAnbnByb2dyZXNzJztcbiAgICBwcm9ncmVzcy5pbm5lckhUTUwgPSBTZXR0aW5ncy50ZW1wbGF0ZTtcblxuICAgIHZhciBiYXIgICAgICA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MuYmFyU2VsZWN0b3IpLFxuICAgICAgICBwZXJjICAgICA9IGZyb21TdGFydCA/ICctMTAwJyA6IHRvQmFyUGVyYyhOUHJvZ3Jlc3Muc3RhdHVzIHx8IDApLFxuICAgICAgICBwYXJlbnQgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MucGFyZW50KSxcbiAgICAgICAgc3Bpbm5lcjtcbiAgICBcbiAgICBjc3MoYmFyLCB7XG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAgbGluZWFyJyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBwZXJjICsgJyUsMCwwKSdcbiAgICB9KTtcblxuICAgIGlmICghU2V0dGluZ3Muc2hvd1NwaW5uZXIpIHtcbiAgICAgIHNwaW5uZXIgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnNwaW5uZXJTZWxlY3Rvcik7XG4gICAgICBzcGlubmVyICYmIHJlbW92ZUVsZW1lbnQoc3Bpbm5lcik7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudCAhPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBhZGRDbGFzcyhwYXJlbnQsICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIH1cblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwcm9ncmVzcyk7XG4gICAgcmV0dXJuIHByb2dyZXNzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50LiBPcHBvc2l0ZSBvZiByZW5kZXIoKS5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ25wcm9ncmVzcy1idXN5Jyk7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLCAnbnByb2dyZXNzLWN1c3RvbS1wYXJlbnQnKTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbnByb2dyZXNzJyk7XG4gICAgcHJvZ3Jlc3MgJiYgcmVtb3ZlRWxlbWVudChwcm9ncmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHJlbmRlcmVkLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaXNSZW5kZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoaWNoIHBvc2l0aW9uaW5nIENTUyBydWxlIHRvIHVzZS5cbiAgICovXG5cbiAgTlByb2dyZXNzLmdldFBvc2l0aW9uaW5nQ1NTID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gU25pZmYgb24gZG9jdW1lbnQuYm9keS5zdHlsZVxuICAgIHZhciBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG4gICAgLy8gU25pZmYgcHJlZml4ZXNcbiAgICB2YXIgdmVuZG9yUHJlZml4ID0gKCdXZWJraXRUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnV2Via2l0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnTW96VHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ01veicgOlxuICAgICAgICAgICAgICAgICAgICAgICAoJ21zVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ21zJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnT1RyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdPJyA6ICcnO1xuXG4gICAgaWYgKHZlbmRvclByZWZpeCArICdQZXJzcGVjdGl2ZScgaW4gYm9keVN0eWxlKSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgd2l0aCAzRCBzdXBwb3J0LCBlLmcuIFdlYmtpdCwgSUUxMFxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUzZCc7XG4gICAgfSBlbHNlIGlmICh2ZW5kb3JQcmVmaXggKyAnVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIEJyb3dzZXJzIHdpdGhvdXQgM0Qgc3VwcG9ydCwgZS5nLiBJRTlcbiAgICAgIHJldHVybiAndHJhbnNsYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCB0cmFuc2xhdGUoKSBzdXBwb3J0LCBlLmcuIElFNy04XG4gICAgICByZXR1cm4gJ21hcmdpbic7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsYW1wKG4sIG1pbiwgbWF4KSB7XG4gICAgaWYgKG4gPCBtaW4pIHJldHVybiBtaW47XG4gICAgaWYgKG4gPiBtYXgpIHJldHVybiBtYXg7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBjb252ZXJ0cyBhIHBlcmNlbnRhZ2UgKGAwLi4xYCkgdG8gYSBiYXIgdHJhbnNsYXRlWFxuICAgKiBwZXJjZW50YWdlIChgLTEwMCUuLjAlYCkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvQmFyUGVyYyhuKSB7XG4gICAgcmV0dXJuICgtMSArIG4pICogMTAwO1xuICB9XG5cblxuICAvKipcbiAgICogKEludGVybmFsKSByZXR1cm5zIHRoZSBjb3JyZWN0IENTUyBmb3IgY2hhbmdpbmcgdGhlIGJhcidzXG4gICAqIHBvc2l0aW9uIGdpdmVuIGFuIG4gcGVyY2VudGFnZSwgYW5kIHNwZWVkIGFuZCBlYXNlIGZyb20gU2V0dGluZ3NcbiAgICovXG5cbiAgZnVuY3Rpb24gYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpIHtcbiAgICB2YXIgYmFyQ1NTO1xuXG4gICAgaWYgKFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09ICd0cmFuc2xhdGUzZCcpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyt0b0JhclBlcmMobikrJyUsMCwwKScgfTtcbiAgICB9IGVsc2UgaWYgKFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09ICd0cmFuc2xhdGUnKSB7XG4gICAgICBiYXJDU1MgPSB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnK3RvQmFyUGVyYyhuKSsnJSwwKScgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyQ1NTID0geyAnbWFyZ2luLWxlZnQnOiB0b0JhclBlcmMobikrJyUnIH07XG4gICAgfVxuXG4gICAgYmFyQ1NTLnRyYW5zaXRpb24gPSAnYWxsICcrc3BlZWQrJ21zICcrZWFzZTtcblxuICAgIHJldHVybiBiYXJDU1M7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBRdWV1ZXMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICovXG5cbiAgdmFyIHF1ZXVlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nID0gW107XG4gICAgXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBmbiA9IHBlbmRpbmcuc2hpZnQoKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHBlbmRpbmcucHVzaChmbik7XG4gICAgICBpZiAocGVuZGluZy5sZW5ndGggPT0gMSkgbmV4dCgpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgQXBwbGllcyBjc3MgcHJvcGVydGllcyB0byBhbiBlbGVtZW50LCBzaW1pbGFyIHRvIHRoZSBqUXVlcnkgXG4gICAqIGNzcyBtZXRob2QuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgaGVscGVyIGRvZXMgYXNzaXN0IHdpdGggdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5IG5hbWVzLCBpdCBcbiAgICogZG9lcyBub3QgcGVyZm9ybSBhbnkgbWFuaXB1bGF0aW9uIG9mIHZhbHVlcyBwcmlvciB0byBzZXR0aW5nIHN0eWxlcy5cbiAgICovXG5cbiAgdmFyIGNzcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY3NzUHJlZml4ZXMgPSBbICdXZWJraXQnLCAnTycsICdNb3onLCAnbXMnIF0sXG4gICAgICAgIGNzc1Byb3BzICAgID0ge307XG5cbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL14tbXMtLywgJ21zLScpLnJlcGxhY2UoLy0oW1xcZGEtel0pL2dpLCBmdW5jdGlvbihtYXRjaCwgbGV0dGVyKSB7XG4gICAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlbmRvclByb3AobmFtZSkge1xuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgIGlmIChuYW1lIGluIHN0eWxlKSByZXR1cm4gbmFtZTtcblxuICAgICAgdmFyIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGgsXG4gICAgICAgICAgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuICAgICAgICAgIHZlbmRvck5hbWU7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZlbmRvck5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XG4gICAgICAgIGlmICh2ZW5kb3JOYW1lIGluIHN0eWxlKSByZXR1cm4gdmVuZG9yTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3R5bGVQcm9wKG5hbWUpIHtcbiAgICAgIG5hbWUgPSBjYW1lbENhc2UobmFtZSk7XG4gICAgICByZXR1cm4gY3NzUHJvcHNbbmFtZV0gfHwgKGNzc1Byb3BzW25hbWVdID0gZ2V0VmVuZG9yUHJvcChuYW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3AgPSBnZXRTdHlsZVByb3AocHJvcCk7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHByb3AsIFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMikge1xuICAgICAgICBmb3IgKHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3ApKSBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5Q3NzKGVsZW1lbnQsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgfVxuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBEZXRlcm1pbmVzIGlmIGFuIGVsZW1lbnQgb3Igc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3MgbmFtZXMgY29udGFpbnMgYSBjbGFzcyBuYW1lLlxuICAgKi9cblxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIGxpc3QgPSB0eXBlb2YgZWxlbWVudCA9PSAnc3RyaW5nJyA/IGVsZW1lbnQgOiBjbGFzc0xpc3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIGxpc3QuaW5kZXhPZignICcgKyBuYW1lICsgJyAnKSA+PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgQWRkcyBhIGNsYXNzIHRvIGFuIGVsZW1lbnQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgb2xkTGlzdCA9IGNsYXNzTGlzdChlbGVtZW50KSxcbiAgICAgICAgbmV3TGlzdCA9IG9sZExpc3QgKyBuYW1lO1xuXG4gICAgaWYgKGhhc0NsYXNzKG9sZExpc3QsIG5hbWUpKSByZXR1cm47IFxuXG4gICAgLy8gVHJpbSB0aGUgb3BlbmluZyBzcGFjZS5cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUmVtb3ZlcyBhIGNsYXNzIGZyb20gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0O1xuXG4gICAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBuYW1lKSkgcmV0dXJuO1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgY2xhc3MgbmFtZS5cbiAgICBuZXdMaXN0ID0gb2xkTGlzdC5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHNwYWNlcy5cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEsIG5ld0xpc3QubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBHZXRzIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGNsYXNzIG5hbWVzIG9uIHRoZSBlbGVtZW50LiBcbiAgICogVGhlIGxpc3QgaXMgd3JhcHBlZCB3aXRoIGEgc2luZ2xlIHNwYWNlIG9uIGVhY2ggZW5kIHRvIGZhY2lsaXRhdGUgZmluZGluZyBcbiAgICogbWF0Y2hlcyB3aXRoaW4gdGhlIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsYXNzTGlzdChlbGVtZW50KSB7XG4gICAgcmV0dXJuICgnICcgKyAoZWxlbWVudC5jbGFzc05hbWUgfHwgJycpICsgJyAnKS5yZXBsYWNlKC9cXHMrL2dpLCAnICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIE5Qcm9ncmVzcztcbn0pO1xuXG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmlzTm90aGluZyAgICAgID0gaXNOb3RoaW5nO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICAgICAgPSBpc09iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgICAgICAgID0gdG9BcnJheTtcbm1vZHVsZS5leHBvcnRzLnJlcGVhdCAgICAgICAgID0gcmVwZWF0O1xubW9kdWxlLmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBpc05lZ2F0aXZlWmVybztcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCAgICAgICAgID0gZXh0ZW5kO1xuIiwgIi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuLy9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKSArICh0aGlzLm1hcmsgPyAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKSA6ICcnKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZSArICc6ICc7XG5cbiAgcmVzdWx0ICs9IHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5mdW5jdGlvbiBNYXJrKG5hbWUsIGJ1ZmZlciwgcG9zaXRpb24sIGxpbmUsIGNvbHVtbikge1xuICB0aGlzLm5hbWUgICAgID0gbmFtZTtcbiAgdGhpcy5idWZmZXIgICA9IGJ1ZmZlcjtcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcbn1cblxuXG5NYXJrLnByb3RvdHlwZS5nZXRTbmlwcGV0ID0gZnVuY3Rpb24gZ2V0U25pcHBldChpbmRlbnQsIG1heExlbmd0aCkge1xuICB2YXIgaGVhZCwgc3RhcnQsIHRhaWwsIGVuZCwgc25pcHBldDtcblxuICBpZiAoIXRoaXMuYnVmZmVyKSByZXR1cm4gbnVsbDtcblxuICBpbmRlbnQgPSBpbmRlbnQgfHwgNDtcbiAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDc1O1xuXG4gIGhlYWQgPSAnJztcbiAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChzdGFydCA+IDAgJiYgJ1xceDAwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScuaW5kZXhPZih0aGlzLmJ1ZmZlci5jaGFyQXQoc3RhcnQgLSAxKSkgPT09IC0xKSB7XG4gICAgc3RhcnQgLT0gMTtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiAtIHN0YXJ0ID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgaGVhZCA9ICcgLi4uICc7XG4gICAgICBzdGFydCArPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGFpbCA9ICcnO1xuICBlbmQgPSB0aGlzLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChlbmQgPCB0aGlzLmJ1ZmZlci5sZW5ndGggJiYgJ1xceDAwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScuaW5kZXhPZih0aGlzLmJ1ZmZlci5jaGFyQXQoZW5kKSkgPT09IC0xKSB7XG4gICAgZW5kICs9IDE7XG4gICAgaWYgKGVuZCAtIHRoaXMucG9zaXRpb24gPiAobWF4TGVuZ3RoIC8gMiAtIDEpKSB7XG4gICAgICB0YWlsID0gJyAuLi4gJztcbiAgICAgIGVuZCAtPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc25pcHBldCA9IHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50KSArIGhlYWQgKyBzbmlwcGV0ICsgdGFpbCArICdcXG4nICtcbiAgICAgICAgIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQgKyB0aGlzLnBvc2l0aW9uIC0gc3RhcnQgKyBoZWFkLmxlbmd0aCkgKyAnXic7XG59O1xuXG5cbk1hcmsucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgc25pcHBldCwgd2hlcmUgPSAnJztcblxuICBpZiAodGhpcy5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIHRoaXMubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJ2F0IGxpbmUgJyArICh0aGlzLmxpbmUgKyAxKSArICcsIGNvbHVtbiAnICsgKHRoaXMuY29sdW1uICsgMSk7XG5cbiAgaWYgKCFjb21wYWN0KSB7XG4gICAgc25pcHBldCA9IHRoaXMuZ2V0U25pcHBldCgpO1xuXG4gICAgaWYgKHNuaXBwZXQpIHtcbiAgICAgIHdoZXJlICs9ICc6XFxuJyArIHNuaXBwZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdoZXJlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcms7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG5cbnZhciBUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMgPSBbXG4gICdraW5kJyxcbiAgJ3Jlc29sdmUnLFxuICAnY29uc3RydWN0JyxcbiAgJ2luc3RhbmNlT2YnLFxuICAncHJlZGljYXRlJyxcbiAgJ3JlcHJlc2VudCcsXG4gICdkZWZhdWx0U3R5bGUnLFxuICAnc3R5bGVBbGlhc2VzJ1xuXTtcblxudmFyIFlBTUxfTk9ERV9LSU5EUyA9IFtcbiAgJ3NjYWxhcicsXG4gICdzZXF1ZW5jZScsXG4gICdtYXBwaW5nJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlQWxpYXNlcyhtYXApIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBtYXBbc3R5bGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBUeXBlKHRhZywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24gb3B0aW9uIFwiJyArIG5hbWUgKyAnXCIgaXMgbWV0IGluIGRlZmluaXRpb24gb2YgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxuICB0aGlzLnRhZyAgICAgICAgICA9IHRhZztcbiAgdGhpcy5raW5kICAgICAgICAgPSBvcHRpb25zWydraW5kJ10gICAgICAgICB8fCBudWxsO1xuICB0aGlzLnJlc29sdmUgICAgICA9IG9wdGlvbnNbJ3Jlc29sdmUnXSAgICAgIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gIHRoaXMuY29uc3RydWN0ICAgID0gb3B0aW9uc1snY29uc3RydWN0J10gICAgfHwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH07XG4gIHRoaXMuaW5zdGFuY2VPZiAgID0gb3B0aW9uc1snaW5zdGFuY2VPZiddICAgfHwgbnVsbDtcbiAgdGhpcy5wcmVkaWNhdGUgICAgPSBvcHRpb25zWydwcmVkaWNhdGUnXSAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudCAgICA9IG9wdGlvbnNbJ3JlcHJlc2VudCddICAgIHx8IG51bGw7XG4gIHRoaXMuZGVmYXVsdFN0eWxlID0gb3B0aW9uc1snZGVmYXVsdFN0eWxlJ10gfHwgbnVsbDtcbiAgdGhpcy5zdHlsZUFsaWFzZXMgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmIChZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIGtpbmQgXCInICsgdGhpcy5raW5kICsgJ1wiIGlzIHNwZWNpZmllZCBmb3IgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJiBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCkge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBleGNsdWRlLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge31cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHRoaXMuaW5jbHVkZSAgPSBkZWZpbml0aW9uLmluY2x1ZGUgIHx8IFtdO1xuICB0aGlzLmltcGxpY2l0ID0gZGVmaW5pdGlvbi5pbXBsaWNpdCB8fCBbXTtcbiAgdGhpcy5leHBsaWNpdCA9IGRlZmluaXRpb24uZXhwbGljaXQgfHwgW107XG5cbiAgdGhpcy5pbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgdHlwZS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdpbXBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2V4cGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkVHlwZU1hcCAgPSBjb21waWxlTWFwKHRoaXMuY29tcGlsZWRJbXBsaWNpdCwgdGhpcy5jb21waWxlZEV4cGxpY2l0KTtcbn1cblxuXG5TY2hlbWEuREVGQVVMVCA9IG51bGw7XG5cblxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcbiAgdmFyIHNjaGVtYXMsIHR5cGVzO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBzY2hlbWFzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiAnJzsgfVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdOyB9XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG4iLCAiLy8gU3RhbmRhcmQgWUFNTCdzIEZhaWxzYWZlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMjM0NlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3N0cicpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2VxJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tYXAnKVxuICBdXG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBCb29sZWFuXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcblxuICBjaCA9IGRhdGFbaW5kZXhdO1xuXG4gIC8vIHNpZ25cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgLy8gMFxuICAgIGlmIChpbmRleCArIDEgPT09IG1heCkgcmV0dXJuIHRydWU7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuXG4gICAgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMCkgb3IgYmFzZSA2MFxuXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG4gIGlmIChjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKGNoID09PSAnOicpIGJyZWFrO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG4gIGlmICghaGFzRGlnaXRzIHx8IGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICAvLyBpZiAhYmFzZTYwIC0gZG9uZTtcbiAgaWYgKGNoICE9PSAnOicpIHJldHVybiB0cnVlO1xuXG4gIC8vIGJhc2U2MCBhbG1vc3Qgbm90IHVzZWQsIG5vIG5lZWRzIHRvIG9wdGltaXplXG4gIHJldHVybiAvXig6WzAtNV0/WzAtOV0pKyQvLnRlc3QoZGF0YS5zbGljZShpbmRleCkpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sSW50ZWdlcihkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEsIHNpZ24gPSAxLCBjaCwgYmFzZSwgZGlnaXRzID0gW107XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUludCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IChkICogYmFzZSk7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBiJyArIG9iai50b1N0cmluZygyKSA6ICctMGInICsgb2JqLnRvU3RyaW5nKDIpLnNsaWNlKDEpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwJyAgKyBvYmoudG9TdHJpbmcoOCkgOiAnLTAnICArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTsgfSxcbiAgICBkZWNpbWFsOiAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTsgfSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSA6ICAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OjB8WzEtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLjJlNCwgLjJcbiAgLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gMjA6NTlcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignOicpID49IDApIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuXG52YXIgU0NJRU5USUZJQ19XSVRIT1VUX0RPVCA9IC9eWy0rXT9bMC05XStlLztcblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLm5hbic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5OQU4nO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICctLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy0uSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH1cblxuICByZXMgPSBvYmplY3QudG9TdHJpbmcoMTApO1xuXG4gIC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJykgJiZcbiAgICAgICAgIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCAiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAzMjMxXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgdGhpcyBzY2hlbWEgaXMgbm90IHN1Y2ggc3RyaWN0IGFzIGRlZmluZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vIEl0IGFsbG93cyBudW1iZXJzIGluIGJpbmFyeSBub3RhaW9uLCB1c2UgYE51bGxgIGFuZCBgTlVMTGAgYXMgYG51bGxgLCBldGMuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9mYWlsc2FmZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9udWxsJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9ib29sJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Zsb2F0JylcbiAgXVxufSk7XG4iLCAiLy8gU3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODA0OTIzXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgQ29yZSBzY2hlbWEgaGFzIG5vIGRpc3RpbmN0aW9ucyBmcm9tIEpTT04gc2NoZW1hIGlzIEpTLVlBTUwuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9qc29uJylcbiAgXVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfREFURV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldKSQnKTsgICAgICAgICAgICAgICAgICAgLy8gWzNdIGRheVxuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/JCcpOyAgICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAobWF0Y2hbOV0gPT09ICctJykgZGVsdGEgPSAtZGVsdGE7XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICc8PCcgfHwgZGF0YSA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG5cbnZhciBOb2RlQnVmZmVyO1xuXG50cnkge1xuICAvLyBBIHRyaWNrIGZvciBicm93c2VyaWZpZWQgdmVyc2lvbiwgdG8gbm90IGluY2x1ZGUgYEJ1ZmZlcmAgc2hpbVxuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICBOb2RlQnVmZmVyID0gX3JlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbn0gY2F0Y2ggKF9fKSB7fVxuXG52YXIgVHlwZSAgICAgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuXG4vLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG52YXIgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVxcblxccic7XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgY29kZSA9IG1hcC5pbmRleE9mKGRhdGEuY2hhckF0KGlkeCkpO1xuXG4gICAgLy8gU2tpcCBDUi9MRlxuICAgIGlmIChjb2RlID4gNjQpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTApICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMikgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA0KSAmIDB4RkYpO1xuICB9XG5cbiAgLy8gV3JhcCBpbnRvIEJ1ZmZlciBmb3IgTm9kZUpTIGFuZCBsZWF2ZSBBcnJheSBmb3IgYnJvd3NlclxuICBpZiAoTm9kZUJ1ZmZlcikge1xuICAgIC8vIFN1cHBvcnQgbm9kZSA2LisgQnVmZmVyIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgIHJldHVybiBOb2RlQnVmZmVyLmZyb20gPyBOb2RlQnVmZmVyLmZyb20ocmVzdWx0KSA6IG5ldyBOb2RlQnVmZmVyKHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sQmluYXJ5KG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJycsIGJpdHMgPSAwLCBpZHgsIHRhaWwsXG4gICAgICBtYXggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IGV2ZXJ5IHRocmVlIGJ5dGVzIHRvIDQgQVNDSUkgY2hhcmFjdGVycy5cblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDMgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgOCkgKyBvYmplY3RbaWR4XTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWwgPSBtYXggJSAzO1xuXG4gIGlmICh0YWlsID09PSAwKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAyKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDEpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNCaW5hcnkob2JqZWN0KSB7XG4gIHJldHVybiBOb2RlQnVmZmVyICYmIE5vZGVCdWZmZXIuaXNCdWZmZXIob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCaW5hcnksXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJpbmFyeSxcbiAgcHJlZGljYXRlOiBpc0JpbmFyeSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sQmluYXJ5XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChwYWlyS2V5IGluIHBhaXIpIHtcbiAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChwYWlyLCBwYWlyS2V5KSkge1xuICAgICAgICBpZiAoIXBhaXJIYXNLZXkpIHBhaXJIYXNLZXkgPSB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhaXJIYXNLZXkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkgPT09IC0xKSBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE9tYXAoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxPbWFwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxPbWFwXG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sU2V0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxTZXRcbn0pO1xuIiwgIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYHNhZmVMb2FkYCBmdW5jdGlvbi5cbi8vIEl0IGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vXG4vLyBUaGlzIHNjaGVtYSBpcyBiYXNlZCBvbiBzdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEgYW5kIGluY2x1ZGVzIG1vc3Qgb2Zcbi8vIGV4dHJhIHR5cGVzIGRlc2NyaWJlZCBhdCBZQU1MIHRhZyByZXBvc2l0b3J5LiAoaHR0cDovL3lhbWwub3JnL3R5cGUvKVxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vY29yZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS90aW1lc3RhbXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21lcmdlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2JpbmFyeScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvb21hcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvcGFpcnMnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NldCcpXG4gIF1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3VuZGVmaW5lZCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQsXG4gIHByZWRpY2F0ZTogaXNVbmRlZmluZWQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZFxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG5cbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA+IDMpIHJldHVybiBmYWxzZTtcbiAgICAvLyBpZiBleHByZXNzaW9uIHN0YXJ0cyB3aXRoIC8sIGlzIHNob3VsZCBiZSBwcm9wZXJseSB0ZXJtaW5hdGVkXG4gICAgaWYgKHJlZ2V4cFtyZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDFdICE9PSAnLycpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuICBpZiAocmVnZXhwWzBdID09PSAnLycpIHtcbiAgICBpZiAodGFpbCkgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICByZWdleHAgPSByZWdleHAuc2xpY2UoMSwgcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcvJyArIG9iamVjdC5zb3VyY2UgKyAnLyc7XG5cbiAgaWYgKG9iamVjdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNwcmltYTtcblxuLy8gQnJvd3NlcmlmaWVkIHZlcnNpb24gZG9lcyBub3QgaGF2ZSBlc3ByaW1hXG4vL1xuLy8gMS4gRm9yIG5vZGUuanMganVzdCByZXF1aXJlIG1vZHVsZSBhcyBkZXBzXG4vLyAyLiBGb3IgYnJvd3NlciB0cnkgdG8gcmVxdWlyZSBtdWR1bGUgdmlhIGV4dGVybmFsIEFNRCBzeXN0ZW0uXG4vLyAgICBJZiBub3QgZm91bmQgLSB0cnkgdG8gZmFsbGJhY2sgdG8gd2luZG93LmVzcHJpbWEuIElmIG5vdFxuLy8gICAgZm91bmQgdG9vIC0gdGhlbiBmYWlsIHRvIHBhcnNlLlxuLy9cbnRyeSB7XG4gIC8vIHdvcmthcm91bmQgdG8gZXhjbHVkZSBwYWNrYWdlIGZyb20gYnJvd3NlcmlmeSBsaXN0LlxuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICBlc3ByaW1hID0gX3JlcXVpcmUoJ2VzcHJpbWEnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG4gIC8qIGdsb2JhbCB3aW5kb3cgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBlc3ByaW1hID0gd2luZG93LmVzcHJpbWE7XG59XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgICBhc3QgICAgPSBlc3ByaW1hLnBhcnNlKHNvdXJjZSwgeyByYW5nZTogdHJ1ZSB9KTtcblxuICAgIGlmIChhc3QudHlwZSAgICAgICAgICAgICAgICAgICAgIT09ICdQcm9ncmFtJyAgICAgICAgICAgICB8fFxuICAgICAgICBhc3QuYm9keS5sZW5ndGggICAgICAgICAgICAgIT09IDEgICAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgICBhc3QuYm9keVswXS50eXBlICAgICAgICAgICAgIT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyB8fFxuICAgICAgICAoYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nICYmXG4gICAgICAgICAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIC8qanNsaW50IGV2aWw6dHJ1ZSovXG5cbiAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICBhc3QgICAgPSBlc3ByaW1hLnBhcnNlKHNvdXJjZSwgeyByYW5nZTogdHJ1ZSB9KSxcbiAgICAgIHBhcmFtcyA9IFtdLFxuICAgICAgYm9keTtcblxuICBpZiAoYXN0LnR5cGUgICAgICAgICAgICAgICAgICAgICE9PSAnUHJvZ3JhbScgICAgICAgICAgICAgfHxcbiAgICAgIGFzdC5ib2R5Lmxlbmd0aCAgICAgICAgICAgICAhPT0gMSAgICAgICAgICAgICAgICAgICAgIHx8XG4gICAgICBhc3QuYm9keVswXS50eXBlICAgICAgICAgICAgIT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyB8fFxuICAgICAgKGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyAmJlxuICAgICAgICBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdGdW5jdGlvbkV4cHJlc3Npb24nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcGFyYW1zLnB1c2gocGFyYW0ubmFtZSk7XG4gIH0pO1xuXG4gIGJvZHkgPSBhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2U7XG5cbiAgLy8gRXNwcmltYSdzIHJhbmdlcyBpbmNsdWRlIHRoZSBmaXJzdCAneycgYW5kIHRoZSBsYXN0ICd9JyBjaGFyYWN0ZXJzIG9uXG4gIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb25zLiBTbyBjdXQgdGhlbSBvdXQuXG4gIGlmIChhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMqL1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSArIDEsIGJvZHlbMV0gLSAxKSk7XG4gIH1cbiAgLy8gRVM2IGFycm93IGZ1bmN0aW9ucyBjYW4gb21pdCB0aGUgQmxvY2tTdGF0ZW1lbnQuIEluIHRoYXQgY2FzZSwganVzdCByZXR1cm5cbiAgLy8gdGhlIGJvZHkuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMqL1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKHBhcmFtcywgJ3JldHVybiAnICsgc291cmNlLnNsaWNlKGJvZHlbMF0sIGJvZHlbMV0pKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvZnVuY3Rpb24nLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRGdW5jdGlvbixcbiAgcHJlZGljYXRlOiBpc0Z1bmN0aW9uLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvblxufSk7XG4iLCAiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgbG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gSlMtWUFNTCdzIGRlZmF1bHQgc2FmZSBzY2hlbWEgYW5kIGluY2x1ZGVzXG4vLyBKYXZhU2NyaXB0LXNwZWNpZmljIHR5cGVzOiAhIWpzL3VuZGVmaW5lZCwgISFqcy9yZWdleHAgYW5kICEhanMvZnVuY3Rpb24uXG4vL1xuLy8gQWxzbyB0aGlzIHNjaGVtYSBpcyB1c2VkIGFzIGRlZmF1bHQgYmFzZSBzY2hlbWEgYXQgYFNjaGVtYS5jcmVhdGVgIGZ1bmN0aW9uLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWEuREVGQVVMVCA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9kZWZhdWx0X3NhZmUnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvdW5kZWZpbmVkJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9yZWdleHAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL2Z1bmN0aW9uJylcbiAgXVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgTWFyayAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWFyaycpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiBjID09PSAweDJDLyogLCAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1Qi8qIFsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUQvKiBdICovIHx8XG4gICAgICAgICBjID09PSAweDdCLyogeyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3RC8qIH0gKi87XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDBcbiAgKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICB0aGlzLmZpbGVuYW1lICA9IG9wdGlvbnNbJ2ZpbGVuYW1lJ10gIHx8IG51bGw7XG4gIHRoaXMuc2NoZW1hICAgID0gb3B0aW9uc1snc2NoZW1hJ10gICAgfHwgREVGQVVMVF9GVUxMX1NDSEVNQTtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuICB0aGlzLmpzb24gICAgICA9IG9wdGlvbnNbJ2pzb24nXSAgICAgIHx8IGZhbHNlO1xuICB0aGlzLmxpc3RlbmVyICA9IG9wdGlvbnNbJ2xpc3RlbmVyJ10gIHx8IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihcbiAgICBtZXNzYWdlLFxuICAgIG5ldyBNYXJrKHN0YXRlLmZpbGVuYW1lLCBzdGF0ZS5pbnB1dCwgc3RhdGUucG9zaXRpb24sIHN0YXRlLmxpbmUsIChzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydCkpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCBoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHByZWZpeCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS50YWdNYXBbaGFuZGxlXSA9IHByZWZpeDtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7IF9wb3NpdGlvbiA8IF9sZW5ndGg7IF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoX2NoYXJhY3RlciA9PT0gMHgwOSB8fFxuICAgICAgICAgICAgICAoMHgyMCA8PSBfY2hhcmFjdGVyICYmIF9jaGFyYWN0ZXIgPD0gMHgxMEZGRkYpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChfcmVzdWx0KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdWx0ICs9IF9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgZGVzdGluYXRpb24sIHNvdXJjZSwgb3ZlcnJpZGFibGVLZXlzKSB7XG4gIHZhciBzb3VyY2VLZXlzLCBrZXksIGluZGV4LCBxdWFudGl0eTtcblxuICBpZiAoIWNvbW1vbi5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlJyk7XG4gIH1cblxuICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuXG4gICAgaWYgKCFfaGFzT3duUHJvcGVydHkuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBzdGFydExpbmUsIHN0YXJ0UG9zKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG4gIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGtleU5vZGUgPSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkuY2FsbChvdmVycmlkYWJsZUtleXMsIGtleU5vZGUpICYmXG4gICAgICAgIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsIGtleU5vZGUpKSB7XG4gICAgICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lIHx8IHN0YXRlLmxpbmU7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXJ0UG9zIHx8IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0ZWQgbWFwcGluZyBrZXknKTtcbiAgICB9XG4gICAgX3Jlc3VsdFtrZXlOb2RlXSA9IHZhbHVlTm9kZTtcbiAgICBkZWxldGUgb3ZlcnJpZGFibGVLZXlzW2tleU5vZGVdO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDBBLyogTEYgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDBELyogQ1IgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiBjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIGNoICE9PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKGNoID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja0luZGVudCAhPT0gLTEgJiYgbGluZUJyZWFrcyAhPT0gMCAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoY2ggPT09IDB4MkQvKiAtICovIHx8IGNoID09PSAweDJFLyogLiAqLykgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDEpICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAyKSkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgfHxcbiAgICAgIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSB8fFxuICAgICAgY2ggPT09IDB4MjMvKiAjICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNi8qICYgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDJBLyogKiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjEvKiAhICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg3Qy8qIHwgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDNFLyogPiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjcvKiAnICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMi8qIFwiICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNS8qICUgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDQwLyogQCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgcHJlY2VkaW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiAtIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKHByZWNlZGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHx8XG4gICAgICAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICAgIGJyZWFrO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2xpbmVJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIC0xKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBjYXB0dXJlRW5kO1xuICAgICAgICBzdGF0ZS5saW5lID0gX2xpbmU7XG4gICAgICAgIHN0YXRlLmxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSBfbGluZUluZGVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBzdGF0ZS5saW5lIC0gX2xpbmUpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG5cbiAgaWYgKHN0YXRlLnJlc3VsdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9IF9raW5kO1xuICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI3LyogJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMi8qIFwiICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjIvKiBcIiAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvLyBUT0RPOiByZXdvcmsgdG8gaW5saW5lIGZuIHdpdGggbm8gdHlwZSBjYXN0P1xuICAgICAgfSBlbHNlIGlmIChjaCA8IDI1NiAmJiBzaW1wbGVFc2NhcGVDaGVja1tjaF0pIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSBpZiAoKHRtcCA9IGVzY2FwZWRIZXhMZW4oY2gpKSA+IDApIHtcbiAgICAgICAgaGV4TGVuZ3RoID0gdG1wO1xuICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgIGZvciAoOyBoZXhMZW5ndGggPiAwOyBoZXhMZW5ndGgtLSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICBoZXhSZXN1bHQgPSAoaGV4UmVzdWx0IDw8IDQpICsgdG1wO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY2hhckZyb21Db2RlcG9pbnQoaGV4UmVzdWx0KTtcblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0ge30sXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQ7LyogXSAqL1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RDsvKiB9ICovXG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJDLyogLCAqLykge1xuICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkTmV4dCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbicpO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGZvbGRpbmcsXG4gICAgICBjaG9tcGluZyAgICAgICA9IENIT01QSU5HX0NMSVAsXG4gICAgICBkaWRSZWFkQ29udGVudCA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSBmYWxzZSxcbiAgICAgIHRleHRJbmRlbnQgICAgID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgICAgID0gMCxcbiAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2UsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Qy8qIHwgKi8pIHtcbiAgICBmb2xkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4M0UvKiA+ICovKSB7XG4gICAgZm9sZGluZyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgICAgaWYgKENIT01QSU5HX0NMSVAgPT09IGNob21waW5nKSB7XG4gICAgICAgIGNob21waW5nID0gKGNoID09PSAweDJCLyogKyAqLykgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGEgY2hvbXBpbmcgbW9kZSBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpO1xuXG4gICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiZcbiAgICAgICAgICAgKGNoID09PSAweDIwLyogU3BhY2UgKi8pKSB7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCFkZXRlY3RlZEluZGVudCAmJiBzdGF0ZS5saW5lSW5kZW50ID4gdGV4dEluZGVudCkge1xuICAgICAgdGV4dEluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGVtcHR5TGluZXMrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkge1xuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBjaG9tcGluZy5cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfS0VFUCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY29udGVudCBsaW5lIChjZi4gRXhhbXBsZSA4LjEpXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG5cbiAgICAgIC8vIEVuZCBvZiBtb3JlLWluZGVudGVkIGJsb2NrLlxuICAgICAgfSBlbHNlIGlmIChhdE1vcmVJbmRlbnRlZCkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBKdXN0IG9uZSBsaW5lIGJyZWFrIC0gcGVyY2VpdmUgYXMgdGhlIHNhbWUgbGluZS5cbiAgICAgIH0gZWxzZSBpZiAoZW1wdHlMaW5lcyA9PT0gMCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHdlIGhhdmUgYWxyZWFkeSByZWFkIHNvbWUgc2NhbGFyIGNvbnRlbnQuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAvLyBTZXZlcmFsIGxpbmUgYnJlYWtzIC0gcGVyY2VpdmUgYXMgZGlmZmVyZW50IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuXG4gICAgLy8gTGl0ZXJhbCBzdHlsZToganVzdCBhZGQgZXhhY3QgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gY29udGVudCBsaW5lcy5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gS2VlcCBhbGwgbGluZSBicmVha3MgZXhjZXB0IHRoZSBoZWFkZXIgbGluZSBicmVhay5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgfVxuXG4gICAgZGlkUmVhZENvbnRlbnQgPSB0cnVlO1xuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgX2xpbmUsXG4gICAgICBfdGFnICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgPSBbXSxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGRldGVjdGVkICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG5cbiAgICBpZiAoY2ggIT09IDB4MkQvKiAtICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBfcmVzdWx0LnB1c2goc3RhdGUucmVzdWx0KTtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIHNlcXVlbmNlIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnc2VxdWVuY2UnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBub2RlSW5kZW50LCBmbG93SW5kZW50KSB7XG4gIHZhciBmb2xsb3dpbmcsXG4gICAgICBhbGxvd0NvbXBhY3QsXG4gICAgICBfbGluZSxcbiAgICAgIF9wb3MsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIC8vXG4gICAgLy8gRXhwbGljaXQgbm90YXRpb24gY2FzZS4gVGhlcmUgYXJlIHR3byBzZXBhcmF0ZSBibG9ja3M6XG4gICAgLy8gZmlyc3QgZm9yIHRoZSBrZXkgKGRlbm90ZWQgYnkgXCI/XCIpIGFuZCBzZWNvbmQgZm9yIHRoZSB2YWx1ZSAoZGVub3RlZCBieSBcIjpcIilcbiAgICAvL1xuICAgIGlmICgoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDNBLyogOiAqLykgJiYgaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcblxuICAgICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkOyBvciBmb2xsb3dlZCBieSBhIG5vbi10YWJ1bGF0ZWQgZW1wdHkgbGluZScpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICAgICAgY2ggPSBmb2xsb3dpbmc7XG5cbiAgICAvL1xuICAgIC8vIEltcGxpY2l0IG5vdGF0aW9uIGNhc2UuIEZsb3ctc3R5bGUgbm9kZSBhcyB0aGUga2V5IGZpcnN0LCB0aGVuIFwiOlwiLCBhbmQgdGhlIHZhbHVlLlxuICAgIC8vXG4gICAgfSBlbHNlIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrOyAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX3Bvcyk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjEvKiAhICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgzQy8qIDwgKi8pIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgY2ggIT09IDB4M0UvKiA+ICovKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCB0YWdIYW5kbGUpKSB7XG4gICAgc3RhdGUudGFnID0gc3RhdGUudGFnTWFwW3RhZ0hhbmRsZV0gKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnIScpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnISEnKSB7XG4gICAgc3RhdGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicgKyB0YWdIYW5kbGUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI2LyogJiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYW4gYW5jaG9yIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgc3RhdGUuYW5jaG9yID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQWxpYXMoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiwgYWxpYXMsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyQS8qICogKi8pIHJldHVybiBmYWxzZTtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbGlhcyBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBhbGlhcyA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUuYW5jaG9yTWFwLCBhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICc/Jykge1xuICAgICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAgIC8vIHRhZywgZm9yIGV4YW1wbGUgbGlrZSB0aGlzOiBcIiE8Pz4gWzBdXCJcbiAgICAgIC8vXG4gICAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPD8+IHRhZzsgaXQgc2hvdWxkIGJlIFwic2NhbGFyXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgICBpZiAodHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXSwgc3RhdGUudGFnKSkge1xuICAgICAgdHlwZSA9IHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXVtzdGF0ZS50YWddO1xuXG4gICAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgc3RhdGUudGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZS5raW5kICsgJ1wiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gdGFnICE8JyArIHN0YXRlLnRhZyArICc+Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgIHN0YXRlLmFuY2hvciAhPT0gbnVsbCB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0ge307XG4gIHN0YXRlLmFuY2hvck1hcCA9IHt9O1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IGNoICE9PSAweDI1LyogJSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkgYnJlYWs7XG5cbiAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVBcmdzLnB1c2goc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbikpO1xuICAgIH1cblxuICAgIGlmIChjaCAhPT0gMCkgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICAgICA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyRS8qIC4gKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEEvKiBMRiAqLyAmJlxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBELyogQ1IgKi8pIHtcbiAgICAgIGlucHV0ICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIEJPTVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGlucHV0LCBvcHRpb25zKTtcblxuICB2YXIgbnVsbHBvcyA9IGlucHV0LmluZGV4T2YoJ1xcMCcpO1xuXG4gIGlmIChudWxscG9zICE9PSAtMSkge1xuICAgIHN0YXRlLnBvc2l0aW9uID0gbnVsbHBvcztcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbnVsbCBieXRlIGlzIG5vdCBhbGxvd2VkIGluIGlucHV0Jyk7XG4gIH1cblxuICAvLyBVc2UgMCBhcyBzdHJpbmcgdGVybWluYXRvci4gVGhhdCBzaWduaWZpY2FudGx5IHNpbXBsaWZpZXMgYm91bmRzIGNoZWNrLlxuICBzdGF0ZS5pbnB1dCArPSAnXFwwJztcblxuICB3aGlsZSAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MjAvKiBTcGFjZSAqLykge1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgKz0gMTtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgcmVhZERvY3VtZW50KHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5kb2N1bWVudHM7XG59XG5cblxuZnVuY3Rpb24gbG9hZEFsbChpbnB1dCwgaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgaWYgKGl0ZXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBpdGVyYXRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGl0ZXJhdG9yO1xuICAgIGl0ZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBpdGVyYXRvcihkb2N1bWVudHNbaW5kZXhdKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0sIGJ1dCBmb3VuZCBtb3JlJyk7XG59XG5cblxuZnVuY3Rpb24gc2FmZUxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIGl0ZXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gbG9hZEFsbChpbnB1dCwgaXRlcmF0b3IsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBsb2FkKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICA9IGxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICA9IGxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCA9IHNhZmVMb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWQgICAgPSBzYWZlTG9hZDtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG5cbiAgaWYgKG1hcCA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gJyEhJykge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuICAgIHR5cGUgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwWydmYWxsYmFjayddW3RhZ107XG5cbiAgICBpZiAodHlwZSAmJiBfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcblxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGNoYXJhY3RlciA8PSAweEZGKSB7XG4gICAgaGFuZGxlID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRikge1xuICAgIGhhbmRsZSA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkZGRkZGKSB7XG4gICAgaGFuZGxlID0gJ1UnO1xuICAgIGxlbmd0aCA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICAgID0gb3B0aW9uc1snc2NoZW1hJ10gfHwgREVGQVVMVF9GVUxMX1NDSEVNQTtcbiAgdGhpcy5pbmRlbnQgICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkICAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgICA9IG9wdGlvbnNbJ25vUmVmcyddIHx8IGZhbHNlO1xuICB0aGlzLm5vQ29tcGF0TW9kZSAgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcblxuICB0aGlzLnRhZyA9IG51bGw7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufVxuXG4vLyBJbmRlbnRzIGV2ZXJ5IGxpbmUgaW4gYSBzdHJpbmcuIEVtcHR5IGxpbmVzIChcXG4gb25seSkgYXJlIG5vdCBpbmRlbnRlZC5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHJlc3VsdCArPSBpbmQ7XG5cbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBjID09PSBDSEFSX1NQQUNFIHx8IGMgPT09IENIQVJfVEFCO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciBjYW4gYmUgcHJpbnRlZCB3aXRob3V0IGVzY2FwaW5nLlxuLy8gRnJvbSBZQU1MIDEuMjogXCJhbnkgYWxsb3dlZCBjaGFyYWN0ZXJzIGtub3duIHRvIGJlIG5vbi1wcmludGFibGVcbi8vIHNob3VsZCBhbHNvIGJlIGVzY2FwZWQuIFtIb3dldmVyLF0gVGhpcyBpc25cdTIwMTl0IG1hbmRhdG9yeVwiXG4vLyBEZXJpdmVkIGZyb20gbmItY2hhciAtIFxcdCAtICN4ODUgLSAjeEEwIC0gI3gyMDI4IC0gI3gyMDI5LlxuZnVuY3Rpb24gaXNQcmludGFibGUoYykge1xuICByZXR1cm4gICgweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSlcbiAgICAgIHx8ICgoMHgwMDBBMSA8PSBjICYmIGMgPD0gMHgwMEQ3RkYpICYmIGMgIT09IDB4MjAyOCAmJiBjICE9PSAweDIwMjkpXG4gICAgICB8fCAoKDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEKSAmJiBjICE9PSAweEZFRkYgLyogQk9NICovKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBbMjRdIGItbGluZS1mZWVkICAgICAgIDo6PSAgICAgI3hBICAgIC8qIExGICovXG4vLyBbMjVdIGItY2FycmlhZ2UtcmV0dXJuIDo6PSAgICAgI3hEICAgIC8qIENSICovXG4vLyBbM10gIGMtYnl0ZS1vcmRlci1tYXJrIDo6PSAgICAgI3hGRUZGXG5mdW5jdGlvbiBpc05zQ2hhcihjKSB7XG4gIHJldHVybiBpc1ByaW50YWJsZShjKSAmJiAhaXNXaGl0ZXNwYWNlKGMpXG4gICAgLy8gYnl0ZS1vcmRlci1tYXJrXG4gICAgJiYgYyAhPT0gMHhGRUZGXG4gICAgLy8gYi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9DQVJSSUFHRV9SRVRVUk5cbiAgICAmJiBjICE9PSBDSEFSX0xJTkVfRkVFRDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmUoYywgcHJldikge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5iLWNoYXIgLSBjLWZsb3ctaW5kaWNhdG9yIC0gXCI6XCIgLSBcIiNcIlxuICAvLyB3aGVyZSBuYi1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItY2hhciAtIGMtYnl0ZS1vcmRlci1tYXJrLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGXG4gICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIC0gXCI6XCIgLSBcIiNcIlxuICAgIC8vIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIFwiI1wiXG4gICAgJiYgYyAhPT0gQ0hBUl9DT0xPTlxuICAgICYmICgoYyAhPT0gQ0hBUl9TSEFSUCkgfHwgKHByZXYgJiYgaXNOc0NoYXIocHJldikpKTtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRlxuICAgICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gICAgLy8gLSAoYy1pbmRpY2F0b3IgOjo9XG4gICAgLy8gXHUyMDFDLVx1MjAxRCB8IFx1MjAxQz9cdTIwMUQgfCBcdTIwMUM6XHUyMDFEIHwgXHUyMDFDLFx1MjAxRCB8IFx1MjAxQ1tcdTIwMUQgfCBcdTIwMUNdXHUyMDFEIHwgXHUyMDFDe1x1MjAxRCB8IFx1MjAxQ31cdTIwMURcbiAgICAmJiBjICE9PSBDSEFSX01JTlVTXG4gICAgJiYgYyAhPT0gQ0hBUl9RVUVTVElPTlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gICAgLy8gfCBcdTIwMUMjXHUyMDFEIHwgXHUyMDFDJlx1MjAxRCB8IFx1MjAxQypcdTIwMUQgfCBcdTIwMUMhXHUyMDFEIHwgXHUyMDFDfFx1MjAxRCB8IFx1MjAxQz1cdTIwMUQgfCBcdTIwMUM+XHUyMDFEIHwgXHUyMDFDJ1x1MjAxRCB8IFx1MjAxQ1wiXHUyMDFEXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUFxuICAgICYmIGMgIT09IENIQVJfQU1QRVJTQU5EXG4gICAgJiYgYyAhPT0gQ0hBUl9BU1RFUklTS1xuICAgICYmIGMgIT09IENIQVJfRVhDTEFNQVRJT05cbiAgICAmJiBjICE9PSBDSEFSX1ZFUlRJQ0FMX0xJTkVcbiAgICAmJiBjICE9PSBDSEFSX0VRVUFMU1xuICAgICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOXG4gICAgJiYgYyAhPT0gQ0hBUl9TSU5HTEVfUVVPVEVcbiAgICAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URVxuICAgIC8vIHwgXHUyMDFDJVx1MjAxRCB8IFx1MjAxQ0BcdTIwMUQgfCBcdTIwMUNgXHUyMDFEKVxuICAgICYmIGMgIT09IENIQVJfUEVSQ0VOVFxuICAgICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVFxuICAgICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufVxuXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpIHtcbiAgdmFyIGxlYWRpbmdTcGFjZVJlID0gL15cXG4qIC87XG4gIHJldHVybiBsZWFkaW5nU3BhY2VSZS50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBTVFlMRV9QTEFJTiAgID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgID0gMixcbiAgICBTVFlMRV9MSVRFUkFMID0gMyxcbiAgICBTVFlMRV9GT0xERUQgID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgID0gNTtcblxuLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cbmZ1bmN0aW9uIGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIGluZGVudFBlckxldmVsLCBsaW5lV2lkdGgsIHRlc3RBbWJpZ3VvdXNUeXBlKSB7XG4gIHZhciBpO1xuICB2YXIgY2hhciwgcHJldl9jaGFyO1xuICB2YXIgaGFzTGluZUJyZWFrID0gZmFsc2U7XG4gIHZhciBoYXNGb2xkYWJsZUxpbmUgPSBmYWxzZTsgLy8gb25seSBjaGVja2VkIGlmIHNob3VsZFRyYWNrV2lkdGhcbiAgdmFyIHNob3VsZFRyYWNrV2lkdGggPSBsaW5lV2lkdGggIT09IC0xO1xuICB2YXIgcHJldmlvdXNMaW5lQnJlYWsgPSAtMTsgLy8gY291bnQgdGhlIGZpcnN0IGxpbmUgY29ycmVjdGx5XG4gIHZhciBwbGFpbiA9IGlzUGxhaW5TYWZlRmlyc3Qoc3RyaW5nLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgJiYgIWlzV2hpdGVzcGFjZShzdHJpbmcuY2hhckNvZGVBdChzdHJpbmcubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChzaW5nbGVMaW5lT25seSkge1xuICAgIC8vIENhc2U6IG5vIGJsb2NrIHN0eWxlcy5cbiAgICAvLyBDaGVjayBmb3IgZGlzYWxsb3dlZCBjaGFyYWN0ZXJzIHRvIHJ1bGUgb3V0IHBsYWluIGFuZCBzaW5nbGUuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcHJldl9jaGFyID0gaSA+IDAgPyBzdHJpbmcuY2hhckNvZGVBdChpIC0gMSkgOiBudWxsO1xuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2X2NoYXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlOiBibG9jayBzdHlsZXMgcGVybWl0dGVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fFxuICAgICAgICAgICAgLy8gRm9sZGFibGUgbGluZSA9IHRvbyBsb25nLCBhbmQgbm90IG1vcmUtaW5kZW50ZWQuXG4gICAgICAgICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpO1xuICAgICAgICAgIHByZXZpb3VzTGluZUJyZWFrID0gaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHByZXZfY2hhciA9IGkgPiAwID8gc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpIDogbnVsbDtcbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldl9jaGFyKTtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICByZXR1cm4gcGxhaW4gJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZylcbiAgICAgID8gU1RZTEVfUExBSU4gOiBTVFlMRV9TSU5HTEU7XG4gIH1cbiAgLy8gRWRnZSBjYXNlOiBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgY2FuIG9ubHkgaGF2ZSBvbmUgZGlnaXQuXG4gIGlmIChpbmRlbnRQZXJMZXZlbCA+IDkgJiYgbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYmxvY2sgc3R5bGVzIGFyZSB2YWxpZC5cbiAgLy8gUHJlZmVyIGxpdGVyYWwgc3R5bGUgdW5sZXNzIHdlIHdhbnQgdG8gZm9sZC5cbiAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG59XG5cbi8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAgXHUyMDIyIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICBcdTIwMjIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgc3RyaW5nLCBsZXZlbCwgaXNrZXkpIHtcbiAgc3RhdGUuZHVtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlICYmXG4gICAgICAgIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYLmluZGV4T2Yoc3RyaW5nKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHN0cmluZyArIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBNYXRoLm1heCgxLCBsZXZlbCk7IC8vIG5vIDAtaW5kZW50IHNjYWxhcnNcbiAgICAvLyBBcyBpbmRlbnRhdGlvbiBnZXRzIGRlZXBlciwgbGV0IHRoZSB3aWR0aCBkZWNyZWFzZSBtb25vdG9uaWNhbGx5XG4gICAgLy8gdG8gdGhlIGxvd2VyIGJvdW5kIG1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBsaWVzXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCBcdTIyNjQgNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGlzIGZpeGVkIGF0IHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyAgc3RhdGUubGluZVdpZHRoID4gNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGRlY3JlYXNlcyB1bnRpbCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gVGhpcyBiZWhhdmVzIGJldHRlciB0aGFuIGEgY29uc3RhbnQgbWluaW11bSB3aWR0aCB3aGljaCBkaXNhbGxvd3MgbmFycm93ZXIgb3B0aW9ucyxcbiAgICAvLyBvciBhbiBpbmRlbnQgdGhyZXNob2xkIHdoaWNoIGNhdXNlcyB0aGUgd2lkdGggdG8gc3VkZGVubHkgaW5jcmVhc2UuXG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aCA9PT0gLTFcbiAgICAgID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTtcblxuICAgIC8vIFdpdGhvdXQga25vd2luZyBpZiBrZXlzIGFyZSBpbXBsaWNpdC9leHBsaWNpdCwgYXNzdW1lIGltcGxpY2l0IGZvciBzYWZldHkuXG4gICAgdmFyIHNpbmdsZUxpbmVPbmx5ID0gaXNrZXlcbiAgICAgIC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgICB8fCAoc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsKTtcbiAgICBmdW5jdGlvbiB0ZXN0QW1iaWd1aXR5KHN0cmluZykge1xuICAgICAgcmV0dXJuIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyaW5nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIHN0YXRlLmluZGVudCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1aXR5KSkge1xuICAgICAgY2FzZSBTVFlMRV9QTEFJTjpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG4gICAgICBjYXNlIFNUWUxFX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiAnfCcgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9GT0xERUQ6XG4gICAgICAgIHJldHVybiAnPicgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZScpO1xuICAgIH1cbiAgfSgpKTtcbn1cblxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cbmZ1bmN0aW9uIGJsb2NrSGVhZGVyKHN0cmluZywgaW5kZW50UGVyTGV2ZWwpIHtcbiAgdmFyIGluZGVudEluZGljYXRvciA9IG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSA/IFN0cmluZyhpbmRlbnRQZXJMZXZlbCkgOiAnJztcblxuICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2U6IHRoZSBzdHJpbmcgJ1xcbicgY291bnRzIGFzIGEgXCJ0cmFpbGluZ1wiIGVtcHR5IGxpbmUuXG4gIHZhciBjbGlwID0gICAgICAgICAgc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbic7XG4gIHZhciBrZWVwID0gY2xpcCAmJiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAyXSA9PT0gJ1xcbicgfHwgc3RyaW5nID09PSAnXFxuJyk7XG4gIHZhciBjaG9tcCA9IGtlZXAgPyAnKycgOiAoY2xpcCA/ICcnIDogJy0nKTtcblxuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn1cblxuLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuZnVuY3Rpb24gZHJvcEVuZGluZ05ld2xpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJyA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbi8vIE5vdGU6IGEgbG9uZyBsaW5lIHdpdGhvdXQgYSBzdWl0YWJsZSBicmVhayBwb2ludCB3aWxsIGV4Y2VlZCB0aGUgd2lkdGggbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogZXZlcnkgY2hhciBpbiBzdHIgaXNQcmludGFibGUsIHN0ci5sZW5ndGggPiAwLCB3aWR0aCA+IDAuXG5mdW5jdGlvbiBmb2xkU3RyaW5nKHN0cmluZywgd2lkdGgpIHtcbiAgLy8gSW4gZm9sZGVkIHN0eWxlLCAkayQgY29uc2VjdXRpdmUgbmV3bGluZXMgb3V0cHV0IGFzICRrKzEkIG5ld2xpbmVzXHUyMDE0XG4gIC8vIHVubGVzcyB0aGV5J3JlIGJlZm9yZSBvciBhZnRlciBhIG1vcmUtaW5kZW50ZWQgbGluZSwgb3IgYXQgdGhlIHZlcnlcbiAgLy8gYmVnaW5uaW5nIG9yIGVuZCwgaW4gd2hpY2ggY2FzZSAkayQgbWFwcyB0byAkayQuXG4gIC8vIFRoZXJlZm9yZSwgcGFyc2UgZWFjaCBjaHVuayBhcyBuZXdsaW5lKHMpIGZvbGxvd2VkIGJ5IGEgY29udGVudCBsaW5lLlxuICB2YXIgbGluZVJlID0gLyhcXG4rKShbXlxcbl0qKS9nO1xuXG4gIC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG4gIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0TEYgPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG4gICAgbmV4dExGID0gbmV4dExGICE9PSAtMSA/IG5leHRMRiA6IHN0cmluZy5sZW5ndGg7XG4gICAgbGluZVJlLmxhc3RJbmRleCA9IG5leHRMRjtcbiAgICByZXR1cm4gZm9sZExpbmUoc3RyaW5nLnNsaWNlKDAsIG5leHRMRiksIHdpZHRoKTtcbiAgfSgpKTtcbiAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuICB2YXIgcHJldk1vcmVJbmRlbnRlZCA9IHN0cmluZ1swXSA9PT0gJ1xcbicgfHwgc3RyaW5nWzBdID09PSAnICc7XG4gIHZhciBtb3JlSW5kZW50ZWQ7XG5cbiAgLy8gcmVzdCBvZiB0aGUgbGluZXNcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gbGluZVJlLmV4ZWMoc3RyaW5nKSkpIHtcbiAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0sIGxpbmUgPSBtYXRjaFsyXTtcbiAgICBtb3JlSW5kZW50ZWQgPSAobGluZVswXSA9PT0gJyAnKTtcbiAgICByZXN1bHQgKz0gcHJlZml4XG4gICAgICArICghcHJldk1vcmVJbmRlbnRlZCAmJiAhbW9yZUluZGVudGVkICYmIGxpbmUgIT09ICcnXG4gICAgICAgID8gJ1xcbicgOiAnJylcbiAgICAgICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuZnVuY3Rpb24gZm9sZExpbmUobGluZSwgd2lkdGgpIHtcbiAgaWYgKGxpbmUgPT09ICcnIHx8IGxpbmVbMF0gPT09ICcgJykgcmV0dXJuIGxpbmU7XG5cbiAgLy8gU2luY2UgYSBtb3JlLWluZGVudGVkIGxpbmUgYWRkcyBhIFxcbiwgYnJlYWtzIGNhbid0IGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2UuXG4gIHZhciBicmVha1JlID0gLyBbXiBdL2c7IC8vIG5vdGU6IHRoZSBtYXRjaCBpbmRleCB3aWxsIGFsd2F5cyBiZSA8PSBsZW5ndGgtMi5cbiAgdmFyIG1hdGNoO1xuICAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cbiAgdmFyIHN0YXJ0ID0gMCwgZW5kLCBjdXJyID0gMCwgbmV4dCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG4gIHdoaWxlICgobWF0Y2ggPSBicmVha1JlLmV4ZWMobGluZSkpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIG1haW50YWluIGludmFyaWFudDogY3VyciAtIHN0YXJ0IDw9IHdpZHRoXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSAoY3VyciA+IHN0YXJ0KSA/IGN1cnIgOiBuZXh0OyAvLyBkZXJpdmUgZW5kIDw9IGxlbmd0aC0yXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgLy8gc2tpcCB0aGUgc3BhY2UgdGhhdCB3YXMgb3V0cHV0IGFzIFxcblxuICAgICAgc3RhcnQgPSBlbmQgKyAxOyAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuICAgIGN1cnIgPSBuZXh0O1xuICB9XG5cbiAgLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cbiAgcmVzdWx0ICs9ICdcXG4nO1xuICAvLyBJbnNlcnQgYSBicmVhayBpZiB0aGUgcmVtYWluZGVyIGlzIHRvbyBsb25nIGFuZCB0aGVyZSBpcyBhIGJyZWFrIGF2YWlsYWJsZS5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufVxuXG4vLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXIsIG5leHRDaGFyO1xuICB2YXIgZXNjYXBlU2VxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIENoZWNrIGZvciBzdXJyb2dhdGUgcGFpcnMgKHJlZmVyZW5jZSBVbmljb2RlIDMuMCBzZWN0aW9uIFwiMy43IFN1cnJvZ2F0ZXNcIikuXG4gICAgaWYgKGNoYXIgPj0gMHhEODAwICYmIGNoYXIgPD0gMHhEQkZGLyogaGlnaCBzdXJyb2dhdGUgKi8pIHtcbiAgICAgIG5leHRDaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKG5leHRDaGFyID49IDB4REMwMCAmJiBuZXh0Q2hhciA8PSAweERGRkYvKiBsb3cgc3Vycm9nYXRlICovKSB7XG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHN1cnJvZ2F0ZSBwYWlyIGFuZCBzdG9yZSBpdCBlc2NhcGVkLlxuICAgICAgICByZXN1bHQgKz0gZW5jb2RlSGV4KChjaGFyIC0gMHhEODAwKSAqIDB4NDAwICsgbmV4dENoYXIgLSAweERDMDAgKyAweDEwMDAwKTtcbiAgICAgICAgLy8gQWR2YW5jZSBpbmRleCBvbmUgZXh0cmEgc2luY2Ugd2UgYWxyZWFkeSB1c2VkIHRoYXQgY2hhciBoZXJlLlxuICAgICAgICBpKys7IGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuICAgIHJlc3VsdCArPSAhZXNjYXBlU2VxICYmIGlzUHJpbnRhYmxlKGNoYXIpXG4gICAgICA/IHN0cmluZ1tpXVxuICAgICAgOiBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoaW5kZXggIT09IDApIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RbaW5kZXhdLCB0cnVlLCB0cnVlKSkge1xuICAgICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG5cbiAgICBwYWlyQnVmZmVyID0gJyc7XG4gICAgaWYgKGluZGV4ICE9PSAwKSBwYWlyQnVmZmVyICs9ICcsICc7XG5cbiAgICBpZiAoc3RhdGUuY29uZGVuc2VGbG93KSBwYWlyQnVmZmVyICs9ICdcIic7XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHBhaXJCdWZmZXIgKz0gJz8gJztcblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcCArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnXCInIDogJycpICsgJzonICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICcnIDogJyAnKTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG4gIGlmIChzdGF0ZS5zb3J0S2V5cyA9PT0gdHJ1ZSkge1xuICAgIC8vIERlZmF1bHQgc29ydGluZ1xuICAgIG9iamVjdEtleUxpc3Quc29ydCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5zb3J0S2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KHN0YXRlLnNvcnRLZXlzKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zb3J0S2V5cykge1xuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZ1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0S2V5LCB0cnVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXkuXG4gICAgfVxuXG4gICAgZXhwbGljaXRQYWlyID0gKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHxcbiAgICAgICAgICAgICAgICAgICAoc3RhdGUuZHVtcCAmJiBzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RWYWx1ZSwgdHJ1ZSwgZXhwbGljaXRQYWlyKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6JztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOiAnO1xuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ3t9JzsgLy8gRW1wdHkgbWFwcGluZyBpZiBubyB2YWxpZCBwYWlycy5cbn1cblxuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBleHBsaWNpdCkge1xuICB2YXIgX3Jlc3VsdCwgdHlwZUxpc3QsIGluZGV4LCBsZW5ndGgsIHR5cGUsIHN0eWxlO1xuXG4gIHR5cGVMaXN0ID0gZXhwbGljaXQgPyBzdGF0ZS5leHBsaWNpdFR5cGVzIDogc3RhdGUuaW1wbGljaXRUeXBlcztcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdHlwZUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSB0eXBlTGlzdFtpbmRleF07XG5cbiAgICBpZiAoKHR5cGUuaW5zdGFuY2VPZiAgfHwgdHlwZS5wcmVkaWNhdGUpICYmXG4gICAgICAgICghdHlwZS5pbnN0YW5jZU9mIHx8ICgodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpICYmIChvYmplY3QgaW5zdGFuY2VvZiB0eXBlLmluc3RhbmNlT2YpKSkgJiZcbiAgICAgICAgKCF0eXBlLnByZWRpY2F0ZSAgfHwgdHlwZS5wcmVkaWNhdGUob2JqZWN0KSkpIHtcblxuICAgICAgc3RhdGUudGFnID0gZXhwbGljaXQgPyB0eXBlLnRhZyA6ICc/JztcblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJyE8JyArIHR5cGUudGFnICsgJz4gdGFnIHJlc29sdmVyIGFjY2VwdHMgbm90IFwiJyArIHN0eWxlICsgJ1wiIHN0eWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kdW1wID0gX3Jlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTZXJpYWxpemVzIGBvYmplY3RgIGFuZCB3cml0ZXMgaXQgdG8gZ2xvYmFsIGByZXN1bHRgLlxuLy8gUmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIG9yIGZhbHNlIG9uIGludmFsaWQgb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgYmxvY2ssIGNvbXBhY3QsIGlza2V5KSB7XG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmR1bXAgPSBvYmplY3Q7XG5cbiAgaWYgKCFkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGZhbHNlKSkge1xuICAgIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgdHJ1ZSk7XG4gIH1cblxuICB2YXIgdHlwZSA9IF90b1N0cmluZy5jYWxsKHN0YXRlLmR1bXApO1xuXG4gIGlmIChibG9jaykge1xuICAgIGJsb2NrID0gKHN0YXRlLmZsb3dMZXZlbCA8IDAgfHwgc3RhdGUuZmxvd0xldmVsID4gbGV2ZWwpO1xuICB9XG5cbiAgdmFyIG9iamVjdE9yQXJyYXkgPSB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgZHVwbGljYXRlSW5kZXgsXG4gICAgICBkdXBsaWNhdGU7XG5cbiAgaWYgKG9iamVjdE9yQXJyYXkpIHtcbiAgICBkdXBsaWNhdGVJbmRleCA9IHN0YXRlLmR1cGxpY2F0ZXMuaW5kZXhPZihvYmplY3QpO1xuICAgIGR1cGxpY2F0ZSA9IGR1cGxpY2F0ZUluZGV4ICE9PSAtMTtcbiAgfVxuXG4gIGlmICgoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fCBkdXBsaWNhdGUgfHwgKHN0YXRlLmluZGVudCAhPT0gMiAmJiBsZXZlbCA+IDApKSB7XG4gICAgY29tcGFjdCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGR1cGxpY2F0ZSAmJiBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICBzdGF0ZS5kdW1wID0gJypyZWZfJyArIGR1cGxpY2F0ZUluZGV4O1xuICB9IGVsc2Uge1xuICAgIGlmIChvYmplY3RPckFycmF5ICYmIGR1cGxpY2F0ZSAmJiAhc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgICBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoT2JqZWN0LmtleXMoc3RhdGUuZHVtcCkubGVuZ3RoICE9PSAwKSkge1xuICAgICAgICB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB2YXIgYXJyYXlMZXZlbCA9IChzdGF0ZS5ub0FycmF5SW5kZW50ICYmIChsZXZlbCA+IDApKSA/IGxldmVsIC0gMSA6IGxldmVsO1xuICAgICAgaWYgKGJsb2NrICYmIChzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBhcnJheUxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgYXJyYXlMZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIHN0YXRlLmR1bXAgPSAnITwnICsgc3RhdGUudGFnICsgJz4gJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMob2JqZWN0LCBzdGF0ZSkge1xuICB2YXIgb2JqZWN0cyA9IFtdLFxuICAgICAgZHVwbGljYXRlc0luZGV4ZXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cbiAgc3RhdGUudXNlZER1cGxpY2F0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcykge1xuICB2YXIgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHNhZmVEdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkdW1wKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgPSBkdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgPSBzYWZlRHVtcDtcbiIsICIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhdGVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB5YW1sID0gcmVxdWlyZSgnLi9saWIvanMteWFtbC5qcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0geWFtbDtcbiIsICJ2YXIgcGFyc2VyID0gcmVxdWlyZSgnanMteWFtbCcpXG52YXIgb3B0aW9uYWxCeXRlT3JkZXJNYXJrID0gJ1xcXFx1ZmVmZj8nXG52YXIgcGxhdGZvcm0gPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzLnBsYXRmb3JtIDogJydcbnZhciBwYXR0ZXJuID0gJ14oJyArXG4gIG9wdGlvbmFsQnl0ZU9yZGVyTWFyayArXG4gICcoPSB5YW1sID18LS0tKScgK1xuICAnJChbXFxcXHNcXFxcU10qPyknICtcbiAgJ14oPzpcXFxcMnxcXFxcLlxcXFwuXFxcXC4pXFxcXHMqJyArXG4gICckJyArXG4gIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdcXFxccj8nIDogJycpICtcbiAgJyg/OlxcXFxuKT8pJ1xuLy8gTk9URTogSWYgdGhpcyBwYXR0ZXJuIHVzZXMgdGhlICdnJyBmbGFnIHRoZSBgcmVnZXhgIHZhcmlhYmxlIGRlZmluaXRpb24gd2lsbFxuLy8gbmVlZCB0byBiZSBtb3ZlZCBkb3duIGludG8gdGhlIGZ1bmN0aW9ucyB0aGF0IHVzZSBpdC5cbnZhciByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ20nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dHJhY3RvclxubW9kdWxlLmV4cG9ydHMudGVzdCA9IHRlc3RcblxuZnVuY3Rpb24gZXh0cmFjdG9yIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgc3RyaW5nID0gc3RyaW5nIHx8ICcnXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHsgYWxsb3dVbnNhZmU6IGZhbHNlIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgaW5zdGFuY2VvZiBPYmplY3QgPyB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH0gOiBkZWZhdWx0T3B0aW9uc1xuICBvcHRpb25zLmFsbG93VW5zYWZlID0gQm9vbGVhbihvcHRpb25zLmFsbG93VW5zYWZlKVxuICB2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoLyhcXHI/XFxuKS8pXG4gIGlmIChsaW5lc1swXSAmJiAvPSB5YW1sID18LS0tLy50ZXN0KGxpbmVzWzBdKSkge1xuICAgIHJldHVybiBwYXJzZShzdHJpbmcsIG9wdGlvbnMuYWxsb3dVbnNhZmUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYm9keTogc3RyaW5nLFxuICAgICAgYm9keUJlZ2luOiAxXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVMb2NhdGlvbiAobWF0Y2gsIGJvZHkpIHtcbiAgdmFyIGxpbmUgPSAxXG4gIHZhciBwb3MgPSBib2R5LmluZGV4T2YoJ1xcbicpXG4gIHZhciBvZmZzZXQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxuXG4gIHdoaWxlIChwb3MgIT09IC0xKSB7XG4gICAgaWYgKHBvcyA+PSBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBsaW5lXG4gICAgfVxuICAgIGxpbmUrK1xuICAgIHBvcyA9IGJvZHkuaW5kZXhPZignXFxuJywgcG9zICsgMSlcbiAgfVxuXG4gIHJldHVybiBsaW5lXG59XG5cbmZ1bmN0aW9uIHBhcnNlIChzdHJpbmcsIGFsbG93VW5zYWZlKSB7XG4gIHZhciBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKVxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYm9keTogc3RyaW5nLFxuICAgICAgYm9keUJlZ2luOiAxXG4gICAgfVxuICB9XG5cbiAgdmFyIGxvYWRlciA9IGFsbG93VW5zYWZlID8gcGFyc2VyLmxvYWQgOiBwYXJzZXIuc2FmZUxvYWRcbiAgdmFyIHlhbWwgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbiAgdmFyIGF0dHJpYnV0ZXMgPSBsb2FkZXIoeWFtbCkgfHwge31cbiAgdmFyIGJvZHkgPSBzdHJpbmcucmVwbGFjZShtYXRjaFswXSwgJycpXG4gIHZhciBsaW5lID0gY29tcHV0ZUxvY2F0aW9uKG1hdGNoLCBzdHJpbmcpXG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGJvZHk6IGJvZHksXG4gICAgYm9keUJlZ2luOiBsaW5lLFxuICAgIGZyb250bWF0dGVyOiB5YW1sXG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdCAoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZyB8fCAnJ1xuXG4gIHJldHVybiByZWdleC50ZXN0KHN0cmluZylcbn1cbiIsICIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fc3ByZWFkQXJyYXk7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDtcclxudmFyIF9fY3JlYXRlQmluZGluZztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uKG0sIG8pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxuICAgIH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgICAgICBvW2syXSA9IG1ba107XHJcbiAgICB9KTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIF9fc3ByZWFkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWRBcnJheSA9IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbiAgICB9KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0U3RhciA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydERlZmF1bHQgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgICAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbn0pO1xyXG4iLCAiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19zcHJlYWRBcnJheXM7XHJcbnZhciBfX3NwcmVhZEFycmF5O1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmc7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbihtLCBvKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbiAgICB9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgb1trMl0gPSBtW2tdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXkgPSBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG4gICAgfSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydFN0YXIgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnREZWZhdWx0ID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5cyk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlcIiwgX19zcHJlYWRBcnJheSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQpO1xyXG59KTtcclxuIiwgImZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHVuZGVmaW5lZCkgY2FjaGVbYXJnXSA9IGZuKGFyZyk7XG4gICAgcmV0dXJuIGNhY2hlW2FyZ107XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCAiaW1wb3J0IG1lbW9pemUgZnJvbSAnQGVtb3Rpb24vbWVtb2l6ZSc7XG5cbnZhciByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkaXNhYmxlUGljdHVyZUluUGljdHVyZXxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLzsgLy8gaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81YmZlZTY4YTRjZDdlNjAwOWVmNjFkMjNcblxudmFyIGluZGV4ID0gbWVtb2l6ZShmdW5jdGlvbiAocHJvcCkge1xuICByZXR1cm4gcmVhY3RQcm9wc1JlZ2V4LnRlc3QocHJvcCkgfHwgcHJvcC5jaGFyQ29kZUF0KDApID09PSAxMTFcbiAgLyogbyAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMSkgPT09IDExMFxuICAvKiBuICovXG4gICYmIHByb3AuY2hhckNvZGVBdCgyKSA8IDkxO1xufVxuLyogWisxICovXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsICJpbXBvcnQgeyBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlciB9IGZyb20gXCJAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXNcIlxuaW1wb3J0ICogYXMgYnVpbGQgZnJvbSBcIkByZW1peC1ydW4vZGV2L3NlcnZlci1idWlsZFwiXG5cbmNvbnN0IGhhbmRsZVJlcXVlc3QgPSBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlcih7XG5cdGJ1aWxkLFxuXHRtb2RlOiBwcm9jZXNzLmVudi5OT0RFX0VOVixcblx0Z2V0TG9hZENvbnRleHQ6IGNvbnRleHQgPT4gY29udGV4dC5lbnZcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBvblJlcXVlc3QoY29udGV4dCkge1xuXHRyZXR1cm4gaGFuZGxlUmVxdWVzdChjb250ZXh0KVxufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBpbnN0YWxsR2xvYmFscyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9IGZyb20gJy4vc2Vzc2lvbnMvY2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UuanMnO1xuZXhwb3J0IHsgY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIsIGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH0gZnJvbSAnLi93b3JrZXIuanMnO1xuXG5pbnN0YWxsR2xvYmFscygpO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBzaWduLCB1bnNpZ24gfSBmcm9tICcuL2Nvb2tpZVNpZ25pbmcuanMnO1xuXG5mdW5jdGlvbiBpbnN0YWxsR2xvYmFscygpIHtcbiAgc2VsZi5zaWduID0gc2lnbjtcbiAgc2VsZi51bnNpZ24gPSB1bnNpZ247XG59XG5cbmV4cG9ydCB7IGluc3RhbGxHbG9iYWxzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmFzeW5jIGZ1bmN0aW9uIHNpZ24odmFsdWUsIHNlY3JldCkge1xuICBsZXQga2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSwge1xuICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgIGhhc2g6IFwiU0hBLTI1NlwiXG4gIH0sIGZhbHNlLCBbXCJzaWduXCJdKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBzaWduYXR1cmUgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oXCJITUFDXCIsIGtleSwgZGF0YSk7XG4gIGxldCBoYXNoID0gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbiAgcmV0dXJuIHZhbHVlICsgXCIuXCIgKyBoYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdW5zaWduKGNvb2tpZSwgc2VjcmV0KSB7XG4gIGxldCBrZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBlbmNvZGVyLmVuY29kZShzZWNyZXQpLCB7XG4gICAgbmFtZTogXCJITUFDXCIsXG4gICAgaGFzaDogXCJTSEEtMjU2XCJcbiAgfSwgZmFsc2UsIFtcInZlcmlmeVwiXSk7XG4gIGxldCB2YWx1ZSA9IGNvb2tpZS5zbGljZSgwLCBjb29raWUubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgbGV0IGhhc2ggPSBjb29raWUuc2xpY2UoY29va2llLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICBsZXQgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IHNpZ25hdHVyZSA9IGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYXRvYihoYXNoKSk7XG4gIGxldCB2YWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KFwiSE1BQ1wiLCBrZXksIHNpZ25hdHVyZSwgZGF0YSk7XG4gIHJldHVybiB2YWxpZCA/IHZhbHVlIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYnl0ZVN0cmluZykge1xuICBsZXQgYXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlU3RyaW5nLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCB7IHNpZ24sIHVuc2lnbiB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBjcmVhdGVTZXNzaW9uU3RvcmFnZSB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTZXNzaW9uU3RvcmFnZSB0aGF0IHN0b3JlcyBzZXNzaW9uIGRhdGEgaW4gdGhlIENsb3VsZGZsYXJlIEtWIFN0b3JlLlxuICpcbiAqIFRoZSBhZHZhbnRhZ2Ugb2YgdXNpbmcgdGhpcyBpbnN0ZWFkIG9mIGNvb2tpZSBzZXNzaW9uIHN0b3JhZ2UgaXMgdGhhdFxuICogS1YgU3RvcmUgbWF5IGNvbnRhaW4gbXVjaCBtb3JlIGRhdGEgdGhhbiBjb29raWVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I2NyZWF0ZWNsb3VkZmxhcmVrdnNlc3Npb25zdG9yYWdlLWNsb3VkZmxhcmUtd29ya2Vyc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSh7XG4gIGNvb2tpZSxcbiAga3Zcbn0pIHtcbiAgcmV0dXJuIGNyZWF0ZVNlc3Npb25TdG9yYWdlKHtcbiAgICBjb29raWUsXG5cbiAgICBhc3luYyBjcmVhdGVEYXRhKGRhdGEsIGV4cGlyZXMpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCByYW5kb21CeXRlcyA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ5dGVzKTsgLy8gVGhpcyBzdG9yYWdlIG1hbmFnZXMgYW4gaWQgc3BhY2Ugb2YgMl42NCBpZHMsIHdoaWNoIGlzIGZhciBncmVhdGVyXG4gICAgICAgIC8vIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGZpbGVzIGFsbG93ZWQgb24gYW4gTlRGUyBvciBleHQ0IHZvbHVtZVxuICAgICAgICAvLyAoMl4zMikuIEhvd2V2ZXIsIHRoZSBsYXJnZXIgaWQgc3BhY2Ugc2hvdWxkIGhlbHAgdG8gYXZvaWQgY29sbGlzaW9uc1xuICAgICAgICAvLyB3aXRoIGV4aXN0aW5nIGlkcyB3aGVuIGNyZWF0aW5nIG5ldyBzZXNzaW9ucywgd2hpY2ggc3BlZWRzIHRoaW5ncyB1cC5cblxuICAgICAgICBsZXQgaWQgPSBbLi4ucmFuZG9tQnl0ZXNdLm1hcCh4ID0+IHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcblxuICAgICAgICBpZiAoYXdhaXQga3YuZ2V0KGlkLCBcImpzb25cIikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGt2LnB1dChpZCwgSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAgICAgICBleHBpcmF0aW9uOiBleHBpcmVzID8gTWF0aC5yb3VuZChleHBpcmVzLmdldFRpbWUoKSAvIDEwMDApIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHJlYWREYXRhKGlkKSB7XG4gICAgICBsZXQgc2Vzc2lvbiA9IGF3YWl0IGt2LmdldChpZCk7XG5cbiAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2Vzc2lvbik7XG4gICAgfSxcblxuICAgIGFzeW5jIHVwZGF0ZURhdGEoaWQsIGRhdGEsIGV4cGlyZXMpIHtcbiAgICAgIGF3YWl0IGt2LnB1dChpZCwgSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAgICAgZXhwaXJhdGlvbjogZXhwaXJlcyA/IE1hdGgucm91bmQoZXhwaXJlcy5nZXRUaW1lKCkgLyAxMDAwKSA6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGRlbGV0ZURhdGEoaWQpIHtcbiAgICAgIGF3YWl0IGt2LmRlbGV0ZShpZCk7XG4gICAgfVxuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgY3JlYXRlQ29va2llLCBpc0Nvb2tpZSB9IGZyb20gJy4vY29va2llcy5qcyc7XG5leHBvcnQgeyBqc29uLCByZWRpcmVjdCB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH0gZnJvbSAnLi9zZXJ2ZXIuanMnO1xuZXhwb3J0IHsgY3JlYXRlU2Vzc2lvbiwgY3JlYXRlU2Vzc2lvblN0b3JhZ2UsIGlzU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbnMuanMnO1xuZXhwb3J0IHsgY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICcuL3Nlc3Npb25zL2Nvb2tpZVN0b3JhZ2UuanMnO1xuZXhwb3J0IHsgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UgfSBmcm9tICcuL3Nlc3Npb25zL21lbW9yeVN0b3JhZ2UuanMnO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I2pzb25cbiAqL1xuZnVuY3Rpb24ganNvbihkYXRhLCBpbml0ID0ge30pIHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG5cbiAgaWYgKHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgc3RhdHVzOiBpbml0XG4gICAgfTtcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuXG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7IC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzXG4gIH0pO1xufVxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNyZWRpcmVjdFxuICovXG5cbmZ1bmN0aW9uIHJlZGlyZWN0KHVybCwgaW5pdCA9IDMwMikge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcblxuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgIHN0YXR1czogcmVzcG9uc2VJbml0XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMocmVzcG9uc2Uuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzQ2F0Y2hSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LUNhdGNoXCIpICE9IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzQ2F0Y2hSZXNwb25zZSwgaXNSZWRpcmVjdFJlc3BvbnNlLCBpc1Jlc3BvbnNlLCBqc29uLCByZWRpcmVjdCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY2FsbFJvdXRlQWN0aW9uLCBjYWxsUm91dGVMb2FkZXIsIGV4dHJhY3REYXRhIH0gZnJvbSAnLi9kYXRhLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzLCBjcmVhdGVFbnRyeU1hdGNoZXMgfSBmcm9tICcuL2VudHJ5LmpzJztcbmltcG9ydCB7IHNlcmlhbGl6ZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnRIZWFkZXJzIH0gZnJvbSAnLi9oZWFkZXJzLmpzJztcbmltcG9ydCB7IG1hdGNoU2VydmVyUm91dGVzIH0gZnJvbSAnLi9yb3V0ZU1hdGNoaW5nLmpzJztcbmltcG9ydCB7IGlzU2VydmVyTW9kZSwgU2VydmVyTW9kZSB9IGZyb20gJy4vbW9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcy5qcyc7XG5pbXBvcnQgeyBpc1JlZGlyZWN0UmVzcG9uc2UsIGlzQ2F0Y2hSZXNwb25zZSwganNvbiB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcgfSBmcm9tICcuL3NlcnZlckhhbmRvZmYuanMnO1xuXG4vKipcbiAqIFRoZSBtYWluIHJlcXVlc3QgaGFuZGxlciBmb3IgYSBSZW1peCBzZXJ2ZXIuIFRoaXMgaGFuZGxlciBydW5zIGluIHRoZSBjb250ZXh0XG4gKiBvZiBhIGNsb3VkIHByb3ZpZGVyJ3Mgc2VydmVyIChlLmcuIEV4cHJlc3Mgb24gRmlyZWJhc2UpIG9yIGxvY2FsbHkgdmlhIHRoZWlyXG4gKiBkZXYgdG9vbHMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBzZXJ2ZXMgSFRUUCByZXF1ZXN0cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEhhbmRsZXIoYnVpbGQsIHBsYXRmb3JtLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IHNlcnZlck1vZGUgPSBpc1NlcnZlck1vZGUobW9kZSkgPyBtb2RlIDogU2VydmVyTW9kZS5Qcm9kdWN0aW9uO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgbG9hZENvbnRleHQpIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHVybC5wYXRobmFtZSk7XG4gICAgbGV0IHJlcXVlc3RUeXBlID0gZ2V0UmVxdWVzdFR5cGUodXJsLCBtYXRjaGVzKTtcbiAgICBsZXQgcmVzcG9uc2U7XG5cbiAgICBzd2l0Y2ggKHJlcXVlc3RUeXBlKSB7XG4gICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZURhdGFSZXF1ZXN0KHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgICAgaGFuZGxlRGF0YVJlcXVlc3Q6IGJ1aWxkLmVudHJ5Lm1vZHVsZS5oYW5kbGVEYXRhUmVxdWVzdCxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImRvY3VtZW50XCI6XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVuZGVyRG9jdW1lbnRSZXF1ZXN0KHtcbiAgICAgICAgICBidWlsZCxcbiAgICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcm91dGVzLFxuICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicmVzb3VyY2VcIjpcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoe1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJoZWFkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVEYXRhUmVxdWVzdCh7XG4gIGhhbmRsZURhdGFSZXF1ZXN0LFxuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgc2VydmVyTW9kZVxufSkge1xuICBpZiAoIWlzVmFsaWRSZXF1ZXN0TWV0aG9kKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke3JlcXVlc3QubWV0aG9kfVwiYCksIDQwNSk7XG4gIH1cblxuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHt1cmwucGF0aG5hbWV9XCJgKSwgNDA0KTtcbiAgfVxuXG4gIGxldCByZXNwb25zZTtcbiAgbGV0IG1hdGNoO1xuXG4gIHRyeSB7XG4gICAgaWYgKGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgbWF0Y2ggPSBnZXRBY3Rpb25SZXF1ZXN0TWF0Y2godXJsLCBtYXRjaGVzKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJvdXRlSWQgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcIl9kYXRhXCIpO1xuXG4gICAgICBpZiAoIXJvdXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYE1pc3Npbmcgcm91dGUgaWQgaW4gP19kYXRhYCksIDQwMyk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZW1wTWF0Y2ggPSBtYXRjaGVzLmZpbmQobWF0Y2ggPT4gbWF0Y2gucm91dGUuaWQgPT09IHJvdXRlSWQpO1xuXG4gICAgICBpZiAoIXRlbXBNYXRjaCkge1xuICAgICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgbWF0Y2ggVVJMIFwiJHt1cmwucGF0aG5hbWV9XCJgKSwgNDAzKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxSb3V0ZUxvYWRlcih7XG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55IHdheSB0byBwcmV2ZW50IGEgZmV0Y2ggcmVxdWVzdCBmcm9tIGZvbGxvd2luZ1xuICAgICAgLy8gcmVkaXJlY3RzLiBTbyB3ZSB1c2UgdGhlIGBYLVJlbWl4LVJlZGlyZWN0YCBoZWFkZXIgdG8gaW5kaWNhdGUgdGhlXG4gICAgICAvLyBuZXh0IFVSTCwgYW5kIHRoZW4gXCJmb2xsb3dcIiB0aGUgcmVkaXJlY3QgbWFudWFsbHkgb24gdGhlIGNsaWVudC5cbiAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIlgtUmVtaXgtUmVkaXJlY3RcIiwgaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKSk7XG4gICAgICBoZWFkZXJzLmRlbGV0ZShcIkxvY2F0aW9uXCIpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRGF0YVJlcXVlc3QpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlRGF0YVJlcXVlc3QocmVzcG9uc2UuY2xvbmUoKSwge1xuICAgICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QuY2xvbmUoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJNb2RlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50KSB7XG4gICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKGVycm9yLCA1MDApO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIiksIDUwMCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyRG9jdW1lbnRSZXF1ZXN0KHtcbiAgYnVpbGQsXG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaGVzLFxuICByZXF1ZXN0LFxuICByb3V0ZXMsXG4gIHNlcnZlck1vZGVcbn0pIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgYXBwU3RhdGUgPSB7XG4gICAgdHJhY2tCb3VuZGFyaWVzOiB0cnVlLFxuICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiB0cnVlLFxuICAgIGNhdGNoQm91bmRhcnlSb3V0ZUlkOiBudWxsLFxuICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICBsb2FkZXJCb3VuZGFyeVJvdXRlSWQ6IG51bGwsXG4gICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICBjYXRjaDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSkge1xuICAgIG1hdGNoZXMgPSBudWxsO1xuICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgc3RhdHVzOiA0MDUsXG4gICAgICBzdGF0dXNUZXh0OiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiXG4gICAgfTtcbiAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgfTtcbiAgfVxuXG4gIGxldCBhY3Rpb25TdGF0dXM7XG4gIGxldCBhY3Rpb25EYXRhO1xuICBsZXQgYWN0aW9uTWF0Y2g7XG4gIGxldCBhY3Rpb25SZXNwb25zZTtcblxuICBpZiAobWF0Y2hlcyAmJiBpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICBhY3Rpb25NYXRjaCA9IGdldEFjdGlvblJlcXVlc3RNYXRjaCh1cmwsIG1hdGNoZXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGFjdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIG1hdGNoOiBhY3Rpb25NYXRjaCxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoYWN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25SZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgYWN0aW9uU3RhdHVzID0ge1xuICAgICAgICBzdGF0dXM6IGFjdGlvblJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogYWN0aW9uUmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfTtcblxuICAgICAgaWYgKGlzQ2F0Y2hSZXNwb25zZShhY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBcIkNhdGNoQm91bmRhcnlcIik7XG4gICAgICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICAgIGFwcFN0YXRlLmNhdGNoID0geyAuLi5hY3Rpb25TdGF0dXMsXG4gICAgICAgICAgZGF0YTogYXdhaXQgZXh0cmFjdERhdGEoYWN0aW9uUmVzcG9uc2UpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25EYXRhID0ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IGF3YWl0IGV4dHJhY3REYXRhKGFjdGlvblJlc3BvbnNlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBcIkVycm9yQm91bmRhcnlcIik7XG4gICAgICBhcHBTdGF0ZS50cmFja0JvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgIGFwcFN0YXRlLmVycm9yID0gYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuXG4gICAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZXJlIHdhcyBhbiBlcnJvciBydW5uaW5nIHRoZSBhY3Rpb24gZm9yIHJvdXRlICR7YWN0aW9uTWF0Y2gucm91dGUuaWR9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHJvdXRlTW9kdWxlcyA9IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKGJ1aWxkLnJvdXRlcyk7XG4gIGxldCBtYXRjaGVzVG9Mb2FkID0gbWF0Y2hlcyB8fCBbXTtcblxuICBpZiAoYXBwU3RhdGUuY2F0Y2gpIHtcbiAgICBtYXRjaGVzVG9Mb2FkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkoIC8vIGdldCByaWQgb2YgdGhlIGFjdGlvbiwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIGl0J3MgbG9hZGVyIGVpdGhlclxuICAgIC8vIGJlY2F1c2Ugd2UnbGwgYmUgcmVuZGVyaW5nIHRoZSBjYXRjaCBib3VuZGFyeSwgaWYgeW91IGNhbiBnZXQgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGxvYWRlciBkYXRhIGluIHRoZSBjYXRjaCBib3VuZGFyeSB0aGVuIGhvdyB0aGUgaGVjayBpcyBpdFxuICAgIC8vIHN1cHBvc2VkIHRvIGRlYWwgd2l0aCB0aHJvd24gcmVzcG9uc2VzP1xuICAgIG1hdGNoZXNUb0xvYWQuc2xpY2UoMCwgLTEpLCBcIkNhdGNoQm91bmRhcnlcIik7XG4gIH0gZWxzZSBpZiAoYXBwU3RhdGUuZXJyb3IpIHtcbiAgICBtYXRjaGVzVG9Mb2FkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkoIC8vIGdldCByaWQgb2YgdGhlIGFjdGlvbiwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIGl0J3MgbG9hZGVyIGVpdGhlclxuICAgIC8vIGJlY2F1c2Ugd2UnbGwgYmUgcmVuZGVyaW5nIHRoZSBlcnJvciBib3VuZGFyeSwgaWYgeW91IGNhbiBnZXQgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGxvYWRlciBkYXRhIGluIHRoZSBlcnJvciBib3VuZGFyeSB0aGVuIGhvdyB0aGUgaGVjayBpcyBpdFxuICAgIC8vIHN1cHBvc2VkIHRvIGRlYWwgd2l0aCBlcnJvcnMgaW4gdGhlIGxvYWRlciwgdG9vP1xuICAgIG1hdGNoZXNUb0xvYWQuc2xpY2UoMCwgLTEpLCBcIkVycm9yQm91bmRhcnlcIik7XG4gIH1cblxuICBsZXQgcm91dGVMb2FkZXJSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKG1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IG1hdGNoLnJvdXRlLm1vZHVsZS5sb2FkZXIgPyBjYWxsUm91dGVMb2FkZXIoe1xuICAgIGxvYWRDb250ZXh0LFxuICAgIG1hdGNoLFxuICAgIHJlcXVlc3RcbiAgfSkgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSkpOyAvLyBTdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGFjdGlvbi4gV2Ugd2lsbCB1c2UgdGhpcyB0byBkZXRlcm1pbmUgbGF0ZXJcbiAgLy8gd2hhdCBjYXRjaCBvciBlcnJvciBib3VuZGFyeSBzaG91bGQgYmUgcmVuZGVyZWQgdW5kZXIgY2FzZXMgd2hlcmVcbiAgLy8gYWN0aW9ucyBkb24ndCB0aHJvdyBidXQgbG9hZGVycyBkbywgYWN0aW9ucyB0aHJvdyBhbmQgcGFyZW50IGxvYWRlcnNcbiAgLy8gYWxzbyB0aHJvdywgZXRjLlxuXG4gIGxldCBhY3Rpb25DYXRjaCA9IGFwcFN0YXRlLmNhdGNoO1xuICBsZXQgYWN0aW9uRXJyb3IgPSBhcHBTdGF0ZS5lcnJvcjtcbiAgbGV0IGFjdGlvbkNhdGNoQm91bmRhcnlSb3V0ZUlkID0gYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQ7XG4gIGxldCBhY3Rpb25Mb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQ7IC8vIFJlc2V0IHRoZSBhcHAgZXJyb3IgYW5kIGNhdGNoIHN0YXRlIHRvIHByb3BvZ2F0ZSB0aGUgbG9hZGVyIHN0YXRlc1xuICAvLyBmcm9tIHRoZSByZXN1bHRzIGludG8gdGhlIGFwcCBzdGF0ZS5cblxuICBhcHBTdGF0ZS5jYXRjaCA9IHVuZGVmaW5lZDtcbiAgYXBwU3RhdGUuZXJyb3IgPSB1bmRlZmluZWQ7XG4gIGxldCByb3V0ZUxvYWRlclJlc3BvbnNlcyA9IHt9O1xuICBsZXQgbG9hZGVyU3RhdHVzQ29kZXMgPSBbXTtcbiAgbGV0IHJvdXRlRGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXRjaGVzVG9Mb2FkLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCBtYXRjaCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdO1xuICAgIGxldCByZXN1bHQgPSByb3V0ZUxvYWRlclJlc3VsdHNbaW5kZXhdO1xuICAgIGxldCBlcnJvciA9IHJlc3VsdC5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIiA/IHJlc3VsdC5yZWFzb24gOiB1bmRlZmluZWQ7XG4gICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiA/IHJlc3VsdC52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgaXNSZWRpcmVjdCA9IHJlc3BvbnNlID8gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSA6IGZhbHNlO1xuICAgIGxldCBpc0NhdGNoID0gcmVzcG9uc2UgPyBpc0NhdGNoUmVzcG9uc2UocmVzcG9uc2UpIDogZmFsc2U7IC8vIElmIGEgcGFyZW50IGxvYWRlciBoYXMgYWxyZWFkeSBjYXVnaHQgb3IgZXJyb3InZCwgYmFpbCBiZWNhdXNlXG4gICAgLy8gd2UgZG9uJ3QgbmVlZCBhbnkgbW9yZSBjaGlsZCBkYXRhLlxuXG4gICAgaWYgKGFwcFN0YXRlLmNhdGNoIHx8IGFwcFN0YXRlLmVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIHRoZXJlIGlzIGEgcmVzcG9uc2UgYW5kIGl0J3MgYSByZWRpcmVjdCwgZG8gaXQgdW5sZXNzIHRoZXJlXG4gICAgLy8gaXMgYW4gYWN0aW9uIGVycm9yIG9yIGNhdGNoIHN0YXRlLCB0aG9zZSBhY3Rpb24gYm91bmRhcnkgc3RhdGVzXG4gICAgLy8gdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHNhdGVzLCB0aGlzIG1lYW5zIGlmIGEgbG9hZGVyIHJlZGlyZWN0c1xuICAgIC8vIGFmdGVyIGFuIGFjdGlvbiBjYXRjaGVzIG9yIGVycm9ycyB3ZSB3b24ndCBmb2xsb3cgaXQsIGFuZCBpbnN0ZWFkXG4gICAgLy8gcmVuZGVyIHRoZSBib3VuZGFyeSBjYXVzZWQgYnkgdGhlIGFjdGlvbi5cblxuXG4gICAgaWYgKCFhY3Rpb25DYXRjaCAmJiAhYWN0aW9uRXJyb3IgJiYgcmVzcG9uc2UgJiYgaXNSZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gLy8gVHJhY2sgdGhlIGJvdW5kYXJ5IElEJ3MgZm9yIHRoZSBsb2FkZXJzXG5cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5tb2R1bGUuQ2F0Y2hCb3VuZGFyeSkge1xuICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gucm91dGUubW9kdWxlLkVycm9yQm91bmRhcnkpIHtcbiAgICAgIGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH1cblxuICAgIGlmIChlcnJvcikge1xuICAgICAgbG9hZGVyU3RhdHVzQ29kZXMucHVzaCg1MDApO1xuICAgICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICBhcHBTdGF0ZS5lcnJvciA9IGF3YWl0IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcblxuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3IgcnVubmluZyB0aGUgZGF0YSBsb2FkZXIgZm9yIHJvdXRlICR7bWF0Y2gucm91dGUuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHJvdXRlTG9hZGVyUmVzcG9uc2VzW21hdGNoLnJvdXRlLmlkXSA9IHJlc3BvbnNlO1xuICAgICAgbG9hZGVyU3RhdHVzQ29kZXMucHVzaChyZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgICBpZiAoaXNDYXRjaCkge1xuICAgICAgICAvLyBJZiBpdCdzIGEgY2F0Y2ggcmVzcG9uc2UsIHN0b3JlIGl0IGluIGFwcCBzdGF0ZSwgYW5kIGJhaWxcbiAgICAgICAgYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICAgICAgZGF0YTogYXdhaXQgZXh0cmFjdERhdGEocmVzcG9uc2UpLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeHRyYWN0IGFuZCBzdG9yZSB0aGUgbG9hZGVyIGRhdGFcbiAgICAgICAgcm91dGVEYXRhW21hdGNoLnJvdXRlLmlkXSA9IGF3YWl0IGV4dHJhY3REYXRhKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSWYgdGhlcmUgd2FzIG5vdCBhIGxvYWRlciBjYXRjaCBvciBlcnJvciBzdGF0ZSB0cmlnZ2VyZWQgcmVzZXQgdGhlXG4gIC8vIGJvdW5kYXJpZXMgYXMgdGhleSBhcmUgcHJvYmFibHkgZGVlcGVyIGluIHRoZSB0cmVlIGlmIHRoZSBhY3Rpb25cbiAgLy8gaW5pdGlhbGx5IHRyaWdnZXJlZCBhIGJvdW5kYXJ5IGFzIHRoYXQgbWF0Y2ggd291bGQgbm90IGV4aXN0IGluIHRoZVxuICAvLyBtYXRjaGVzIHRvIGxvYWQuXG5cblxuICBpZiAoIWFwcFN0YXRlLmNhdGNoKSB7XG4gICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBhY3Rpb25DYXRjaEJvdW5kYXJ5Um91dGVJZDtcbiAgfVxuXG4gIGlmICghYXBwU3RhdGUuZXJyb3IpIHtcbiAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBhY3Rpb25Mb2FkZXJCb3VuZGFyeVJvdXRlSWQ7XG4gIH0gLy8gSWYgdGhlcmUgd2FzIGFuIGFjdGlvbiBlcnJvciBvciBjYXRjaCwgd2Ugd2lsbCByZXNldCB0aGUgc3RhdGUgdG8gdGhlXG4gIC8vIGluaXRpYWwgdmFsdWVzLCBvdGhlcndpc2Ugd2Ugd2lsbCB1c2Ugd2hhdGV2ZXIgY2FtZSBvdXQgb2YgdGhlIGxvYWRlcnMuXG5cblxuICBhcHBTdGF0ZS5jYXRjaCA9IGFjdGlvbkNhdGNoIHx8IGFwcFN0YXRlLmNhdGNoO1xuICBhcHBTdGF0ZS5lcnJvciA9IGFjdGlvbkVycm9yIHx8IGFwcFN0YXRlLmVycm9yO1xuICBsZXQgcmVuZGVyYWJsZU1hdGNoZXMgPSBnZXRSZW5kZXJhYmxlTWF0Y2hlcyhtYXRjaGVzLCBhcHBTdGF0ZSk7XG5cbiAgaWYgKCFyZW5kZXJhYmxlTWF0Y2hlcykge1xuICAgIHJlbmRlcmFibGVNYXRjaGVzID0gW107XG4gICAgbGV0IHJvb3QgPSByb3V0ZXNbMF07XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCAmJiByb290ICE9PSB2b2lkIDAgJiYgcm9vdC5tb2R1bGUuQ2F0Y2hCb3VuZGFyeSkge1xuICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBcInJvb3RcIjtcbiAgICAgIHJlbmRlcmFibGVNYXRjaGVzLnB1c2goe1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcm91dGU6IHJvdXRlc1swXVxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIEhhbmRsZSByZXNwb25zZXMgd2l0aCBhIG5vbi0yMDAgc3RhdHVzIGNvZGUuIFRoZSBmaXJzdCBsb2FkZXIgd2l0aCBhXG4gIC8vIG5vbi0yMDAgc3RhdHVzIGNvZGUgZGV0ZXJtaW5lcyB0aGUgc3RhdHVzIGNvZGUgZm9yIHRoZSB3aG9sZSByZXNwb25zZS5cblxuXG4gIGxldCBub3RPa1Jlc3BvbnNlID0gYWN0aW9uU3RhdHVzICYmIGFjdGlvblN0YXR1cy5zdGF0dXMgIT09IDIwMCA/IGFjdGlvblN0YXR1cy5zdGF0dXMgOiBsb2FkZXJTdGF0dXNDb2Rlcy5maW5kKHN0YXR1cyA9PiBzdGF0dXMgIT09IDIwMCk7XG4gIGxldCByZXNwb25zZVN0YXR1c0NvZGUgPSBhcHBTdGF0ZS5lcnJvciA/IDUwMCA6IHR5cGVvZiBub3RPa1Jlc3BvbnNlID09PSBcIm51bWJlclwiID8gbm90T2tSZXNwb25zZSA6IGFwcFN0YXRlLmNhdGNoID8gYXBwU3RhdGUuY2F0Y2guc3RhdHVzIDogMjAwO1xuICBsZXQgcmVzcG9uc2VIZWFkZXJzID0gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCByZW5kZXJhYmxlTWF0Y2hlcywgcm91dGVMb2FkZXJSZXNwb25zZXMsIGFjdGlvblJlc3BvbnNlKTtcbiAgbGV0IGVudHJ5TWF0Y2hlcyA9IGNyZWF0ZUVudHJ5TWF0Y2hlcyhyZW5kZXJhYmxlTWF0Y2hlcywgYnVpbGQuYXNzZXRzLnJvdXRlcyk7XG4gIGxldCBzZXJ2ZXJIYW5kb2ZmID0ge1xuICAgIGFjdGlvbkRhdGEsXG4gICAgYXBwU3RhdGU6IGFwcFN0YXRlLFxuICAgIG1hdGNoZXM6IGVudHJ5TWF0Y2hlcyxcbiAgICByb3V0ZURhdGFcbiAgfTtcbiAgbGV0IGVudHJ5Q29udGV4dCA9IHsgLi4uc2VydmVySGFuZG9mZixcbiAgICBtYW5pZmVzdDogYnVpbGQuYXNzZXRzLFxuICAgIHJvdXRlTW9kdWxlcyxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpXG4gIH07XG4gIGxldCBoYW5kbGVEb2N1bWVudFJlcXVlc3QgPSBidWlsZC5lbnRyeS5tb2R1bGUuZGVmYXVsdDtcblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QocmVxdWVzdC5jbG9uZSgpLCByZXNwb25zZVN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgZW50cnlDb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXNwb25zZVN0YXR1c0NvZGUgPSA1MDA7IC8vIEdvIGFnYWluLCB0aGlzIHRpbWUgd2l0aCB0aGUgY29tcG9uZW50RGlkQ2F0Y2ggZW11bGF0aW9uLiBBcyBpdCByZW5kZXJlZFxuICAgIC8vIGxhc3QgdGltZSB3ZSBtdXRhdGVkIGBjb21wb25lbnREaWRDYXRjaC5yb3V0ZUlkYCBmb3IgdGhlIGxhc3QgcmVuZGVyZWRcbiAgICAvLyByb3V0ZSwgbm93IHdlIGtub3cgd2hlcmUgdG8gcmVuZGVyIHRoZSBlcnJvciBib3VuZGFyeSAoZmVlbHMgYSBsaXR0bGVcbiAgICAvLyBoYWNreSBidXQgdGhhdCdzIGhvdyBob29rcyB3b3JrKS4gVGhpcyB0ZWxscyB0aGUgZW11bGF0b3IgdG8gc3RvcFxuICAgIC8vIHRyYWNraW5nIHRoZSBgcm91dGVJZGAgYXMgd2UgcmVuZGVyIGJlY2F1c2Ugd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIHRvXG4gICAgLy8gcmVuZGVyLlxuXG4gICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuZXJyb3IgPSBhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvcik7XG4gICAgZW50cnlDb250ZXh0LnNlcnZlckhhbmRvZmZTdHJpbmcgPSBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QocmVxdWVzdC5jbG9uZSgpLCByZXNwb25zZVN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgZW50cnlDb250ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCI7XG5cbiAgICAgIGlmIChzZXJ2ZXJNb2RlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50KSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7U3RyaW5nKGVycm9yKX1gO1xuICAgICAgfSAvLyBHb29kIGdyaWVmIGZvbGtzLCBnZXQgeW91ciBhY3QgdG9nZXRoZXIgXHVEODNEXHVERTAyIVxuXG5cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobWVzc2FnZSwge1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoe1xuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgc2VydmVyTW9kZVxufSkge1xuICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcblxuICB0cnkge1xuICAgIGlmIChpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsUm91dGVBY3Rpb24oe1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbFJvdXRlTG9hZGVyKHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgbGV0IG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCI7XG5cbiAgICBpZiAoc2VydmVyTW9kZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCkge1xuICAgICAgbWVzc2FnZSArPSBgXFxuXFxuJHtTdHJpbmcoZXJyb3IpfWA7XG4gICAgfSAvLyBHb29kIGdyaWVmIGZvbGtzLCBnZXQgeW91ciBhY3QgdG9nZXRoZXIgXHVEODNEXHVERTAyIVxuXG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICAgIHN0YXR1czogNTAwLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RUeXBlKHVybCwgbWF0Y2hlcykge1xuICBpZiAodXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJfZGF0YVwiKSkge1xuICAgIHJldHVybiBcImRhdGFcIjtcbiAgfVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBcImRvY3VtZW50XCI7XG4gIH1cblxuICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcblxuICBpZiAoIW1hdGNoLnJvdXRlLm1vZHVsZS5kZWZhdWx0KSB7XG4gICAgcmV0dXJuIFwicmVzb3VyY2VcIjtcbiAgfVxuXG4gIHJldHVybiBcImRvY3VtZW50XCI7XG59XG5cbmZ1bmN0aW9uIGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSB7XG4gIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbWV0aG9kID09PSBcInBvc3RcIiB8fCBtZXRob2QgPT09IFwicHV0XCIgfHwgbWV0aG9kID09PSBcInBhdGNoXCIgfHwgbWV0aG9kID09PSBcImRlbGV0ZVwiO1xufVxuXG5mdW5jdGlvbiBpc0hlYWRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiaGVhZFwiO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiIHx8IGlzSGVhZFJlcXVlc3QocmVxdWVzdCkgfHwgaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlcnJvckJvdW5kYXJ5RXJyb3IoZXJyb3IsIHN0YXR1cykge1xuICByZXR1cm4ganNvbihhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvciksIHtcbiAgICBzdGF0dXMsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJYLVJlbWl4LUVycm9yXCI6IFwieWVzXCJcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0luZGV4UmVxdWVzdFVybCh1cmwpIHtcbiAgbGV0IGluZGV4UmVxdWVzdCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IHBhcmFtIG9mIHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIikpIHtcbiAgICBpZiAoIXBhcmFtKSB7XG4gICAgICBpbmRleFJlcXVlc3QgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleFJlcXVlc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvblJlcXVlc3RNYXRjaCh1cmwsIG1hdGNoZXMpIHtcbiAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG5cbiAgaWYgKCFpc0luZGV4UmVxdWVzdFVybCh1cmwpICYmIG1hdGNoLnJvdXRlLmlkLmVuZHNXaXRoKFwiL2luZGV4XCIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoLTIpWzBdO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBrZXkpIHtcbiAgbGV0IG1hdGNoZWQgPSBnZXRNYXRjaGVzVXBUb0RlZXBlc3RCb3VuZGFyeShtYXRjaGVzLCBrZXkpLnNsaWNlKC0xKVswXTtcbiAgcmV0dXJuIG1hdGNoZWQgPyBtYXRjaGVkLnJvdXRlLmlkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkobWF0Y2hlcywga2V5KSB7XG4gIGxldCBkZWVwZXN0Qm91bmRhcnlJbmRleCA9IC0xO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5tb2R1bGVba2V5XSkge1xuICAgICAgZGVlcGVzdEJvdW5kYXJ5SW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkZWVwZXN0Qm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAvLyBubyByb3V0ZSBlcnJvciBib3VuZGFyaWVzLCBkb24ndCBuZWVkIHRvIGNhbGwgYW55IGxvYWRlcnNcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBkZWVwZXN0Qm91bmRhcnlJbmRleCArIDEpO1xufSAvLyBUaGlzIHByZXZlbnRzIGA8T3V0bGV0Lz5gIGZyb20gcmVuZGVyaW5nIGFueXRoaW5nIGJlbG93IHdoZXJlIHRoZSBlcnJvciB0aHJld1xuLy8gVE9ETzogbWF5YmUgZG8gdGhpcyBpbiA8UmVtaXhFcnJvckJvdW5kYXJ5ICsgY29udGV4dD5cblxuXG5mdW5jdGlvbiBnZXRSZW5kZXJhYmxlTWF0Y2hlcyhtYXRjaGVzLCBhcHBTdGF0ZSkge1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBubyBlcnJvciwgbm8gd29ycmllc1xuXG5cbiAgaWYgKCFhcHBTdGF0ZS5jYXRjaCAmJiAhYXBwU3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIGxldCBsYXN0UmVuZGVyYWJsZUluZGV4ID0gLTE7XG4gIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG5cbiAgICBpZiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkIHx8IGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBpZCkge1xuICAgICAgbGFzdFJlbmRlcmFibGVJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIGxhc3RSZW5kZXJhYmxlSW5kZXggKyAxKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUmVxdWVzdEhhbmRsZXIgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGlzUmVzcG9uc2UsIGlzUmVkaXJlY3RSZXNwb25zZSwganNvbiB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcblxuLyoqXG4gKiBBbiBvYmplY3Qgb2YgYXJiaXRyYXJ5IGZvciByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHByb3ZpZGVkIGJ5IHRoZVxuICogc2VydmVyJ3MgYGdldExvYWRDb250ZXh0KClgIGZ1bmN0aW9uLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZUFjdGlvbih7XG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaCxcbiAgcmVxdWVzdFxufSkge1xuICBsZXQgYWN0aW9uID0gbWF0Y2gucm91dGUubW9kdWxlLmFjdGlvbjtcblxuICBpZiAoIWFjdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG1hZGUgYSAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGJ1dCBkaWQgbm90IHByb3ZpZGUgYCArIGBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgYCArIGByZXF1ZXN0LmApO1xuICB9XG5cbiAgbGV0IHJlc3VsdDtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGFjdGlvbih7XG4gICAgICByZXF1ZXN0OiBzdHJpcERhdGFQYXJhbShzdHJpcEluZGV4UGFyYW0ocmVxdWVzdCkpLFxuICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtc1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmICghaXNSZWRpcmVjdFJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgZXJyb3IuaGVhZGVycy5zZXQoXCJYLVJlbWl4LUNhdGNoXCIsIFwieWVzXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGVycm9yO1xuICB9XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgZGVmaW5lZCBhbiBhY3Rpb24gZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBidXQgZGlkbid0IHJldHVybiBgICsgYGFueXRoaW5nIGZyb20geW91ciBcXGBhY3Rpb25cXGAgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmApO1xuICB9XG5cbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IGpzb24ocmVzdWx0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZUxvYWRlcih7XG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaCxcbiAgcmVxdWVzdFxufSkge1xuICBsZXQgbG9hZGVyID0gbWF0Y2gucm91dGUubW9kdWxlLmxvYWRlcjtcblxuICBpZiAoIWxvYWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG1hZGUgYSAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGJ1dCBkaWQgbm90IHByb3ZpZGUgYCArIGBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiLCBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSBgICsgYHJlcXVlc3QuYCk7XG4gIH1cblxuICBsZXQgcmVzdWx0O1xuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgbG9hZGVyKHtcbiAgICAgIHJlcXVlc3Q6IHN0cmlwRGF0YVBhcmFtKHN0cmlwSW5kZXhQYXJhbShyZXF1ZXN0LmNsb25lKCkpKSxcbiAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIWlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUmVkaXJlY3RSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIGVycm9yLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1DYXRjaFwiLCBcInllc1wiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBlcnJvcjtcbiAgfVxuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IGRlZmluZWQgYSBsb2FkZXIgZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBidXQgZGlkbid0IHJldHVybiBgICsgYGFueXRoaW5nIGZyb20geW91ciBcXGBsb2FkZXJcXGAgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmApO1xuICB9XG5cbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IGpzb24ocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcblxuICBmb3IgKGxldCBpbmRleFZhbHVlIG9mIGluZGV4VmFsdWVzKSB7XG4gICAgaWYgKGluZGV4VmFsdWUpIHtcbiAgICAgIGluZGV4VmFsdWVzVG9LZWVwLnB1c2goaW5kZXhWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgdG9LZWVwIG9mIGluZGV4VmFsdWVzVG9LZWVwKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB0b0tlZXApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCByZXF1ZXN0KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBEYXRhUGFyYW0ocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiX2RhdGFcIik7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgcmVxdWVzdCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3BvbnNlKSB7XG4gIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuXG4gIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0gLy8gV2hhdCBvdGhlciBkYXRhIHR5cGVzIGRvIHdlIG5lZWQgdG8gaGFuZGxlIGhlcmU/IFdoYXQgb3RoZXIga2luZHMgb2ZcbiAgLy8gcmVzcG9uc2VzIGFyZSBwZW9wbGUgZ29pbmcgdG8gYmUgcmV0dXJuaW5nIGZyb20gdGhlaXIgbG9hZGVycz9cbiAgLy8gLSBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgP1xuICAvLyAtIG11bHRpcGFydC9mb3JtLWRhdGEgP1xuICAvLyAtIGJpbmFyeSAoYXVkaW8vdmlkZW8pID9cblxuXG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmV4cG9ydCB7IGNhbGxSb3V0ZUFjdGlvbiwgY2FsbFJvdXRlTG9hZGVyLCBleHRyYWN0RGF0YSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW50cnlNYXRjaGVzKG1hdGNoZXMsIHJvdXRlcykge1xuICByZXR1cm4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IHJvdXRlc1ttYXRjaC5yb3V0ZS5pZF1cbiAgfSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMobWFuaWZlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5yZWR1Y2UoKG1lbW8sIHJvdXRlSWQpID0+IHtcbiAgICBtZW1vW3JvdXRlSWRdID0gbWFuaWZlc3Rbcm91dGVJZF0ubW9kdWxlO1xuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVudHJ5TWF0Y2hlcywgY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogVGhpcyB0aGluZyBwcm9iYWJseSB3YXJyYW50cyBzb21lIGV4cGxhbmF0aW9uLlxuICpcbiAqIFRoZSB3aG9sZSBwb2ludCBoZXJlIGlzIHRvIGVtdWxhdGUgY29tcG9uZW50RGlkQ2F0Y2ggZm9yIHNlcnZlciByZW5kZXJpbmcgYW5kXG4gKiBkYXRhIGxvYWRpbmcuIEl0IGNhbiBnZXQgdHJpY2t5LiBSZWFjdCBjYW4gZG8gdGhpcyBvbiBjb21wb25lbnQgYm91bmRhcmllc1xuICogYnV0IGRvZXNuJ3Qgc3VwcG9ydCBpdCBmb3Igc2VydmVyIHJlbmRlcmluZyBvciBkYXRhIGxvYWRpbmcuIFdlIGtub3cgZW5vdWdoXG4gKiB3aXRoIG5lc3RlZCByb3V0ZXMgdG8gYmUgYWJsZSB0byBlbXVsYXRlIHRoZSBiZWhhdmlvciAoYmVjYXVzZSB3ZSBrbm93IHRoZW1cbiAqIHN0YXRpY2FsbHkgYmVmb3JlIHJlbmRlcmluZy4pXG4gKlxuICogRWFjaCByb3V0ZSBjYW4gZXhwb3J0IGFuIGBFcnJvckJvdW5kYXJ5YC5cbiAqXG4gKiAtIFdoZW4gcmVuZGVyaW5nIHRocm93cyBhbiBlcnJvciwgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgd2lsbCByZW5kZXJcbiAqICAgKG5vcm1hbCByZWFjdCBjb21wb25lbnREaWRDYXRjaCkuIFRoaXMgd2lsbCBiZSB0aGUgcm91dGUncyBvd24gYm91bmRhcnksIGJ1dFxuICogICBpZiBub25lIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJ1YmJsZSB1cCB0byB0aGUgcGFyZW50cy5cbiAqIC0gV2hlbiBkYXRhIGxvYWRpbmcgdGhyb3dzIGFuIGVycm9yLCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSB3aWxsIHJlbmRlclxuICogLSBXaGVuIHBlcmZvcm1pbmcgYW4gYWN0aW9uLCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSBmb3IgdGhlIGFjdGlvbidzXG4gKiAgIHJvdXRlIHRyZWUgd2lsbCByZW5kZXIgKG5vIHJlZGlyZWN0IGhhcHBlbnMpXG4gKlxuICogRHVyaW5nIG5vcm1hbCByZWFjdCByZW5kZXJpbmcsIHdlIGRvIG5vdGhpbmcgc3BlY2lhbCwganVzdCBub3JtYWxcbiAqIGNvbXBvbmVudERpZENhdGNoLlxuICpcbiAqIEZvciBzZXJ2ZXIgcmVuZGVyaW5nLCB3ZSBtdXRhdGUgYHJlbmRlckJvdW5kYXJ5Um91dGVJZGAgdG8ga25vdyB0aGUgbGFzdFxuICogbGF5b3V0IHRoYXQgaGFzIGFuIGVycm9yIGJvdW5kYXJ5IHRoYXQgdHJpZWQgdG8gcmVuZGVyLiBUaGlzIGVtdWxhdGVzIHdoaWNoXG4gKiBsYXlvdXQgd291bGQgY2F0Y2ggYSB0aHJvd24gZXJyb3IuIElmIHRoZSByZW5kZXJpbmcgZmFpbHMsIHdlIGNhdGNoIHRoZSBlcnJvclxuICogb24gdGhlIHNlcnZlciwgYW5kIGdvIGFnYWluIGEgc2Vjb25kIHRpbWUgd2l0aCB0aGUgZW11bGF0b3IgaG9sZGluZyBvbiB0byB0aGVcbiAqIGluZm9ybWF0aW9uIGl0IG5lZWRzIHRvIHJlbmRlciB0aGUgc2FtZSBlcnJvciBib3VuZGFyeSBhcyBhIGR5bmFtaWNhbGx5XG4gKiB0aHJvd24gcmVuZGVyIGVycm9yLlxuICpcbiAqIFdoZW4gZGF0YSBsb2FkaW5nLCBzZXJ2ZXIgb3IgY2xpZW50IHNpZGUsIHdlIHVzZSB0aGUgZW11bGF0b3IgdG8gbGlrZXdpc2VcbiAqIGhhbmcgb24gdG8gdGhlIGVycm9yIGFuZCByZS1yZW5kZXIgYXQgdGhlIGFwcHJvcHJpYXRlIGxheW91dCAod2hlcmUgYSB0aHJvd25cbiAqIGVycm9yIHdvdWxkIGhhdmUgYmVlbiBjYXVnaHQgYnkgY0RDKS5cbiAqXG4gKiBXaGVuIGFjdGlvbnMgdGhyb3csIGl0IGFsbCB3b3JrcyB0aGUgc2FtZS4gVGhlcmUncyBhbiBlZGdlIGNhc2UgdG8gYmUgYXdhcmVcbiAqIG9mIHRob3VnaC4gQWN0aW9ucyBub3JtYWxseSBhcmUgcmVxdWlyZWQgdG8gcmVkaXJlY3QsIGJ1dCBpbiB0aGUgY2FzZSBvZlxuICogZXJyb3JzLCB3ZSByZW5kZXIgdGhlIGFjdGlvbidzIHJvdXRlIHdpdGggdGhlIGVtdWxhdG9yIGhvbGRpbmcgb24gdG8gdGhlXG4gKiBlcnJvci4gSWYgZHVyaW5nIHRoaXMgcmVuZGVyIGEgcGFyZW50IHJvdXRlL2xvYWRlciB0aHJvd3Mgd2UgaWdub3JlIHRoYXQgbmV3XG4gKiBlcnJvciBhbmQgcmVuZGVyIHRoZSBhY3Rpb24ncyBvcmlnaW5hbCBlcnJvciBhcyBkZWVwbHkgYXMgcG9zc2libGUuIEluIG90aGVyXG4gKiB3b3Jkcywgd2Ugc2ltcGx5IGlnbm9yZSB0aGUgbmV3IGVycm9yIGFuZCB1c2UgdGhlIGFjdGlvbidzIGVycm9yIGluIHBsYWNlXG4gKiBiZWNhdXNlIGl0IGNhbWUgZmlyc3QsIGFuZCB0aGF0IGp1c3Qgd291bGRuJ3QgYmUgZmFpciB0byBsZXQgZXJyb3JzIGN1dCBpblxuICogbGluZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICB9O1xufVxuXG5leHBvcnQgeyBzZXJpYWxpemVFcnJvciB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgc3BsaXRDb29raWVzU3RyaW5nIH0gZnJvbSAnc2V0LWNvb2tpZS1wYXJzZXInO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIG1hdGNoZXMsIHJvdXRlTG9hZGVyUmVzcG9uc2VzLCBhY3Rpb25SZXNwb25zZSkge1xuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoKHBhcmVudEhlYWRlcnMsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IGJ1aWxkLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlO1xuICAgIGxldCByb3V0ZUxvYWRlclJlc3BvbnNlID0gcm91dGVMb2FkZXJSZXNwb25zZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCBsb2FkZXJIZWFkZXJzID0gcm91dGVMb2FkZXJSZXNwb25zZSA/IHJvdXRlTG9hZGVyUmVzcG9uc2UuaGVhZGVycyA6IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGFjdGlvbkhlYWRlcnMgPSBhY3Rpb25SZXNwb25zZSA/IGFjdGlvblJlc3BvbnNlLmhlYWRlcnMgOiBuZXcgSGVhZGVycygpO1xuICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocm91dGVNb2R1bGUuaGVhZGVycyA/IHR5cGVvZiByb3V0ZU1vZHVsZS5oZWFkZXJzID09PSBcImZ1bmN0aW9uXCIgPyByb3V0ZU1vZHVsZS5oZWFkZXJzKHtcbiAgICAgIGxvYWRlckhlYWRlcnMsXG4gICAgICBwYXJlbnRIZWFkZXJzLFxuICAgICAgYWN0aW9uSGVhZGVyc1xuICAgIH0pIDogcm91dGVNb2R1bGUuaGVhZGVycyA6IHVuZGVmaW5lZCk7IC8vIEF1dG9tYXRpY2FsbHkgcHJlc2VydmUgU2V0LUNvb2tpZSBoZWFkZXJzIHRoYXQgd2VyZSBzZXQgZWl0aGVyIGJ5IHRoZVxuICAgIC8vIGxvYWRlciBvciBieSBhIHBhcmVudCByb3V0ZS5cblxuICAgIHByZXBlbmRDb29raWVzKGFjdGlvbkhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKGxvYWRlckhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LCBuZXcgSGVhZGVycygpKTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgY2hpbGRIZWFkZXJzKSB7XG4gIGxldCBwYXJlbnRTZXRDb29raWVTdHJpbmcgPSBwYXJlbnRIZWFkZXJzLmdldChcIlNldC1Db29raWVcIik7XG5cbiAgaWYgKHBhcmVudFNldENvb2tpZVN0cmluZykge1xuICAgIGxldCBjb29raWVzID0gc3BsaXRDb29raWVzU3RyaW5nKHBhcmVudFNldENvb2tpZVN0cmluZyk7XG4gICAgY29va2llcy5mb3JFYWNoKGNvb2tpZSA9PiB7XG4gICAgICBjaGlsZEhlYWRlcnMuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IGdldERvY3VtZW50SGVhZGVycyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgbWF0Y2hSb3V0ZXMgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuLy8gVE9ETzogZXhwb3J0L2ltcG9ydCBmcm9tIHJlYWN0LXJvdXRlci1kb21cbmZ1bmN0aW9uIG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgcGF0aG5hbWUpIHtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKG1hdGNoID0+ICh7XG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoLnBhdGhuYW1lLFxuICAgIHJvdXRlOiBtYXRjaC5yb3V0ZVxuICB9KSk7XG59XG5cbmV4cG9ydCB7IG1hdGNoU2VydmVyUm91dGVzIH07XG4iLCAiaW1wb3J0IF9leHRlbmRzIGZyb20nQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7dmFyIHIsQj1yfHwocj17fSk7Qi5Qb3A9XCJQT1BcIjtCLlB1c2g9XCJQVVNIXCI7Qi5SZXBsYWNlPVwiUkVQTEFDRVwiO3ZhciBDPVwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/ZnVuY3Rpb24oYil7cmV0dXJuIE9iamVjdC5mcmVlemUoYil9OmZ1bmN0aW9uKGIpe3JldHVybiBifTtmdW5jdGlvbiBEKGIsaCl7aWYoIWIpe1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmY29uc29sZS53YXJuKGgpO3RyeXt0aHJvdyBFcnJvcihoKTt9Y2F0Y2goZSl7fX19ZnVuY3Rpb24gRShiKXtiLnByZXZlbnREZWZhdWx0KCk7Yi5yZXR1cm5WYWx1ZT1cIlwifVxuZnVuY3Rpb24gRigpe3ZhciBiPVtdO3JldHVybntnZXQgbGVuZ3RoKCl7cmV0dXJuIGIubGVuZ3RofSxwdXNoOmZ1bmN0aW9uKGgpe2IucHVzaChoKTtyZXR1cm4gZnVuY3Rpb24oKXtiPWIuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlIT09aH0pfX0sY2FsbDpmdW5jdGlvbihoKXtiLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUoaCl9KX19fWZ1bmN0aW9uIEgoKXtyZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsOCl9ZnVuY3Rpb24gSShiKXt2YXIgaD1iLnBhdGhuYW1lO2g9dm9pZCAwPT09aD9cIi9cIjpoO3ZhciBlPWIuc2VhcmNoO2U9dm9pZCAwPT09ZT9cIlwiOmU7Yj1iLmhhc2g7Yj12b2lkIDA9PT1iP1wiXCI6YjtlJiZcIj9cIiE9PWUmJihoKz1cIj9cIj09PWUuY2hhckF0KDApP2U6XCI/XCIrZSk7YiYmXCIjXCIhPT1iJiYoaCs9XCIjXCI9PT1iLmNoYXJBdCgwKT9iOlwiI1wiK2IpO3JldHVybiBofVxuZnVuY3Rpb24gSihiKXt2YXIgaD17fTtpZihiKXt2YXIgZT1iLmluZGV4T2YoXCIjXCIpOzA8PWUmJihoLmhhc2g9Yi5zdWJzdHIoZSksYj1iLnN1YnN0cigwLGUpKTtlPWIuaW5kZXhPZihcIj9cIik7MDw9ZSYmKGguc2VhcmNoPWIuc3Vic3RyKGUpLGI9Yi5zdWJzdHIoMCxlKSk7YiYmKGgucGF0aG5hbWU9Yil9cmV0dXJuIGh9XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShiKXtmdW5jdGlvbiBoKCl7dmFyIGM9cC5sb2NhdGlvbixhPW0uc3RhdGV8fHt9O3JldHVyblthLmlkeCxDKHtwYXRobmFtZTpjLnBhdGhuYW1lLHNlYXJjaDpjLnNlYXJjaCxoYXNoOmMuaGFzaCxzdGF0ZTphLnVzcnx8bnVsbCxrZXk6YS5rZXl8fFwiZGVmYXVsdFwifSldfWZ1bmN0aW9uIGUoYyl7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBjP2M6SShjKX1mdW5jdGlvbiB4KGMsYSl7dm9pZCAwPT09YSYmKGE9bnVsbCk7cmV0dXJuIEMoX2V4dGVuZHMoe3BhdGhuYW1lOnEucGF0aG5hbWUsaGFzaDpcIlwiLHNlYXJjaDpcIlwifSxcInN0cmluZ1wiPT09dHlwZW9mIGM/SihjKTpjLHtzdGF0ZTphLGtleTpIKCl9KSl9ZnVuY3Rpb24geihjKXt0PWM7Yz1oKCk7dj1jWzBdO3E9Y1sxXTtkLmNhbGwoe2FjdGlvbjp0LGxvY2F0aW9uOnF9KX1mdW5jdGlvbiBBKGMsYSl7ZnVuY3Rpb24gZigpe0EoYyxhKX12YXIgbD1yLlB1c2gsaz14KGMsXG5hKTtpZighZy5sZW5ndGh8fChnLmNhbGwoe2FjdGlvbjpsLGxvY2F0aW9uOmsscmV0cnk6Zn0pLCExKSl7dmFyIG49W3t1c3I6ay5zdGF0ZSxrZXk6ay5rZXksaWR4OnYrMX0sZShrKV07az1uWzBdO249blsxXTt0cnl7bS5wdXNoU3RhdGUoayxcIlwiLG4pfWNhdGNoKEcpe3AubG9jYXRpb24uYXNzaWduKG4pfXoobCl9fWZ1bmN0aW9uIHkoYyxhKXtmdW5jdGlvbiBmKCl7eShjLGEpfXZhciBsPXIuUmVwbGFjZSxrPXgoYyxhKTtnLmxlbmd0aCYmKGcuY2FsbCh7YWN0aW9uOmwsbG9jYXRpb246ayxyZXRyeTpmfSksMSl8fChrPVt7dXNyOmsuc3RhdGUsa2V5Omsua2V5LGlkeDp2fSxlKGspXSxtLnJlcGxhY2VTdGF0ZShrWzBdLFwiXCIsa1sxXSkseihsKSl9ZnVuY3Rpb24gdyhjKXttLmdvKGMpfXZvaWQgMD09PWImJihiPXt9KTtiPWIud2luZG93O3ZhciBwPXZvaWQgMD09PWI/ZG9jdW1lbnQuZGVmYXVsdFZpZXc6YixtPXAuaGlzdG9yeSx1PW51bGw7cC5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIixcbmZ1bmN0aW9uKCl7aWYodSlnLmNhbGwodSksdT1udWxsO2Vsc2V7dmFyIGM9ci5Qb3AsYT1oKCksZj1hWzBdO2E9YVsxXTtpZihnLmxlbmd0aClpZihudWxsIT1mKXt2YXIgbD12LWY7bCYmKHU9e2FjdGlvbjpjLGxvY2F0aW9uOmEscmV0cnk6ZnVuY3Rpb24oKXt3KC0xKmwpfX0sdyhsKSl9ZWxzZVwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/RCghMSxcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgY3JlYXRlZCBieSB0aGUgaGlzdG9yeSBsaWJyYXJ5LiBUaGUgYmxvY2sgd2lsbCBmYWlsIHNpbGVudGx5IGluIHByb2R1Y3Rpb24sIGJ1dCBpbiBnZW5lcmFsIHlvdSBzaG91bGQgZG8gYWxsIG5hdmlnYXRpb24gd2l0aCB0aGUgaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgdG8gYXZvaWQgdGhpcyBzaXR1YXRpb24uXCIpOlxudm9pZCAwO2Vsc2UgeihjKX19KTt2YXIgdD1yLlBvcDtiPWgoKTt2YXIgdj1iWzBdLHE9YlsxXSxkPUYoKSxnPUYoKTtudWxsPT12JiYodj0wLG0ucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LG0uc3RhdGUse2lkeDp2fSksXCJcIikpO3JldHVybntnZXQgYWN0aW9uKCl7cmV0dXJuIHR9LGdldCBsb2NhdGlvbigpe3JldHVybiBxfSxjcmVhdGVIcmVmOmUscHVzaDpBLHJlcGxhY2U6eSxnbzp3LGJhY2s6ZnVuY3Rpb24oKXt3KC0xKX0sZm9yd2FyZDpmdW5jdGlvbigpe3coMSl9LGxpc3RlbjpmdW5jdGlvbihjKXtyZXR1cm4gZC5wdXNoKGMpfSxibG9jazpmdW5jdGlvbihjKXt2YXIgYT1nLnB1c2goYyk7MT09PWcubGVuZ3RoJiZwLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIixFKTtyZXR1cm4gZnVuY3Rpb24oKXthKCk7Zy5sZW5ndGh8fHAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLEUpfX19fTtcbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KGIpe2Z1bmN0aW9uIGgoKXt2YXIgYT1KKG0ubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpLGY9YS5wYXRobmFtZSxsPWEuc2VhcmNoO2E9YS5oYXNoO3ZhciBrPXUuc3RhdGV8fHt9O3JldHVybltrLmlkeCxDKHtwYXRobmFtZTp2b2lkIDA9PT1mP1wiL1wiOmYsc2VhcmNoOnZvaWQgMD09PWw/XCJcIjpsLGhhc2g6dm9pZCAwPT09YT9cIlwiOmEsc3RhdGU6ay51c3J8fG51bGwsa2V5Omsua2V5fHxcImRlZmF1bHRcIn0pXX1mdW5jdGlvbiBlKCl7aWYodCljLmNhbGwodCksdD1udWxsO2Vsc2V7dmFyIGE9ci5Qb3AsZj1oKCksbD1mWzBdO2Y9ZlsxXTtpZihjLmxlbmd0aClpZihudWxsIT1sKXt2YXIgaz1xLWw7ayYmKHQ9e2FjdGlvbjphLGxvY2F0aW9uOmYscmV0cnk6ZnVuY3Rpb24oKXtwKC0xKmspfX0scChrKSl9ZWxzZVwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/RCghMSxcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgY3JlYXRlZCBieSB0aGUgaGlzdG9yeSBsaWJyYXJ5LiBUaGUgYmxvY2sgd2lsbCBmYWlsIHNpbGVudGx5IGluIHByb2R1Y3Rpb24sIGJ1dCBpbiBnZW5lcmFsIHlvdSBzaG91bGQgZG8gYWxsIG5hdmlnYXRpb24gd2l0aCB0aGUgaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgdG8gYXZvaWQgdGhpcyBzaXR1YXRpb24uXCIpOlxudm9pZCAwO2Vsc2UgQShhKX19ZnVuY3Rpb24geChhKXt2YXIgZj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKSxsPVwiXCI7ZiYmZi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpJiYoZj1tLmxvY2F0aW9uLmhyZWYsbD1mLmluZGV4T2YoXCIjXCIpLGw9LTE9PT1sP2Y6Zi5zbGljZSgwLGwpKTtyZXR1cm4gbCtcIiNcIisoXCJzdHJpbmdcIj09PXR5cGVvZiBhP2E6SShhKSl9ZnVuY3Rpb24geihhLGYpe3ZvaWQgMD09PWYmJihmPW51bGwpO3JldHVybiBDKF9leHRlbmRzKHtwYXRobmFtZTpkLnBhdGhuYW1lLGhhc2g6XCJcIixzZWFyY2g6XCJcIn0sXCJzdHJpbmdcIj09PXR5cGVvZiBhP0ooYSk6YSx7c3RhdGU6ZixrZXk6SCgpfSkpfWZ1bmN0aW9uIEEoYSl7dj1hO2E9aCgpO3E9YVswXTtkPWFbMV07Zy5jYWxsKHthY3Rpb246dixsb2NhdGlvbjpkfSl9ZnVuY3Rpb24geShhLGYpe2Z1bmN0aW9uIGwoKXt5KGEsZil9dmFyIGs9ci5QdXNoLG49eihhLGYpO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/XG5EKFwiL1wiPT09bi5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIrSlNPTi5zdHJpbmdpZnkoYSkrXCIpXCIpOnZvaWQgMDtpZighYy5sZW5ndGh8fChjLmNhbGwoe2FjdGlvbjprLGxvY2F0aW9uOm4scmV0cnk6bH0pLCExKSl7dmFyIEc9W3t1c3I6bi5zdGF0ZSxrZXk6bi5rZXksaWR4OnErMX0seChuKV07bj1HWzBdO0c9R1sxXTt0cnl7dS5wdXNoU3RhdGUobixcIlwiLEcpfWNhdGNoKEspe20ubG9jYXRpb24uYXNzaWduKEcpfUEoayl9fWZ1bmN0aW9uIHcoYSxmKXtmdW5jdGlvbiBsKCl7dyhhLGYpfXZhciBrPXIuUmVwbGFjZSxuPXooYSxmKTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoXCIvXCI9PT1uLnBhdGhuYW1lLmNoYXJBdCgwKSxcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucmVwbGFjZShcIitKU09OLnN0cmluZ2lmeShhKStcblwiKVwiKTp2b2lkIDA7Yy5sZW5ndGgmJihjLmNhbGwoe2FjdGlvbjprLGxvY2F0aW9uOm4scmV0cnk6bH0pLDEpfHwobj1be3VzcjpuLnN0YXRlLGtleTpuLmtleSxpZHg6cX0seChuKV0sdS5yZXBsYWNlU3RhdGUoblswXSxcIlwiLG5bMV0pLEEoaykpfWZ1bmN0aW9uIHAoYSl7dS5nbyhhKX12b2lkIDA9PT1iJiYoYj17fSk7Yj1iLndpbmRvdzt2YXIgbT12b2lkIDA9PT1iP2RvY3VtZW50LmRlZmF1bHRWaWV3OmIsdT1tLmhpc3RvcnksdD1udWxsO20uYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsZSk7bS5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLGZ1bmN0aW9uKCl7dmFyIGE9aCgpWzFdO0koYSkhPT1JKGQpJiZlKCl9KTt2YXIgdj1yLlBvcDtiPWgoKTt2YXIgcT1iWzBdLGQ9YlsxXSxnPUYoKSxjPUYoKTtudWxsPT1xJiYocT0wLHUucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LHUuc3RhdGUse2lkeDpxfSksXCJcIikpO3JldHVybntnZXQgYWN0aW9uKCl7cmV0dXJuIHZ9LGdldCBsb2NhdGlvbigpe3JldHVybiBkfSxcbmNyZWF0ZUhyZWY6eCxwdXNoOnkscmVwbGFjZTp3LGdvOnAsYmFjazpmdW5jdGlvbigpe3AoLTEpfSxmb3J3YXJkOmZ1bmN0aW9uKCl7cCgxKX0sbGlzdGVuOmZ1bmN0aW9uKGEpe3JldHVybiBnLnB1c2goYSl9LGJsb2NrOmZ1bmN0aW9uKGEpe3ZhciBmPWMucHVzaChhKTsxPT09Yy5sZW5ndGgmJm0uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLEUpO3JldHVybiBmdW5jdGlvbigpe2YoKTtjLmxlbmd0aHx8bS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsRSl9fX19O1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShiKXtmdW5jdGlvbiBoKGQsZyl7dm9pZCAwPT09ZyYmKGc9bnVsbCk7cmV0dXJuIEMoX2V4dGVuZHMoe3BhdGhuYW1lOnQucGF0aG5hbWUsc2VhcmNoOlwiXCIsaGFzaDpcIlwifSxcInN0cmluZ1wiPT09dHlwZW9mIGQ/SihkKTpkLHtzdGF0ZTpnLGtleTpIKCl9KSl9ZnVuY3Rpb24gZShkLGcsYyl7cmV0dXJuIXEubGVuZ3RofHwocS5jYWxsKHthY3Rpb246ZCxsb2NhdGlvbjpnLHJldHJ5OmN9KSwhMSl9ZnVuY3Rpb24geChkLGcpe3U9ZDt0PWc7di5jYWxsKHthY3Rpb246dSxsb2NhdGlvbjp0fSl9ZnVuY3Rpb24geihkLGcpe3ZhciBjPXIuUHVzaCxhPWgoZCxnKTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoXCIvXCI9PT10LnBhdGhuYW1lLmNoYXJBdCgwKSxcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeS5wdXNoKFwiK0pTT04uc3RyaW5naWZ5KGQpK1wiKVwiKTpcbnZvaWQgMDtlKGMsYSxmdW5jdGlvbigpe3ooZCxnKX0pJiYobSs9MSxwLnNwbGljZShtLHAubGVuZ3RoLGEpLHgoYyxhKSl9ZnVuY3Rpb24gQShkLGcpe3ZhciBjPXIuUmVwbGFjZSxhPWgoZCxnKTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoXCIvXCI9PT10LnBhdGhuYW1lLmNoYXJBdCgwKSxcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeS5yZXBsYWNlKFwiK0pTT04uc3RyaW5naWZ5KGQpK1wiKVwiKTp2b2lkIDA7ZShjLGEsZnVuY3Rpb24oKXtBKGQsZyl9KSYmKHBbbV09YSx4KGMsYSkpfWZ1bmN0aW9uIHkoZCl7dmFyIGc9TWF0aC5taW4oTWF0aC5tYXgobStkLDApLHAubGVuZ3RoLTEpLGM9ci5Qb3AsYT1wW2ddO2UoYyxhLGZ1bmN0aW9uKCl7eShkKX0pJiYobT1nLHgoYyxhKSl9dm9pZCAwPT09YiYmKGI9e30pO3ZhciB3PWI7Yj13LmluaXRpYWxFbnRyaWVzO3c9dy5pbml0aWFsSW5kZXg7dmFyIHA9KHZvaWQgMD09PVxuYj9bXCIvXCJdOmIpLm1hcChmdW5jdGlvbihkKXt2YXIgZz1DKF9leHRlbmRzKHtwYXRobmFtZTpcIi9cIixzZWFyY2g6XCJcIixoYXNoOlwiXCIsc3RhdGU6bnVsbCxrZXk6SCgpfSxcInN0cmluZ1wiPT09dHlwZW9mIGQ/SihkKTpkKSk7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKFwiL1wiPT09Zy5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY3JlYXRlTWVtb3J5SGlzdG9yeSh7IGluaXRpYWxFbnRyaWVzIH0pIChpbnZhbGlkIGVudHJ5OiBcIitKU09OLnN0cmluZ2lmeShkKStcIilcIik6dm9pZCAwO3JldHVybiBnfSksbT1NYXRoLm1pbihNYXRoLm1heChudWxsPT13P3AubGVuZ3RoLTE6dywwKSxwLmxlbmd0aC0xKSx1PXIuUG9wLHQ9cFttXSx2PUYoKSxxPUYoKTtyZXR1cm57Z2V0IGluZGV4KCl7cmV0dXJuIG19LGdldCBhY3Rpb24oKXtyZXR1cm4gdX0sZ2V0IGxvY2F0aW9uKCl7cmV0dXJuIHR9LGNyZWF0ZUhyZWY6ZnVuY3Rpb24oZCl7cmV0dXJuXCJzdHJpbmdcIj09PVxudHlwZW9mIGQ/ZDpJKGQpfSxwdXNoOnoscmVwbGFjZTpBLGdvOnksYmFjazpmdW5jdGlvbigpe3koLTEpfSxmb3J3YXJkOmZ1bmN0aW9uKCl7eSgxKX0sbGlzdGVuOmZ1bmN0aW9uKGQpe3JldHVybiB2LnB1c2goZCl9LGJsb2NrOmZ1bmN0aW9uKGQpe3JldHVybiBxLnB1c2goZCl9fX07ZXhwb3J0e3IgYXMgQWN0aW9uLGNyZWF0ZUJyb3dzZXJIaXN0b3J5LGNyZWF0ZUhhc2hIaXN0b3J5LGNyZWF0ZU1lbW9yeUhpc3RvcnksSSBhcyBjcmVhdGVQYXRoLEogYXMgcGFyc2VQYXRofVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEhpc3RvcnksXG4gIEluaXRpYWxFbnRyeSxcbiAgTG9jYXRpb24sXG4gIE1lbW9yeUhpc3RvcnksXG4gIFBhdGgsXG4gIFRvXG59IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQge1xuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIGNyZWF0ZU1lbW9yeUhpc3RvcnksXG4gIHBhcnNlUGF0aFxufSBmcm9tIFwiaGlzdG9yeVwiO1xuXG5leHBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbywgTmF2aWdhdGlvblR5cGUgfTtcblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKTogYXNzZXJ0cyBjb25kIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCBSb3V0ZXIhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuY29uc3QgYWxyZWFkeVdhcm5lZDogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleTogc3RyaW5nLCBjb25kOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENPTlRFWFRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIE5hdmlnYXRvciBpcyBhIFwibG9jYXRpb24gY2hhbmdlclwiOyBpdCdzIGhvdyB5b3UgZ2V0IHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gKlxuICogRXZlcnkgaGlzdG9yeSBpbnN0YW5jZSBjb25mb3JtcyB0byB0aGUgTmF2aWdhdG9yIGludGVyZmFjZSwgYnV0IHRoZVxuICogZGlzdGluY3Rpb24gaXMgdXNlZnVsIHByaW1hcmlseSB3aGVuIGl0IGNvbWVzIHRvIHRoZSBsb3ctbGV2ZWwgPFJvdXRlcj4gQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IHR5cGUgTmF2aWdhdG9yID0gUGljazxIaXN0b3J5LCBcImdvXCIgfCBcInB1c2hcIiB8IFwicmVwbGFjZVwiIHwgXCJjcmVhdGVIcmVmXCI+O1xuXG5pbnRlcmZhY2UgTmF2aWdhdGlvbkNvbnRleHRPYmplY3Qge1xuICBiYXNlbmFtZTogc3RyaW5nO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljOiBib29sZWFuO1xufVxuXG5jb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmF2aWdhdGlvbkNvbnRleHRPYmplY3Q+KG51bGwhKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cblxuaW50ZXJmYWNlIExvY2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgbmF2aWdhdGlvblR5cGU6IE5hdmlnYXRpb25UeXBlO1xufVxuXG5jb25zdCBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PExvY2F0aW9uQ29udGV4dE9iamVjdD4obnVsbCEpO1xuXG5pZiAoX19ERVZfXykge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5cbmludGVyZmFjZSBSb3V0ZUNvbnRleHRPYmplY3Qge1xuICBvdXRsZXQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGw7XG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXTtcbn1cblxuY29uc3QgUm91dGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxSb3V0ZUNvbnRleHRPYmplY3Q+KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXVxufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBpbml0aWFsRW50cmllcz86IEluaXRpYWxFbnRyeVtdO1xuICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQSA8Um91dGVyPiB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtZW1vcnlyb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1lbW9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaW5pdGlhbEVudHJpZXMsXG4gIGluaXRpYWxJbmRleFxufTogTWVtb3J5Um91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxNZW1vcnlIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHsgaW5pdGlhbEVudHJpZXMsIGluaXRpYWxJbmRleCB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlUHJvcHMge1xuICB0bzogVG87XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gKiBhYmxlIHRvIHVzZSBob29rcy4gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCB3ZSByZWNvbW1lbmQgeW91IHVzZSB0aGVcbiAqIGB1c2VOYXZpZ2F0ZWAgaG9vayBpbnN0ZWFkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5hdmlnYXRlKHsgdG8sIHJlcGxhY2UsIHN0YXRlIH06IE5hdmlnYXRlUHJvcHMpOiBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICB3YXJuaW5nKFxuICAgICFSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gYCArXG4gICAgICBgVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIGAgK1xuICAgICAgYG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcblxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlIH0pO1xuICB9KTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdXRsZXRQcm9wcyB7XG4gIGNvbnRleHQ/OiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNoaWxkIHJvdXRlJ3MgZWxlbWVudCwgaWYgdGhlcmUgaXMgb25lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPdXRsZXQocHJvcHM6IE91dGxldFByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4PzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXRoUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4PzogZmFsc2U7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXlvdXRSb3V0ZVByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4Um91dGVQcm9wcyB7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBpbmRleDogdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZShcbiAgX3Byb3BzOiBQYXRoUm91dGVQcm9wcyB8IExheW91dFJvdXRlUHJvcHMgfCBJbmRleFJvdXRlUHJvcHNcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgYCArXG4gICAgICBgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb246IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xuICBuYXZpZ2F0aW9uVHlwZT86IE5hdmlnYXRpb25UeXBlO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIDxSb3V0ZXI+IGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgPEJyb3dzZXJSb3V0ZXI+XG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVyKHtcbiAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gIG5hdmlnYXRpb25UeXBlID0gTmF2aWdhdGlvblR5cGUuUG9wLFxuICBuYXZpZ2F0b3IsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlXG59OiBSb3V0ZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIGBZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LmAgK1xuICAgICAgYCBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5gXG4gICk7XG5cbiAgbGV0IGJhc2VuYW1lID0gbm9ybWFsaXplUGF0aG5hbWUoYmFzZW5hbWVQcm9wKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoeyBiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWM6IHN0YXRpY1Byb3AgfSksXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpY1Byb3BdXG4gICk7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuXG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuXG4gIGxldCBsb2NhdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB0cmFpbGluZ1BhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpO1xuXG4gICAgaWYgKHRyYWlsaW5nUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaCxcbiAgICAgIHN0YXRlLFxuICAgICAga2V5XG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5XSk7XG5cbiAgd2FybmluZyhcbiAgICBsb2NhdGlvbiAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBgICtcbiAgICAgIGBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYCArXG4gICAgICBgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuXG4gIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bmF2aWdhdGlvbkNvbnRleHR9PlxuICAgICAgPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICAgIHZhbHVlPXt7IGxvY2F0aW9uLCBuYXZpZ2F0aW9uVHlwZSB9fVxuICAgICAgLz5cbiAgICA8L05hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlc1Byb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgPFJvdXRlPiBlbGVtZW50cyB0aGF0IHJlbmRlcnMgdGhlIGJyYW5jaFxuICogdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvblxufTogUm91dGVzUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhPT0tTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlaHJlZlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSHJlZih0bzogVG8pOiBzdHJpbmcge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IGhhc2gsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG5cbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBsZXQgdG9QYXRobmFtZSA9IGdldFRvUGF0aG5hbWUodG8pO1xuICAgIGxldCBlbmRzV2l0aFNsYXNoID0gdG9QYXRobmFtZSAhPSBudWxsICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAgIGpvaW5lZFBhdGhuYW1lID1cbiAgICAgIHBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICA/IGJhc2VuYW1lICsgKGVuZHNXaXRoU2xhc2ggPyBcIi9cIiA6IFwiXCIpXG4gICAgICAgIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGVyPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZWlucm91dGVyY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYXRpb24oKTogTG9jYXRpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbnR5cGUgUGFyYW1QYXJzZUZhaWxlZCA9IHsgZmFpbGVkOiB0cnVlIH07XG5cbnR5cGUgUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBDaGVjayBoZXJlIGlmIHRoZXJlIGV4aXN0cyBhIGZvcndhcmQgc2xhc2ggaW4gdGhlIHN0cmluZy5cbiAgU2VnbWVudCBleHRlbmRzIGAke2luZmVyIExlZnRTZWdtZW50fS8ke2luZmVyIFJpZ2h0U2VnbWVudH1gXG4gICAgPyAvLyBJZiB0aGVyZSBpcyBhIGZvcndhcmQgc2xhc2gsIHRoZW4gYXR0ZW1wdCB0byBwYXJzZSBlYWNoIHNpZGUgb2YgdGhlXG4gICAgICAvLyBmb3J3YXJkIHNsYXNoLlxuICAgICAgUGFyYW1QYXJzZVNlZ21lbnQ8TGVmdFNlZ21lbnQ+IGV4dGVuZHMgaW5mZXIgTGVmdFJlc3VsdFxuICAgICAgPyBQYXJhbVBhcnNlU2VnbWVudDxSaWdodFNlZ21lbnQ+IGV4dGVuZHMgaW5mZXIgUmlnaHRSZXN1bHRcbiAgICAgICAgPyBMZWZ0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgPyAvLyBJZiB0aGUgbGVmdCBzaWRlIGlzIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYXMgYSBwYXJhbSwgdGhlbiBjaGVjayBpZlxuICAgICAgICAgICAgLy8gdGhlIHJpZ2h0IHNpZGUgY2FuIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYXMgd2VsbC4gSWYgYm90aCBzaWRlc1xuICAgICAgICAgICAgLy8gY2FuIGJlIHBhcnNlZCwgdGhlbiB0aGUgcmVzdWx0IGlzIGEgdW5pb24gb2YgdGhlIHR3byBzaWRlc1xuICAgICAgICAgICAgLy8gKHJlYWQ6IFwiZm9vXCIgfCBcImJhclwiKS5cbiAgICAgICAgICAgIFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgICA/IExlZnRSZXN1bHQgfCBSaWdodFJlc3VsdFxuICAgICAgICAgICAgOiBMZWZ0UmVzdWx0XG4gICAgICAgICAgOiAvLyBJZiB0aGUgbGVmdCBzaWRlIGlzIG5vdCBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIGEgcGFyYW0sIHRoZW4gY2hlY2tcbiAgICAgICAgICAvLyBpZiBvbmx5IHRoZSByaWdodCBzaWRlIGNhbiBiZSBzdWNjZXNzZnVsbHkgcGFyc2UgYXMgYSBwYXJhbS4gSWYgaXRcbiAgICAgICAgICAvLyBjYW4sIHRoZW4gdGhlIHJlc3VsdCBpcyBqdXN0IHJpZ2h0LCBlbHNlIGl0J3MgYSBmYWlsdXJlLlxuICAgICAgICAgIFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgPyBSaWdodFJlc3VsdFxuICAgICAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICAgIDogLy8gSWYgdGhlIGxlZnQgc2lkZSBkaWRuJ3QgcGFyc2UgaW50byBhIHBhcmFtLCB0aGVuIGp1c3QgY2hlY2sgdGhlIHJpZ2h0XG4gICAgICAvLyBzaWRlLlxuICAgICAgUGFyYW1QYXJzZVNlZ21lbnQ8UmlnaHRTZWdtZW50PiBleHRlbmRzIGluZmVyIFJpZ2h0UmVzdWx0XG4gICAgICA/IFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgID8gUmlnaHRSZXN1bHRcbiAgICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICA6IC8vIElmIHRoZXJlJ3Mgbm8gZm9yd2FyZCBzbGFzaCwgdGhlbiBjaGVjayBpZiB0aGlzIHNlZ21lbnQgc3RhcnRzIHdpdGggYVxuICAgIC8vIGNvbG9uLiBJZiBpdCBkb2VzLCB0aGVuIHRoaXMgaXMgYSBkeW5hbWljIHNlZ21lbnQsIHNvIHRoZSByZXN1bHQgaXNcbiAgICAvLyBqdXN0IHRoZSByZW1haW5kZXIgb2YgdGhlIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCdzIGEgZmFpbHVyZS5cbiAgICBTZWdtZW50IGV4dGVuZHMgYDoke2luZmVyIFJlbWFpbmluZ31gXG4gICAgPyBSZW1haW5pbmdcbiAgICA6IFBhcmFtUGFyc2VGYWlsZWQ7XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxudHlwZSBQYXJhbVBhcnNlS2V5PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudD4gZXh0ZW5kcyBzdHJpbmdcbiAgICA/IFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQ+XG4gICAgOiBzdHJpbmc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRpb250eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpOiBOYXZpZ2F0aW9uVHlwZSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBVUkwgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUgbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29tcG9uZW50cyB0aGF0IG5lZWQgdG8ga25vdyBcImFjdGl2ZVwiIHN0YXRlLCBlLmcuXG4gKiA8TmF2TGluaz4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VtYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgpOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aDxQYXJhbUtleSwgUGF0aD4ocGF0dGVybiwgcGF0aG5hbWUpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVGdW5jdGlvbiB7XG4gICh0bzogVG8sIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICAoZGVsdGE6IG51bWJlcik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVPcHRpb25zIHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSA8TGluaz5zLCBidXRcbiAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpOiBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgbWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgbGV0IG5hdmlnYXRlOiBOYXZpZ2F0ZUZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRvOiBUbyB8IG51bWJlciwgb3B0aW9uczogTmF2aWdhdGVPcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGFjdGl2ZVJlZi5jdXJyZW50LFxuICAgICAgICBgWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gYCArXG4gICAgICAgICAgYHlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLmBcbiAgICAgICk7XG5cbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lXG4gICAgICApO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGgucGF0aG5hbWUgPSBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKFxuICAgICAgICBwYXRoLFxuICAgICAgICBvcHRpb25zLnN0YXRlXG4gICAgICApO1xuICAgIH0sXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZV1cbiAgKTtcblxuICByZXR1cm4gbmF2aWdhdGU7XG59XG5cbmNvbnN0IE91dGxldENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHVua25vd24+KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgKGlmIHByb3ZpZGVkKSBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW91dGxldGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldENvbnRleHQ8Q29udGV4dCA9IHVua25vd24+KCk6IENvbnRleHQge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KSBhcyBDb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgPE91dGxldD4gdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW91dGxldFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQ/OiB1bmtub3duKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGxldCBvdXRsZXQgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxPdXRsZXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0fT57b3V0bGV0fTwvT3V0bGV0Q29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xuICB9XG4gIHJldHVybiBvdXRsZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50XG4gKiBVUkwgdGhhdCB3ZXJlIG1hdGNoZWQgYnkgdGhlIHJvdXRlIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VwYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhcmFtczxcbiAgUGFyYW1zT3JLZXkgZXh0ZW5kcyBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gc3RyaW5nXG4+KCk6IFJlYWRvbmx5PFxuICBbUGFyYW1zT3JLZXldIGV4dGVuZHMgW3N0cmluZ10gPyBQYXJhbXM8UGFyYW1zT3JLZXk+IDogUGFydGlhbDxQYXJhbXNPcktleT5cbj4ge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IChyb3V0ZU1hdGNoLnBhcmFtcyBhcyBhbnkpIDoge307XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGhuYW1lIG9mIHRoZSBnaXZlbiBgdG9gIHZhbHVlIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VyZXNvbHZlZHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bzogVG8pOiBQYXRoIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgbWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZV1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHQgdG8gcmVuZGVyIHRoZSByZW1haW5kZXIgb2YgdGhlIHJvdXRlIHRyZWUuIFJvdXRlXG4gKiBlbGVtZW50cyBpbiB0aGUgdHJlZSBtdXN0IHJlbmRlciBhbiA8T3V0bGV0PiB0byByZW5kZXIgdGhlaXIgY2hpbGQgcm91dGUnc1xuICogZWxlbWVudC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXJvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGxvY2F0aW9uQXJnPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmdcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgLy8gd2l0aG91dCBhIHRyYWlsaW5nICosIGJ1dCB0aGlzIGlzIGEgYmVzdC1lZmZvcnQgd2FybmluZyBhbnl3YXkgc2luY2Ugd2VcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAvL1xuICAgIC8vIEV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8Um91dGVzPlxuICAgIC8vICAgey8qIFRoaXMgcm91dGUgcGF0aCBNVVNUIGVuZCB3aXRoIC8qIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nL2ZlZWRcIiBlbGVtZW50PXs8QmxvZ0ZlZWQgLz59IC8+XG4gICAgLy8gPC9Sb3V0ZXM+XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBCbG9nKCkge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAvLyAgICAgICA8Um91dGUgcGF0aD1cInBvc3QvOmlkXCIgZWxlbWVudD17PFBvc3QgLz59IC8+XG4gICAgLy8gICAgIDwvUm91dGVzPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgbGV0IHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLFxuICAgICAgYFlvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgXFxgdXNlUm91dGVzKClcXGApIGF0IGAgK1xuICAgICAgICBgXCIke3BhcmVudFBhdGhuYW1lfVwiICh1bmRlciA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4pIGJ1dCB0aGUgYCArXG4gICAgICAgIGBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGAgK1xuICAgICAgICBgZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgYCArXG4gICAgICAgIGByb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuYCArXG4gICAgICAgIGBQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+IHRvIDxSb3V0ZSBgICtcbiAgICAgICAgYHBhdGg9XCIke3BhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBgJHtwYXJlbnRQYXRofS8qYH1cIj4uYFxuICAgICk7XG4gIH1cblxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPVxuICAgICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fFxuICAgICAgICBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZT8uc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpLFxuICAgICAgYFdoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgXFxgPFJvdXRlcyBsb2NhdGlvbj5cXGAgb3IgXFxgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pXFxgLCBgICtcbiAgICAgICAgYHRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBgICtcbiAgICAgICAgYG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBgICtcbiAgICAgICAgYGJ1dCBwYXRobmFtZSBcIiR7cGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWV9XCIgd2FzIGdpdmVuIGluIHRoZSBcXGBsb2NhdGlvblxcYCBwcm9wLmBcbiAgICApO1xuXG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cblxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICA/IHBhdGhuYW1lXG4gICAgICA6IHBhdGhuYW1lLnNsaWNlKHBhcmVudFBhdGhuYW1lQmFzZS5sZW5ndGgpIHx8IFwiL1wiO1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgeyBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUgfSk7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgcGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLFxuICAgICAgYE5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgYFxuICAgICk7XG5cbiAgICB3YXJuaW5nKFxuICAgICAgbWF0Y2hlcyA9PSBudWxsIHx8XG4gICAgICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQsXG4gICAgICBgTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50LiBgICtcbiAgICAgICAgYFRoaXMgbWVhbnMgaXQgd2lsbCByZW5kZXIgYW4gPE91dGxldCAvPiB3aXRoIGEgbnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcImVtcHR5XCIgcGFnZS5gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhcbiAgICBtYXRjaGVzICYmXG4gICAgICBtYXRjaGVzLm1hcChtYXRjaCA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgICAgICBwYXRobmFtZUJhc2U6XG4gICAgICAgICAgICBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICAgICAgICAgID8gcGFyZW50UGF0aG5hbWVCYXNlXG4gICAgICAgICAgICAgIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgIHBhcmVudE1hdGNoZXNcbiAgKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcm91dGUgY29uZmlnIGZyb20gYSBSZWFjdCBcImNoaWxkcmVuXCIgb2JqZWN0LCB3aGljaCBpcyB1c3VhbGx5XG4gKiBlaXRoZXIgYSBgPFJvdXRlPmAgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGVtLiBVc2VkIGludGVybmFsbHkgYnlcbiAqIGA8Um91dGVzPmAgdG8gY3JlYXRlIGEgcm91dGUgY29uZmlnIGZyb20gaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjY3JlYXRlcm91dGVzZnJvbWNoaWxkcmVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbik6IFJvdXRlT2JqZWN0W10ge1xuICBsZXQgcm91dGVzOiBSb3V0ZU9iamVjdFtdID0gW107XG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZWxlbWVudCA9PiB7XG4gICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbilcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHtcbiAgICAgICAgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lXG4gICAgICB9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG5cbiAgICBsZXQgcm91dGU6IFJvdXRlT2JqZWN0ID0ge1xuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGhcbiAgICB9O1xuXG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFyc2VkIGZyb20gdGhlIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXM8S2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW2tleSBpbiBLZXldOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEEgcm91dGUgb2JqZWN0IHJlcHJlc2VudHMgYSBsb2dpY2FsIHJvdXRlLCB3aXRoIChvcHRpb25hbGx5KSBpdHMgY2hpbGRcbiAqIHJvdXRlcyBvcmdhbml6ZWQgaW4gYSB0cmVlLWxpa2Ugc3RydWN0dXJlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlT2JqZWN0IHtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNoaWxkcmVuPzogUm91dGVPYmplY3RbXTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5kZXg/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI2dlbmVyYXRlcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKHBhdGg6IHN0cmluZywgcGFyYW1zOiBQYXJhbXMgPSB7fSk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoXG4gICAgLnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGtleSkgPT4ge1xuICAgICAgaW52YXJpYW50KHBhcmFtc1trZXldICE9IG51bGwsIGBNaXNzaW5nIFwiOiR7a2V5fVwiIHBhcmFtYCk7XG4gICAgICByZXR1cm4gcGFyYW1zW2tleV0hO1xuICAgIH0pXG4gICAgLnJlcGxhY2UoL1xcLypcXCokLywgXyA9PlxuICAgICAgcGFyYW1zW1wiKlwiXSA9PSBudWxsID8gXCJcIiA6IHBhcmFtc1tcIipcIl0ucmVwbGFjZSgvXlxcLyovLCBcIi9cIilcbiAgICApO1xufVxuXG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVNYXRjaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByb3V0ZSBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHJvdXRlOiBSb3V0ZU9iamVjdDtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI21hdGNocm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmcsXG4gIGJhc2VuYW1lID0gXCIvXCJcbik6IFJvdXRlTWF0Y2hbXSB8IG51bGwge1xuICBsZXQgbG9jYXRpb24gPVxuICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG5cbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuXG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2hlc1tpXSwgcGF0aG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmludGVyZmFjZSBSb3V0ZU1ldGEge1xuICByZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgY2FzZVNlbnNpdGl2ZTogYm9vbGVhbjtcbiAgY2hpbGRyZW5JbmRleDogbnVtYmVyO1xuICByb3V0ZTogUm91dGVPYmplY3Q7XG59XG5cbmludGVyZmFjZSBSb3V0ZUJyYW5jaCB7XG4gIHBhdGg6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91dGVzTWV0YTogUm91dGVNZXRhW107XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10gPSBbXSxcbiAgcGFyZW50c01ldGE6IFJvdXRlTWV0YVtdID0gW10sXG4gIHBhcmVudFBhdGggPSBcIlwiXG4pOiBSb3V0ZUJyYW5jaFtdIHtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCBtZXRhOiBSb3V0ZU1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJvdXRlLnBhdGggfHwgXCJcIixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSxcbiAgICAgICAgYEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBgICtcbiAgICAgICAgICBgYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXCIke3BhdGh9XCIuYFxuICAgICAgKTtcblxuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIFJvdXRlcyB3aXRob3V0IGEgcGF0aCBzaG91bGRuJ3QgZXZlciBtYXRjaCBieSB0aGVtc2VsdmVzIHVubGVzcyB0aGV5IGFyZVxuICAgIC8vIGluZGV4IHJvdXRlcywgc28gZG9uJ3QgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcG9zc2libGUgYnJhbmNoZXMuXG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicmFuY2hlcy5wdXNoKHsgcGF0aCwgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksIHJvdXRlc01ldGEgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10pOiB2b2lkIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT5cbiAgICBhLnNjb3JlICE9PSBiLnNjb3JlXG4gICAgICA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICAgICAgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgICAgICBhLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgICAgICBiLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KVxuICAgICAgICApXG4gICk7XG59XG5cbmNvbnN0IHBhcmFtUmUgPSAvXjpcXHcrJC87XG5jb25zdCBkeW5hbWljU2VnbWVudFZhbHVlID0gMztcbmNvbnN0IGluZGV4Um91dGVWYWx1ZSA9IDI7XG5jb25zdCBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG5jb25zdCBzdGF0aWNTZWdtZW50VmFsdWUgPSAxMDtcbmNvbnN0IHNwbGF0UGVuYWx0eSA9IC0yO1xuY29uc3QgaXNTcGxhdCA9IChzOiBzdHJpbmcpID0+IHMgPT09IFwiKlwiO1xuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aDogc3RyaW5nLCBpbmRleDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cblxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzXG4gICAgLmZpbHRlcihzID0+ICFpc1NwbGF0KHMpKVxuICAgIC5yZWR1Y2UoXG4gICAgICAoc2NvcmUsIHNlZ21lbnQpID0+XG4gICAgICAgIHNjb3JlICtcbiAgICAgICAgKHBhcmFtUmUudGVzdChzZWdtZW50KVxuICAgICAgICAgID8gZHluYW1pY1NlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc2VnbWVudCA9PT0gXCJcIlxuICAgICAgICAgID8gZW1wdHlTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksXG4gICAgICBpbml0aWFsU2NvcmVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgc2libGluZ3MgPVxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG5cbiAgcmV0dXJuIHNpYmxpbmdzXG4gICAgPyAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gICAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICAgICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICAgOiAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgICAgIDA7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICBicmFuY2g6IFJvdXRlQnJhbmNoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBSb3V0ZU1hdGNoPFBhcmFtS2V5PltdIHwgbnVsbCB7XG4gIGxldCB7IHJvdXRlc01ldGEgfSA9IGJyYW5jaDtcblxuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBwYXRobmFtZVxuICAgICAgICA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcblxuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG5cbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSksXG4gICAgICByb3V0ZVxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbFxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGwsXG4gIHBhcmVudE1hdGNoZXM6IFJvdXRlTWF0Y2hbXSA9IFtdXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxSb3V0ZUNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgY2hpbGRyZW49e1xuICAgICAgICAgIG1hdGNoLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCA/IG1hdGNoLnJvdXRlLmVsZW1lbnQgOiA8T3V0bGV0IC8+XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgbWF0Y2hlczogcGFyZW50TWF0Y2hlcy5jb25jYXQobWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApO1xuICB9LCBudWxsIGFzIFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwpO1xufVxuXG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFBhdHRlcm48UGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBhIFVSTCBwYXRobmFtZS4gTWF5IGNvbnRhaW4gYDppZGAtc3R5bGUgc2VnbWVudHNcbiAgICogdG8gaW5kaWNhdGUgcGxhY2Vob2xkZXJzIGZvciBkeW5hbWljIHBhcmFtZXRlcnMuIE1heSBhbHNvIGVuZCB3aXRoIGAvKmAgdG9cbiAgICogaW5kaWNhdGUgbWF0Y2hpbmcgdGhlIHJlc3Qgb2YgdGhlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIHBhdGg6IFBhdGg7XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBzdGF0aWMgcG9ydGlvbnMgb2YgdGhlIGBwYXRoYCBzaG91bGQgYmUgbWF0Y2hlZCBpblxuICAgKiB0aGUgc2FtZSBjYXNlLlxuICAgKi9cbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoaXMgcGF0dGVybiBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBlbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgUGF0aE1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgUGF0aFBhdHRlcm4gbWF0Y2hlZCBvbiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcGF0dGVybjogUGF0aFBhdHRlcm47XG59XG5cbnR5cGUgTXV0YWJsZTxUPiA9IHtcbiAgLXJlYWRvbmx5IFtQIGluIGtleW9mIFRdOiBUW1BdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUGF0aDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KFxuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKVxuICAgICAgICAgIC5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIixcbiAgICAgICAgcGFyYW1OYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVBhdGgoXG4gIHBhdGg6IHN0cmluZyxcbiAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICBlbmQgPSB0cnVlXG4pOiBbUmVnRXhwLCBzdHJpbmdbXV0ge1xuICB3YXJuaW5nKFxuICAgIHBhdGggPT09IFwiKlwiIHx8ICFwYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXRoLmVuZHNXaXRoKFwiLypcIiksXG4gICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgYCArXG4gICAgICBgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBgICtcbiAgICAgIGBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIGAgK1xuICAgICAgYHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICApO1xuXG4gIGxldCBwYXJhbU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcmVnZXhwU291cmNlID1cbiAgICBcIl5cIiArXG4gICAgcGF0aFxuICAgICAgLnJlcGxhY2UoL1xcLypcXCo/JC8sIFwiXCIpIC8vIElnbm9yZSB0cmFpbGluZyAvIGFuZCAvKiwgd2UnbGwgaGFuZGxlIGl0IGJlbG93XG4gICAgICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAgICAgLnJlcGxhY2UoL1tcXFxcLiorXiQ/e318KClbXFxdXS9nLCBcIlxcXFwkJlwiKSAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyc1xuICAgICAgLnJlcGxhY2UoLzooXFx3KykvZywgKF86IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcGFyYW1OYW1lcy5wdXNoKHBhcmFtTmFtZSk7XG4gICAgICAgIHJldHVybiBcIihbXlxcXFwvXSspXCI7XG4gICAgICB9KTtcblxuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbU5hbWVzLnB1c2goXCIqXCIpO1xuICAgIHJlZ2V4cFNvdXJjZSArPVxuICAgICAgcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiXG4gICAgICAgID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgICAgIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjsgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgLyBpbiBwYXJhbXNbXCIqXCJdXG4gIH0gZWxzZSB7XG4gICAgcmVnZXhwU291cmNlICs9IGVuZFxuICAgICAgPyBcIlxcXFwvKiRcIiAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgICA6IC8vIE90aGVyd2lzZSwgbWF0Y2ggYSB3b3JkIGJvdW5kYXJ5IG9yIGEgcHJvY2VlZGluZyAvLiBUaGUgd29yZCBib3VuZGFyeSByZXN0cmljdHNcbiAgICAgICAgLy8gcGFyZW50IHJvdXRlcyB0byBtYXRjaGluZyBvbmx5IHRoZWlyIG93biB3b3JkcyBhbmQgbm90aGluZyBtb3JlLCBlLmcuIHBhcmVudFxuICAgICAgICAvLyByb3V0ZSBcIi9ob21lXCIgc2hvdWxkIG5vdCBtYXRjaCBcIi9ob21lMlwiLlxuICAgICAgICBcIig/OlxcXFxifFxcXFwvfCQpXCI7XG4gIH1cblxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xuXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1OYW1lc107XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSUNvbXBvbmVudCh2YWx1ZTogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgdmFsdWUgZm9yIHRoZSBVUkwgcGFyYW0gXCIke3BhcmFtTmFtZX1cIiB3aWxsIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2VgICtcbiAgICAgICAgYCB0aGUgc3RyaW5nIFwiJHt2YWx1ZX1cIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseWAgK1xuICAgICAgICBgIGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcmVzb2x2ZXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvOiBUbywgZnJvbVBhdGhuYW1lID0gXCIvXCIpOiBQYXRoIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG5cbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZVxuICAgID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgPyB0b1BhdGhuYW1lXG4gICAgICA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpXG4gICAgOiBmcm9tUGF0aG5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHJlbGF0aXZlUGF0aDogc3RyaW5nLCBmcm9tUGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgbGV0IHJlbGF0aXZlU2VnbWVudHMgPSByZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpO1xuXG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVG8oXG4gIHRvQXJnOiBUbyxcbiAgcm91dGVQYXRobmFtZXM6IHN0cmluZ1tdLFxuICBsb2NhdGlvblBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGgge1xuICBsZXQgdG8gPSB0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG9BcmcpIDogdG9Bcmc7XG4gIGxldCB0b1BhdGhuYW1lID0gdG9BcmcgPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCIgPyBcIi9cIiA6IHRvLnBhdGhuYW1lO1xuXG4gIC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cbiAgbGV0IGZyb206IHN0cmluZztcbiAgaWYgKHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuXG4gICAgICAvLyBFYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFucyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmVcbiAgICAgIC8vIFVSTCBzZWdtZW50XCIuICBUaGlzIGlzIGEga2V5IGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGFcbiAgICAgIC8vIG1ham9yIHJlYXNvbiB3ZSBjYWxsIHRoaXMgYSBcInRvXCIgdmFsdWUgaW5zdGVhZCBvZiBhIFwiaHJlZlwiLlxuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuXG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIHRvIHZhbHVlIGhhZCBvbmUuXG4gIGlmIChcbiAgICB0b1BhdGhuYW1lICYmXG4gICAgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiZcbiAgICB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgICFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKVxuICApIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG86IFRvKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCAodG8gYXMgUGF0aCkucGF0aG5hbWUgPT09IFwiXCJcbiAgICA/IFwiL1wiXG4gICAgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCJcbiAgICA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWVcbiAgICA6IHRvLnBhdGhuYW1lO1xufVxuXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lOiBzdHJpbmcsIGJhc2VuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuXG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoYmFzZW5hbWUubGVuZ3RoKTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIC8vIHBhdGhuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggYmFzZW5hbWUvXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWUuc2xpY2UoYmFzZW5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbn1cblxuY29uc3Qgam9pblBhdGhzID0gKHBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyA9PlxuICBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcblxuY29uc3Qgbm9ybWFsaXplUGF0aG5hbWUgPSAocGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuXG5jb25zdCBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiXG4gICAgPyBcIlwiXG4gICAgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIilcbiAgICA/IHNlYXJjaFxuICAgIDogXCI/XCIgKyBzZWFyY2g7XG5cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSAoaGFzaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgTmF2aWdhdGlvbkNvbnRleHQgYXMgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQgYXMgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHRcbn07XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEJyb3dzZXJIaXN0b3J5LCBIYXNoSGlzdG9yeSwgSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgeyBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZVBhdGggfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgZ2VuZXJhdGVQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgbWF0Y2hQYXRoLFxuICByZXNvbHZlUGF0aCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUm91dGVzLFxuICB1c2VPdXRsZXRDb250ZXh0XG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB0eXBlIHsgVG8gfSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSRS1FWFBPUlRTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBOb3RlOiBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yb3V0ZXIgZXhwb3J0cyFcbmV4cG9ydCB7XG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGdlbmVyYXRlUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIG1hdGNoUGF0aCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgcmVzb2x2ZVBhdGgsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJvdXRlcyxcbiAgdXNlT3V0bGV0Q29udGV4dFxufTtcblxuZXhwb3J0IHR5cGUge1xuICBMb2NhdGlvbixcbiAgUGF0aCxcbiAgVG8sXG4gIE5hdmlnYXRpb25UeXBlLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVGdW5jdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBOYXZpZ2F0b3IsXG4gIE91dGxldFByb3BzLFxuICBQYXJhbXMsXG4gIFBhdGhNYXRjaCxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG4gIFJvdXRlUHJvcHMsXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIFJvdXRlclByb3BzLFxuICBSb3V0ZXNQcm9wc1xufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERBTkdFUiEgUExFQVNFIFJFQUQgTUUhXG4vLyBXZSBwcm92aWRlIHRoZXNlIGV4cG9ydHMgYXMgYW4gZXNjYXBlIGhhdGNoIGluIHRoZSBldmVudCB0aGF0IHlvdSBuZWVkIGFueVxuLy8gcm91dGluZyBkYXRhIHRoYXQgd2UgZG9uJ3QgcHJvdmlkZSBhbiBleHBsaWNpdCBBUEkgZm9yLiBXaXRoIHRoYXQgc2FpZCwgd2Vcbi8vIHdhbnQgdG8gY292ZXIgeW91ciB1c2UgY2FzZSBpZiB3ZSBjYW4sIHNvIGlmIHlvdSBmZWVsIHRoZSBuZWVkIHRvIHVzZSB0aGVzZVxuLy8gd2Ugd2FudCB0byBoZWFyIGZyb20geW91LiBMZXQgdXMga25vdyB3aGF0IHlvdSdyZSBidWlsZGluZyBhbmQgd2UnbGwgZG8gb3VyXG4vLyBiZXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gc3VwcG9ydCB5b3UhXG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlc2UgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIGRvIG5vdCBndWFyYW50ZWVcbi8vIGFnYWluc3QgYW55IGJyZWFraW5nIGNoYW5nZXMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNlbXZlciByZWxlYXNlLiBVc2Ugd2l0aFxuLy8gZXh0cmVtZSBjYXV0aW9uIGFuZCBvbmx5IGlmIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuIEdvZHNwZWVkLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQge1xuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHRcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQnJvd3NlclJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgd2luZG93XG59OiBCcm93c2VyUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8QnJvd3Nlckhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93IH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaFJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBTdG9yZXMgdGhlIGxvY2F0aW9uIGluIHRoZSBoYXNoXG4gKiBwb3J0aW9uIG9mIHRoZSBVUkwgc28gaXQgaXMgbm90IHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEhhc2hSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIHdpbmRvdyB9OiBIYXNoUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8SGFzaEhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHsgd2luZG93IH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCBoaXN0b3J5IH06IEhpc3RvcnlSb3V0ZXJQcm9wcykge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmlmIChfX0RFVl9fKSB7XG4gIEhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbn1cblxuZXhwb3J0IHsgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyIH07XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxSZWFjdC5BbmNob3JIVE1MQXR0cmlidXRlczxIVE1MQW5jaG9yRWxlbWVudD4sIFwiaHJlZlwiPiB7XG4gIHJlbG9hZERvY3VtZW50PzogYm9vbGVhbjtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICB0bzogVG87XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5leHBvcnQgY29uc3QgTGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIExpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIExpbmtXaXRoUmVmKFxuICAgIHsgb25DbGljaywgcmVsb2FkRG9jdW1lbnQsIHJlcGxhY2UgPSBmYWxzZSwgc3RhdGUsIHRhcmdldCwgdG8sIC4uLnJlc3QgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywgeyByZXBsYWNlLCBzdGF0ZSwgdGFyZ2V0IH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKFxuICAgICAgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEFuY2hvckVsZW1lbnQsIE1vdXNlRXZlbnQ+XG4gICAgKSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgIXJlbG9hZERvY3VtZW50KSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICAgIDxhXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBocmVmPXtocmVmfVxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHRhcmdldD17dGFyZ2V0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2TGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxMaW5rUHJvcHMsIFwiY2xhc3NOYW1lXCIgfCBcInN0eWxlXCIgfCBcImNoaWxkcmVuXCI+IHtcbiAgY2hpbGRyZW46XG4gICAgfCBSZWFjdC5SZWFjdE5vZGVcbiAgICB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gUmVhY3QuUmVhY3ROb2RlKTtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNsYXNzTmFtZT86IHN0cmluZyB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gc3RyaW5nKTtcbiAgZW5kPzogYm9vbGVhbjtcbiAgc3R5bGU/OlxuICAgIHwgUmVhY3QuQ1NTUHJvcGVydGllc1xuICAgIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbiB9KSA9PiBSZWFjdC5DU1NQcm9wZXJ0aWVzKTtcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5hdkxpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBOYXZMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZihcbiAgICB7XG4gICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgICBlbmQgPSBmYWxzZSxcbiAgICAgIHN0eWxlOiBzdHlsZVByb3AsXG4gICAgICB0byxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IHBhdGgucGF0aG5hbWU7XG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNBY3RpdmUgPVxuICAgICAgbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fFxuICAgICAgKCFlbmQgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuXG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AoeyBpc0FjdGl2ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgICBjbGFzc05hbWUgPSBbY2xhc3NOYW1lUHJvcCwgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZVByb3AgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlUHJvcCh7IGlzQWN0aXZlIH0pIDogc3R5bGVQcm9wO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMaW5rXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBhcmlhLWN1cnJlbnQ9e2FyaWFDdXJyZW50fVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgdG89e3RvfVxuICAgICAgPlxuICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbih7IGlzQWN0aXZlIH0pIDogY2hpbGRyZW59XG4gICAgICA8L0xpbms+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSE9PS1Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICogeW91IG5lZWQgdG8gY3JlYXRlIGN1c3RvbSBgPExpbms+YCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgY2xpY2sgYmVoYXZpb3Igd2VcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyPEUgZXh0ZW5kcyBFbGVtZW50ID0gSFRNTEFuY2hvckVsZW1lbnQ+KFxuICB0bzogVG8sXG4gIHtcbiAgICB0YXJnZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgc3RhdGVcbiAgfToge1xuICAgIHRhcmdldD86IFJlYWN0LkhUTUxBdHRyaWJ1dGVBbmNob3JUYXJnZXQ7XG4gICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgc3RhdGU/OiBhbnk7XG4gIH0gPSB7fVxuKTogKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB2b2lkIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICAgICAoIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxuICAgICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUuXG4gICAgICAgIGxldCByZXBsYWNlID1cbiAgICAgICAgICAhIXJlcGxhY2VQcm9wIHx8IGNyZWF0ZVBhdGgobG9jYXRpb24pID09PSBjcmVhdGVQYXRoKHBhdGgpO1xuXG4gICAgICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2xvY2F0aW9uLCBuYXZpZ2F0ZSwgcGF0aCwgcmVwbGFjZVByb3AsIHN0YXRlLCB0YXJnZXQsIHRvXVxuICApO1xufVxuXG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQ/OiBVUkxTZWFyY2hQYXJhbXNJbml0KSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IGAgK1xuICAgICAgYHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgYCArXG4gICAgICBgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgYCArXG4gICAgICBgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuYCArXG4gICAgICBgSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IGAgK1xuICAgICAgYGh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBgICtcbiAgICAgIGB0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgYCArXG4gICAgICBgdXNlci5gXG4gICk7XG5cbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG5cbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKTtcblxuICAgIGZvciAobGV0IGtleSBvZiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQua2V5cygpKSB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQuZ2V0QWxsKGtleSkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbiAgfSwgW2xvY2F0aW9uLnNlYXJjaF0pO1xuXG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoXG4gICAgICBuZXh0SW5pdDogVVJMU2VhcmNoUGFyYW1zSW5pdCxcbiAgICAgIG5hdmlnYXRlT3B0aW9ucz86IHsgcmVwbGFjZT86IGJvb2xlYW47IHN0YXRlPzogYW55IH1cbiAgICApID0+IHtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgY3JlYXRlU2VhcmNoUGFyYW1zKG5leHRJbml0KSwgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9LFxuICAgIFtuYXZpZ2F0ZV1cbiAgKTtcblxuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXSBhcyBjb25zdDtcbn1cblxuZXhwb3J0IHR5cGUgUGFyYW1LZXlWYWx1ZVBhaXIgPSBbc3RyaW5nLCBzdHJpbmddO1xuXG5leHBvcnQgdHlwZSBVUkxTZWFyY2hQYXJhbXNJbml0ID1cbiAgfCBzdHJpbmdcbiAgfCBQYXJhbUtleVZhbHVlUGFpcltdXG4gIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+XG4gIHwgVVJMU2VhcmNoUGFyYW1zO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXG4gKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcbiAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICogICBdKTtcbiAqXG4gKiB5b3UgY2FuIGRvOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XG4gKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAqICAgfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gIGluaXQ6IFVSTFNlYXJjaFBhcmFtc0luaXQgPSBcIlwiXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgIEFycmF5LmlzQXJyYXkoaW5pdCkgfHxcbiAgICBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zXG4gICAgICA/IGluaXRcbiAgICAgIDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgICAgICk7XG4gICAgICAgIH0sIFtdIGFzIFBhcmFtS2V5VmFsdWVQYWlyW10pXG4gICk7XG59XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKipcbiAqIFRoZSBtb2RlIHRvIHVzZSB3aGVuIHJ1bm5pbmcgdGhlIHNlcnZlci5cbiAqL1xubGV0IFNlcnZlck1vZGU7XG5cbihmdW5jdGlvbiAoU2VydmVyTW9kZSkge1xuICBTZXJ2ZXJNb2RlW1wiRGV2ZWxvcG1lbnRcIl0gPSBcImRldmVsb3BtZW50XCI7XG4gIFNlcnZlck1vZGVbXCJQcm9kdWN0aW9uXCJdID0gXCJwcm9kdWN0aW9uXCI7XG4gIFNlcnZlck1vZGVbXCJUZXN0XCJdID0gXCJ0ZXN0XCI7XG59KShTZXJ2ZXJNb2RlIHx8IChTZXJ2ZXJNb2RlID0ge30pKTtcblxuZnVuY3Rpb24gaXNTZXJ2ZXJNb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCB8fCB2YWx1ZSA9PT0gU2VydmVyTW9kZS5Qcm9kdWN0aW9uIHx8IHZhbHVlID09PSBTZXJ2ZXJNb2RlLlRlc3Q7XG59XG5cbmV4cG9ydCB7IFNlcnZlck1vZGUsIGlzU2VydmVyTW9kZSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLy8gTk9URTogbWFrZSBzdXJlIHRvIGNoYW5nZSB0aGUgUm91dGUgaW4gcmVtaXgtcmVhY3QgaWYgeW91IGNoYW5nZSB0aGlzXG4vLyBOT1RFOiBtYWtlIHN1cmUgdG8gY2hhbmdlIHRoZSBFbnRyeVJvdXRlIGluIHJlbWl4LXJlYWN0IGlmIHlvdSBjaGFuZ2UgdGhpc1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzKG1hbmlmZXN0LCBwYXJlbnRJZCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWFuaWZlc3QpLmZpbHRlcihrZXkgPT4gbWFuaWZlc3Rba2V5XS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpLm1hcChpZCA9PiAoeyAuLi5tYW5pZmVzdFtpZF0sXG4gICAgY2hpbGRyZW46IGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgaWQpXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUm91dGVzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQganNlc2MgZnJvbSAnanNlc2MnO1xuXG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpIHtcbiAgLy8gVXNlIGpzZXNjIHRvIGVzY2FwZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIGxvYWRlcnMuIFRoaXMgc3RyaW5nIGlzXG4gIC8vIGluc2VydGVkIGRpcmVjdGx5IGludG8gdGhlIEhUTUwgaW4gdGhlIGA8U2NyaXB0cz5gIGVsZW1lbnQuXG4gIHJldHVybiBqc2VzYyhzZXJ2ZXJIYW5kb2ZmLCB7XG4gICAgaXNTY3JpcHRDb250ZXh0OiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGNyZWF0ZVJlcXVlc3RIYW5kbGVyIGFzIGNyZWF0ZVJlcXVlc3RIYW5kbGVyJDEgfSBmcm9tICdAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lJztcblxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEhhbmRsZXIoe1xuICBidWlsZCxcbiAgZ2V0TG9hZENvbnRleHQsXG4gIG1vZGVcbn0pIHtcbiAgbGV0IHBsYXRmb3JtID0ge307XG4gIGxldCBoYW5kbGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdEhhbmRsZXIkMShidWlsZCwgcGxhdGZvcm0sIG1vZGUpO1xuICByZXR1cm4gY29udGV4dCA9PiB7XG4gICAgbGV0IGxvYWRDb250ZXh0ID0gdHlwZW9mIGdldExvYWRDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIgPyBnZXRMb2FkQ29udGV4dChjb250ZXh0KSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gaGFuZGxlUmVxdWVzdChjb250ZXh0LnJlcXVlc3QsIGxvYWRDb250ZXh0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyKHtcbiAgYnVpbGQsXG4gIGdldExvYWRDb250ZXh0LFxuICBtb2RlXG59KSB7XG4gIGNvbnN0IGhhbmRsZVJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0SGFuZGxlcih7XG4gICAgYnVpbGQsXG4gICAgZ2V0TG9hZENvbnRleHQsXG4gICAgbW9kZVxuICB9KTtcblxuICBjb25zdCBoYW5kbGVGZXRjaCA9IGFzeW5jIGNvbnRleHQgPT4ge1xuICAgIGxldCByZXNwb25zZTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmUvd3JhbmdsZXIyL2lzc3Vlcy8xMTdcblxuICAgIGNvbnRleHQucmVxdWVzdC5oZWFkZXJzLmRlbGV0ZShcImlmLW5vbmUtbWF0Y2hcIik7XG5cbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjb250ZXh0LmVudi5BU1NFVFMuZmV0Y2goY29udGV4dC5yZXF1ZXN0LnVybCwgY29udGV4dC5yZXF1ZXN0LmNsb25lKCkpO1xuICAgICAgcmVzcG9uc2UgPSByZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDQwMCA/IG5ldyBSZXNwb25zZShyZXNwb25zZS5ib2R5LCByZXNwb25zZSkgOiB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCB7fVxuXG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXF1ZXN0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcblxuICByZXR1cm4gYXN5bmMgY29udGV4dCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVGZXRjaChjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShlLm1lc3NhZ2UgfHwgZS50b1N0cmluZygpLCB7XG4gICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJJbnRlcm5hbCBFcnJvclwiLCB7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyLCBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9O1xuIiwgIlxuaW1wb3J0ICogYXMgZW50cnlTZXJ2ZXIgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXGVudHJ5LnNlcnZlci50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlMCBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm9vdC50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlMSBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXGRvd25sb2FkLnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUyIGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxyb3V0ZXNcXFxcc3VwcG9ydC50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlMyBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXHNvdXJjZS50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlNCBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXGFib3V0LnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGU1IGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxyb3V0ZXNcXFxcYXBwbGUudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTYgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXHJvdXRlc1xcXFxpbmRleC50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlNyBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXGxpbnV4LnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGU4IGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxyb3V0ZXNcXFxcYmxvZy50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlOSBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXGJsb2dcXFxcJHNsdWcudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTEwIGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxyb3V0ZXNcXFxcYmxvZ1xcXFxpbmRleC50c3hcIjtcbiAgZXhwb3J0IHsgZGVmYXVsdCBhcyBhc3NldHMgfSBmcm9tIFwiQHJlbWl4LXJ1bi9kZXYvYXNzZXRzLW1hbmlmZXN0XCI7XG4gIGV4cG9ydCBjb25zdCBlbnRyeSA9IHsgbW9kdWxlOiBlbnRyeVNlcnZlciB9O1xuICBleHBvcnQgY29uc3Qgcm91dGVzID0ge1xuICAgIFwicm9vdFwiOiB7XG4gICAgICBpZDogXCJyb290XCIsXG4gICAgICBwYXJlbnRJZDogdW5kZWZpbmVkLFxuICAgICAgcGF0aDogXCJcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlMFxuICAgIH0sXG4gIFwicm91dGVzL2Rvd25sb2FkXCI6IHtcbiAgICAgIGlkOiBcInJvdXRlcy9kb3dubG9hZFwiLFxuICAgICAgcGFyZW50SWQ6IFwicm9vdFwiLFxuICAgICAgcGF0aDogXCJkb3dubG9hZFwiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGUxXG4gICAgfSxcbiAgXCJyb3V0ZXMvc3VwcG9ydFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvc3VwcG9ydFwiLFxuICAgICAgcGFyZW50SWQ6IFwicm9vdFwiLFxuICAgICAgcGF0aDogXCJzdXBwb3J0XCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTJcbiAgICB9LFxuICBcInJvdXRlcy9zb3VyY2VcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL3NvdXJjZVwiLFxuICAgICAgcGFyZW50SWQ6IFwicm9vdFwiLFxuICAgICAgcGF0aDogXCJzb3VyY2VcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlM1xuICAgIH0sXG4gIFwicm91dGVzL2Fib3V0XCI6IHtcbiAgICAgIGlkOiBcInJvdXRlcy9hYm91dFwiLFxuICAgICAgcGFyZW50SWQ6IFwicm9vdFwiLFxuICAgICAgcGF0aDogXCJhYm91dFwiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGU0XG4gICAgfSxcbiAgXCJyb3V0ZXMvYXBwbGVcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL2FwcGxlXCIsXG4gICAgICBwYXJlbnRJZDogXCJyb290XCIsXG4gICAgICBwYXRoOiBcImFwcGxlXCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTVcbiAgICB9LFxuICBcInJvdXRlcy9pbmRleFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvaW5kZXhcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgIGluZGV4OiB0cnVlLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTZcbiAgICB9LFxuICBcInJvdXRlcy9saW51eFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvbGludXhcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IFwibGludXhcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlN1xuICAgIH0sXG4gIFwicm91dGVzL2Jsb2dcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL2Jsb2dcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IFwiYmxvZ1wiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGU4XG4gICAgfSxcbiAgXCJyb3V0ZXMvYmxvZy8kc2x1Z1wiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvYmxvZy8kc2x1Z1wiLFxuICAgICAgcGFyZW50SWQ6IFwicm91dGVzL2Jsb2dcIixcbiAgICAgIHBhdGg6IFwiOnNsdWdcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlOVxuICAgIH0sXG4gIFwicm91dGVzL2Jsb2cvaW5kZXhcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL2Jsb2cvaW5kZXhcIixcbiAgICAgIHBhcmVudElkOiBcInJvdXRlcy9ibG9nXCIsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBpbmRleDogdHJ1ZSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGUxMFxuICAgIH1cbiAgfTsiLCAiaW1wb3J0IHsgcmVuZGVyVG9TdHJpbmcgfSBmcm9tIFwicmVhY3QtZG9tL3NlcnZlclwiXG5pbXBvcnQgeyBSZW1peFNlcnZlciB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgdHlwZSB7IEVudHJ5Q29udGV4dCB9IGZyb20gJ3JlbWl4J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICByZXNwb25zZVN0YXR1c0NvZGU6IG51bWJlcixcbiAgcmVzcG9uc2VIZWFkZXJzOiBIZWFkZXJzLFxuICByZW1peENvbnRleHQ6IEVudHJ5Q29udGV4dFxuKSB7XG4gIGNvbnN0IG1hcmt1cCA9IHJlbmRlclRvU3RyaW5nKFxuICAgIDxSZW1peFNlcnZlciBjb250ZXh0PXtyZW1peENvbnRleHR9IHVybD17cmVxdWVzdC51cmx9IC8+XG4gIClcblxuICByZXNwb25zZUhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9odG1sXCIpXG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcIjwhRE9DVFlQRSBodG1sPlwiICsgbWFya3VwLCB7XG4gICAgc3RhdHVzOiByZXNwb25zZVN0YXR1c0NvZGUsXG4gICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gIH0pXG59XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IGNyZWF0ZUNsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlIH0gZnJvbSAnQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzJztcblxuLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5leHBvcnQgeyBjcmVhdGVDb29raWUsIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlLCBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSwgY3JlYXRlU2Vzc2lvbiwgY3JlYXRlU2Vzc2lvblN0b3JhZ2UsIGlzQ29va2llLCBpc1Nlc3Npb24sIGpzb24sIHJlZGlyZWN0IH0gZnJvbSAnQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSc7XG5cbi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgRm9ybSwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIE91dGxldCwgUHJlZmV0Y2hQYWdlTGlua3MsIFJlbWl4QnJvd3NlciwgUmVtaXhTZXJ2ZXIsIFNjcmlwdHMsIFNjcm9sbFJlc3RvcmF0aW9uLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUNhdGNoLCB1c2VGZXRjaGVyLCB1c2VGZXRjaGVycywgdXNlRm9ybUFjdGlvbiwgdXNlSHJlZiwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlU2VhcmNoUGFyYW1zLCB1c2VTdWJtaXQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICdAcmVtaXgtcnVuL3JlYWN0JztcblxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgUmVtaXhCcm93c2VyIH0gZnJvbSAnLi9icm93c2VyLmpzJztcbmV4cG9ydCB7IE91dGxldCwgdXNlSHJlZiwgdXNlTG9jYXRpb24sIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlU2VhcmNoUGFyYW1zIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5leHBvcnQgeyBGb3JtLCBMaW5rLCBMaW5rcywgTGl2ZVJlbG9hZCwgTWV0YSwgTmF2TGluaywgUHJlZmV0Y2hQYWdlTGlua3MsIFNjcmlwdHMsIHVzZUFjdGlvbkRhdGEsIHVzZUJlZm9yZVVubG9hZCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUxvYWRlckRhdGEsIHVzZU1hdGNoZXMsIHVzZVN1Ym1pdCwgdXNlVHJhbnNpdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5leHBvcnQgeyB1c2VDYXRjaCB9IGZyb20gJy4vZXJyb3JCb3VuZGFyaWVzLmpzJztcbmV4cG9ydCB7IFNjcm9sbFJlc3RvcmF0aW9uIH0gZnJvbSAnLi9zY3JvbGwtcmVzdG9yYXRpb24uanMnO1xuZXhwb3J0IHsgUmVtaXhTZXJ2ZXIgfSBmcm9tICcuL3NlcnZlci5qcyc7XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUhyZWYsIE5hdkxpbmsgYXMgTmF2TGluayQxLCBMaW5rIGFzIExpbmskMSwgdXNlTG9jYXRpb24sIHVzZVJlc29sdmVkUGF0aCwgdXNlTmF2aWdhdGUsIFJvdXRlciwgdXNlUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyBSZW1peEVycm9yQm91bmRhcnksIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LCBSZW1peENhdGNoQm91bmRhcnksIFJlbWl4Um9vdERlZmF1bHRDYXRjaEJvdW5kYXJ5IH0gZnJvbSAnLi9lcnJvckJvdW5kYXJpZXMuanMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuL2ludmFyaWFudC5qcyc7XG5pbXBvcnQgeyBnZXRMaW5rc0Zvck1hdGNoZXMsIGlzUGFnZUxpbmtEZXNjcmlwdG9yLCBnZXROZXdNYXRjaGVzRm9yTGlua3MsIGdldERhdGFMaW5rSHJlZnMsIGdldE1vZHVsZUxpbmtIcmVmcywgZ2V0U3R5bGVzaGVldFByZWZldGNoTGlua3MgfSBmcm9tICcuL2xpbmtzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUh0bWwgfSBmcm9tICcuL21hcmt1cC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcy5qcyc7XG5pbXBvcnQgeyBtYXRjaENsaWVudFJvdXRlcyB9IGZyb20gJy4vcm91dGVNYXRjaGluZy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciB9IGZyb20gJy4vdHJhbnNpdGlvbi5qcyc7XG5cbmNvbnN0IFJlbWl4RW50cnlDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gdXNlUmVtaXhFbnRyeUNvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChSZW1peEVudHJ5Q29udGV4dCk7XG4gIGludmFyaWFudChjb250ZXh0LCBcIllvdSBtdXN0IHJlbmRlciB0aGlzIGVsZW1lbnQgaW5zaWRlIGEgPFJlbWl4PiBlbGVtZW50XCIpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gUmVtaXhFbnRyeSh7XG4gIGNvbnRleHQ6IGVudHJ5Q29udGV4dCxcbiAgYWN0aW9uLFxuICBsb2NhdGlvbjogaGlzdG9yeUxvY2F0aW9uLFxuICBuYXZpZ2F0b3I6IF9uYXZpZ2F0b3IsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlXG59KSB7XG4gIGxldCB7XG4gICAgbWFuaWZlc3QsXG4gICAgcm91dGVEYXRhOiBkb2N1bWVudExvYWRlckRhdGEsXG4gICAgYWN0aW9uRGF0YTogZG9jdW1lbnRBY3Rpb25EYXRhLFxuICAgIHJvdXRlTW9kdWxlcyxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgIGFwcFN0YXRlOiBlbnRyeUNvbXBvbmVudERpZENhdGNoRW11bGF0b3JcbiAgfSA9IGVudHJ5Q29udGV4dDtcbiAgbGV0IGNsaWVudFJvdXRlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY3JlYXRlQ2xpZW50Um91dGVzKG1hbmlmZXN0LnJvdXRlcywgcm91dGVNb2R1bGVzLCBSZW1peFJvdXRlKSwgW21hbmlmZXN0LCByb3V0ZU1vZHVsZXNdKTtcbiAgbGV0IFtjbGllbnRTdGF0ZSwgc2V0Q2xpZW50U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yKTtcbiAgbGV0IFt0cmFuc2l0aW9uTWFuYWdlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKHtcbiAgICAgIHJvdXRlczogY2xpZW50Um91dGVzLFxuICAgICAgYWN0aW9uRGF0YTogZG9jdW1lbnRBY3Rpb25EYXRhLFxuICAgICAgbG9hZGVyRGF0YTogZG9jdW1lbnRMb2FkZXJEYXRhLFxuICAgICAgbG9jYXRpb246IGhpc3RvcnlMb2NhdGlvbixcbiAgICAgIGNhdGNoOiBlbnRyeUNvbXBvbmVudERpZENhdGNoRW11bGF0b3IuY2F0Y2gsXG4gICAgICBjYXRjaEJvdW5kYXJ5SWQ6IGVudHJ5Q29tcG9uZW50RGlkQ2F0Y2hFbXVsYXRvci5jYXRjaEJvdW5kYXJ5Um91dGVJZCxcbiAgICAgIG9uUmVkaXJlY3Q6IF9uYXZpZ2F0b3IucmVwbGFjZSxcbiAgICAgIG9uQ2hhbmdlOiBzdGF0ZSA9PiB7XG4gICAgICAgIHNldENsaWVudFN0YXRlKHtcbiAgICAgICAgICBjYXRjaDogc3RhdGUuY2F0Y2gsXG4gICAgICAgICAgZXJyb3I6IHN0YXRlLmVycm9yLFxuICAgICAgICAgIGNhdGNoQm91bmRhcnlSb3V0ZUlkOiBzdGF0ZS5jYXRjaEJvdW5kYXJ5SWQsXG4gICAgICAgICAgbG9hZGVyQm91bmRhcnlSb3V0ZUlkOiBzdGF0ZS5lcnJvckJvdW5kYXJ5SWQsXG4gICAgICAgICAgcmVuZGVyQm91bmRhcnlSb3V0ZUlkOiBudWxsLFxuICAgICAgICAgIHRyYWNrQm91bmRhcmllczogZmFsc2UsXG4gICAgICAgICAgdHJhY2tDYXRjaEJvdW5kYXJpZXM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gRW5zdXJlcyBwdXNoZXMgaW50ZXJydXB0aW5nIHBlbmRpbmcgbmF2aWdhdGlvbnMgdXNlIHJlcGxhY2VcbiAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIFJlYWN0IFJvdXRlclxuXG4gIGxldCBuYXZpZ2F0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgcHVzaCA9ICh0bywgc3RhdGUpID0+IHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpLnRyYW5zaXRpb24uc3RhdGUgIT09IFwiaWRsZVwiID8gX25hdmlnYXRvci5yZXBsYWNlKHRvLCBzdGF0ZSkgOiBfbmF2aWdhdG9yLnB1c2godG8sIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgLi4uX25hdmlnYXRvcixcbiAgICAgIHB1c2hcbiAgICB9O1xuICB9LCBbX25hdmlnYXRvciwgdHJhbnNpdGlvbk1hbmFnZXJdKTtcbiAgbGV0IHtcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaGVzLFxuICAgIGxvYWRlckRhdGEsXG4gICAgYWN0aW9uRGF0YVxuICB9ID0gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTsgLy8gU2VuZCBuZXcgbG9jYXRpb24gdG8gdGhlIHRyYW5zaXRpb24gbWFuYWdlclxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGxvY2F0aW9uXG4gICAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgaWYgKGhpc3RvcnlMb2NhdGlvbiA9PT0gbG9jYXRpb24pIHJldHVybjtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5zZW5kKHtcbiAgICAgIHR5cGU6IFwibmF2aWdhdGlvblwiLFxuICAgICAgbG9jYXRpb246IGhpc3RvcnlMb2NhdGlvbixcbiAgICAgIHN1Ym1pc3Npb246IGNvbnN1bWVOZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oKSxcbiAgICAgIGFjdGlvblxuICAgIH0pO1xuICB9LCBbdHJhbnNpdGlvbk1hbmFnZXIsIGhpc3RvcnlMb2NhdGlvbiwgYWN0aW9uXSk7IC8vIElmIHdlIHRyaWVkIHRvIHJlbmRlciBhbmQgZmFpbGVkLCBhbmQgdGhlIGFwcCB0aHJldyBiZWZvcmUgcmVuZGVyaW5nIGFueVxuICAvLyByb3V0ZXMsIGdldCB0aGUgZXJyb3IgYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZVxuICAvLyBgY29tcG9uZW50RGlkQ2F0Y2hgXG5cbiAgbGV0IHNzckVycm9yQmVmb3JlUm91dGVzUmVuZGVyZWQgPSBjbGllbnRTdGF0ZS5lcnJvciAmJiBjbGllbnRTdGF0ZS5yZW5kZXJCb3VuZGFyeVJvdXRlSWQgPT09IG51bGwgJiYgY2xpZW50U3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID09PSBudWxsID8gZGVzZXJpYWxpemVFcnJvcihjbGllbnRTdGF0ZS5lcnJvcikgOiB1bmRlZmluZWQ7XG4gIGxldCBzc3JDYXRjaEJlZm9yZVJvdXRlc1JlbmRlcmVkID0gY2xpZW50U3RhdGUuY2F0Y2ggJiYgY2xpZW50U3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPT09IG51bGwgPyBjbGllbnRTdGF0ZS5jYXRjaCA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbWl4RW50cnlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGFwcFN0YXRlOiBjbGllbnRTdGF0ZSxcbiAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgIHNlcnZlckhhbmRvZmZTdHJpbmcsXG4gICAgICBjbGllbnRSb3V0ZXMsXG4gICAgICByb3V0ZURhdGE6IGxvYWRlckRhdGEsXG4gICAgICBhY3Rpb25EYXRhLFxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbWl4RXJyb3JCb3VuZGFyeSwge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjb21wb25lbnQ6IFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LFxuICAgIGVycm9yOiBzc3JFcnJvckJlZm9yZVJvdXRlc1JlbmRlcmVkXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbWl4Q2F0Y2hCb3VuZGFyeSwge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjb21wb25lbnQ6IFJlbWl4Um9vdERlZmF1bHRDYXRjaEJvdW5kYXJ5LFxuICAgIGNhdGNoOiBzc3JDYXRjaEJlZm9yZVJvdXRlc1JlbmRlcmVkXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIG5hdmlnYXRpb25UeXBlOiBhY3Rpb24sXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogc3RhdGljUHJvcFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXMsIG51bGwpKSkpKTtcbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcihkYXRhKSB7XG4gIGxldCBlcnJvciA9IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICBlcnJvci5zdGFjayA9IGRhdGEuc3RhY2s7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gUm91dGVzKCkge1xuICAvLyBUT0RPOiBBZGQgYHJlbmRlck1hdGNoZXNgIGZ1bmN0aW9uIHRvIFJSIHRoYXQgd2UgY2FuIHVzZSBhbmQgdGhlbiB3ZSBkb24ndFxuICAvLyBuZWVkIHRoaXMgY29tcG9uZW50LCB3ZSBjYW4ganVzdCBgcmVuZGVyTWF0Y2hlc2AgZnJvbSBSZW1peEVudHJ5XG4gIGxldCB7XG4gICAgY2xpZW50Um91dGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpOyAvLyBmYWxsYmFjayB0byB0aGUgcm9vdCBpZiB3ZSBkb24ndCBoYXZlIGEgbWF0Y2hcblxuICBsZXQgZWxlbWVudCA9IHVzZVJvdXRlcyhjbGllbnRSb3V0ZXMpIHx8IGNsaWVudFJvdXRlc1swXS5lbGVtZW50O1xuICByZXR1cm4gZWxlbWVudDtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFJlbWl4Um91dGVcblxuXG5jb25zdCBSZW1peFJvdXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHVzZVJlbWl4Um91dGVDb250ZXh0KCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVtaXhSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoY29udGV4dCwgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluIGEgcmVtaXggcm91dGUgZWxlbWVudFwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRSb3V0ZUNvbXBvbmVudCh7XG4gIGlkXG59KSB7XG4gIHRocm93IG5ldyBFcnJvcihgUm91dGUgXCIke2lkfVwiIGhhcyBubyBjb21wb25lbnQhIFBsZWFzZSBnbyBhZGQgYSBcXGBkZWZhdWx0XFxgIGV4cG9ydCBpbiB0aGUgcm91dGUgbW9kdWxlIGZpbGUuXFxuYCArIFwiSWYgeW91IHdlcmUgdHJ5aW5nIHRvIG5hdmlnYXRlIG9yIHN1Ym1pdCB0byBhIHJlc291cmNlIHJvdXRlLCB1c2UgYDxhPmAgaW5zdGVhZCBvZiBgPExpbms+YCBvciBgPEZvcm0gcmVsb2FkRG9jdW1lbnQ+YC5cIik7XG59XG5cbmZ1bmN0aW9uIFJlbWl4Um91dGUoe1xuICBpZFxufSkge1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQge1xuICAgIHJvdXRlRGF0YSxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgYXBwU3RhdGVcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBkYXRhID0gcm91dGVEYXRhW2lkXTtcbiAgbGV0IHtcbiAgICBkZWZhdWx0OiBDb21wb25lbnQsXG4gICAgQ2F0Y2hCb3VuZGFyeSxcbiAgICBFcnJvckJvdW5kYXJ5XG4gIH0gPSByb3V0ZU1vZHVsZXNbaWRdO1xuICBsZXQgZWxlbWVudCA9IENvbXBvbmVudCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgbnVsbCkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0Um91dGVDb21wb25lbnQsIHtcbiAgICBpZDogaWRcbiAgfSk7XG4gIGxldCBjb250ZXh0ID0ge1xuICAgIGRhdGEsXG4gICAgaWRcbiAgfTtcblxuICBpZiAoQ2F0Y2hCb3VuZGFyeSkge1xuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlbmRlciBhbmQgZmFpbGVkLCBhbmQgdGhpcyByb3V0ZSB0aHJldyB0aGUgZXJyb3IsIGZpbmQgaXRcbiAgICAvLyBhbmQgcGFzcyBpdCB0byB0aGUgRXJyb3JCb3VuZGFyeSB0byBlbXVsYXRlIGBjb21wb25lbnREaWRDYXRjaGBcbiAgICBsZXQgbWF5YmVTZXJ2ZXJDYXVnaHQgPSBhcHBTdGF0ZS5jYXRjaCAmJiBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZCA9PT0gaWQgPyBhcHBTdGF0ZS5jYXRjaCA6IHVuZGVmaW5lZDsgLy8gVGhpcyBuZWVkcyB0byBydW4gYWZ0ZXIgd2UgY2hlY2sgZm9yIHRoZSBlcnJvciBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3aWxsIGluY29ycmVjdGx5IHJlbmRlciB0aGlzIGJvdW5kYXJ5IGZvciBhIGxvYWRlciBlcnJvclxuICAgIC8vIGRlZXBlciBpbiB0aGUgdHJlZS5cblxuICAgIGlmIChhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcykge1xuICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBpZDtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gbWF5YmVTZXJ2ZXJDYXVnaHQgPyB7XG4gICAgICBpZCxcblxuICAgICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhIGNhdGNoIGJvdW5kYXJ5LlwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gOiB7XG4gICAgICBpZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIGVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peENhdGNoQm91bmRhcnksIHtcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIGNvbXBvbmVudDogQ2F0Y2hCb3VuZGFyeSxcbiAgICAgIGNhdGNoOiBtYXliZVNlcnZlckNhdWdodFxuICAgIH0sIGVsZW1lbnQpO1xuICB9IC8vIE9ubHkgd3JhcCBpbiBlcnJvciBib3VuZGFyeSBpZiB0aGUgcm91dGUgZGVmaW5lZCBvbmUsIG90aGVyd2lzZSBsZXQgdGhlXG4gIC8vIGVycm9yIGJ1YmJsZSB0byB0aGUgcGFyZW50IGJvdW5kYXJ5LiBXZSBjb3VsZCBkZWZhdWx0IHRvIHVzaW5nIGVycm9yXG4gIC8vIGJvdW5kYXJpZXMgYXJvdW5kIGV2ZXJ5IHJvdXRlLCBidXQgbm93IGlmIHRoZSBhcHAgZG9lc24ndCB3YW50IHVzZXJzXG4gIC8vIHNlZWluZyB0aGUgZGVmYXVsdCBSZW1peCBFcnJvckJvdW5kYXJ5IGNvbXBvbmVudCwgdGhleSAqbXVzdCogZGVmaW5lIGFuXG4gIC8vIGVycm9yIGJvdW5kYXJ5IGZvciAqZXZlcnkqIHJvdXRlIGFuZCB0aGF0IHdvdWxkIGJlIGFubm95aW5nLiBNaWdodCBhc1xuICAvLyB3ZWxsIG1ha2UgaXQgcmVxdWlyZWQgYXQgdGhhdCBwb2ludC5cbiAgLy9cbiAgLy8gQnkgY29uZGl0aW9uYWxseSB3cmFwcGluZyBsaWtlIHRoaXMsIHdlIGFsbG93IGFwcHMgdG8gZGVmaW5lIGEgdG9wIGxldmVsXG4gIC8vIEVycm9yQm91bmRhcnkgY29tcG9uZW50IGFuZCBiZSBkb25lIHdpdGggaXQuIFRoZW4sIGlmIHRoZXkgd2FudCB0bywgdGhleVxuICAvLyBjYW4gYWRkIG1vcmUgc3BlY2lmaWMgYm91bmRhcmllcyBieSBleHBvcnRpbmcgRXJyb3JCb3VuZGFyeSBjb21wb25lbnRzXG4gIC8vIGZvciB3aGljaGV2ZXIgcm91dGVzIHRoZXkgcGxlYXNlLlxuICAvL1xuICAvLyBOT1RFOiB0aGlzIGtpbmQgb2YgbG9naWMgd2lsbCBtb3ZlIGludG8gUmVhY3QgUm91dGVyXG5cblxuICBpZiAoRXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlbmRlciBhbmQgZmFpbGVkLCBhbmQgdGhpcyByb3V0ZSB0aHJldyB0aGUgZXJyb3IsIGZpbmQgaXRcbiAgICAvLyBhbmQgcGFzcyBpdCB0byB0aGUgRXJyb3JCb3VuZGFyeSB0byBlbXVsYXRlIGBjb21wb25lbnREaWRDYXRjaGBcbiAgICBsZXQgbWF5YmVTZXJ2ZXJSZW5kZXJFcnJvciA9IGFwcFN0YXRlLmVycm9yICYmIChhcHBTdGF0ZS5yZW5kZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkIHx8IGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9PT0gaWQpID8gZGVzZXJpYWxpemVFcnJvcihhcHBTdGF0ZS5lcnJvcikgOiB1bmRlZmluZWQ7IC8vIFRoaXMgbmVlZHMgdG8gcnVuIGFmdGVyIHdlIGNoZWNrIGZvciB0aGUgZXJyb3IgZnJvbSBhIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBpbmNvcnJlY3RseSByZW5kZXIgdGhpcyBib3VuZGFyeSBmb3IgYSBsb2FkZXIgZXJyb3JcbiAgICAvLyBkZWVwZXIgaW4gdGhlIHRyZWUuXG5cbiAgICBpZiAoYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzKSB7XG4gICAgICBhcHBTdGF0ZS5yZW5kZXJCb3VuZGFyeVJvdXRlSWQgPSBpZDtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gbWF5YmVTZXJ2ZXJSZW5kZXJFcnJvciA/IHtcbiAgICAgIGlkLFxuXG4gICAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBjYW5ub3QgYHVzZUxvYWRlckRhdGFgIGluIGFuIGVycm9yIGJvdW5kYXJ5LlwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gOiB7XG4gICAgICBpZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIGVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHtcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIGNvbXBvbmVudDogRXJyb3JCb3VuZGFyeSxcbiAgICAgIGVycm9yOiBtYXliZVNlcnZlclJlbmRlckVycm9yXG4gICAgfSwgZWxlbWVudCk7XG4gIH0gLy8gSXQncyBpbXBvcnRhbnQgZm9yIHRoZSByb3V0ZSBjb250ZXh0IHRvIGJlIGFib3ZlIHRoZSBlcnJvciBib3VuZGFyeSBzbyB0aGF0XG4gIC8vIGEgY2FsbCB0byBgdXNlTG9hZGVyRGF0YWAgZG9lc24ndCBhY2NpZGVudGFsbHkgZ2V0IHRoZSBwYXJlbnRzIHJvdXRlJ3MgZGF0YS5cblxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIGVsZW1lbnQpO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUHVibGljIEFQSVxuXG4vKipcbiAqIERlZmluZXMgdGhlIHByZWZldGNoaW5nIGJlaGF2aW9yIG9mIHRoZSBsaW5rOlxuICpcbiAqIC0gXCJpbnRlbnRcIjogRmV0Y2hlZCB3aGVuIHRoZSB1c2VyIGZvY3VzZXMgb3IgaG92ZXJzIHRoZSBsaW5rXG4gKiAtIFwicmVuZGVyXCI6IEZldGNoZWQgd2hlbiB0aGUgbGluayBpcyByZW5kZXJlZFxuICogLSBcIm5vbmVcIjogTmV2ZXIgZmV0Y2hlZFxuICovXG5cbmZ1bmN0aW9uIHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHRoZWlyRWxlbWVudFByb3BzKSB7XG4gIGxldCBbbWF5YmVQcmVmZXRjaCwgc2V0TWF5YmVQcmVmZXRjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGxldCBbc2hvdWxkUHJlZmV0Y2gsIHNldFNob3VsZFByZWZldGNoXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgbGV0IHtcbiAgICBvbkZvY3VzLFxuICAgIG9uQmx1cixcbiAgICBvbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlLFxuICAgIG9uVG91Y2hTdGFydFxuICB9ID0gdGhlaXJFbGVtZW50UHJvcHM7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZWZldGNoID09PSBcInJlbmRlclwiKSB7XG4gICAgICBzZXRTaG91bGRQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gIH0sIFtwcmVmZXRjaF0pO1xuXG4gIGxldCBzZXRJbnRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKHByZWZldGNoID09PSBcImludGVudFwiKSB7XG4gICAgICBzZXRNYXliZVByZWZldGNoKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBsZXQgY2FuY2VsSW50ZW50ID0gKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJpbnRlbnRcIikge1xuICAgICAgc2V0TWF5YmVQcmVmZXRjaChmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1heWJlUHJlZmV0Y2gpIHtcbiAgICAgIGxldCBpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRTaG91bGRQcmVmZXRjaCh0cnVlKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFttYXliZVByZWZldGNoXSk7XG4gIHJldHVybiBbc2hvdWxkUHJlZmV0Y2gsIHtcbiAgICBvbkZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkZvY3VzLCBzZXRJbnRlbnQpLFxuICAgIG9uQmx1cjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25CbHVyLCBjYW5jZWxJbnRlbnQpLFxuICAgIG9uTW91c2VFbnRlcjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Nb3VzZUVudGVyLCBzZXRJbnRlbnQpLFxuICAgIG9uTW91c2VMZWF2ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Nb3VzZUxlYXZlLCBjYW5jZWxJbnRlbnQpLFxuICAgIG9uVG91Y2hTdGFydDogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Ub3VjaFN0YXJ0LCBzZXRJbnRlbnQpXG4gIH1dO1xufVxuLyoqXG4gKiBBIHNwZWNpYWwga2luZCBvZiBgPExpbms+YCB0aGF0IGtub3dzIHdoZXRoZXIgb3Igbm90IGl0IGlzIFwiYWN0aXZlXCIuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbmF2bGlua1xuICovXG5cblxubGV0IE5hdkxpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0byxcbiAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOYXZMaW5rJDEsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB0bzogdG9cbiAgfSwgcHJvcHMsIHByZWZldGNoSGFuZGxlcnMpKSwgc2hvdWxkUHJlZmV0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywge1xuICAgIHBhZ2U6IGhyZWZcbiAgfSkgOiBudWxsKTtcbn0pO1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGFuIGFuY2hvciB0YWcgYW5kIGlzIHRoZSBwcmltYXJ5IHdheSB0aGUgdXNlciB3aWxsXG4gKiBuYXZpZ2F0ZSBhcm91bmQgeW91ciB3ZWJzaXRlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I2xpbmtcbiAqL1xuXG5sZXQgTGluayA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHRvLFxuICBwcmVmZXRjaCA9IFwibm9uZVwiLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGxldCBocmVmID0gdXNlSHJlZih0byk7XG4gIGxldCBbc2hvdWxkUHJlZmV0Y2gsIHByZWZldGNoSGFuZGxlcnNdID0gdXNlUHJlZmV0Y2hCZWhhdmlvcihwcmVmZXRjaCwgcHJvcHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpbmskMSwgX2V4dGVuZHMoe1xuICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgIHRvOiB0b1xuICB9LCBwcm9wcywgcHJlZmV0Y2hIYW5kbGVycykpLCBzaG91bGRQcmVmZXRjaCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCB7XG4gICAgcGFnZTogaHJlZlxuICB9KSA6IG51bGwpO1xufSk7XG5mdW5jdGlvbiBjb21wb3NlRXZlbnRIYW5kbGVycyh0aGVpckhhbmRsZXIsIG91ckhhbmRsZXIpIHtcbiAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICB0aGVpckhhbmRsZXIgJiYgdGhlaXJIYW5kbGVyKGV2ZW50KTtcblxuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgb3VySGFuZGxlcihldmVudCk7XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgPGxpbms+YCB0YWdzIGZvciB0aGUgY3VycmVudCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cblxuZnVuY3Rpb24gTGlua3MoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgbWFuaWZlc3RcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBsaW5rcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0TGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpLCBbbWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGxpbmtzLm1hcChsaW5rID0+IGlzUGFnZUxpbmtEZXNjcmlwdG9yKGxpbmspID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIF9leHRlbmRzKHtcbiAgICBrZXk6IGxpbmsucGFnZVxuICB9LCBsaW5rKSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogbGluay5yZWwgKyBsaW5rLmhyZWZcbiAgfSwgbGluaykpKSk7XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgYWxsIG9mIHRoZSBgPGxpbmsgcmVsPVwicHJlZmV0Y2hcIj5gIGFuZFxuICogYDxsaW5rIHJlbD1cIm1vZHVsZXByZWxvYWRcIi8+YCB0YWdzIGZvciBhbGwgdGhlIGFzc2V0cyAoZGF0YSwgbW9kdWxlcywgY3NzKSBvZlxuICogYSBnaXZlbiBwYWdlLlxuICpcbiAqIEBwYXJhbSBwcm9wc1xuICogQHBhcmFtIHByb3BzLnBhZ2VcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3ByZWZldGNocGFnZWxpbmtzLVxuICovXG5cbmZ1bmN0aW9uIFByZWZldGNoUGFnZUxpbmtzKHtcbiAgcGFnZSxcbiAgLi4uZGF0YUxpbmtQcm9wc1xufSkge1xuICBsZXQge1xuICAgIGNsaWVudFJvdXRlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IG1hdGNoZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoQ2xpZW50Um91dGVzKGNsaWVudFJvdXRlcywgcGFnZSksIFtjbGllbnRSb3V0ZXMsIHBhZ2VdKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICBjb25zb2xlLndhcm4oYFRyaWVkIHRvIHByZWZldGNoICR7cGFnZX0gYnV0IG5vIHJvdXRlcyBtYXRjaGVkLmApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzSW1wbCwgX2V4dGVuZHMoe1xuICAgIHBhZ2U6IHBhZ2UsXG4gICAgbWF0Y2hlczogbWF0Y2hlc1xuICB9LCBkYXRhTGlua1Byb3BzKSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZWZldGNoZWRTdHlsZXNoZWV0cyhtYXRjaGVzKSB7XG4gIGxldCB7XG4gICAgcm91dGVNb2R1bGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgW3N0eWxlTGlua3MsIHNldFN0eWxlTGlua3NdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcykudGhlbihsaW5rcyA9PiB7XG4gICAgICBpZiAoIWludGVycnVwdGVkKSBzZXRTdHlsZUxpbmtzKGxpbmtzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFttYXRjaGVzLCByb3V0ZU1vZHVsZXNdKTtcbiAgcmV0dXJuIHN0eWxlTGlua3M7XG59XG5cbmZ1bmN0aW9uIFByZWZldGNoUGFnZUxpbmtzSW1wbCh7XG4gIHBhZ2UsXG4gIG1hdGNoZXM6IG5leHRNYXRjaGVzLFxuICAuLi5saW5rUHJvcHNcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzLFxuICAgIG1hbmlmZXN0XG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbmV3TWF0Y2hlc0ZvckRhdGEgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb24sIFwiZGF0YVwiKSwgW3BhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBsb2NhdGlvbl0pO1xuICBsZXQgbmV3TWF0Y2hlc0ZvckFzc2V0cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKHBhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBsb2NhdGlvbiwgXCJhc3NldHNcIiksIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb25dKTtcbiAgbGV0IGRhdGFIcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0RGF0YUxpbmtIcmVmcyhwYWdlLCBuZXdNYXRjaGVzRm9yRGF0YSwgbWFuaWZlc3QpLCBbbmV3TWF0Y2hlc0ZvckRhdGEsIHBhZ2UsIG1hbmlmZXN0XSk7XG4gIGxldCBtb2R1bGVIcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0TW9kdWxlTGlua0hyZWZzKG5ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0KSwgW25ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0XSk7IC8vIG5lZWRzIHRvIGJlIGEgaG9vayB3aXRoIGFzeW5jIGJlaGF2aW9yIGJlY2F1c2Ugd2UgbmVlZCB0aGUgbW9kdWxlcywgbm90XG4gIC8vIGp1c3QgdGhlIG1hbmlmZXN0IGxpa2UgdGhlIG90aGVyIGxpbmtzIGluIGhlcmUuXG5cbiAgbGV0IHN0eWxlTGlua3MgPSB1c2VQcmVmZXRjaGVkU3R5bGVzaGVldHMobmV3TWF0Y2hlc0ZvckFzc2V0cyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZGF0YUhyZWZzLm1hcChocmVmID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBocmVmLFxuICAgIHJlbDogXCJwcmVmZXRjaFwiLFxuICAgIGFzOiBcImZldGNoXCIsXG4gICAgaHJlZjogaHJlZlxuICB9LCBsaW5rUHJvcHMpKSksIG1vZHVsZUhyZWZzLm1hcChocmVmID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBocmVmLFxuICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgaHJlZjogaHJlZlxuICB9LCBsaW5rUHJvcHMpKSksIHN0eWxlTGlua3MubWFwKGxpbmsgPT5cbiAgLyojX19QVVJFX18qL1xuICAvLyB0aGVzZSBkb24ndCBzcHJlYWQgYGxpbmtQcm9wc2AgYmVjYXVzZSB0aGV5IGFyZSBmdWxsIGxpbmsgZGVzY3JpcHRvcnNcbiAgLy8gYWxyZWFkeSB3aXRoIHRoZWlyIG93biBwcm9wc1xuICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBsaW5rLmhyZWZcbiAgfSwgbGluaykpKSk7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhlIGA8dGl0bGU+YCBhbmQgYDxtZXRhPmAgdGFncyBmb3IgdGhlIGN1cnJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cblxuZnVuY3Rpb24gTWV0YSgpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzLFxuICAgIHJvdXRlRGF0YSxcbiAgICByb3V0ZU1vZHVsZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtZXRhID0ge307XG4gIGxldCBwYXJlbnRzRGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGxldCBkYXRhID0gcm91dGVEYXRhW3JvdXRlSWRdO1xuICAgIGxldCBwYXJhbXMgPSBtYXRjaC5wYXJhbXM7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlSWRdO1xuXG4gICAgaWYgKHJvdXRlTW9kdWxlLm1ldGEpIHtcbiAgICAgIGxldCByb3V0ZU1ldGEgPSB0eXBlb2Ygcm91dGVNb2R1bGUubWV0YSA9PT0gXCJmdW5jdGlvblwiID8gcm91dGVNb2R1bGUubWV0YSh7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHBhcmVudHNEYXRhLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICB9KSA6IHJvdXRlTW9kdWxlLm1ldGE7XG4gICAgICBPYmplY3QuYXNzaWduKG1ldGEsIHJvdXRlTWV0YSk7XG4gICAgfVxuXG4gICAgcGFyZW50c0RhdGFbcm91dGVJZF0gPSBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBPYmplY3QuZW50cmllcyhtZXRhKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAvLyBPcGVuIEdyYXBoIHRhZ3MgdXNlIHRoZSBgcHJvcGVydHlgIGF0dHJpYnV0ZSwgd2hpbGUgb3RoZXIgbWV0YSB0YWdzXG4gICAgLy8gdXNlIGBuYW1lYC4gU2VlIGh0dHBzOi8vb2dwLm1lL1xuICAgIGxldCBpc09wZW5HcmFwaFRhZyA9IG5hbWUuc3RhcnRzV2l0aChcIm9nOlwiKTtcbiAgICByZXR1cm4gbmFtZSA9PT0gXCJ0aXRsZVwiID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCB7XG4gICAgICBrZXk6IFwidGl0bGVcIlxuICAgIH0sIHZhbHVlKSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKGNvbnRlbnQgPT4gaXNPcGVuR3JhcGhUYWcgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBuYW1lICsgY29udGVudCxcbiAgICAgIHByb3BlcnR5OiBuYW1lLFxuICAgICAgY29udGVudDogY29udGVudFxuICAgIH0pIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogbmFtZSArIGNvbnRlbnQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgY29udGVudDogY29udGVudFxuICAgIH0pKSA6IGlzT3BlbkdyYXBoVGFnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogbmFtZSxcbiAgICAgIHByb3BlcnR5OiBuYW1lLFxuICAgICAgY29udGVudDogdmFsdWVcbiAgICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgY29udGVudDogdmFsdWVcbiAgICB9KTtcbiAgfSkpO1xufVxuLyoqXG4gKiBUcmFja3Mgd2hldGhlciBSZW1peCBoYXMgZmluaXNoZWQgaHlkcmF0aW5nIG9yIG5vdCwgc28gc2NyaXB0cyBjYW4gYmUgc2tpcHBlZFxuICogZHVyaW5nIGNsaWVudC1zaWRlIHVwZGF0ZXMuXG4gKi9cblxubGV0IGlzSHlkcmF0ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgPHNjcmlwdD5gIHRhZ3MgbmVlZGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuIEJ1bmRsZXMgZm9yXG4gKiBhZGRpdGlvbmFsIHJvdXRlcyBhcmUgbG9hZGVkIGxhdGVyIGFzIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgQWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGFkZCB0byBlYWNoIHNjcmlwdCB0YWcgdGhhdCBpcyByZW5kZXJlZC5cbiAqIEluIGFkZGl0aW9uIHRvIHNjcmlwdHMsIFxcPGxpbmsgcmVsPVwibW9kdWxlcHJlbG9hZFwiPiB0YWdzIHJlY2VpdmUgdGhlIGNyb3NzT3JpZ2luXG4gKiBwcm9wZXJ0eSBpZiBwcm92aWRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNtZXRhLWxpbmtzLXNjcmlwdHNcbiAqL1xuZnVuY3Rpb24gU2NyaXB0cyhwcm9wcykge1xuICBsZXQge1xuICAgIG1hbmlmZXN0LFxuICAgIG1hdGNoZXMsXG4gICAgcGVuZGluZ0xvY2F0aW9uLFxuICAgIGNsaWVudFJvdXRlcyxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzSHlkcmF0ZWQgPSB0cnVlO1xuICB9LCBbXSk7XG4gIGxldCBpbml0aWFsU2NyaXB0cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBjb250ZXh0U2NyaXB0ID0gc2VydmVySGFuZG9mZlN0cmluZyA/IGB3aW5kb3cuX19yZW1peENvbnRleHQgPSAke3NlcnZlckhhbmRvZmZTdHJpbmd9O2AgOiBcIlwiO1xuICAgIGxldCByb3V0ZU1vZHVsZXNTY3JpcHQgPSBgJHttYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiBgaW1wb3J0ICogYXMgcm91dGUke2luZGV4fSBmcm9tICR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXS5tb2R1bGUpfTtgKS5qb2luKFwiXFxuXCIpfVxud2luZG93Ll9fcmVtaXhSb3V0ZU1vZHVsZXMgPSB7JHttYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiBgJHtKU09OLnN0cmluZ2lmeShtYXRjaC5yb3V0ZS5pZCl9OnJvdXRlJHtpbmRleH1gKS5qb2luKFwiLFwiKX19O2A7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBjcmVhdGVIdG1sKGNvbnRleHRTY3JpcHQpXG4gICAgfSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHNyYzogbWFuaWZlc3QudXJsXG4gICAgfSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBjcmVhdGVIdG1sKHJvdXRlTW9kdWxlc1NjcmlwdCksXG4gICAgICB0eXBlOiBcIm1vZHVsZVwiXG4gICAgfSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHNyYzogbWFuaWZlc3QuZW50cnkubW9kdWxlLFxuICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgIH0pKSk7IC8vIGRpc2FibGVkIGRlcHMgYXJyYXkgYmVjYXVzZSB3ZSBhcmUgcHVycG9zZWZ1bGx5IG9ubHkgcmVuZGVyaW5nIHRoaXMgb25jZVxuICAgIC8vIGZvciBoeWRyYXRpb24sIGFmdGVyIHRoYXQgd2Ugd2FudCB0byBqdXN0IGNvbnRpbnVlIHJlbmRlcmluZyB0aGUgaW5pdGlhbFxuICAgIC8vIHNjcmlwdHMgYXMgdGhleSB3ZXJlIHdoZW4gdGhlIHBhZ2UgZmlyc3QgbG9hZGVkXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIH0sIFtdKTsgLy8gYXZvaWQgd2F0ZXJmYWxsIHdoZW4gaW1wb3J0aW5nIHRoZSBuZXh0IHJvdXRlIG1vZHVsZVxuXG4gIGxldCBuZXh0TWF0Y2hlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChwZW5kaW5nTG9jYXRpb24pIHtcbiAgICAgIC8vIEZJWE1FOiBjYW4gcHJvYmFibHkgdXNlIHRyYW5zaXRpb25NYW5hZ2VyIGBuZXh0TWF0Y2hlc2BcbiAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hDbGllbnRSb3V0ZXMoY2xpZW50Um91dGVzLCBwZW5kaW5nTG9jYXRpb24pO1xuICAgICAgaW52YXJpYW50KG1hdGNoZXMsIGBObyByb3V0ZXMgbWF0Y2ggcGF0aCBcIiR7cGVuZGluZ0xvY2F0aW9uLnBhdGhuYW1lfVwiYCk7XG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH0sIFtwZW5kaW5nTG9jYXRpb24sIGNsaWVudFJvdXRlc10pO1xuICBsZXQgcm91dGVQcmVsb2FkcyA9IG1hdGNoZXMuY29uY2F0KG5leHRNYXRjaGVzKS5tYXAobWF0Y2ggPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgcmV0dXJuIChyb3V0ZS5pbXBvcnRzIHx8IFtdKS5jb25jYXQoW3JvdXRlLm1vZHVsZV0pO1xuICB9KS5mbGF0KDEpO1xuICBsZXQgcHJlbG9hZHMgPSBtYW5pZmVzdC5lbnRyeS5pbXBvcnRzLmNvbmNhdChyb3V0ZVByZWxvYWRzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBkZWR1cGUocHJlbG9hZHMpLm1hcChwYXRoID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7XG4gICAga2V5OiBwYXRoLFxuICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgaHJlZjogcGF0aCxcbiAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW5cbiAgfSkpLCBpc0h5ZHJhdGVkID8gbnVsbCA6IGluaXRpYWxTY3JpcHRzKTtcbn1cblxuZnVuY3Rpb24gZGVkdXBlKGFycmF5KSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xufVxuXG4vKipcbiAqIEEgUmVtaXgtYXdhcmUgYDxmb3JtPmAuIEl0IGJlaGF2ZXMgbGlrZSBhIG5vcm1hbCBmb3JtIGV4Y2VwdCB0aGF0IHRoZVxuICogaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxuICogcmVxdWVzdHMsIGFsbG93aW5nIGNvbXBvbmVudHMgdG8gYWRkIG5pY2VyIFVYIHRvIHRoZSBwYWdlIGFzIHRoZSBmb3JtIGlzXG4gKiBzdWJtaXR0ZWQgYW5kIHJldHVybnMgd2l0aCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I2Zvcm1cbiAqL1xubGV0IEZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKTtcbn0pO1xubGV0IEZvcm1JbXBsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgcmVsb2FkRG9jdW1lbnQgPSBmYWxzZSxcbiAgcmVwbGFjZSA9IGZhbHNlLFxuICBtZXRob2QgPSBcImdldFwiLFxuICBhY3Rpb24gPSBcIi5cIixcbiAgZW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gIGZldGNoS2V5LFxuICBvblN1Ym1pdCxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChmZXRjaEtleSk7XG4gIGxldCBmb3JtTWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIGZvcm1NZXRob2QpO1xuICBsZXQgZm9ybVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBsZXQgcmVmID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgZm9ybVJlZik7IC8vIFdoZW4gY2FsbGluZyBgc3VibWl0YCBvbiB0aGUgZm9ybSBlbGVtZW50IGl0c2VsZiwgd2UgZG9uJ3QgZ2V0IGRhdGEgZnJvbVxuICAvLyB0aGUgYnV0dG9uIHRoYXQgc3VibWl0dGVkIHRoZSBldmVudC4gRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vICAgPEZvcm0+XG4gIC8vICAgICA8YnV0dG9uIG5hbWU9XCJzb21ldGhpbmdcIiB2YWx1ZT1cIndoYXRldmVyXCI+U3VibWl0PC9idXR0b24+XG4gIC8vICAgPC9Gb3JtPlxuICAvL1xuICAvLyBmb3JtRGF0YS5nZXQoXCJzb21ldGhpbmdcIikgc2hvdWxkIGJlIFwid2hhdGV2ZXJcIiwgYnV0IHdlIGRvbid0IGdldCB0aGF0XG4gIC8vIHVubGVzcyB3ZSBjYWxsIHN1Ym1pdCBvbiB0aGUgY2xpY2tlZCBidXR0b24gaXRzZWxmLlxuICAvL1xuICAvLyBUbyBmaWd1cmUgb3V0IHdoaWNoIGJ1dHRvbiB0cmlnZ2VyZWQgdGhlIHN1Ym1pdCwgd2UnbGwgYXR0YWNoIGEgY2xpY2tcbiAgLy8gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGZvcm0uIFRoZSBjbGljayBldmVudCBpcyBhbHdheXMgdHJpZ2dlcmVkIGJlZm9yZVxuICAvLyB0aGUgc3VibWl0IGV2ZW50IChldmVuIHdoZW4gc3VibWl0dGluZyB2aWEga2V5Ym9hcmQgd2hlbiBmb2N1c2VkIG9uXG4gIC8vIGFub3RoZXIgZm9ybSBmaWVsZCwgeWVlZWVldCkgc28gd2Ugc2hvdWxkIGhhdmUgYWNjZXNzIHRvIHRoYXQgYnV0dG9uJ3NcbiAgLy8gZGF0YSBmb3IgdXNlIGluIHRoZSBzdWJtaXQgaGFuZGxlci5cblxuICBsZXQgY2xpY2tlZEJ1dHRvblJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBmb3JtID0gZm9ybVJlZi5jdXJyZW50O1xuICAgIGlmICghZm9ybSkgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgIGlmICghKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpKSByZXR1cm47XG4gICAgICBsZXQgc3VibWl0QnV0dG9uID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCJidXR0b24saW5wdXRbdHlwZT1zdWJtaXRdXCIpO1xuXG4gICAgICBpZiAoc3VibWl0QnV0dG9uICYmIHN1Ym1pdEJ1dHRvbi5mb3JtID09PSBmb3JtICYmIHN1Ym1pdEJ1dHRvbi50eXBlID09PSBcInN1Ym1pdFwiKSB7XG4gICAgICAgIGNsaWNrZWRCdXR0b25SZWYuY3VycmVudCA9IHN1Ym1pdEJ1dHRvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBtZXRob2Q6IGZvcm1NZXRob2QsXG4gICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgIGVuY1R5cGU6IGVuY1R5cGUsXG4gICAgb25TdWJtaXQ6IHJlbG9hZERvY3VtZW50ID8gdW5kZWZpbmVkIDogZXZlbnQgPT4ge1xuICAgICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdWJtaXQoY2xpY2tlZEJ1dHRvblJlZi5jdXJyZW50IHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIGNsaWNrZWRCdXR0b25SZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBwcm9wcykpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQWN0aW9uUmVxdWVzdE1ldGhvZChtZXRob2QpIHtcbiAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBtZXRob2QgPT09IFwicG9zdFwiIHx8IG1ldGhvZCA9PT0gXCJwdXRcIiB8fCBtZXRob2QgPT09IFwicGF0Y2hcIiB8fCBtZXRob2QgPT09IFwiZGVsZXRlXCI7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgYDxmb3JtIGFjdGlvbj5gIHBhdGggcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlZm9ybWFjdGlvblxuICovXG5cblxuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24gPSBcIi5cIiwgbWV0aG9kID0gXCJnZXRcIikge1xuICBsZXQge1xuICAgIGlkXG4gIH0gPSB1c2VSZW1peFJvdXRlQ29udGV4dCgpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aChhY3Rpb24pO1xuICBsZXQgc2VhcmNoID0gcGF0aC5zZWFyY2g7XG4gIGxldCBpc0luZGV4Um91dGUgPSBpZC5lbmRzV2l0aChcIi9pbmRleFwiKTtcblxuICBpZiAoYWN0aW9uID09PSBcIi5cIiAmJiBpc0luZGV4Um91dGUgJiYgaXNBY3Rpb25SZXF1ZXN0TWV0aG9kKG1ldGhvZCkpIHtcbiAgICBzZWFyY2ggPSBzZWFyY2ggPyBzZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cblxuICByZXR1cm4gcGF0aC5wYXRobmFtZSArIHNlYXJjaDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZXN1Ym1pdFxuICovXG5mdW5jdGlvbiB1c2VTdWJtaXQoKSB7XG4gIHJldHVybiB1c2VTdWJtaXRJbXBsKCk7XG59XG5mdW5jdGlvbiB1c2VTdWJtaXRJbXBsKGtleSkge1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgZGVmYXVsdEFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oKTtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKCh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGxldCBtZXRob2Q7XG4gICAgbGV0IGFjdGlvbjtcbiAgICBsZXQgZW5jVHlwZTtcbiAgICBsZXQgZm9ybURhdGE7XG5cbiAgICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICBsZXQgc3VibWlzc2lvblRyaWdnZXIgPSBvcHRpb25zLnN1Ym1pc3Npb25UcmlnZ2VyO1xuICAgICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgdGFyZ2V0Lm1ldGhvZDtcbiAgICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IHRhcmdldC5hY3Rpb247XG4gICAgICBlbmNUeXBlID0gb3B0aW9ucy5lbmNUeXBlIHx8IHRhcmdldC5lbmN0eXBlO1xuICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGFyZ2V0KTtcblxuICAgICAgaWYgKHN1Ym1pc3Npb25UcmlnZ2VyICYmIHN1Ym1pc3Npb25UcmlnZ2VyLm5hbWUpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKHN1Ym1pc3Npb25UcmlnZ2VyLm5hbWUsIHN1Ym1pc3Npb25UcmlnZ2VyLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQnV0dG9uRWxlbWVudCh0YXJnZXQpIHx8IGlzSW5wdXRFbGVtZW50KHRhcmdldCkgJiYgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuXG4gICAgICBpZiAoZm9ybSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IHdpdGhvdXQgYSA8Zm9ybT5gKTtcbiAgICAgIH0gLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG5cblxuICAgICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgZm9ybS5tZXRob2Q7XG4gICAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmFjdGlvbjtcbiAgICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1lbmN0eXBlXCIpIHx8IGZvcm0uZW5jdHlwZTtcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pOyAvLyBJbmNsdWRlIG5hbWUgKyB2YWx1ZSBmcm9tIGEgPGJ1dHRvbj5cblxuICAgICAgaWYgKHRhcmdldC5uYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLnNldCh0YXJnZXQubmFtZSwgdGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBgICsgYDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YCk7XG4gICAgICB9XG5cbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiZ2V0XCI7XG4gICAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCBkZWZhdWx0QWN0aW9uO1xuICAgICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuXG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgZm9ybURhdGEgPSB0YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIHRhcmdldCkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIE9iamVjdC5rZXlzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGNhbGxpbmcgc3VibWl0IGR1cmluZyB0aGUgc2VydmVyIHJlbmRlci4gXCIgKyBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiKTtcbiAgICB9XG5cbiAgICBsZXQge1xuICAgICAgcHJvdG9jb2wsXG4gICAgICBob3N0XG4gICAgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChhY3Rpb24sIGAke3Byb3RvY29sfS8vJHtob3N0fWApO1xuXG4gICAgaWYgKG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiKSB7XG4gICAgICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIGZvcm1EYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3VibWl0IGJpbmFyeSBmb3JtIGRhdGEgdXNpbmcgR0VUYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc3VibWlzc2lvbiA9IHtcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgYWN0aW9uOiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLFxuICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgIGVuY1R5cGUsXG4gICAgICBrZXk6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA4KVxuICAgIH07XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJmZXRjaGVyXCIsXG4gICAgICAgIGhyZWY6IHN1Ym1pc3Npb24uYWN0aW9uLFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXROZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbik7XG4gICAgICBuYXZpZ2F0ZSh1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLCB7XG4gICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZGVmYXVsdEFjdGlvbiwga2V5LCBuYXZpZ2F0ZSwgdHJhbnNpdGlvbk1hbmFnZXJdKTtcbn1cbmxldCBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb247XG5cbmZ1bmN0aW9uIHNldE5leHROYXZpZ2F0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKSB7XG4gIG5leHROYXZpZ2F0aW9uU3VibWlzc2lvbiA9IHN1Ym1pc3Npb247XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVOZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oKSB7XG4gIGxldCBzdWJtaXNzaW9uID0gbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uO1xuICBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24gPSB1bmRlZmluZWQ7XG4gIHJldHVybiBzdWJtaXNzaW9uO1xufVxuXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cblxuZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cblxuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xufVxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLCB3aGljaCBhdXRvbWF0aWNhbGx5IGhhcHBlbnMgb24gdGhlIG5leHQgYDxMaW5rPmAgY2xpY2sgd2hlbiBSZW1peFxuICogZGV0ZWN0cyBhIG5ldyB2ZXJzaW9uIG9mIHRoZSBhcHAgaXMgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlYmVmb3JldW5sb2FkXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoY2FsbGJhY2spIHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tdKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCByb3V0ZSBtYXRjaGVzIG9uIHRoZSBwYWdlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmdcbiAqIGxheW91dCBhYnN0cmFjdGlvbnMgd2l0aCB5b3VyIGN1cnJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZW1hdGNoZXNcbiAqL1xuXG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVEYXRhLFxuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIHZhciBfcm91dGVNb2R1bGVzJG1hdGNoJHI7XG5cbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gbWF0Y2g7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBtYXRjaC5yb3V0ZS5pZCxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcGFyYW1zLFxuICAgICAgZGF0YTogcm91dGVEYXRhW21hdGNoLnJvdXRlLmlkXSxcbiAgICAgIC8vIGlmIHRoZSBtb2R1bGUgZmFpbHMgdG8gbG9hZCBvciBhbiBlcnJvci9yZXNwb25zZSBpcyB0aHJvd24sIHRoZSBtb2R1bGVcbiAgICAgIC8vIHdvbid0IGJlIGRlZmluZWQuXG4gICAgICBoYW5kbGU6IChfcm91dGVNb2R1bGVzJG1hdGNoJHIgPSByb3V0ZU1vZHVsZXNbbWF0Y2gucm91dGUuaWRdKSA9PT0gbnVsbCB8fCBfcm91dGVNb2R1bGVzJG1hdGNoJHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yb3V0ZU1vZHVsZXMkbWF0Y2gkci5oYW5kbGVcbiAgICB9O1xuICB9KSwgW21hdGNoZXMsIHJvdXRlRGF0YSwgcm91dGVNb2R1bGVzXSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gcGFyc2VkIGRhdGEgZnJvbSB0aGUgY3VycmVudCByb3V0ZSdzIGBsb2FkZXJgLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWxvYWRlcmRhdGFcbiAqL1xuXG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICByZXR1cm4gdXNlUmVtaXhSb3V0ZUNvbnRleHQoKS5kYXRhO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIHBhcnNlZCBkYXRhIGZyb20gdGhlIGN1cnJlbnQgcm91dGUncyBgYWN0aW9uYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VhY3Rpb25kYXRhXG4gKi9cblxuZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpIHtcbiAgbGV0IHtcbiAgICBpZDogcm91dGVJZFxuICB9ID0gdXNlUmVtaXhSb3V0ZUNvbnRleHQoKTtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBhY3Rpb25EYXRhXG4gIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICByZXR1cm4gYWN0aW9uRGF0YSA/IGFjdGlvbkRhdGFbcm91dGVJZF0gOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byBrbm93IGFib3V0IGEgcGFnZSB0cmFuc2l0aW9uIHRvIGJ1aWxkIHBlbmRpbmdcbiAqIG5hdmlnYXRpb24gaW5kaWNhdG9ycyBhbmQgb3B0aW1pc3RpYyBVSSBvbiBkYXRhIG11dGF0aW9ucy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2V0cmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCkudHJhbnNpdGlvbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hlckZvcm0oZmV0Y2hLZXkpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgLy8gVE9ETzogbWFrZSBBTk9USEVSIGZvcm0gdy9vIGEgZmV0Y2hLZXkgcHJvcFxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtSW1wbCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICByZWY6IHJlZixcbiAgICAgIGZldGNoS2V5OiBmZXRjaEtleVxuICAgIH0pKTtcbiAgfSk7XG59XG5cbmxldCBmZXRjaGVySWQgPSAwO1xuXG4vKipcbiAqIEludGVyYWN0cyB3aXRoIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgd2l0aG91dCBjYXVzaW5nIGEgbmF2aWdhdGlvbi4gR3JlYXRcbiAqIGZvciBhbnkgaW50ZXJhY3Rpb24gdGhhdCBzdGF5cyBvbiB0aGUgc2FtZSBwYWdlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWZldGNoZXJcbiAqL1xuZnVuY3Rpb24gdXNlRmV0Y2hlcigpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IFtrZXldID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gU3RyaW5nKCsrZmV0Y2hlcklkKSk7XG4gIGxldCBbRm9ybV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVGZXRjaGVyRm9ybShrZXkpKTtcbiAgbGV0IFtsb2FkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGhyZWYgPT4ge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLnNlbmQoe1xuICAgICAgdHlwZTogXCJmZXRjaGVyXCIsXG4gICAgICBocmVmLFxuICAgICAga2V5XG4gICAgfSk7XG4gIH0pO1xuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChrZXkpO1xuICBsZXQgZmV0Y2hlciA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldEZldGNoZXIoa2V5KTtcbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBGb3JtLFxuICAgIHN1Ym1pdCxcbiAgICBsb2FkLFxuICAgIC4uLmZldGNoZXJcbiAgfSksIFtmZXRjaGVyLCBGb3JtLCBzdWJtaXQsIGxvYWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJcyB0aGlzIGJ1c3RlZCB3aGVuIHRoZSBSZWFjdCB0ZWFtIGdldHMgcmVhbCB3ZWlyZCBhbmQgY2FsbHMgZWZmZWN0c1xuICAgIC8vIHR3aWNlIG9uIG1vdW50PyAgV2UgcmVhbGx5IGp1c3QgbmVlZCB0byBnYXJiYWdlIGNvbGxlY3QgaGVyZSB3aGVuIHRoaXNcbiAgICAvLyBmZXRjaGVyIGlzIG5vIGxvbmdlciBhcm91bmQuXG4gICAgcmV0dXJuICgpID0+IHRyYW5zaXRpb25NYW5hZ2VyLmRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBrZXldKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VmZXRjaGVyc1xuICovXG5cbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xuICBsZXQge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQge1xuICAgIGZldGNoZXJzXG4gIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICByZXR1cm4gWy4uLmZldGNoZXJzLnZhbHVlcygpXTtcbn0gLy8gRGVhZCBDb2RlIEVsaW1pbmF0aW9uIG1hZ2ljIGZvciBwcm9kdWN0aW9uIGJ1aWxkcy5cbi8vIFRoaXMgd2F5IGRldnMgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBkb2luZyB0aGUgTk9ERV9FTlYgY2hlY2sgdGhlbXNlbHZlcy5cblxuY29uc3QgTGl2ZVJlbG9hZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgPyAoKSA9PiBudWxsIDogZnVuY3Rpb24gTGl2ZVJlbG9hZCh7XG4gIHBvcnQgPSBOdW1iZXIocHJvY2Vzcy5lbnYuUkVNSVhfREVWX1NFUlZFUl9XU19QT1JUIHx8IDgwMDIpXG59KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogYFxubGV0IHByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzczonIDogJ3dzOic7XG5sZXQgaG9zdCA9IGxvY2F0aW9uLmhvc3RuYW1lO1xubGV0IHNvY2tldFBhdGggPSBwcm90b2NvbCArICcvLycgKyBob3N0ICsgJzoke3BvcnR9L3NvY2tldCc7XG5cbmxldCB3cyA9IG5ldyBXZWJTb2NrZXQoc29ja2V0UGF0aCk7XG53cy5vbm1lc3NhZ2UgPSBtZXNzYWdlID0+IHtcbiAgbGV0IGV2ZW50ID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICBpZiAoZXZlbnQudHlwZSA9PT0gXCJMT0dcIikge1xuICAgIGNvbnNvbGUubG9nKGV2ZW50Lm1lc3NhZ2UpO1xuICB9XG4gIGlmIChldmVudC50eXBlID09PSBcIlJFTE9BRFwiKSB7XG4gICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdURDQkYgUmVsb2FkaW5nIHdpbmRvdyAuLi5cIik7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG59O1xud3Mub25lcnJvciA9IGVycm9yID0+IHtcbiAgY29uc29sZS5sb2coXCJSZW1peCBkZXYgYXNzZXQgc2VydmVyIHdlYiBzb2NrZXQgZXJyb3I6XCIpO1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn07XG4gICAgICAgICAgICAgIGAudHJpbSgpXG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHVzZUNvbXBvc2VkUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBmb3IgKGxldCByZWYgb2YgcmVmcykge1xuICAgICAgaWYgKHJlZiA9PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH1cbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICB9LCByZWZzKTtcbn1cblxuZXhwb3J0IHsgRm9ybSwgRm9ybUltcGwsIExpbmssIExpbmtzLCBMaXZlUmVsb2FkLCBNZXRhLCBOYXZMaW5rLCBQcmVmZXRjaFBhZ2VMaW5rcywgUmVtaXhFbnRyeSwgUmVtaXhFbnRyeUNvbnRleHQsIFJlbWl4Um91dGUsIFNjcmlwdHMsIGNvbXBvc2VFdmVudEhhbmRsZXJzLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMb2FkZXJEYXRhLCB1c2VNYXRjaGVzLCB1c2VTdWJtaXQsIHVzZVN1Ym1pdEltcGwsIHVzZVRyYW5zaXRpb24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCB7IF9leHRlbmRzIGFzIGV4dGVuZHMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuY2xhc3MgUmVtaXhFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLFxuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICAvLyBXaGVuIHdlIGdldCBpbnRvIGFuIGVycm9yIHN0YXRlLCB0aGUgdXNlciB3aWxsIGxpa2VseSBjbGljayBcImJhY2tcIiB0byB0aGVcbiAgICAvLyBwcmV2aW91cyBwYWdlIHRoYXQgZGlkbid0IGhhdmUgYW4gZXJyb3IuIEJlY2F1c2UgdGhpcyB3cmFwcyB0aGUgZW50aXJlXG4gICAgLy8gYXBwbGljYXRpb24gKGV2ZW4gdGhlIEhUTUwhKSB0aGF0IHdpbGwgaGF2ZSBubyBlZmZlY3QtLXRoZSBlcnJvciBwYWdlXG4gICAgLy8gY29udGludWVzIHRvIGRpc3BsYXkuIFRoaXMgZ2l2ZXMgdXMgYSBtZWNoYW5pc20gdG8gcmVjb3ZlciBmcm9tIHRoZSBlcnJvclxuICAgIC8vIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgLy9cbiAgICAvLyBXaGV0aGVyIHdlJ3JlIGluIGFuIGVycm9yIHN0YXRlIG9yIG5vdCwgd2UgdXBkYXRlIHRoZSBsb2NhdGlvbiBpbiBzdGF0ZVxuICAgIC8vIHNvIHRoYXQgd2hlbiB3ZSBhcmUgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGdldHMgcmVzZXQgd2hlbiBhIG5ldyBsb2NhdGlvblxuICAgIC8vIGNvbWVzIGluIGFuZCB0aGUgdXNlciByZWNvdmVycyBmcm9tIHRoZSBlcnJvci5cbiAgICBpZiAoc3RhdGUubG9jYXRpb24gIT09IHByb3BzLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCxcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uXG4gICAgICB9O1xuICAgIH0gLy8gSWYgd2UncmUgbm90IGNoYW5naW5nIGxvY2F0aW9ucywgcHJlc2VydmUgdGhlIGxvY2F0aW9uIGJ1dCBzdGlsbCBzdXJmYWNlXG4gICAgLy8gYW55IG5ldyBlcnJvcnMgdGhhdCBtYXkgY29tZSB0aHJvdWdoLiBXZSByZXRhaW4gdGhlIGV4aXN0aW5nIGVycm9yLCB3ZSBkb1xuICAgIC8vIHRoaXMgYmVjYXVzZSB0aGUgZXJyb3IgcHJvdmlkZWQgZnJvbSB0aGUgYXBwIHN0YXRlIG1heSBiZSBjbGVhcmVkIHdpdGhvdXRcbiAgICAvLyB0aGUgbG9jYXRpb24gY2hhbmdpbmcuXG5cblxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgc3RhdGUuZXJyb3IsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICB9O1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodGhpcy5wcm9wcy5jb21wb25lbnQsIHtcbiAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3JcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1cblxufVxuLyoqXG4gKiBXaGVuIGFwcCdzIGRvbid0IHByb3ZpZGUgYSByb290IGxldmVsIEVycm9yQm91bmRhcnksIHdlIGRlZmF1bHQgdG8gdGhpcy5cbiAqL1xuXG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSh7XG4gIGVycm9yXG59KSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIsIHtcbiAgICBsYW5nOiBcImVuXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgY2hhclNldDogXCJ1dGYtOFwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgIG5hbWU6IFwidmlld3BvcnRcIixcbiAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEsdmlld3BvcnQtZml0PWNvdmVyXCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgXCJBcHBsaWNhdGlvbiBFcnJvciFcIikpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImJvZHlcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtYWluXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZm9udEZhbWlseTogXCJzeXN0ZW0tdWksIHNhbnMtc2VyaWZcIixcbiAgICAgIHBhZGRpbmc6IFwiMnJlbVwiXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImgxXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZm9udFNpemU6IFwiMjRweFwiXG4gICAgfVxuICB9LCBcIkFwcGxpY2F0aW9uIEVycm9yXCIpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByZVwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IFwiMnJlbVwiLFxuICAgICAgYmFja2dyb3VuZDogXCJoc2xhKDEwLCA1MCUsIDUwJSwgMC4xKVwiLFxuICAgICAgY29sb3I6IFwicmVkXCIsXG4gICAgICBvdmVyZmxvdzogXCJhdXRvXCJcbiAgICB9XG4gIH0sIGVycm9yLnN0YWNrKSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiXHVEODNEXHVEQ0JGIEhleSBkZXZlbG9wZXJcdUQ4M0RcdURDNEIuIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycy4gQ2hlY2sgb3V0IGh0dHBzOi8vcmVtaXgucnVuL2d1aWRlcy9lcnJvcnMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGBcbiAgICB9XG4gIH0pKSk7XG59XG5sZXQgUmVtaXhDYXRjaENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhyb3duIHJlc3BvbnNlIGRhdGEuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjY2F0Y2hib3VuZGFyeVxuICovXG5cbmZ1bmN0aW9uIHVzZUNhdGNoKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChSZW1peENhdGNoQ29udGV4dCk7XG59XG5mdW5jdGlvbiBSZW1peENhdGNoQm91bmRhcnkoe1xuICBjYXRjaDogY2F0Y2hWYWwsXG4gIGNvbXBvbmVudDogQ29tcG9uZW50LFxuICBjaGlsZHJlblxufSkge1xuICBpZiAoY2F0Y2hWYWwpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVtaXhDYXRjaENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjYXRjaFZhbFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgbnVsbCkpO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG4vKipcbiAqIFdoZW4gYXBwJ3MgZG9uJ3QgcHJvdmlkZSBhIHJvb3QgbGV2ZWwgQ2F0Y2hCb3VuZGFyeSwgd2UgZGVmYXVsdCB0byB0aGlzLlxuICovXG5cbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRDYXRjaEJvdW5kYXJ5KCkge1xuICBsZXQgY2F1Z2h0ID0gdXNlQ2F0Y2goKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCB7XG4gICAgbGFuZzogXCJlblwiXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgIGNoYXJTZXQ6IFwidXRmLThcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLHZpZXdwb3J0LWZpdD1jb3ZlclwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIFwiVW5oYW5kbGVkIFRocm93biBSZXNwb25zZSFcIikpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImJvZHlcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRGYW1pbHk6IFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIsXG4gICAgICBwYWRkaW5nOiBcIjJyZW1cIlxuICAgIH1cbiAgfSwgY2F1Z2h0LnN0YXR1cywgXCIgXCIsIGNhdWdodC5zdGF0dXNUZXh0KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJcdUQ4M0RcdURDQkYgSGV5IGRldmVsb3Blclx1RDgzRFx1REM0Qi4gWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgNDA0cyAoYW5kIG90aGVyIHJlc3BvbnNlcykuIENoZWNrIG91dCBodHRwczovL3JlbWl4LnJ1bi9ndWlkZXMvbm90LWZvdW5kIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBgXG4gICAgfVxuICB9KSkpO1xufVxuXG5leHBvcnQgeyBSZW1peENhdGNoQm91bmRhcnksIFJlbWl4RXJyb3JCb3VuZGFyeSwgUmVtaXhSb290RGVmYXVsdENhdGNoQm91bmRhcnksIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LCB1c2VDYXRjaCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCB7IGludmFyaWFudCBhcyBkZWZhdWx0IH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCB7IGxvYWRSb3V0ZU1vZHVsZSB9IGZyb20gJy4vcm91dGVNb2R1bGVzLmpzJztcblxuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogR2V0cyBhbGwgdGhlIGxpbmtzIGZvciBhIHNldCBvZiBtYXRjaGVzLiBUaGUgbW9kdWxlcyBhcmUgYXNzdW1lZCB0byBoYXZlIGJlZW5cbiAqIGxvYWRlZCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBnZXRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCkge1xuICBsZXQgZGVzY3JpcHRvcnMgPSBtYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgdmFyIF9tb2R1bGUkbGlua3M7XG5cbiAgICBsZXQgbW9kdWxlID0gcm91dGVNb2R1bGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICByZXR1cm4gKChfbW9kdWxlJGxpbmtzID0gbW9kdWxlLmxpbmtzKSA9PT0gbnVsbCB8fCBfbW9kdWxlJGxpbmtzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbW9kdWxlJGxpbmtzLmNhbGwobW9kdWxlKSkgfHwgW107XG4gIH0pLmZsYXQoMSk7XG4gIGxldCBwcmVsb2FkcyA9IGdldEN1cnJlbnRQYWdlTW9kdWxlUHJlbG9hZEhyZWZzKG1hdGNoZXMsIG1hbmlmZXN0KTtcbiAgcmV0dXJuIGRlZHVwZShkZXNjcmlwdG9ycywgcHJlbG9hZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlTW9kdWxlKSB7XG4gIGlmICghcm91dGVNb2R1bGUubGlua3MpIHJldHVybjtcbiAgbGV0IGRlc2NyaXB0b3JzID0gcm91dGVNb2R1bGUubGlua3MoKTtcbiAgaWYgKCFkZXNjcmlwdG9ycykgcmV0dXJuO1xuICBsZXQgc3R5bGVMaW5rcyA9IFtdO1xuXG4gIGZvciAobGV0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IucmVsID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgc3R5bGVMaW5rcy5wdXNoKHsgLi4uZGVzY3JpcHRvcixcbiAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgYXM6IFwic3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIGRvbid0IGJsb2NrIGZvciBub24tbWF0Y2hpbmcgbWVkaWEgcXVlcmllc1xuXG5cbiAgbGV0IG1hdGNoaW5nTGlua3MgPSBzdHlsZUxpbmtzLmZpbHRlcihsaW5rID0+ICFsaW5rLm1lZGlhIHx8IHdpbmRvdy5tYXRjaE1lZGlhKGxpbmsubWVkaWEpLm1hdGNoZXMpO1xuICBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGluZ0xpbmtzLm1hcChwcmVmZXRjaFN0eWxlTGluaykpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFN0eWxlTGluayhkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgIE9iamVjdC5hc3NpZ24obGluaywgZGVzY3JpcHRvcik7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVMaW5rKCkge1xuICAgICAgLy8gaWYgYSBuYXZpZ2F0aW9uIGludGVycnVwdHMgdGhpcyBwcmVmZXRjaCBSZWFjdCB3aWxsIHVwZGF0ZSB0aGUgPGhlYWQ+XG4gICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBsaW5rIHdlIHB1dCBpbiB0aGVyZSBtYW51YWxseSwgc28gd2UgY2hlY2sgaWYgaXQncyBzdGlsbFxuICAgICAgLy8gdGhlcmUgYmVmb3JlIHRyeWluZyB0byByZW1vdmUgaXRcbiAgICAgIGlmIChkb2N1bWVudC5oZWFkLmNvbnRhaW5zKGxpbmspKSB7XG4gICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluay5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIGxpbmsub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlbW92ZUxpbmsoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgfSk7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuZnVuY3Rpb24gaXNQYWdlTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnBhZ2UgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0h0bWxMaW5rRGVzY3JpcHRvcihvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QucmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaHJlZiA9PT0gXCJzdHJpbmdcIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgbGlua3MgPSBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGVzLm1hcChhc3luYyBtYXRjaCA9PiB7XG4gICAgbGV0IG1vZCA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgICByZXR1cm4gbW9kLmxpbmtzID8gbW9kLmxpbmtzKCkgOiBbXTtcbiAgfSkpO1xuICByZXR1cm4gbGlua3MuZmxhdCgxKS5maWx0ZXIoaXNIdG1sTGlua0Rlc2NyaXB0b3IpLmZpbHRlcihsaW5rID0+IGxpbmsucmVsID09PSBcInN0eWxlc2hlZXRcIiB8fCBsaW5rLnJlbCA9PT0gXCJwcmVsb2FkXCIpLm1hcCgoe1xuICAgIHJlbCxcbiAgICAuLi5hdHRyc1xuICB9KSA9PiByZWwgPT09IFwicHJlbG9hZFwiID8ge1xuICAgIHJlbDogXCJwcmVmZXRjaFwiLFxuICAgIC4uLmF0dHJzXG4gIH0gOiB7XG4gICAgcmVsOiBcInByZWZldGNoXCIsXG4gICAgYXM6IFwic3R5bGVcIixcbiAgICAuLi5hdHRyc1xuICB9KTtcbn0gLy8gVGhpcyBpcyByaWRpY3Vsb3VzbHkgaWRlbnRpY2FsIHRvIHRyYW5zaXRpb24udHMgYGZpbHRlck1hdGNoZXNUb0xvYWRgXG5cbmZ1bmN0aW9uIGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgY3VycmVudE1hdGNoZXMsIGxvY2F0aW9uLCBtb2RlKSB7XG4gIGxldCBwYXRoID0gcGFyc2VQYXRoUGF0Y2gocGFnZSk7XG5cbiAgbGV0IGlzTmV3ID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghY3VycmVudE1hdGNoZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5pZDtcbiAgfTtcblxuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2N1cnJlbnRNYXRjaGVzJGluZGV4O1xuXG4gICAgcmV0dXJuICgvLyBwYXJhbSBjaGFuZ2UsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgICAgY3VycmVudE1hdGNoZXNbaW5kZXhdLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fCAoKF9jdXJyZW50TWF0Y2hlcyRpbmRleCA9IGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoKSA9PT0gbnVsbCB8fCBfY3VycmVudE1hdGNoZXMkaW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jdXJyZW50TWF0Y2hlcyRpbmRleC5lbmRzV2l0aChcIipcIikpICYmIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTsgLy8gTk9URToga2VlcCB0aGlzIG1vc3RseSB1cC10by1kYXRlIHcvIHRoZSB0cmFuc2l0aW9uIGRhdGEgZGlmZiwgYnV0IHRoaXNcbiAgLy8gdmVyc2lvbiBkb2Vzbid0IGNhcmUgYWJvdXQgc3VibWlzc2lvbnNcblxuXG4gIGxldCBuZXdNYXRjaGVzID0gbW9kZSA9PT0gXCJkYXRhXCIgJiYgbG9jYXRpb24uc2VhcmNoICE9PSBwYXRoLnNlYXJjaCA/IC8vIHRoaXMgaXMgcmVhbGx5IHNpbWlsYXIgdG8gc3R1ZmYgaW4gdHJhbnNpdGlvbi50cywgbWF5YmUgc29tZWJvZHkgc21hcnRlclxuICAvLyB0aGFuIG1lIChvciBpbiBsZXNzIG9mIGEgaHVycnkpIGNhbiBzaGFyZSBzb21lIG9mIGl0LiBZb3UncmUgdGhlIGJlc3QuXG4gIG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQpIHtcbiAgICAgIHJldHVybiBtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQoe1xuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgcHJldlVybDogbmV3IFVSTChsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gsIHdpbmRvdy5vcmlnaW4pLFxuICAgICAgICB1cmw6IG5ldyBVUkwocGFnZSwgd2luZG93Lm9yaWdpbilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KSA6IG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmhhc0xvYWRlciAmJiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpO1xuICB9KTtcbiAgcmV0dXJuIG5ld01hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREYXRhTGlua0hyZWZzKHBhZ2UsIG1hdGNoZXMsIG1hbmlmZXN0KSB7XG4gIGxldCBwYXRoID0gcGFyc2VQYXRoUGF0Y2gocGFnZSk7XG4gIHJldHVybiBkZWR1cGVIcmVmcyhtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdLmhhc0xvYWRlcikubWFwKG1hdGNoID0+IHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2hcbiAgICB9ID0gcGF0aDtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJfZGF0YVwiLCBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgcmV0dXJuIGAke3BhdGhuYW1lfT8ke3NlYXJjaFBhcmFtc31gO1xuICB9KSk7XG59XG5mdW5jdGlvbiBnZXRNb2R1bGVMaW5rSHJlZnMobWF0Y2hlcywgbWFuaWZlc3RQYXRjaCkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMobWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0UGF0Y2gucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBsZXQgaHJlZnMgPSBbcm91dGUubW9kdWxlXTtcblxuICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5pbXBvcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZnM7XG4gIH0pLmZsYXQoMSkpO1xufSAvLyBUaGUgYDxTY3JpcHQ+YCB3aWxsIHJlbmRlciByZWw9bW9kdWxlcHJlbG9hZCBmb3IgdGhlIGN1cnJlbnQgcGFnZSwgd2UgZG9uJ3Rcbi8vIG5lZWQgdG8gaW5jbHVkZSB0aGVtIGluIGEgcGFnZSBwcmVmZXRjaCwgdGhpcyBnaXZlcyB1cyB0aGUgbGlzdCB0byByZW1vdmVcbi8vIHdoaWxlIGRlZHVwaW5nLlxuXG5mdW5jdGlvbiBnZXRDdXJyZW50UGFnZU1vZHVsZVByZWxvYWRIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMobWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG5cbiAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaW1wb3J0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWZzO1xuICB9KS5mbGF0KDEpKTtcbn1cblxuZnVuY3Rpb24gZGVkdXBlSHJlZnMoaHJlZnMpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGhyZWZzKV07XG59XG5cbmZ1bmN0aW9uIGRlZHVwZShkZXNjcmlwdG9ycywgcHJlbG9hZHMpIHtcbiAgbGV0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IHByZWxvYWRzU2V0ID0gbmV3IFNldChwcmVsb2Fkcyk7XG4gIHJldHVybiBkZXNjcmlwdG9ycy5yZWR1Y2UoKGRlZHVwZWQsIGRlc2NyaXB0b3IpID0+IHtcbiAgICBsZXQgYWxyZWFkeU1vZHVsZVByZWxvYWQgPSAhaXNQYWdlTGlua0Rlc2NyaXB0b3IoZGVzY3JpcHRvcikgJiYgZGVzY3JpcHRvci5hcyA9PT0gXCJzY3JpcHRcIiAmJiBkZXNjcmlwdG9yLmhyZWYgJiYgcHJlbG9hZHNTZXQuaGFzKGRlc2NyaXB0b3IuaHJlZik7XG5cbiAgICBpZiAoYWxyZWFkeU1vZHVsZVByZWxvYWQpIHtcbiAgICAgIHJldHVybiBkZWR1cGVkO1xuICAgIH1cblxuICAgIGxldCBzdHIgPSBKU09OLnN0cmluZ2lmeShkZXNjcmlwdG9yKTtcblxuICAgIGlmICghc2V0LmhhcyhzdHIpKSB7XG4gICAgICBzZXQuYWRkKHN0cik7XG4gICAgICBkZWR1cGVkLnB1c2goZGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZHVwZWQ7XG4gIH0sIFtdKTtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L2lzc3Vlcy84OTdcblxuZnVuY3Rpb24gcGFyc2VQYXRoUGF0Y2goaHJlZikge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aChocmVmKTtcbiAgaWYgKHBhdGguc2VhcmNoID09PSB1bmRlZmluZWQpIHBhdGguc2VhcmNoID0gXCJcIjtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCB7IGRlZHVwZSwgZ2V0RGF0YUxpbmtIcmVmcywgZ2V0TGlua3NGb3JNYXRjaGVzLCBnZXRNb2R1bGVMaW5rSHJlZnMsIGdldE5ld01hdGNoZXNGb3JMaW5rcywgZ2V0U3R5bGVzaGVldFByZWZldGNoTGlua3MsIGlzSHRtbExpbmtEZXNjcmlwdG9yLCBpc1BhZ2VMaW5rRGVzY3JpcHRvciwgcHJlZmV0Y2hTdHlsZUxpbmtzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuLy8gYW5kIGxldmVyYWdlIGByZWFjdC1yb3V0ZXJgIGhlcmUgaW5zdGVhZFxuLy8gVE9ETzogaW1wb3J0L2V4cG9ydCBmcm9tIHJlYWN0LXJvdXRlci1kb21cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHJlbmRlcmVkIHdoZW4gdGhlIHNlcnZlciB0aHJvd3MgYSBSZXNwb25zZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9jb252ZW50aW9ucyNjYXRjaGJvdW5kYXJ5XG4gKi9cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHJlbmRlcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3Igb24gYSByb3V0ZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9jb252ZW50aW9ucyNlcnJvcmJvdW5kYXJ5XG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBgPGxpbms+YCB0YWdzIHRvIGJlIGluc2VydGVkIGludG8gdGhlIGA8aGVhZD5gIG9mXG4gKiB0aGUgZG9jdW1lbnQgb24gcm91dGUgdHJhbnNpdGlvbnMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgb2YgbmFtZSArIGNvbnRlbnQgcGFpcnMgdG8gdXNlIGZvclxuICogYDxtZXRhPmAgdGFncyBmb3IgYSByb3V0ZS4gVGhlc2UgdGFncyB3aWxsIGJlIG1lcmdlZCB3aXRoIChhbmQgdGFrZVxuICogcHJlY2VkZW5jZSBvdmVyKSB0YWdzIGZyb20gcGFyZW50IHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNtZXRhLWxpbmtzLXNjcmlwdHNcbiAqL1xuXG4vKipcbiAqIEEgbmFtZS9jb250ZW50IHBhaXIgdXNlZCB0byByZW5kZXIgYDxtZXRhPmAgdGFncyBpbiBhIG1ldGEgZnVuY3Rpb24gZm9yIGFcbiAqIHJvdXRlLiBUaGUgdmFsdWUgY2FuIGJlIGVpdGhlciBhIHN0cmluZywgd2hpY2ggd2lsbCByZW5kZXIgYSBzaW5nbGUgYDxtZXRhPmBcbiAqIHRhZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgcmVuZGVyIG11bHRpcGxlIHRhZ3Mgd2l0aCB0aGUgc2FtZVxuICogYG5hbWVgIGF0dHJpYnV0ZS5cbiAqL1xuXG4vKipcbiAqIER1cmluZyBjbGllbnQgc2lkZSB0cmFuc2l0aW9ucyBSZW1peCB3aWxsIG9wdGltaXplIHJlbG9hZGluZyBvZiByb3V0ZXMgdGhhdFxuICogYXJlIGN1cnJlbnRseSBvbiB0aGUgcGFnZSBieSBhdm9pZGluZyBsb2FkaW5nIHJvdXRlcyB0aGF0IGFyZW4ndCBjaGFuZ2luZy5cbiAqIEhvd2V2ZXIsIGluIHNvbWUgY2FzZXMsIGxpa2UgZm9ybSBzdWJtaXNzaW9ucyBvciBzZWFyY2ggcGFyYW1zIFJlbWl4IGRvZXNuJ3RcbiAqIGtub3cgd2hpY2ggcm91dGVzIG5lZWQgdG8gYmUgcmVsb2FkZWQgc28gaXQgcmVsb2FkcyB0aGVtIGFsbCB0byBiZSBzYWZlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbGV0cyBhcHBzIGZ1cnRoZXIgb3B0aW1pemUgYnkgcmV0dXJuaW5nIGBmYWxzZWAgd2hlbiBSZW1peCBpc1xuICogYWJvdXQgdG8gcmVsb2FkIHRoZSByb3V0ZS4gQSBjb21tb24gY2FzZSBpcyBhIHJvb3QgbG9hZGVyIHdpdGggbm90aGluZyBidXRcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlczogYWZ0ZXIgZm9ybSBzdWJtaXNzaW9ucyB0aGUgcm9vdCBwcm9iYWJseSBkb2Vzbid0IG5lZWRcbiAqIHRvIGJlIHJlbG9hZGVkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL2NvbnZlbnRpb25zI3Vuc3RhYmxlX3Nob3VsZHJlbG9hZFxuICovXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCBmb3IgYSByb3V0ZS5cbiAqL1xuXG4vKipcbiAqIEFuIGFyYml0cmFyeSBvYmplY3QgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYSByb3V0ZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9jb252ZW50aW9ucyNoYW5kbGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICBpZiAocm91dGUuaWQgaW4gcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSBhd2FpdCBpbXBvcnQocm91dGUubW9kdWxlKTtcbiAgICByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF0gPSByb3V0ZU1vZHVsZTtcbiAgICByZXR1cm4gcm91dGVNb2R1bGU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVXNlciBnb3QgY2F1Z2h0IGluIHRoZSBtaWRkbGUgb2YgYSBkZXBsb3kgYW5kIHRoZSBDRE4gbm8gbG9uZ2VyIGhhcyB0aGVcbiAgICAvLyBhc3NldCB3ZSdyZSB0cnlpbmcgdG8gaW1wb3J0ISBSZWxvYWQgZnJvbSB0aGUgc2VydmVyIGFuZCB0aGUgdXNlclxuICAgIC8vIChzaG91bGQpIGdldCB0aGUgbmV3IG1hbmlmZXN0LS11bmxlc3MgdGhlIGRldmVsb3BlciBwdXJnZWQgdGhlIHN0YXRpY1xuICAgIC8vIGFzc2V0cywgdGhlIG1hbmlmZXN0IHBhdGgsIGJ1dCBub3QgdGhlIGRvY3VtZW50cyBcdUQ4M0RcdURFMkNcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHsvLyBjaGVjayBvdXQgb2YgdGhpcyBob29rIGNhdXNlIHRoZSBESnMgbmV2ZXIgZ29ubmEgcmVbc11vbHZlIHRoaXNcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUh0bWwoaHRtbCkge1xuICByZXR1cm4ge1xuICAgIF9faHRtbDogaHRtbFxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVIdG1sIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfSBmcm9tICcuL3JvdXRlTW9kdWxlcy5qcyc7XG5pbXBvcnQgeyBmZXRjaERhdGEsIGlzQ2F0Y2hSZXNwb25zZSwgZXh0cmFjdERhdGEsIGlzUmVkaXJlY3RSZXNwb25zZSB9IGZyb20gJy4vZGF0YS5qcyc7XG5pbXBvcnQgeyBDYXRjaFZhbHVlLCBUcmFuc2l0aW9uUmVkaXJlY3QgfSBmcm9tICcuL3RyYW5zaXRpb24uanMnO1xuaW1wb3J0IHsgcHJlZmV0Y2hTdHlsZUxpbmtzIH0gZnJvbSAnLi9saW5rcy5qcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJy4vaW52YXJpYW50LmpzJztcblxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGUoZW50cnlSb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUsIENvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgIGNhc2VTZW5zaXRpdmU6ICEhZW50cnlSb3V0ZS5jYXNlU2Vuc2l0aXZlLFxuICAgIGVsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgaWQ6IGVudHJ5Um91dGUuaWRcbiAgICB9KSxcbiAgICBpZDogZW50cnlSb3V0ZS5pZCxcbiAgICBwYXRoOiBlbnRyeVJvdXRlLnBhdGgsXG4gICAgaW5kZXg6IGVudHJ5Um91dGUuaW5kZXgsXG4gICAgbW9kdWxlOiBlbnRyeVJvdXRlLm1vZHVsZSxcbiAgICBsb2FkZXI6IGNyZWF0ZUxvYWRlcihlbnRyeVJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSksXG4gICAgYWN0aW9uOiBjcmVhdGVBY3Rpb24oZW50cnlSb3V0ZSksXG4gICAgc2hvdWxkUmVsb2FkOiBjcmVhdGVTaG91bGRSZWxvYWQoZW50cnlSb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpLFxuICAgIEVycm9yQm91bmRhcnk6IGVudHJ5Um91dGUuaGFzRXJyb3JCb3VuZGFyeSxcbiAgICBDYXRjaEJvdW5kYXJ5OiBlbnRyeVJvdXRlLmhhc0NhdGNoQm91bmRhcnksXG4gICAgaGFzTG9hZGVyOiBlbnRyeVJvdXRlLmhhc0xvYWRlclxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGVzKHJvdXRlTWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQsIHBhcmVudElkKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyb3V0ZU1hbmlmZXN0KS5maWx0ZXIoa2V5ID0+IHJvdXRlTWFuaWZlc3Rba2V5XS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpLm1hcChrZXkgPT4ge1xuICAgIGxldCByb3V0ZSA9IGNyZWF0ZUNsaWVudFJvdXRlKHJvdXRlTWFuaWZlc3Rba2V5XSwgcm91dGVNb2R1bGVzQ2FjaGUsIENvbXBvbmVudCk7XG4gICAgbGV0IGNoaWxkcmVuID0gY3JlYXRlQ2xpZW50Um91dGVzKHJvdXRlTWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQsIHJvdXRlLmlkKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgcm91dGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICByZXR1cm4gcm91dGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaG91bGRSZWxvYWQocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgc2hvdWxkUmVsb2FkID0gYXJnID0+IHtcbiAgICBsZXQgbW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQobW9kdWxlLCBgRXhwZWN0ZWQgcm91dGUgbW9kdWxlIHRvIGJlIGxvYWRlZCBmb3IgJHtyb3V0ZS5pZH1gKTtcblxuICAgIGlmIChtb2R1bGUudW5zdGFibGVfc2hvdWxkUmVsb2FkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLnVuc3RhYmxlX3Nob3VsZFJlbG9hZChhcmcpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBzaG91bGRSZWxvYWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICBhd2FpdCBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGVNb2R1bGUpO1xuICByZXR1cm4gcm91dGVNb2R1bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvYWRlcihyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCBsb2FkZXIgPSBhc3luYyAoe1xuICAgIHVybCxcbiAgICBzaWduYWwsXG4gICAgc3VibWlzc2lvblxuICB9KSA9PiB7XG4gICAgaWYgKHJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgbGV0IFtyZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2ZldGNoRGF0YSh1cmwsIHJvdXRlLmlkLCBzaWduYWwsIHN1Ym1pc3Npb24pLCBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKV0pO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyByZXN1bHQ7XG4gICAgICBsZXQgcmVkaXJlY3QgPSBhd2FpdCBjaGVja1JlZGlyZWN0KHJlc3VsdCk7XG4gICAgICBpZiAocmVkaXJlY3QpIHJldHVybiByZWRpcmVjdDtcblxuICAgICAgaWYgKGlzQ2F0Y2hSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDYXRjaFZhbHVlKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBhd2FpdCBleHRyYWN0RGF0YShyZXN1bHQuY2xvbmUoKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0cmFjdERhdGEocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsb2FkZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihyb3V0ZSkge1xuICBpZiAoIXJvdXRlLmhhc0FjdGlvbikgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBsZXQgYWN0aW9uID0gYXN5bmMgKHtcbiAgICB1cmwsXG4gICAgc2lnbmFsLFxuICAgIHN1Ym1pc3Npb25cbiAgfSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBmZXRjaERhdGEodXJsLCByb3V0ZS5pZCwgc2lnbmFsLCBzdWJtaXNzaW9uKTtcblxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgcmVzdWx0O1xuICAgIH1cblxuICAgIGxldCByZWRpcmVjdCA9IGF3YWl0IGNoZWNrUmVkaXJlY3QocmVzdWx0KTtcbiAgICBpZiAocmVkaXJlY3QpIHJldHVybiByZWRpcmVjdDtcblxuICAgIGlmIChpc0NhdGNoUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IENhdGNoVmFsdWUocmVzdWx0LnN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGF3YWl0IGV4dHJhY3REYXRhKHJlc3VsdC5jbG9uZSgpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dHJhY3REYXRhKHJlc3VsdCk7XG4gIH07XG5cbiAgcmV0dXJuIGFjdGlvbjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tSZWRpcmVjdChyZXNwb25zZSkge1xuICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG5cbiAgICBpZiAodXJsLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh1cmwuaHJlZik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uUmVkaXJlY3QodXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNsaWVudFJvdXRlLCBjcmVhdGVDbGllbnRSb3V0ZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuXG5mdW5jdGlvbiBpc0NhdGNoUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LUNhdGNoXCIpICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LUVycm9yXCIpICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJlZGlyZWN0XCIpICE9IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaERhdGEodXJsLCByb3V0ZUlkLCBzaWduYWwsIHN1Ym1pc3Npb24pIHtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJfZGF0YVwiLCByb3V0ZUlkKTtcbiAgbGV0IGluaXQgPSBzdWJtaXNzaW9uID8gZ2V0QWN0aW9uSW5pdChzdWJtaXNzaW9uLCBzaWduYWwpIDoge1xuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgc2lnbmFsXG4gIH07XG4gIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC5ocmVmLCBpbml0KTtcblxuICBpZiAoaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgIGxldCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgIGVycm9yLnN0YWNrID0gZGF0YS5zdGFjaztcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwb25zZSkge1xuICAvLyBUaGlzIHNhbWUgYWxnb3JpdGhtIGlzIHVzZWQgb24gdGhlIHNlcnZlciB0byBpbnRlcnByZXQgbG9hZFxuICAvLyByZXN1bHRzIHdoZW4gd2UgcmVuZGVyIHRoZSBIVE1MIHBhZ2UuXG4gIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuXG4gIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25Jbml0KHN1Ym1pc3Npb24sIHNpZ25hbCkge1xuICBsZXQge1xuICAgIGVuY1R5cGUsXG4gICAgbWV0aG9kLFxuICAgIGZvcm1EYXRhXG4gIH0gPSBzdWJtaXNzaW9uO1xuICBsZXQgaGVhZGVycyA9IHVuZGVmaW5lZDtcbiAgbGV0IGJvZHkgPSBmb3JtRGF0YTtcblxuICBpZiAoZW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikge1xuICAgIGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEpIHtcbiAgICAgIGludmFyaWFudCh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIsIGBGaWxlIGlucHV0cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGVuY1R5cGUgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgcGxlYXNlIHVzZSBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiBpbnN0ZWFkLmApO1xuICAgICAgYm9keS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IGVuY1R5cGVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2QsXG4gICAgYm9keSxcbiAgICBzaWduYWwsXG4gICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICBoZWFkZXJzXG4gIH07XG59XG5cbmV4cG9ydCB7IGV4dHJhY3REYXRhLCBmZXRjaERhdGEsIGlzQ2F0Y2hSZXNwb25zZSwgaXNFcnJvclJlc3BvbnNlLCBpc1JlZGlyZWN0UmVzcG9uc2UgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuL2ludmFyaWFudC5qcyc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG5jbGFzcyBDYXRjaFZhbHVlIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBzdGF0dXNUZXh0LCBkYXRhKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGlzQWN0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKSB7XG4gIHJldHVybiBbXCJQT1NUXCIsIFwiUFVUXCIsIFwiUEFUQ0hcIiwgXCJERUxFVEVcIl0uaW5jbHVkZXMoc3VibWlzc2lvbi5tZXRob2QpO1xufVxuXG5mdW5jdGlvbiBpc0xvYWRlclN1Ym1pc3Npb24oc3VibWlzc2lvbikge1xuICByZXR1cm4gc3VibWlzc2lvbi5tZXRob2QgPT09IFwiR0VUXCI7XG59XG5cbmZ1bmN0aW9uIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gQm9vbGVhbihsb2NhdGlvbi5zdGF0ZSkgJiYgbG9jYXRpb24uc3RhdGUuaXNSZWRpcmVjdDtcbn1cblxuZnVuY3Rpb24gaXNMb2FkZXJSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pICYmIGxvY2F0aW9uLnN0YXRlLnR5cGUgPT09IFwibG9hZGVyXCI7XG59XG5cbmZ1bmN0aW9uIGlzQWN0aW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImFjdGlvblwiO1xufVxuXG5mdW5jdGlvbiBpc0ZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJmZXRjaEFjdGlvblwiO1xufVxuXG5mdW5jdGlvbiBpc0xvYWRlclN1Ym1pc3Npb25SZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pICYmIGxvY2F0aW9uLnN0YXRlLnR5cGUgPT09IFwibG9hZGVyU3VibWlzc2lvblwiO1xufVxuXG5jbGFzcyBUcmFuc2l0aW9uUmVkaXJlY3Qge1xuICBjb25zdHJ1Y3Rvcihsb2NhdGlvbikge1xuICAgIHRoaXMubG9jYXRpb24gPSB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBsb2NhdGlvbiA6IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoO1xuICB9XG5cbn1cbmNvbnN0IElETEVfVFJBTlNJVElPTiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG4gIHR5cGU6IFwiaWRsZVwiXG59O1xuY29uc3QgSURMRV9GRVRDSEVSID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIHR5cGU6IFwiaW5pdFwiLFxuICBkYXRhOiB1bmRlZmluZWQsXG4gIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxufTtcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKGluaXQpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXNcbiAgfSA9IGluaXQ7XG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXI7XG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcbiAgbGV0IG5hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcCgpO1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKHJvdXRlcywgaW5pdC5sb2NhdGlvbik7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IG1hdGNoIGEgdXNlci1wcm92aWRlZC1yb3V0ZSwgZmFsbCBiYWNrIHRvIHRoZSByb290XG4gICAgLy8gdG8gYWxsb3cgdGhlIENhdGNoQm91bmRhcnkgdG8gdGFrZSBvdmVyXG4gICAgbWF0Y2hlcyA9IFt7XG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICByb3V0ZTogcm91dGVzWzBdXG4gICAgfV07XG4gIH1cblxuICBsZXQgc3RhdGUgPSB7XG4gICAgbG9jYXRpb246IGluaXQubG9jYXRpb24sXG4gICAgbG9hZGVyRGF0YTogaW5pdC5sb2FkZXJEYXRhIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IGluaXQuYWN0aW9uRGF0YSxcbiAgICBjYXRjaDogaW5pdC5jYXRjaCxcbiAgICBlcnJvcjogaW5pdC5lcnJvcixcbiAgICBjYXRjaEJvdW5kYXJ5SWQ6IGluaXQuY2F0Y2hCb3VuZGFyeUlkIHx8IG51bGwsXG4gICAgZXJyb3JCb3VuZGFyeUlkOiBpbml0LmVycm9yQm91bmRhcnlJZCB8fCBudWxsLFxuICAgIG1hdGNoZXMsXG4gICAgbmV4dE1hdGNoZXM6IHVuZGVmaW5lZCxcbiAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgZmV0Y2hlcnM6IG5ldyBNYXAoKVxuICB9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZSh1cGRhdGVzKSB7XG4gICAgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgdXBkYXRlcyk7XG4gICAgaW5pdC5vbkNoYW5nZShzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGZXRjaGVyKGtleSkge1xuICAgIHJldHVybiBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleSkge1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNlbmQoZXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJuYXZpZ2F0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBzdWJtaXNzaW9uXG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hDbGllbnRSb3V0ZXMocm91dGVzLCBsb2NhdGlvbik7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPSBbe1xuICAgICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgICAgICAgcm91dGU6IHJvdXRlc1swXVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVOb3RGb3VuZE5hdmlnYXRpb24obG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN1Ym1pc3Npb24gJiYgaXNIYXNoQ2hhbmdlT25seShsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUhhc2hDaGFuZ2UobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gYmFjay9mb3J3YXJkIGJ1dHRvbiwgdHJlYXQgYWxsIGFzIG5vcm1hbCBuYXZpZ2F0aW9uXG4gICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSBBY3Rpb24uUG9wKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIDxGb3JtIG1ldGhvZD1cInBvc3QgfCBwdXQgfCBkZWxldGUgfCBwYXRjaFwiPlxuICAgICAgICAgIGVsc2UgaWYgKHN1Ym1pc3Npb24gJiYgaXNBY3Rpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVBY3Rpb25TdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyA8Rm9ybSBtZXRob2Q9XCJnZXRcIi8+XG4gICAgICAgICAgZWxzZSBpZiAoc3VibWlzc2lvbiAmJiBpc0xvYWRlclN1Ym1pc3Npb24oc3VibWlzc2lvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlclN1Ym1pc3Npb25OYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIGFjdGlvbj0+cmVkaXJlY3RcbiAgICAgICAgICBlbHNlIGlmIChpc0FjdGlvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVBY3Rpb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyA8Rm9ybSBtZXRob2Q9XCJnZXRcIj4gLS0+IGxvYWRlcj0+cmVkaXJlY3RcbiAgICAgICAgICBlbHNlIGlmIChpc0xvYWRlclN1Ym1pc3Npb25SZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyU3VibWlzc2lvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIGxvYWRlcj0+cmVkaXJlY3RcbiAgICAgICAgICBlbHNlIGlmIChpc0xvYWRlclJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJSZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyB1c2VTdWJtaXNzaW9uKCk9PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlRmV0Y2hBY3Rpb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyA8TGluaz4sIG5hdmlnYXRlKClcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWQobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZmV0Y2hlclwiOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgICAgICBocmVmXG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hDbGllbnRSb3V0ZXMocm91dGVzLCBocmVmKTtcbiAgICAgICAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJObyBtYXRjaGVzIGZvdW5kXCIpO1xuICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcblxuICAgICAgICAgIGlmIChzdWJtaXNzaW9uICYmIGlzQWN0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQWN0aW9uRmV0Y2hTdWJtaXNzaW9uKGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3VibWlzc2lvbiAmJiBpc0xvYWRlclN1Ym1pc3Npb24oc3VibWlzc2lvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlckZldGNoU3VibWlzc2lvbihocmVmLCBrZXksIHN1Ym1pc3Npb24sIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyRmV0Y2goaHJlZiwga2V5LCBtYXRjaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSBldmVudCB0eXBlOiAke2V2ZW50LnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuXG4gICAgZm9yIChsZXQgWywgY29udHJvbGxlcl0gb2YgZmV0Y2hDb250cm9sbGVycykge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbkZldGNoU3VibWlzc2lvbihrZXksIHN1Ym1pc3Npb24sIG1hdGNoKSB7XG4gICAgbGV0IGN1cnJlbnRGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblN1Ym1pc3Npb25cIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBkYXRhOiAoY3VycmVudEZldGNoZXIgPT09IG51bGwgfHwgY3VycmVudEZldGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGZXRjaGVyLmRhdGEpIHx8IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgY29udHJvbGxlcik7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxBY3Rpb24oc3VibWlzc2lvbiwgbWF0Y2gsIGNvbnRyb2xsZXIuc2lnbmFsKTtcblxuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwiZmV0Y2hBY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZXN1bHQudmFsdWUubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgICBkYXRhOiByZXN1bHQudmFsdWUsXG4gICAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1heWJlQmFpbE9uRXJyb3IobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBtYXliZUJhaWxPbkNhdGNoKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbG9hZEZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblJlbG9hZFwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvblxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCA9IGlzRXJyb3JSZXN1bHQocmVzdWx0KSA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCA9IGlzQ2F0Y2hSZXN1bHQocmVzdWx0KSA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbWF0Y2hlc1RvTG9hZCA9IHN0YXRlLm5leHRNYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXM7XG4gICAgbGV0IGhyZWZUb0xvYWQgPSBjcmVhdGVIcmVmKHN0YXRlLnRyYW5zaXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb24pO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbExvYWRlcnMoc3RhdGUsIGNyZWF0ZVVybChocmVmVG9Mb2FkKSwgbWF0Y2hlc1RvTG9hZCwgY29udHJvbGxlci5zaWduYWwsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQsIG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQsIHN1Ym1pc3Npb24sIG1hdGNoLnJvdXRlLmlkLCBsb2FkRmV0Y2hlcik7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuXG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZWRpcmVjdC5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IFtlcnJvciwgZXJyb3JCb3VuZGFyeUlkXSA9IGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgc3RhdGUubWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IFtjYXRjaFZhbCwgY2F0Y2hCb3VuZGFyeUlkXSA9IGF3YWl0IGZpbmRDYXRjaEFuZEJvdW5kYXJ5SWQocmVzdWx0cywgc3RhdGUubWF0Y2hlcywgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCk7XG4gICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgdHlwZTogXCJkb25lXCIsXG4gICAgICBkYXRhOiByZXN1bHQudmFsdWUsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICBsZXQgYWJvcnRlZEtleXMgPSBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuXG4gICAgaWYgKGFib3J0ZWRLZXlzKSB7XG4gICAgICBtYXJrRmV0Y2hlcnNEb25lKGFib3J0ZWRLZXlzKTtcbiAgICB9XG5cbiAgICBsZXQgeWVldGVkTmF2aWdhdGlvbiA9IHllZXRTdGFsZU5hdmlnYXRpb25Mb2FkKGxvYWRJZCk7IC8vIG5lZWQgdG8gZG8gd2hhdCB3ZSB3b3VsZCBoYXZlIGRvbmUgd2hlbiB0aGUgbmF2aWdhdGlvbiBsb2FkIGNvbXBsZXRlZFxuXG4gICAgaWYgKHllZXRlZE5hdmlnYXRpb24pIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHRyYW5zaXRpb25cbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGludmFyaWFudCh0cmFuc2l0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiwgXCJFeHBlY3RlZCBsb2FkaW5nIHRyYW5zaXRpb25cIik7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBsb2NhdGlvbjogdHJhbnNpdGlvbi5sb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogc3RhdGUubmV4dE1hdGNoZXMsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5SWQsXG4gICAgICAgIGNhdGNoOiBjYXRjaFZhbCxcbiAgICAgICAgY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgICBsb2FkZXJEYXRhOiBtYWtlTG9hZGVyRGF0YShzdGF0ZSwgcmVzdWx0cywgbWF0Y2hlc1RvTG9hZCksXG4gICAgICAgIGFjdGlvbkRhdGE6IHRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiA/IHN0YXRlLmFjdGlvbkRhdGEgOiB1bmRlZmluZWQsXG4gICAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICB9IC8vIG90aGVyd2lzZSBqdXN0IHVwZGF0ZSB0aGUgaW5mbyBmb3IgdGhlIGRhdGFcbiAgICBlbHNlIHtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGVycm9yQm91bmRhcnlJZCxcbiAgICAgICAgbG9hZGVyRGF0YTogbWFrZUxvYWRlckRhdGEoc3RhdGUsIHJlc3VsdHMsIG1hdGNoZXNUb0xvYWQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB5ZWV0U3RhbGVOYXZpZ2F0aW9uTG9hZChsYW5kZWRJZCkge1xuICAgIGxldCBpc0xvYWRpbmdOYXZpZ2F0aW9uID0gc3RhdGUudHJhbnNpdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCI7XG5cbiAgICBpZiAoaXNMb2FkaW5nTmF2aWdhdGlvbiAmJiBuYXZpZ2F0aW9uTG9hZElkIDwgbGFuZGVkSWQpIHtcbiAgICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoZXJzRG9uZShrZXlzKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgICBkYXRhOiBmZXRjaGVyLmRhdGEsXG4gICAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG5cbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG5cbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPyB5ZWV0ZWRLZXlzIDogZmFsc2U7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJGZXRjaFN1Ym1pc3Npb24oaHJlZiwga2V5LCBzdWJtaXNzaW9uLCBtYXRjaCkge1xuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZGF0YTogKGN1cnJlbnRGZXRjaGVyID09PSBudWxsIHx8IGN1cnJlbnRGZXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmV0Y2hlci5kYXRhKSB8fCB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGNvbnRyb2xsZXIpO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyKG1hdGNoLCBjcmVhdGVVcmwoaHJlZiksIGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZXN1bHQudmFsdWUubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgdHlwZTogXCJkb25lXCIsXG4gICAgICBkYXRhOiByZXN1bHQudmFsdWUsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJGZXRjaChocmVmLCBrZXksIG1hdGNoKSB7XG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImhhbmRsZUxvYWRlckZldGNoIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArIFwiWW91IGFyZSBsaWtlbHkgY2FsbGluZyB1c2VGZXRjaGVyLmxvYWQoKSBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgKyBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIik7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbExvYWRcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGRhdGE6IChjdXJyZW50RmV0Y2hlciA9PT0gbnVsbCB8fCBjdXJyZW50RmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZldGNoZXIuZGF0YSkgfHwgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBjb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlcihtYXRjaCwgY3JlYXRlVXJsKGhyZWYpLCBjb250cm9sbGVyLnNpZ25hbCk7XG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHJldHVybjtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpIHtcbiAgICBpZiAoaXNDYXRjaFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgY2F0Y2hCb3VuZGFyeUlkID0gZmluZE5lYXJlc3RDYXRjaEJvdW5kYXJ5KG1hdGNoLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGNhdGNoOiB7XG4gICAgICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLmRhdGEsXG4gICAgICAgICAgc3RhdHVzOiByZXN1bHQudmFsdWUuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3VsdC52YWx1ZS5zdGF0dXNUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkge1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvckJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBlcnJvcjogcmVzdWx0LnZhbHVlLFxuICAgICAgICBlcnJvckJvdW5kYXJ5SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTm90Rm91bmROYXZpZ2F0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbExvYWRcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7IC8vIEZvcmNlIGFzeW5jIHNvIFVJIGNvZGUgZG9lc24ndCBoYXZlIHRvIHNwZWNpYWwgbm90IGZvdW5kIHJvdXRlIGNoYW5nZXMgbm90XG4gICAgLy8gc2tpcHBpbmcgdGhlIHBlbmRpbmcgc3RhdGUgKGxpa2Ugc2Nyb2xsIHJlc3RvcmF0aW9uIGdldHMgcmVhbGx5XG4gICAgLy8gY29tcGxpY2F0ZWQgd2l0aG91dCB0aGUgcGVuZGluZyBzdGF0ZSwgbWF5YmUgd2UgY2FuIGZpZ3VyZSBzb21ldGhpbmcgZWxzZVxuICAgIC8vIG91dCBsYXRlciwgYnV0IHRoaXMgd29ya3MgZ3JlYXQuKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbGV0IGNhdGNoQm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShtYXRjaGVzWzBdLCBtYXRjaGVzKTtcbiAgICB1cGRhdGUoe1xuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgY2F0Y2g6IHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCJcbiAgICAgIH0sXG4gICAgICBjYXRjaEJvdW5kYXJ5SWQsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvblN1Ym1pc3Npb25OYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblN1Ym1pc3Npb25cIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgICBpZiAoIWlzSW5kZXhSZXF1ZXN0QWN0aW9uKHN1Ym1pc3Npb24uYWN0aW9uKSAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaWQuZW5kc1dpdGgoXCIvaW5kZXhcIikpIHtcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICBsZXQgbGVhZk1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxBY3Rpb24oc3VibWlzc2lvbiwgbGVhZk1hdGNoLCBjb250cm9sbGVyLnNpZ25hbCk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImFjdGlvblwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQ2F0Y2hSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IFtjYXRjaFZhbCwgY2F0Y2hCb3VuZGFyeUlkXSA9IGF3YWl0IGZpbmRDYXRjaEFuZEJvdW5kYXJ5SWQoW3Jlc3VsdF0sIG1hdGNoZXMsIHJlc3VsdCk7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICAgIGNhdGNoOiBjYXRjaFZhbCxcbiAgICAgICAgY2F0Y2hCb3VuZGFyeUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbG9hZFRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblJlbG9hZFwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbjogbG9hZFRyYW5zaXRpb24sXG4gICAgICBhY3Rpb25EYXRhOiB7XG4gICAgICAgIFtsZWFmTWF0Y2gucm91dGUuaWRdOiByZXN1bHQudmFsdWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxlYWZNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlclN1Ym1pc3Npb25OYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25cIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbExvYWRcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7IC8vIEZvcmNlIGFzeW5jIHNvIFVJIGNvZGUgZG9lc24ndCBoYXZlIHRvIHNwZWNpYWwgY2FzZSBoYXNoIGNoYW5nZXMgbm90XG4gICAgLy8gc2tpcHBpbmcgdGhlIHBlbmRpbmcgc3RhdGUgKGxpa2Ugc2Nyb2xsIHJlc3RvcmF0aW9uIGdldHMgcmVhbGx5XG4gICAgLy8gY29tcGxpY2F0ZWQgd2l0aG91dCB0aGUgcGVuZGluZyBzdGF0ZSwgbWF5YmUgd2UgY2FuIGZpZ3VyZSBzb21ldGhpbmcgZWxzZVxuICAgIC8vIG91dCBsYXRlciwgYnV0IHRoaXMgd29ya3MgZ3JlYXQuKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdXBkYXRlKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTlxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJSZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxSZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyU3VibWlzc2lvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgaW52YXJpYW50KHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJsb2FkZXJTdWJtaXNzaW9uXCIsIGBVbmV4cGVjdGVkIHRyYW5zaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoc3RhdGUudHJhbnNpdGlvbil9YCk7XG4gICAgbGV0IHtcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9ID0gc3RhdGUudHJhbnNpdGlvbjtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibG9hZGVyU3VibWlzc2lvblJlZGlyZWN0XCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwiZmV0Y2hBY3Rpb25SZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBpbnZhcmlhbnQoc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblN1Ym1pc3Npb25cIiB8fCAvLyBsb2FkZXIgcmVkaXJlY3RlZCBkdXJpbmcgYWN0aW9uIHJlbG9hZFxuICAgIHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiwgYFVuZXhwZWN0ZWQgdHJhbnNpdGlvbjogJHtKU09OLnN0cmluZ2lmeShzdGF0ZS50cmFuc2l0aW9uKX1gKTtcbiAgICBsZXQge1xuICAgICAgc3VibWlzc2lvblxuICAgIH0gPSBzdGF0ZS50cmFuc2l0aW9uO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkobG9jYXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlSHJlZihzdGF0ZS5sb2NhdGlvbikgPT09IGNyZWF0ZUhyZWYobG9jYXRpb24pICYmIHN0YXRlLmxvY2F0aW9uLmhhc2ggIT09IGxvY2F0aW9uLmhhc2g7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24sIHN1Ym1pc3Npb25Sb3V0ZUlkLCBhY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCA9IGFjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkgPyBhY3Rpb25SZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQgPSBhY3Rpb25SZXN1bHQgJiYgaXNDYXRjaFJlc3VsdChhY3Rpb25SZXN1bHQpID8gYWN0aW9uUmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgbmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbExvYWRlcnMoc3RhdGUsIGNyZWF0ZVVybChjcmVhdGVIcmVmKGxvY2F0aW9uKSksIG1hdGNoZXMsIGNvbnRyb2xsZXIuc2lnbmFsLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0LCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcblxuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgLy8gbG9hZGVyIHJlZGlyZWN0ZWQgZHVyaW5nIGFuIGFjdGlvbiByZWxvYWQsIHRyZWF0IGl0IGxpa2UgYW5cbiAgICAgIC8vIGFjdGlvblJlZGlyZWN0IGluc3RlYWQgc28gdGhhdCBhbGwgdGhlIGxvYWRlcnMgZ2V0IGNhbGxlZCBhZ2FpbiBhbmQgdGhlXG4gICAgICAvLyBzdWJtaXNzaW9uIHN0aWNrcyBhcm91bmQgZm9yIG9wdGltaXN0aWMvcGVuZGluZyBVSS5cbiAgICAgIGlmIChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIpIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcImFjdGlvblwiXG4gICAgICAgIH07XG4gICAgICAgIGluaXQub25SZWRpcmVjdChyZWRpcmVjdC5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJsb2FkZXJTdWJtaXNzaW9uXCIpIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25cIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcImxvYWRlclwiXG4gICAgICAgIH07XG4gICAgICAgIGluaXQub25SZWRpcmVjdChyZWRpcmVjdC5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgW2Vycm9yLCBlcnJvckJvdW5kYXJ5SWRdID0gZmluZEVycm9yQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0KTtcbiAgICBsZXQgW2NhdGNoVmFsLCBjYXRjaEJvdW5kYXJ5SWRdID0gYXdhaXQgZmluZENhdGNoQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0KTtcbiAgICBsZXQgYWJvcnRlZElkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKG5hdmlnYXRpb25Mb2FkSWQpO1xuXG4gICAgaWYgKGFib3J0ZWRJZHMpIHtcbiAgICAgIG1hcmtGZXRjaGVyc0RvbmUoYWJvcnRlZElkcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgY2F0Y2g6IGNhdGNoVmFsLFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgbG9hZGVyRGF0YTogbWFrZUxvYWRlckRhdGEoc3RhdGUsIHJlc3VsdHMsIG1hdGNoZXMpLFxuICAgICAgYWN0aW9uRGF0YTogc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiID8gc3RhdGUuYWN0aW9uRGF0YSA6IHVuZGVmaW5lZCxcbiAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgIGZldGNoZXJzOiBhYm9ydGVkSWRzID8gbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgOiBzdGF0ZS5mZXRjaGVyc1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCkge1xuICAgIHZhciBfcGVuZGluZ05hdmlnYXRpb25Db247XG5cbiAgICAoX3BlbmRpbmdOYXZpZ2F0aW9uQ29uID0gcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSA9PT0gbnVsbCB8fCBfcGVuZGluZ05hdmlnYXRpb25Db24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZW5kaW5nTmF2aWdhdGlvbkNvbi5hYm9ydCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleSkge1xuICAgIGxldCBjb250cm9sbGVyID0gZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KTtcbiAgICBpbnZhcmlhbnQoY29udHJvbGxlciwgYEV4cGVjdGVkIGZldGNoIGNvbnRyb2xsZXI6ICR7a2V5fWApO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZW5kLFxuICAgIGdldFN0YXRlLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcixcbiAgICBkaXNwb3NlLFxuXG4gICAgZ2V0IF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMoKSB7XG4gICAgICByZXR1cm4gZmV0Y2hDb250cm9sbGVycztcbiAgICB9XG5cbiAgfTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNJbmRleFJlcXVlc3RBY3Rpb24oYWN0aW9uKSB7XG4gIGxldCBpbmRleFJlcXVlc3QgPSBmYWxzZTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYWN0aW9uLnNwbGl0KFwiP1wiLCAyKVsxXSB8fCBcIlwiKTtcblxuICBmb3IgKGxldCBwYXJhbSBvZiBzZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIikpIHtcbiAgICBpZiAoIXBhcmFtKSB7XG4gICAgICBpbmRleFJlcXVlc3QgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleFJlcXVlc3Q7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzKHN0YXRlLCB1cmwsIG1hdGNoZXMsIHNpZ25hbCwgYWN0aW9uRXJyb3JSZXN1bHQsIGFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgZmV0Y2hlcikge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IGZpbHRlck1hdGNoZXNUb0xvYWQoc3RhdGUsIHVybCwgbWF0Y2hlcywgYWN0aW9uRXJyb3JSZXN1bHQsIGFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgZmV0Y2hlcik7XG4gIHJldHVybiBQcm9taXNlLmFsbChtYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBjYWxsTG9hZGVyKG1hdGNoLCB1cmwsIHNpZ25hbCkpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcihtYXRjaCwgdXJsLCBzaWduYWwpIHtcbiAgaW52YXJpYW50KG1hdGNoLnJvdXRlLmxvYWRlciwgYEV4cGVjdGVkIGxvYWRlciBmb3IgJHttYXRjaC5yb3V0ZS5pZH1gKTtcblxuICB0cnkge1xuICAgIGxldCB7XG4gICAgICBwYXJhbXNcbiAgICB9ID0gbWF0Y2g7XG4gICAgbGV0IHZhbHVlID0gYXdhaXQgbWF0Y2gucm91dGUubG9hZGVyKHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHVybCxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZTogZXJyb3JcbiAgICB9O1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxBY3Rpb24oc3VibWlzc2lvbiwgbWF0Y2gsIHNpZ25hbCkge1xuICBpZiAoIW1hdGNoLnJvdXRlLmFjdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgUm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiIGRvZXMgbm90IGhhdmUgYW4gYWN0aW9uLCBidXQgeW91IGFyZSB0cnlpbmcgYCArIGB0byBzdWJtaXQgdG8gaXQuIFRvIGZpeCB0aGlzLCBwbGVhc2UgYWRkIGFuIFxcYGFjdGlvblxcYCBmdW5jdGlvbiB0byB0aGUgcm91dGVgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbGV0IHZhbHVlID0gYXdhaXQgbWF0Y2gucm91dGUuYWN0aW9uKHtcbiAgICAgIHVybDogY3JlYXRlVXJsKHN1Ym1pc3Npb24uYWN0aW9uKSxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZTogZXJyb3JcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlck1hdGNoZXNUb0xvYWQoc3RhdGUsIHVybCwgbWF0Y2hlcywgYWN0aW9uRXJyb3JSZXN1bHQsIGFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgZmV0Y2hlcikge1xuICAvLyBGaWx0ZXIgb3V0IGFsbCByb3V0ZXMgYmVsb3cgdGhlIHByb2JsZW1hdGljIHJvdXRlIGFzIHRoZXkgYXJlbid0IGdvaW5nXG4gIC8vIHRvIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbS5cbiAgaWYgKHN1Ym1pc3Npb25Sb3V0ZUlkICYmIChhY3Rpb25DYXRjaFJlc3VsdCB8fCBhY3Rpb25FcnJvclJlc3VsdCkpIHtcbiAgICBsZXQgZm91bmRQcm9ibGVtYXRpY1JvdXRlID0gZmFsc2U7XG4gICAgbWF0Y2hlcyA9IG1hdGNoZXMuZmlsdGVyKG1hdGNoID0+IHtcbiAgICAgIGlmIChmb3VuZFByb2JsZW1hdGljUm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IHN1Ym1pc3Npb25Sb3V0ZUlkKSB7XG4gICAgICAgIGZvdW5kUHJvYmxlbWF0aWNSb3V0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBsZXQgaXNOZXcgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgLy8gW2FdIC0+IFthLCBiXVxuICAgIGlmICghc3RhdGUubWF0Y2hlc1tpbmRleF0pIHJldHVybiB0cnVlOyAvLyBbYSwgYl0gLT4gW2EsIGNdXG5cbiAgICByZXR1cm4gbWF0Y2gucm91dGUuaWQgIT09IHN0YXRlLm1hdGNoZXNbaW5kZXhdLnJvdXRlLmlkO1xuICB9O1xuXG4gIGxldCBtYXRjaFBhdGhDaGFuZ2VkID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHZhciBfc3RhdGUkbWF0Y2hlcyRpbmRleCQ7XG5cbiAgICByZXR1cm4gKC8vIHBhcmFtIGNoYW5nZSwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgICBzdGF0ZS5tYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgKChfc3RhdGUkbWF0Y2hlcyRpbmRleCQgPSBzdGF0ZS5tYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoKSA9PT0gbnVsbCB8fCBfc3RhdGUkbWF0Y2hlcyRpbmRleCQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRtYXRjaGVzJGluZGV4JC5lbmRzV2l0aChcIipcIikpICYmIHN0YXRlLm1hdGNoZXNbaW5kZXhdLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl1cbiAgICApO1xuICB9O1xuXG4gIGxldCBmaWx0ZXJCeVJvdXRlUHJvcHMgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQpIHtcbiAgICAgIGxldCBwcmV2VXJsID0gY3JlYXRlVXJsKGNyZWF0ZUhyZWYoc3RhdGUubG9jYXRpb24pKTtcbiAgICAgIHJldHVybiBtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQoe1xuICAgICAgICBwcmV2VXJsLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBsZXQgaXNJblJvb3RDYXRjaEJvdW5kYXJ5ID0gc3RhdGUubWF0Y2hlcy5sZW5ndGggPT09IDE7XG5cbiAgaWYgKGlzSW5Sb290Q2F0Y2hCb3VuZGFyeSkge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiAhIW1hdGNoLnJvdXRlLmxvYWRlcik7XG4gIH1cblxuICBpZiAoKGZldGNoZXIgPT09IG51bGwgfHwgZmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hlci50eXBlKSA9PT0gXCJhY3Rpb25SZWxvYWRcIikge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihmaWx0ZXJCeVJvdXRlUHJvcHMpO1xuICB9IGVsc2UgaWYgKCAvLyBtdXRhdGlvbiwgcmVsb2FkIGZvciBmcmVzaCBkYXRhXG4gIHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiB8fCBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVkaXJlY3RcIiB8fCAvLyBjbGlja2VkIHRoZSBzYW1lIGxpbmssIHJlc3VibWl0dGVkIGEgR0VUIGZvcm1cbiAgY3JlYXRlSHJlZih1cmwpID09PSBjcmVhdGVIcmVmKHN0YXRlLmxvY2F0aW9uKSB8fCAvLyBzZWFyY2ggYWZmZWN0cyBhbGwgbG9hZGVyc1xuICB1cmwuc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCkgIT09IHN0YXRlLmxvY2F0aW9uLnNlYXJjaCkge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihmaWx0ZXJCeVJvdXRlUHJvcHMpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgsIGFycikgPT4ge1xuICAgIC8vIGRvbid0IGxvYWQgZXJyb3JlZCBhY3Rpb24gcm91dGVcbiAgICBpZiAoKGFjdGlvbkVycm9yUmVzdWx0IHx8IGFjdGlvbkNhdGNoUmVzdWx0KSAmJiBhcnIubGVuZ3RoIC0gMSA9PT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2gucm91dGUubG9hZGVyICYmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgVHJhbnNpdGlvblJlZGlyZWN0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gIHJldHVybiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbn1cblxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHMpIHtcbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIG1hdGNoZXMsIGFjdGlvbkNhdGNoUmVzdWx0KSB7XG4gIGxldCBsb2FkZXJDYXRjaFJlc3VsdDtcblxuICBmb3IgKGxldCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGlmIChpc0NhdGNoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxvYWRlckNhdGNoUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgbGV0IGV4dHJhY3RDYXRjaERhdGEgPSBhc3luYyByZXMgPT4gKHtcbiAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c1RleHQsXG4gICAgZGF0YTogcmVzLmRhdGFcbiAgfSk7IC8vIFdlaXJkIGNhc2Ugd2hlcmUgYWN0aW9uIHRocmV3LCBhbmQgdGhlbiBhIHBhcmVudCBsb2FkZXIgQUxTTyB0aHJldywgd2VcbiAgLy8gdXNlIHRoZSBhY3Rpb24gY2F0Y2ggYnV0IHRoZSBsb2FkZXIncyBuZWFyZXN0IGJvdW5kYXJ5IChjYXVzZSB3ZSBjYW4ndFxuICAvLyByZW5kZXIgZG93biB0byB0aGUgYm91bmRhcnkgdGhlIGFjdGlvbiB3b3VsZCBwcmVmZXIpXG5cblxuICBpZiAoYWN0aW9uQ2F0Y2hSZXN1bHQgJiYgbG9hZGVyQ2F0Y2hSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShsb2FkZXJDYXRjaFJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthd2FpdCBleHRyYWN0Q2F0Y2hEYXRhKGFjdGlvbkNhdGNoUmVzdWx0LnZhbHVlKSwgYm91bmRhcnlJZF07XG4gIH1cblxuICBpZiAobG9hZGVyQ2F0Y2hSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShsb2FkZXJDYXRjaFJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthd2FpdCBleHRyYWN0Q2F0Y2hEYXRhKGxvYWRlckNhdGNoUmVzdWx0LnZhbHVlKSwgYm91bmRhcnlJZF07XG4gIH1cblxuICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cblxuZnVuY3Rpb24gZmluZEVycm9yQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBhY3Rpb25FcnJvclJlc3VsdCkge1xuICBsZXQgbG9hZGVyRXJyb3JSZXN1bHQ7XG5cbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsb2FkZXJFcnJvclJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBXZWlyZCBjYXNlIHdoZXJlIGFjdGlvbiBlcnJvcmVkLCBhbmQgdGhlbiBhIHBhcmVudCBsb2FkZXIgQUxTTyBlcnJvcmVkLCB3ZVxuICAvLyB1c2UgdGhlIGFjdGlvbiBlcnJvciBidXQgdGhlIGxvYWRlcidzIG5lYXJlc3QgYm91bmRhcnkgKGNhdXNlIHdlIGNhbid0XG4gIC8vIHJlbmRlciBkb3duIHRvIHRoZSBib3VuZGFyeSB0aGUgYWN0aW9uIHdvdWxkIHByZWZlcilcblxuXG4gIGlmIChhY3Rpb25FcnJvclJlc3VsdCAmJiBsb2FkZXJFcnJvclJlc3VsdCkge1xuICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShsb2FkZXJFcnJvclJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthY3Rpb25FcnJvclJlc3VsdC52YWx1ZSwgYm91bmRhcnlJZF07XG4gIH1cblxuICBpZiAoYWN0aW9uRXJyb3JSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoYWN0aW9uRXJyb3JSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYWN0aW9uRXJyb3JSZXN1bHQudmFsdWUsIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGxvYWRlckVycm9yUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGxvYWRlckVycm9yUmVzdWx0Lm1hdGNoLCBtYXRjaGVzKTtcbiAgICByZXR1cm4gW2xvYWRlckVycm9yUmVzdWx0LnZhbHVlLCBib3VuZGFyeUlkXTtcbiAgfVxuXG4gIHJldHVybiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xufVxuXG5mdW5jdGlvbiBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobWF0Y2hXaXRoRXJyb3IsIG1hdGNoZXMpIHtcbiAgbGV0IG5lYXJlc3RCb3VuZGFyeUlkID0gbnVsbDtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLkNhdGNoQm91bmRhcnkpIHtcbiAgICAgIG5lYXJlc3RCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfSAvLyBvbmx5IHNlYXJjaCBwYXJlbnRzIChzdG9wIGF0IHRocm93aW5nIG1hdGNoKVxuXG5cbiAgICBpZiAobWF0Y2ggPT09IG1hdGNoV2l0aEVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEJvdW5kYXJ5SWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hXaXRoRXJyb3IsIG1hdGNoZXMpIHtcbiAgbGV0IG5lYXJlc3RCb3VuZGFyeUlkID0gbnVsbDtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpIHtcbiAgICAgIG5lYXJlc3RCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfSAvLyBvbmx5IHNlYXJjaCBwYXJlbnRzIChzdG9wIGF0IHRocm93aW5nIG1hdGNoKVxuXG5cbiAgICBpZiAobWF0Y2ggPT09IG1hdGNoV2l0aEVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEJvdW5kYXJ5SWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzKSB7XG4gIGxldCBuZXdEYXRhID0ge307XG5cbiAgZm9yIChsZXQge1xuICAgIG1hdGNoLFxuICAgIHZhbHVlXG4gIH0gb2YgcmVzdWx0cykge1xuICAgIG5ld0RhdGFbbWF0Y2gucm91dGUuaWRdID0gdmFsdWU7XG4gIH1cblxuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IHtcbiAgICByb3V0ZVxuICB9IG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgdmFsdWUgPSBuZXdEYXRhW3JvdXRlLmlkXSAhPT0gdW5kZWZpbmVkID8gbmV3RGF0YVtyb3V0ZS5pZF0gOiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlLmlkXTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2FkZXJEYXRhW3JvdXRlLmlkXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2FkZXJEYXRhO1xufVxuXG5mdW5jdGlvbiBpc0NhdGNoUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgQ2F0Y2hWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvclJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcmwoaHJlZikge1xuICByZXR1cm4gbmV3IFVSTChocmVmLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbn1cblxuZXhwb3J0IHsgQ2F0Y2hWYWx1ZSwgSURMRV9GRVRDSEVSLCBJRExFX1RSQU5TSVRJT04sIFRyYW5zaXRpb25SZWRpcmVjdCwgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IG1hdGNoUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG5mdW5jdGlvbiBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbik7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBtYXRjaENsaWVudFJvdXRlcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTG9jYXRpb24gfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCB7IHVzZUJlZm9yZVVubG9hZCwgdXNlVHJhbnNpdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5cbmxldCBTVE9SQUdFX0tFWSA9IFwicG9zaXRpb25zXCI7XG5sZXQgcG9zaXRpb25zID0ge307XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcblxuICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgIHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBlbXVsYXRlIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHJlc3RvcmF0aW9uIG9uIGxvY2F0aW9uXG4gKiBjaGFuZ2VzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3Njcm9sbHJlc3RvcmF0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgdXNlU2Nyb2xsUmVzdG9yYXRpb24oKTsgLy8gd2FpdCBmb3IgdGhlIGJyb3dzZXIgdG8gcmVzdG9yZSBpdCBvbiBpdHMgb3duXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gIH0sIFtdKTsgLy8gbGV0IHRoZSBicm93c2VyIHJlc3RvcmUgb24gaXQncyBvd24gZm9yIHJlZnJlc2hcblxuICB1c2VCZWZvcmVVbmxvYWQoUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gIH0sIFtdKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogYFxuICAgICAgICAgIGxldCBTVE9SQUdFX0tFWSA9ICR7SlNPTi5zdHJpbmdpZnkoU1RPUkFHRV9LRVkpfTtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8ICF3aW5kb3cuaGlzdG9yeS5zdGF0ZS5rZXkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogTWF0aC5yYW5kb20oKS50b1N0cmluZygzMikuc2xpY2UoMikgfSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKSB8fCAne30nKVxuICAgICAgICAgICAgbGV0IHN0b3JlZFkgPSBwb3NpdGlvbnNbd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkWSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHN0b3JlZFkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oU1RPUkFHRV9LRVkpXG4gICAgICAgICAgfVxuICAgICAgICBgXG4gICAgfVxuICB9KTtcbn1cbmxldCBoeWRyYXRlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uKCk7XG4gIGxldCB3YXNTdWJtaXNzaW9uUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvbi5zdWJtaXNzaW9uKSB7XG4gICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3RyYW5zaXRpb25dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvbi5sb2NhdGlvbikge1xuICAgICAgcG9zaXRpb25zW2xvY2F0aW9uLmtleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uLCBsb2NhdGlvbl0pO1xuICB1c2VCZWZvcmVVbmxvYWQoUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHBvc2l0aW9ucykpO1xuICB9LCBbXSkpO1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgb24gaHlkcmF0aW9uLCB0aGUgY29tcG9uZW50IGFscmVhZHkgZGlkIHRoaXMgd2l0aCBhblxuICAgICAgLy8gaW5saW5lIHNjcmlwdC5cbiAgICAgIGlmICghaHlkcmF0ZWQpIHtcbiAgICAgICAgaHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB5ID0gcG9zaXRpb25zW2xvY2F0aW9uLmtleV07IC8vIGJlZW4gaGVyZSBiZWZvcmUsIHNjcm9sbCB0byBpdFxuXG4gICAgICBpZiAoeSkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgeSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gdHJ5IHRvIHNjcm9sbCB0byB0aGUgaGFzaFxuXG5cbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIGRvbid0IGRvIGFueXRoaW5nIG9uIHN1Ym1pc3Npb25zXG5cblxuICAgICAgaWYgKHdhc1N1Ym1pc3Npb25SZWYuY3VycmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBvdGhlcndpc2UgZ28gdG8gdGhlIHRvcCBvbiBuZXcgbG9jYXRpb25zXG5cblxuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbl0pO1xuICB9XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvbi5zdWJtaXNzaW9uKSB7XG4gICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3RyYW5zaXRpb25dKTtcbn1cblxuZXhwb3J0IHsgU2Nyb2xsUmVzdG9yYXRpb24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IEFjdGlvbiwgY3JlYXRlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVtaXhFbnRyeSB9IGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG5cbi8qKlxuICogVGhlIGVudHJ5IHBvaW50IGZvciBhIFJlbWl4IGFwcCB3aGVuIGl0IGlzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgKGluXG4gKiBgYXBwL2VudHJ5LnNlcnZlci5qc2ApLiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBIVE1MIGluIHRoZVxuICogcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiBSZW1peFNlcnZlcih7XG4gIGNvbnRleHQsXG4gIHVybFxufSkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgfVxuXG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICBoYXNoOiBcIlwiLFxuICAgIHN0YXRlOiBudWxsLFxuICAgIGtleTogXCJkZWZhdWx0XCJcbiAgfTtcbiAgbGV0IHN0YXRpY05hdmlnYXRvciA9IHtcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICB9LFxuXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IucHVzaCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IucmVwbGFjZSgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgYCArIGBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmdvKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBgICsgYFxcYG5hdmlnYXRlKCR7ZGVsdGF9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIGJhY2soKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5iYWNrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfSxcblxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5mb3J3YXJkKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfSxcblxuICAgIGJsb2NrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuYmxvY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC5gKTtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbWl4RW50cnksIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGFjdGlvbjogQWN0aW9uLlBvcCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgbmF2aWdhdG9yOiBzdGF0aWNOYXZpZ2F0b3IsXG4gICAgc3RhdGljOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBSZW1peFNlcnZlciB9O1xuIiwgImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiXG5pbXBvcnQgTlByb2dyZXNzIGZyb20gXCJucHJvZ3Jlc3NcIlxuaW1wb3J0IG5Qcm9ncmVzc1N0eWxlcyBmcm9tIFwibnByb2dyZXNzL25wcm9ncmVzcy5jc3NcIlxuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi9zdHlsZXMvYXBwLmNzc1wiXG5pbXBvcnQgeyBNZXRhRnVuY3Rpb24sIE5hdkxpbmssIHVzZU1hdGNoZXMgfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IHtcblx0TGluayxcblx0TGlua3MsXG5cdExpdmVSZWxvYWQsXG5cdE1ldGEsXG5cdE91dGxldCxcblx0U2NyaXB0cyxcblx0U2Nyb2xsUmVzdG9yYXRpb24sXG5cdHVzZUNhdGNoLFxuXHR1c2VUcmFuc2l0aW9uLFxufSBmcm9tIFwicmVtaXhcIlxuXG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG5cbmV4cG9ydCBjb25zdCBsaW5rcyA9ICgpID0+IHtcblx0cmV0dXJuIFtcblx0XHR7IHJlbDogXCJzdHlsZXNoZWV0XCIsIGhyZWY6IHN0eWxlcyB9LFxuXHRcdHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogblByb2dyZXNzU3R5bGVzIH0sXG5cdF1cbn1cblxuZXhwb3J0IGNvbnN0IG1ldGE6IE1ldGFGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIHsgdGl0bGU6IFwiVW5pa2V5IC0gQlx1MDBFMG4gcGhcdTAwRURtIHRpXHUxRUJGbmcgVmlcdTFFQzd0XCIgfVxufVxuXG5pbnRlcmZhY2UgRG9jdW1lbnRQcm9wcyB7XG5cdGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcblx0dGl0bGU/OiBzdHJpbmdcbn1cblxuY29uc3QgbWVudUl0ZW1zID0gW1xuXHR7IHRvOiBcIi9hYm91dFwiLCB0ZXh0OiBcIkdpXHUxRURCaSB0aGlcdTFFQzd1XCIgfSxcblx0eyB0bzogXCIvYmxvZ1wiLCB0ZXh0OiBcIkJsb2dcIiB9LFxuXHR7IHRvOiBcIi9saW51eFwiLCB0ZXh0OiBcIkxpbnV4XCIgfSxcblx0eyB0bzogXCIvYXBwbGVcIiwgdGV4dDogXCJBcHBsZVwiIH0sXG5cdHsgdG86IFwiL3N1cHBvcnRcIiwgdGV4dDogXCJUclx1MUVFMyBnaVx1MDBGQXBcIiB9LFxuXHR7IHRvOiBcIi9zb3VyY2VcIiwgdGV4dDogXCJNXHUwMEUzIG5ndVx1MUVEM25cIiB9XG5dXG5cbmNvbnN0IGFjdGl2ZU5hdkxpbmtTdHlsZSA9IFwiIHRleHQtcmVkLTUwMCBcIlxuXG5mdW5jdGlvbiBEb2N1bWVudCh7IGNoaWxkcmVuLCB0aXRsZSB9OiBEb2N1bWVudFByb3BzKSB7XG5cdGNvbnN0IHRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uKClcblx0Y29uc3QgbWF0Y2hlcyA9IHVzZU1hdGNoZXMoKVxuXG5cdFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Ly8gd2hlbiB0aGUgc3RhdGUgaXMgaWRsZSB0aGVuIHdlIGNhbiB0byBjb21wbGV0ZSB0aGUgcHJvZ3Jlc3MgYmFyXG5cdFx0aWYgKHRyYW5zaXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSBOUHJvZ3Jlc3MuZG9uZSgpXG5cdFx0Ly8gYW5kIHdoZW4gaXQncyBzb21ldGhpbmcgZWxzZSBpdCBtZWFucyBpdCdzIGVpdGhlciBzdWJtaXR0aW5nIGEgZm9ybSBvclxuXHRcdC8vIHdhaXRpbmcgZm9yIHRoZSBsb2FkZXJzIG9mIHRoZSBuZXh0IGxvY2F0aW9uIHNvIHdlIHN0YXJ0IGl0XG5cdFx0ZWxzZSBOUHJvZ3Jlc3Muc3RhcnQoKVxuXHR9LCBbdHJhbnNpdGlvbi5zdGF0ZV0pXG5cblx0cmV0dXJuIChcblx0XHQ8aHRtbCBsYW5nPVwiZW5cIj5cblx0XHRcdDxoZWFkPlxuXHRcdFx0XHQ8bWV0YSBjaGFyU2V0PVwidXRmLThcIiAvPlxuXHRcdFx0XHQ8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MVwiIC8+XG5cdFx0XHRcdDxNZXRhIC8+XG5cdFx0XHRcdHt0aXRsZSA/IDx0aXRsZT57dGl0bGV9PC90aXRsZT4gOiBudWxsfVxuXHRcdFx0XHQ8TGlua3MgLz5cblx0XHRcdDwvaGVhZD5cblx0XHRcdDxib2R5PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWluLXctZnVsbCBtaW4taC1zY3JlZW5cIj5cblx0XHRcdFx0XHQ8bmF2IGNsYXNzTmFtZT1cInB5LTEwIHB4LTEwIGJnLXppbmMtMTAwXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBmbGV4IGp1c3RpZnktYmV0d2VlbiBtYXgtdy1zY3JlZW4tbGcgbXgtYXV0b1wiPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInByLTEwXCI+XG5cdFx0XHRcdFx0XHRcdFx0PGEgaHJlZj1cIi9cIiBjbGFzc05hbWU9XCJob3Zlcjpuby11bmRlcmxpbmVcIj48c3Ryb25nPlVuaUtleTwvc3Ryb25nPjwvYT5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBvdmVyZmxvdy1oaWRkZW5cIj5cblx0XHRcdFx0XHRcdFx0XHR7bWVudUl0ZW1zLm1hcChtZW51SXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8TmF2TGlua1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17bWVudUl0ZW0udG99XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG89e21lbnVJdGVtLnRvfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17KHsgaXNBY3RpdmUgfSkgPT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYm9yZGVyLWItNCBib3JkZXItdHJhbnNwYXJlbnQgaG92ZXI6Ym9yZGVyLWItNCBob3Zlcjpib3JkZXItcmVkLTUwMCBob3Zlcjpuby11bmRlcmxpbmUgcHktMSBteC00IGZvbnQtc2VtaWJvbGQgYm94LWNvbnRlbnQgd2hpdGVzcGFjZS1ub3dyYXBcIiArIChpc0FjdGl2ZSA/IGFjdGl2ZU5hdkxpbmtTdHlsZSA6IFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e21lbnVJdGVtLnRleHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvTmF2TGluaz5cblx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L25hdj5cblxuXHRcdFx0XHRcdDxtYWluIGNsYXNzTmFtZT1cIm1iLTIwXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBweC0xMCBtYXgtdy1zY3JlZW4tbWQgbXgtYXV0byBteS0xMFwiPlxuXHRcdFx0XHRcdFx0XHR7Y2hpbGRyZW59XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L21haW4+XG5cblx0XHRcdFx0XHQ8Zm9vdGVyIGNsYXNzTmFtZT1cInAtNiBtdC1hdXRvIGJnLXNsYXRlLTUwMFwiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgcHgtMTAgbWF4LXctc2NyZWVuLWxnIG14LWF1dG8gdGV4dC13aGl0ZVwiPlx1MDBBOSAyMDIxIFBoYW0gS2ltIExvbmcuPC9kaXY+XG5cdFx0XHRcdFx0PC9mb290ZXI+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxTY3JvbGxSZXN0b3JhdGlvbiAvPlxuXHRcdFx0XHQ8U2NyaXB0cyAvPlxuXHRcdFx0XHQ8TGl2ZVJlbG9hZCAvPlxuXHRcdFx0PC9ib2R5ID5cblx0XHQ8L2h0bWwgPlxuXHQpXG59XG5cbkRvY3VtZW50LnByb3BUeXBlcyA9IHtcblx0Y2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXHR0aXRsZTogUHJvcFR5cGVzLnN0cmluZ1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoKSB7XG5cdHJldHVybiAoXG5cdFx0PERvY3VtZW50PlxuXHRcdFx0PE91dGxldCAvPlxuXHRcdDwvRG9jdW1lbnQ+XG5cdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhdGNoQm91bmRhcnkoKSB7XG5cdGNvbnN0IGNhdWdodCA9IHVzZUNhdGNoKClcblxuXHRyZXR1cm4gKFxuXHRcdDxEb2N1bWVudCB0aXRsZT17YCR7Y2F1Z2h0LnN0YXR1c30gJHtjYXVnaHQuc3RhdHVzVGV4dH1gfT5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZXJyb3ItY29udGFpbmVyXCI+XG5cdFx0XHRcdDxoMT5cblx0XHRcdFx0XHR7Y2F1Z2h0LnN0YXR1c30ge2NhdWdodC5zdGF0dXNUZXh0fVxuXHRcdFx0XHQ8L2gxPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9Eb2N1bWVudD5cblx0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSh7IGVycm9yIH06IHsgZXJyb3I6IEVycm9yIH0pIHtcblx0Y29uc29sZS5lcnJvcihlcnJvcilcblxuXHRyZXR1cm4gKFxuXHRcdDxEb2N1bWVudCB0aXRsZT1cIlVoLW9oIVwiPlxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJlcnJvci1jb250YWluZXJcIj5cblx0XHRcdFx0PGgxPkFwcCBFcnJvcjwvaDE+XG5cdFx0XHRcdDxwcmU+e2Vycm9yLm1lc3NhZ2V9PC9wcmU+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L0RvY3VtZW50PlxuXHQpXG59XG5cbkVycm9yQm91bmRhcnkucHJvcFR5cGVzID0ge1xuXHRlcnJvcjogUHJvcFR5cGVzLm9iamVjdCxcbn1cbiIsICJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IExpbmssIHVzZUxvYWRlckRhdGEgfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IHR5cGUgeyBMb2FkZXJGdW5jdGlvbiwgTWV0YUZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCBnZXRQYWdlRGF0YSBmcm9tIFwifi91dGlscy9nZXRQYWdlRGF0YVwiXG5pbXBvcnQgeyBkb3dubG9hZF9tZHggfSBmcm9tIFwifi9jb250ZW50L2Rvd25sb2FkLm1kLmpzXCJcbmltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbmltcG9ydCB7IHBhZ2VNb3Rpb24gfSBmcm9tIFwifi91dGlscy9tb3Rpb25WYXJpYW50c1wiXG5cbmV4cG9ydCBjb25zdCBoYW5kbGUgPSB7XG5cdGJyZWFkY3J1bWI6ICgpID0+IDxMaW5rIHRvPVwiL2Rvd25sb2FkXCI+RG93bmxvYWQ8L0xpbms+XG59XG5cbmV4cG9ydCBjb25zdCBtZXRhOiBNZXRhRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiB7IHRpdGxlOiBcIkRvd25sb2FkIFVuaUtleSB8IFVuaWtleVwiIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxvYWRlcjogTG9hZGVyRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiBnZXRQYWdlRGF0YShkb3dubG9hZF9tZHgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERvd25sb2FkUGFnZSgpIHtcblx0Y29uc3QgeyBhdHRyaWJ1dGVzLCBodG1sIH0gPSB1c2VMb2FkZXJEYXRhKClcblx0cmV0dXJuIChcblx0XHQ8bW90aW9uLmRpdiB2YXJpYW50cz17cGFnZU1vdGlvbn0gaW5pdGlhbD1cImhpZGRlblwiIGFuaW1hdGU9XCJ2aXNpYmxlXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInByb3NlIG1heC13LXNjcmVlbi1sZ1wiIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fSAvPlxuXHRcdDwvbW90aW9uLmRpdj5cblx0KVxufVxuIiwgImltcG9ydCB7IG1hcmtlZCB9IGZyb20gXCJtYXJrZWRcIlxuaW1wb3J0IHBhcnNlRnJvbnRNYXR0ZXIgZnJvbSBcImZyb250LW1hdHRlclwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhZ2VEYXRhKHNvdXJjZTogc3RyaW5nKSB7XG5cdC8vZXh0cmFjdCB0aGUgZGF0YVxuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGJvZHkgfSA9IHBhcnNlRnJvbnRNYXR0ZXIoc291cmNlKVxuXHQvL2NvbnZlcnQgbWFya2Rvd24gdG8gaHRtbFxuXHRjb25zdCBodG1sID0gbWFya2VkLnBhcnNlKGJvZHkpXG5cblx0cmV0dXJuIHsgYXR0cmlidXRlcywgaHRtbCB9XG59IiwgIi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIyLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZVVybDogbnVsbCxcbiAgICBicmVha3M6IGZhbHNlLFxuICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgZ2ZtOiB0cnVlLFxuICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICBtYW5nbGU6IHRydWUsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICBzYW5pdGl6ZXI6IG51bGwsXG4gICAgc2lsZW50OiBmYWxzZSxcbiAgICBzbWFydExpc3RzOiBmYWxzZSxcbiAgICBzbWFydHlwYW50czogZmFsc2UsXG4gICAgdG9rZW5pemVyOiBudWxsLFxuICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgeGh0bWw6IGZhbHNlXG4gIH07XG59XG5cbmxldCBkZWZhdWx0cyA9IGdldERlZmF1bHRzKCk7XG5cbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGRlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG59XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbmNvbnN0IGVzY2FwZVJlcGxhY2UgPSAvWyY8PlwiJ10vZztcbmNvbnN0IGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS87XG5jb25zdCBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvZztcbmNvbnN0IGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICBpZiAoZW5jb2RlKSB7XG4gICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn1cblxuY29uc3QgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIChfLCBuKSA9PiB7XG4gICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcbiAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpXG4gICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxuXG5jb25zdCBjYXJldCA9IC8oXnxbXlxcW10pXFxeL2c7XG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2UgfHwgcmVnZXg7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgY29uc3Qgb2JqID0ge1xuICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZ2V0UmVnZXg6ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3Qgbm9uV29yZEFuZENvbG9uVGVzdCA9IC9bXlxcdzpdL2c7XG5jb25zdCBvcmlnaW5JbmRlcGVuZGVudFVybCA9IC9eJHxeW2Etel1bYS16MC05Ky4tXSo6fF5bPyNdL2k7XG5mdW5jdGlvbiBjbGVhblVybChzYW5pdGl6ZSwgYmFzZSwgaHJlZikge1xuICBpZiAoc2FuaXRpemUpIHtcbiAgICBsZXQgcHJvdDtcbiAgICB0cnkge1xuICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2Uobm9uV29yZEFuZENvbG9uVGVzdCwgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICBocmVmID0gcmVzb2x2ZVVybChiYXNlLCBocmVmKTtcbiAgfVxuICB0cnkge1xuICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaHJlZjtcbn1cblxuY29uc3QgYmFzZVVybHMgPSB7fTtcbmNvbnN0IGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuY29uc3QgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG5jb25zdCBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0oYmFzZSwgJy8nLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuICBjb25zdCByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG5cbiAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UoZG9tYWluLCAnJDEnKSArIGhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICB9XG59XG5cbmNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiBmdW5jdGlvbiBub29wVGVzdCgpIHt9IH07XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICBsZXQgaSA9IDEsXG4gICAgdGFyZ2V0LFxuICAgIGtleTtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gIGNvbnN0IHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCAobWF0Y2gsIG9mZnNldCwgc3RyKSA9PiB7XG4gICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICBjdXJyID0gb2Zmc2V0O1xuICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKSBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgIHJldHVybiAnfCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gIGxldCBpID0gMDtcblxuICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgaWYgKCFjZWxsc1swXS50cmltKCkpIHsgY2VsbHMuc2hpZnQoKTsgfVxuICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7IGNlbGxzLnBvcCgpOyB9XG5cbiAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpIGNlbGxzLnB1c2goJycpO1xuICB9XG5cbiAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufVxuXG4vLyBSZW1vdmUgdHJhaWxpbmcgJ2Mncy4gRXF1aXZhbGVudCB0byBzdHIucmVwbGFjZSgvYyokLywgJycpLlxuLy8gL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbi8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gIGNvbnN0IGwgPSBzdHIubGVuZ3RoO1xuICBpZiAobCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG4gIGxldCBzdWZmTGVuID0gMDtcblxuICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgd2hpbGUgKHN1ZmZMZW4gPCBsKSB7XG4gICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgIHN1ZmZMZW4rKztcbiAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgc3VmZkxlbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cigwLCBsIC0gc3VmZkxlbik7XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgbGV0IGxldmVsID0gMCxcbiAgICBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgbGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCkge1xuICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHNhbml0aXplIGFuZCBzYW5pdGl6ZXIgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuNy4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9tYXJrZWQuanMub3JnLyMvVVNJTkdfQURWQU5DRUQubWQjb3B0aW9ucycpO1xuICB9XG59XG5cbi8vIGNvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzLzgwNjc3N1xuZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHBhdHRlcm4sIGNvdW50KSB7XG4gIGlmIChjb3VudCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgaWYgKGNvdW50ICYgMSkge1xuICAgICAgcmVzdWx0ICs9IHBhdHRlcm47XG4gICAgfVxuICAgIGNvdW50ID4+PSAxO1xuICAgIHBhdHRlcm4gKz0gcGF0dGVybjtcbiAgfVxuICByZXR1cm4gcmVzdWx0ICsgcGF0dGVybjtcbn1cblxuZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdywgbGV4ZXIpIHtcbiAgY29uc3QgaHJlZiA9IGxpbmsuaHJlZjtcbiAgY29uc3QgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgY29uc3QgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcblxuICBpZiAoY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnKSB7XG4gICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIHJhdyxcbiAgICAgIGhyZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRleHQsXG4gICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyh0ZXh0LCBbXSlcbiAgICB9O1xuICAgIGxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgIHJldHVybiB0b2tlbjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgIHJhdyxcbiAgICAgIGhyZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRleHQ6IGVzY2FwZSh0ZXh0KVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIHRleHQpIHtcbiAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG5cbiAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcblxuICByZXR1cm4gdGV4dFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAubWFwKG5vZGUgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hJbmRlbnRJbk5vZGUgPSBub2RlLm1hdGNoKC9eXFxzKy8pO1xuICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBUb2tlbml6ZXJcbiAqL1xuY2xhc3MgVG9rZW5pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHM7XG4gIH1cblxuICBzcGFjZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5ld2xpbmUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGNvZGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICA6IHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZmVuY2VzKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCByYXcgPSBjYXBbMF07XG4gICAgICBjb25zdCB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgcmF3LFxuICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpIDogY2FwWzJdLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGhlYWRpbmcoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBsZXQgdGV4dCA9IGNhcFsyXS50cmltKCk7XG5cbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuICAgICAgaWYgKC8jJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gcnRyaW0odGV4dCwgJyMnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgfSBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH07XG4gICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfVxuXG4gIGhyKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHIuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5ibG9ja3F1b3RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnModGV4dCwgW10pLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGxpc3Qoc3JjKSB7XG4gICAgbGV0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGlzdC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHJhdywgaXN0YXNrLCBpc2NoZWNrZWQsIGluZGVudCwgaSwgYmxhbmtMaW5lLCBlbmRzV2l0aEJsYW5rTGluZSxcbiAgICAgICAgbGluZSwgbmV4dExpbmUsIHJhd0xpbmUsIGl0ZW1Db250ZW50cywgZW5kRWFybHk7XG5cbiAgICAgIGxldCBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgIGNvbnN0IGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcblxuICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICByYXc6ICcnLFxuICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICBpdGVtczogW11cbiAgICAgIH07XG5cbiAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBgXFxcXGR7MSw5fVxcXFwke2J1bGwuc2xpY2UoLTEpfWAgOiBgXFxcXCR7YnVsbH1gO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICBjb25zdCBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKGBeKCB7MCwzfSR7YnVsbH0pKCg/OiBbXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgIGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF07XG4gICAgICAgIG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnRyaW1MZWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50ID0gY2FwWzJdLnNlYXJjaCgvW14gXS8pOyAvLyBGaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICBpbmRlbnQgKz0gY2FwWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJsYW5rTGluZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghbGluZSAmJiAvXiAqJC8udGVzdChuZXh0TGluZSkpIHsgLy8gSXRlbXMgYmVnaW4gd2l0aCBhdCBtb3N0IG9uZSBibGFuayBsaW5lXG4gICAgICAgICAgcmF3ICs9IG5leHRMaW5lICsgJ1xcbic7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICBlbmRFYXJseSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgY29uc3QgbmV4dEJ1bGxldFJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpbKistXXxcXFxcZHsxLDl9Wy4pXSlgKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgcmF3TGluZSA9IHNyYy5zcGxpdCgnXFxuJywgMSlbMF07XG4gICAgICAgICAgICBsaW5lID0gcmF3TGluZTtcblxuICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csICcgICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcbiAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0UmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmUuc2VhcmNoKC9bXiBdLykgPj0gaW5kZW50IHx8ICFsaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYmxhbmtMaW5lKSB7IC8vIFVudGlsIGJsYW5rIGxpbmUsIGl0ZW0gZG9lc24ndCBuZWVkIGluZGVudGF0aW9uXG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmU7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBPdGhlcndpc2UsIGltcHJvcGVyIGluZGVudGF0aW9uIGVuZHMgdGhpcyBpdGVtXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSAmJiAhbGluZS50cmltKCkpIHsgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGJsYW5rXG4gICAgICAgICAgICAgIGJsYW5rTGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhdyArPSByYXdMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhd0xpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGl0ZW0gZW5kZWQgd2l0aCBhIGJsYW5rIGxpbmUsIHRoZSBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9cXG4gKlxcbiAqJC8udGVzdChyYXcpKSB7XG4gICAgICAgICAgICBlbmRzV2l0aEJsYW5rTGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgaXNjaGVja2VkID0gaXN0YXNrWzBdICE9PSAnWyBdICc7XG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBpdGVtQ29udGVudHMucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50c1xuICAgICAgICB9KTtcblxuICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG4gICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gcmF3LnRyaW1SaWdodCgpO1xuICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnRleHQgPSBpdGVtQ29udGVudHMudHJpbVJpZ2h0KCk7XG4gICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnRyaW1SaWdodCgpO1xuXG4gICAgICBjb25zdCBsID0gbGlzdC5pdGVtcy5sZW5ndGg7XG5cbiAgICAgIC8vIEl0ZW0gY2hpbGQgdG9rZW5zIGhhbmRsZWQgaGVyZSBhdCBlbmQgYmVjYXVzZSB3ZSBuZWVkZWQgdG8gaGF2ZSB0aGUgZmluYWwgaXRlbSB0byB0cmltIGl0IGZpcnN0XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gZmFsc2U7XG4gICAgICAgIGxpc3QuaXRlbXNbaV0udG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2VucyhsaXN0Lml0ZW1zW2ldLnRleHQsIFtdKTtcbiAgICAgICAgY29uc3Qgc3BhY2VycyA9IGxpc3QuaXRlbXNbaV0udG9rZW5zLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ3NwYWNlJyk7XG4gICAgICAgIGNvbnN0IGhhc011bHRpcGxlTGluZUJyZWFrcyA9IHNwYWNlcnMuZXZlcnkodCA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhcnMgPSB0LnJhdy5zcGxpdCgnJyk7XG4gICAgICAgICAgbGV0IGxpbmVCcmVha3MgPSAwO1xuICAgICAgICAgIGZvciAoY29uc3QgY2hhciBvZiBjaGFycykge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGxpbmVCcmVha3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzID4gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbGlzdC5sb29zZSAmJiBzcGFjZXJzLmxlbmd0aCAmJiBoYXNNdWx0aXBsZUxpbmVCcmVha3MpIHtcbiAgICAgICAgICAvLyBIYXZpbmcgYSBzaW5nbGUgbGluZSBicmVhayBkb2Vzbid0IG1lYW4gYSBsaXN0IGlzIGxvb3NlLiBBIHNpbmdsZSBsaW5lIGJyZWFrIGlzIHRlcm1pbmF0aW5nIHRoZSBsYXN0IGxpc3QgaXRlbVxuICAgICAgICAgIGxpc3QubG9vc2UgPSB0cnVlO1xuICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIGh0bWwoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgICAgICB0b2tlbi50eXBlID0gJ3BhcmFncmFwaCc7XG4gICAgICAgIHRva2VuLnRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSk7XG4gICAgICAgIHRva2VuLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfVxuXG4gIGRlZihzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmRlZi5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgaWYgKGNhcFszXSkgY2FwWzNdID0gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgdGFnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHRhYmxlKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyhjYXBbMV0pLm1hcChjID0+IHsgcmV0dXJuIHsgdGV4dDogYyB9OyB9KSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICByb3dzOiBjYXBbM10gJiYgY2FwWzNdLnRyaW0oKSA/IGNhcFszXS5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgfTtcblxuICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgaXRlbS5yYXcgPSBjYXBbMF07XG5cbiAgICAgICAgbGV0IGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgbGV0IGksIGosIGssIHJvdztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGl0ZW0ucm93c1tpXSA9IHNwbGl0Q2VsbHMoaXRlbS5yb3dzW2ldLCBpdGVtLmhlYWRlci5sZW5ndGgpLm1hcChjID0+IHsgcmV0dXJuIHsgdGV4dDogYyB9OyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIGNoaWxkIHRva2VucyBpbnNpZGUgaGVhZGVycyBhbmQgY2VsbHNcblxuICAgICAgICAvLyBoZWFkZXIgY2hpbGQgdG9rZW5zXG4gICAgICAgIGwgPSBpdGVtLmhlYWRlci5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICBpdGVtLmhlYWRlcltqXS50b2tlbnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmxleGVyLmlubGluZVRva2VucyhpdGVtLmhlYWRlcltqXS50ZXh0LCBpdGVtLmhlYWRlcltqXS50b2tlbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2VsbCBjaGlsZCB0b2tlbnNcbiAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICByb3cgPSBpdGVtLnJvd3Nbal07XG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgcm93W2tdLnRva2VucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMocm93W2tdLnRleHQsIHJvd1trXS50b2tlbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxoZWFkaW5nKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcbiAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcGFyYWdyYXBoKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICA6IGNhcFsxXSxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcbiAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgdGV4dChzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH07XG4gICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfVxuXG4gIGVzY2FwZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogZXNjYXBlKGNhcFsxXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdGFnKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICd0ZXh0J1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICh0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKSlcbiAgICAgICAgICA6IGNhcFswXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBsaW5rKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmxpbmsuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRyaW1tZWRVcmwgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgIC8vIGNvbW1vbm1hcmsgcmVxdWlyZXMgbWF0Y2hpbmcgYW5nbGUgYnJhY2tldHNcbiAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgIGNvbnN0IHJ0cmltU2xhc2ggPSBydHJpbSh0cmltbWVkVXJsLnNsaWNlKDAsIC0xKSwgJ1xcXFwnKTtcbiAgICAgICAgaWYgKCh0cmltbWVkVXJsLmxlbmd0aCAtIHJ0cmltU2xhc2gubGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbmQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgIGNvbnN0IGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgLy8gc3BsaXQgcGVkYW50aWMgaHJlZiBhbmQgdGl0bGVcbiAgICAgICAgY29uc3QgbGluayA9IC9eKFteJ1wiXSpbXlxcc10pXFxzKyhbJ1wiXSkoLiopXFwyLy5leGVjKGhyZWYpO1xuXG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgIH1cblxuICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogdGl0bGVcbiAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgfVxuICB9XG5cbiAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgbGV0IGNhcDtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgIGxldCBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgfVxuICB9XG5cbiAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgIGlmIChtYXRjaFszXSAmJiBwcmV2Q2hhci5tYXRjaCgvW1xccHtMfVxccHtOfV0vdSkpIHJldHVybjtcblxuICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG5cbiAgICBpZiAoIW5leHRDaGFyIHx8IChuZXh0Q2hhciAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkpIHtcbiAgICAgIGNvbnN0IGxMZW5ndGggPSBtYXRjaFswXS5sZW5ndGggLSAxO1xuICAgICAgbGV0IHJEZWxpbSwgckxlbmd0aCwgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsIG1pZERlbGltVG90YWwgPSAwO1xuXG4gICAgICBjb25zdCBlbmRSZWcgPSBtYXRjaFswXVswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kO1xuICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG5cbiAgICAgICAgaWYgKCFyRGVsaW0pIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG5cbiAgICAgICAgckxlbmd0aCA9IHJEZWxpbS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7IC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkgeyAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcblxuICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcblxuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBgZW1gIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgb2RkIGNoYXIgY291bnQuICphKioqXG4gICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gc3JjLnNsaWNlKDEsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCArIDEpLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCwgW10pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSAnc3Ryb25nJyBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIGV2ZW4gY2hhciBjb3VudC4gKiphKioqXG4gICAgICAgIGNvbnN0IHRleHQgPSBzcmMuc2xpY2UoMiwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgIHJhdzogc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGggKyAxKSxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCwgW10pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29kZXNwYW4oc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHRleHQgPSBlc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBicihzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ici5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZGVsKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdLCBbXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFsxXSkgOiBjYXBbMV0pO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRva2VuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgbGV0IGNhcDtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICBsZXQgcHJldkNhcFplcm87XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBwcmV2Q2FwWmVybyA9IGNhcFswXTtcbiAgICAgICAgICBjYXBbMF0gPSB0aGlzLnJ1bGVzLmlubGluZS5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKVswXTtcbiAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgaHJlZiA9ICdodHRwOi8vJyArIHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRva2VuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaW5saW5lVGV4dChzcmMsIHNtYXJ0eXBhbnRzKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQ7XG4gICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAodGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pKSA6IGNhcFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICBmZW5jZXM6IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSpcXG4pfH57Myx9KShbXlxcbl0qKVxcbig/OnwoW1xcc1xcU10qPylcXG4pKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS8sXG4gIGhyOiAvXiB7MCwzfSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXCogKil7Myx9KSg/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICBsaXN0OiAvXiggezAsM31idWxsKSggW15cXG5dKz8pPyg/OlxcbnwkKS8sXG4gIGh0bWw6ICdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg2KVxuICAgICsgJ3w8KD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgICArICd8PC8oPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVthLXpdW1xcXFx3LV0qXFxcXHMqPig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLFxuICBkZWY6IC9eIHswLDN9XFxbKGxhYmVsKVxcXTogKig/OlxcbiAqKT88PyhbXlxccz5dKyk+Pyg/Oig/OiArKD86XFxuICopP3wgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wVGVzdCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHx0YWJsZXwgK1xcbilbXlxcbl0rKSopLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmJsb2NrLl90aXRsZSA9IC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS87XG5ibG9jay5kZWYgPSBlZGl0KGJsb2NrLmRlZilcbiAgLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKVxuICAucmVwbGFjZSgndGl0bGUnLCBibG9jay5fdGl0bGUpXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5ibG9jay5saXN0SXRlbVN0YXJ0ID0gZWRpdCgvXiggKikoYnVsbCkgKi8pXG4gIC5yZXBsYWNlKCdidWxsJywgYmxvY2suYnVsbGV0KVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2subGlzdCA9IGVkaXQoYmxvY2subGlzdClcbiAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKVxuICAucmVwbGFjZSgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbidcbiAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nXG4gICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInXG4gICsgJ3x0cmFja3x1bCc7XG5ibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuYmxvY2suaHRtbCA9IGVkaXQoYmxvY2suaHRtbCwgJ2knKVxuICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZylcbiAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IGVkaXQoYmxvY2suYmxvY2txdW90ZSlcbiAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaClcbiAgLmdldFJlZ2V4KCk7XG5cbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5ub3JtYWwgPSBtZXJnZSh7fSwgYmxvY2spO1xuXG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2suZ2ZtID0gbWVyZ2Uoe30sIGJsb2NrLm5vcm1hbCwge1xuICB0YWJsZTogJ14gKihbXlxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSg/OlxcXFx8ICopPyg6Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKSg/OlxcXFx8ICopPycgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcbn0pO1xuXG5ibG9jay5nZm0udGFibGUgPSBlZGl0KGJsb2NrLmdmbS50YWJsZSlcbiAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKVxuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCd0YWJsZScsIGJsb2NrLmdmbS50YWJsZSkgLy8gaW50ZXJydXB0IHBhcmFncmFwaHMgd2l0aCB0YWJsZVxuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gKi9cblxuYmxvY2sucGVkYW50aWMgPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGh0bWw6IGVkaXQoXG4gICAgJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJ1xuICAgICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKVxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpXG4gICAgLnJlcGxhY2UoL3RhZy9nLCAnKD8hKD86J1xuICAgICAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YidcbiAgICAgICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJ1xuICAgICAgKyAnXFxcXGIpXFxcXHcrKD8hOnxbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJylcbiAgICAuZ2V0UmVnZXgoKSxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gIGZlbmNlczogbm9vcFRlc3QsIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gIHBhcmFncmFwaDogZWRpdChibG9jay5ub3JtYWwuX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJylcbiAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnfGZlbmNlcycsICcnKVxuICAgIC5yZXBsYWNlKCd8bGlzdCcsICcnKVxuICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgIC5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICB1cmw6IG5vb3BUZXN0LFxuICB0YWc6ICdeY29tbWVudCdcbiAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JywgLy8gQ0RBVEEgc2VjdGlvblxuICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LyxcbiAgcmVmbGlua1NlYXJjaDogJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJyxcbiAgZW1TdHJvbmc6IHtcbiAgICBsRGVsaW06IC9eKD86XFwqKyg/OihbcHVuY3RfXSl8W15cXHMqXSkpfF5fKyg/OihbcHVuY3QqXSl8KFteXFxzX10pKS8sXG4gICAgLy8gICAgICAgICgxKSBhbmQgKDIpIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyLiAoMykgYW5kICg0KSBjYW4gb25seSBiZSBMZWZ0LiAgKDUpIGFuZCAoNikgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0LlxuICAgIC8vICAgICAgICAoKSBTa2lwIG9ycGhhbiBkZWxpbSBpbnNpZGUgc3Ryb25nICAgICgxKSAjKioqICAgICAgICAgICAgICAgICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICg0KSAqKiojICAgICAgICAgICAgICAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICg2KSBhKioqYVxuICAgIHJEZWxpbUFzdDogL15bXl8qXSo/XFxfXFxfW15fKl0qP1xcKlteXypdKj8oPz1cXF9cXF8pfFtwdW5jdF9dKFxcKispKD89W1xcc118JCl8W15wdW5jdCpfXFxzXShcXCorKSg/PVtwdW5jdF9cXHNdfCQpfFtwdW5jdF9cXHNdKFxcKispKD89W15wdW5jdCpfXFxzXSl8W1xcc10oXFwqKykoPz1bcHVuY3RfXSl8W3B1bmN0X10oXFwqKykoPz1bcHVuY3RfXSl8W15wdW5jdCpfXFxzXShcXCorKSg/PVtecHVuY3QqX1xcc10pLyxcbiAgICByRGVsaW1VbmQ6IC9eW15fKl0qP1xcKlxcKlteXypdKj9cXF9bXl8qXSo/KD89XFwqXFwqKXxbcHVuY3QqXShcXF8rKSg/PVtcXHNdfCQpfFtecHVuY3QqX1xcc10oXFxfKykoPz1bcHVuY3QqXFxzXXwkKXxbcHVuY3QqXFxzXShcXF8rKSg/PVtecHVuY3QqX1xcc10pfFtcXHNdKFxcXyspKD89W3B1bmN0Kl0pfFtwdW5jdCpdKFxcXyspKD89W3B1bmN0Kl0pLyAvLyBeLSBOb3QgYWxsb3dlZCBmb3IgX1xuICB9LFxuICBjb2RlOiAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvLFxuICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3BUZXN0LFxuICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvLFxuICBwdW5jdHVhdGlvbjogL14oW1xcc3B1bmN0dWF0aW9uXSkvXG59O1xuXG4vLyBsaXN0IG9mIHB1bmN0dWF0aW9uIG1hcmtzIGZyb20gQ29tbW9uTWFyayBzcGVjXG4vLyB3aXRob3V0ICogYW5kIF8gdG8gaGFuZGxlIHRoZSBkaWZmZXJlbnQgZW1waGFzaXMgbWFya2VycyAqIGFuZCBfXG5pbmxpbmUuX3B1bmN0dWF0aW9uID0gJyFcIiMkJSZcXCcoKStcXFxcLS4sLzo7PD0+P0BcXFxcW1xcXFxdYF57fH1+JztcbmlubGluZS5wdW5jdHVhdGlvbiA9IGVkaXQoaW5saW5lLnB1bmN0dWF0aW9uKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuXG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuaW5saW5lLmJsb2NrU2tpcCA9IC9cXFtbXlxcXV0qP1xcXVxcKFteXFwpXSo/XFwpfGBbXmBdKj9gfDxbXj5dKj8+L2c7XG5pbmxpbmUuZXNjYXBlZEVtU3QgPSAvXFxcXFxcKnxcXFxcXy9nO1xuXG5pbmxpbmUuX2NvbW1lbnQgPSBlZGl0KGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcblxuaW5saW5lLmVtU3Ryb25nLmxEZWxpbSA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLmxEZWxpbSlcbiAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0ID0gZWRpdChpbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0LCAnZycpXG4gIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAuZ2V0UmVnZXgoKTtcblxuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCwgJ2cnKVxuICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS9nO1xuXG5pbmxpbmUuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbmlubGluZS5fZW1haWwgPSAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLztcbmlubGluZS5hdXRvbGluayA9IGVkaXQoaW5saW5lLmF1dG9saW5rKVxuICAucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lLl9zY2hlbWUpXG4gIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcblxuaW5saW5lLnRhZyA9IGVkaXQoaW5saW5lLnRhZylcbiAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpXG4gIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCBpbmxpbmUuX2F0dHJpYnV0ZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5fbGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuaW5saW5lLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbmlubGluZS5fdGl0bGUgPSAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLztcblxuaW5saW5lLmxpbmsgPSBlZGl0KGlubGluZS5saW5rKVxuICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZilcbiAgLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgLnJlcGxhY2UoJ3JlZicsIGJsb2NrLl9sYWJlbClcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5ub2xpbmsgPSBlZGl0KGlubGluZS5ub2xpbmspXG4gIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJylcbiAgLnJlcGxhY2UoJ3JlZmxpbmsnLCBpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ25vbGluaycsIGlubGluZS5ub2xpbmspXG4gIC5nZXRSZWdleCgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzoge1xuICAgIHN0YXJ0OiAvXl9ffFxcKlxcKi8sXG4gICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICBlbmRBc3Q6IC9cXCpcXCooPyFcXCopL2csXG4gICAgZW5kVW5kOiAvX18oPyFfKS9nXG4gIH0sXG4gIGVtOiB7XG4gICAgc3RhcnQ6IC9eX3xcXCovLFxuICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgZW5kQXN0OiAvXFwqKD8hXFwqKS9nLFxuICAgIGVuZFVuZDogL18oPyFfKS9nXG4gIH0sXG4gIGxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXCgoLio/KVxcKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAuZ2V0UmVnZXgoKSxcbiAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KClcbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IGVkaXQoaW5saW5lLmVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypffigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypffildKyg/ISQpKSsvLFxuICBkZWw6IC9eKH5+PykoPz1bXlxcc35dKShbXFxzXFxTXSo/W15cXHN+XSlcXDEoPz1bXn5dfCQpLyxcbiAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn0pO1xuXG5pbmxpbmUuZ2ZtLnVybCA9IGVkaXQoaW5saW5lLmdmbS51cmwsICdpJylcbiAgLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLmdmbS5fZXh0ZW5kZWRfZW1haWwpXG4gIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogZWRpdChpbmxpbmUuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gIHRleHQ6IGVkaXQoaW5saW5lLmdmbS50ZXh0KVxuICAgIC5yZXBsYWNlKCdcXFxcYl8nLCAnXFxcXGJffCB7Mix9XFxcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgLmdldFJlZ2V4KClcbn0pO1xuXG4vKipcbiAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufVxuXG4vKipcbiAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAqL1xuZnVuY3Rpb24gbWFuZ2xlKHRleHQpIHtcbiAgbGV0IG91dCA9ICcnLFxuICAgIGksXG4gICAgY2g7XG5cbiAgY29uc3QgbCA9IHRleHQubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5jbGFzcyBMZXhlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBUb2tlbml6ZXIoKTtcbiAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnRva2VuaXplci5sZXhlciA9IHRoaXM7XG4gICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpbkxpbms6IGZhbHNlLFxuICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICB0b3A6IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICBibG9jazogYmxvY2subm9ybWFsLFxuICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBSdWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBydWxlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2ssXG4gICAgICBpbmxpbmVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBMZXggTWV0aG9kXG4gICAqL1xuICBzdGF0aWMgbGV4KHNyYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBsZXhJbmxpbmUoc3JjLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIGxleGVyLmlubGluZVRva2VucyhzcmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXByb2Nlc3NpbmdcbiAgICovXG4gIGxleChzcmMpIHtcbiAgICBzcmMgPSBzcmNcbiAgICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpO1xuXG4gICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zKTtcblxuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChuZXh0ID0gdGhpcy5pbmxpbmVRdWV1ZS5zaGlmdCgpKSB7XG4gICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXhpbmdcbiAgICovXG4gIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuICAgIH1cbiAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZDtcblxuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9jay5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXdsaW5lXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGlmICh0b2tlbi5yYXcubGVuZ3RoID09PSAxICYmIHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAvLyBzbyBtb3ZlIGl0IHRoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IHVuZWNlc3NhcnkgcGFyYWdyYXBoIHRhZ3NcbiAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvZGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZlbmNlc1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaGVhZGluZ1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGhyXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGJsb2NrcXVvdGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBsaXN0XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaHRtbFxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZlxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10pIHtcbiAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRhYmxlIChnZm0pXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGxoZWFkaW5nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saGVhZGluZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jay5mb3JFYWNoKGZ1bmN0aW9uKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHsgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RQYXJhZ3JhcGhDbGlwcGVkICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IChjdXRTcmMubGVuZ3RoICE9PSBzcmMubGVuZ3RoKTtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRleHRcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgaW5saW5lKHNyYywgdG9rZW5zKSB7XG4gICAgdGhpcy5pbmxpbmVRdWV1ZS5wdXNoKHsgc3JjLCB0b2tlbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGV4aW5nL0NvbXBpbGluZ1xuICAgKi9cbiAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjO1xuXG4gICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICBsZXQgbWFza2VkU3JjID0gc3JjO1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcblxuICAgIC8vIE1hc2sgb3V0IHJlZmxpbmtzXG4gICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcbiAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gTWFzayBvdXQgZXNjYXBlZCBlbSAmIHN0cm9uZyBkZWxpbWl0ZXJzXG4gICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnKysnICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5sYXN0SW5kZXgpO1xuICAgIH1cblxuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgIGlmICgha2VlcFByZXZDaGFyKSB7XG4gICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICB9XG4gICAgICBrZWVwUHJldkNoYXIgPSBmYWxzZTtcblxuICAgICAgLy8gZXh0ZW5zaW9uc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zXG4gICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZVxuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUuc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNjYXBlXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lc2NhcGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0YWdcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvZGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGVzcGFuKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYnJcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVsIChnZm0pXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhdXRvbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYXV0b2xpbmsoc3JjLCBtYW5nbGUpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXh0XG4gICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUuZm9yRWFjaChmdW5jdGlvbihnZXRTdGFydEluZGV4KSB7XG4gICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7IHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpOyB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYywgc21hcnR5cGFudHMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHsgLy8gVHJhY2sgcHJldkNoYXIgYmVmb3JlIHN0cmluZyBvZiBfX19fIHN0YXJ0ZWRcbiAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgIH1cbiAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5jbGFzcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICB9XG5cbiAgY29kZShjb2RlLCBpbmZvc3RyaW5nLCBlc2NhcGVkKSB7XG4gICAgY29uc3QgbGFuZyA9IChpbmZvc3RyaW5nIHx8ICcnKS5tYXRjaCgvXFxTKi8pWzBdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICBjb25zdCBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgY29kZSA9IG91dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXG4kLywgJycpICsgJ1xcbic7XG5cbiAgICBpZiAoIWxhbmcpIHtcbiAgICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICAgKyAnXCI+J1xuICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgfVxuXG4gIGJsb2NrcXVvdGUocXVvdGUpIHtcbiAgICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbiAgfVxuXG4gIGh0bWwoaHRtbCkge1xuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3LCBzbHVnZ2VyKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJJZHMpIHtcbiAgICAgIHJldHVybiAnPGgnXG4gICAgICAgICsgbGV2ZWxcbiAgICAgICAgKyAnIGlkPVwiJ1xuICAgICAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICAgICAgKyBzbHVnZ2VyLnNsdWcocmF3KVxuICAgICAgICArICdcIj4nXG4gICAgICAgICsgdGV4dFxuICAgICAgICArICc8L2gnXG4gICAgICAgICsgbGV2ZWxcbiAgICAgICAgKyAnPlxcbic7XG4gICAgfVxuICAgIC8vIGlnbm9yZSBJRHNcbiAgICByZXR1cm4gJzxoJyArIGxldmVsICsgJz4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gIH1cblxuICBocigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgfVxuXG4gIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgc3RhcnRhdHQgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgfVxuXG4gIGxpc3RpdGVtKHRleHQpIHtcbiAgICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG4gIH1cblxuICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgcmV0dXJuICc8aW5wdXQgJ1xuICAgICAgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKVxuICAgICAgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIidcbiAgICAgICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJylcbiAgICAgICsgJz4gJztcbiAgfVxuXG4gIHBhcmFncmFwaCh0ZXh0KSB7XG4gICAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbiAgfVxuXG4gIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgIGlmIChib2R5KSBib2R5ID0gJzx0Ym9keT4nICsgYm9keSArICc8L3Rib2R5Pic7XG5cbiAgICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgICArICc8dGhlYWQ+XFxuJ1xuICAgICAgKyBoZWFkZXJcbiAgICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICAgKyBib2R5XG4gICAgICArICc8L3RhYmxlPlxcbic7XG4gIH1cblxuICB0YWJsZXJvdyhjb250ZW50KSB7XG4gICAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xuICB9XG5cbiAgdGFibGVjZWxsKGNvbnRlbnQsIGZsYWdzKSB7XG4gICAgY29uc3QgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgIGNvbnN0IHRhZyA9IGZsYWdzLmFsaWduXG4gICAgICA/ICc8JyArIHR5cGUgKyAnIGFsaWduPVwiJyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICAgIDogJzwnICsgdHlwZSArICc+JztcbiAgICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICB9XG5cbiAgLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuICBzdHJvbmcodGV4dCkge1xuICAgIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xuICB9XG5cbiAgZW0odGV4dCkge1xuICAgIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+JztcbiAgfVxuXG4gIGNvZGVzcGFuKHRleHQpIHtcbiAgICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xuICB9XG5cbiAgYnIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG4gIH1cblxuICBkZWwodGV4dCkge1xuICAgIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xuICB9XG5cbiAgbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBlc2NhcGUoaHJlZikgKyAnXCInO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICAgIH1cbiAgICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICBocmVmID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG4gICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGxldCBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgfVxuICAgIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICB0ZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIFRleHRSZW5kZXJlciB7XG4gIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICBzdHJvbmcodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgZW0odGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgY29kZXNwYW4odGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgZGVsKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGh0bWwodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgdGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBsaW5rKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIGJyKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICovXG5jbGFzcyBTbHVnZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZWVuID0ge307XG4gIH1cblxuICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAudHJpbSgpXG4gICAgICAvLyByZW1vdmUgaHRtbCB0YWdzXG4gICAgICAucmVwbGFjZSgvPFshXFwvYS16XS4qPz4vaWcsICcnKVxuICAgICAgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpXG4gICAgICAucmVwbGFjZSgvXFxzL2csICctJyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIG5leHQgc2FmZSAodW5pcXVlKSBzbHVnIHRvIHVzZVxuICAgKi9cbiAgZ2V0TmV4dFNhZmVTbHVnKG9yaWdpbmFsU2x1ZywgaXNEcnlSdW4pIHtcbiAgICBsZXQgc2x1ZyA9IG9yaWdpbmFsU2x1ZztcbiAgICBsZXQgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSAwO1xuICAgIGlmICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcbiAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gdGhpcy5zZWVuW29yaWdpbmFsU2x1Z107XG4gICAgICBkbyB7XG4gICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yKys7XG4gICAgICAgIHNsdWcgPSBvcmlnaW5hbFNsdWcgKyAnLScgKyBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gICAgfVxuICAgIGlmICghaXNEcnlSdW4pIHtcbiAgICAgIHRoaXMuc2VlbltvcmlnaW5hbFNsdWddID0gb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICB0aGlzLnNlZW5bc2x1Z10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc2x1ZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHN0cmluZyB0byB1bmlxdWUgaWRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmRyeXJ1biBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dCB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAqL1xuICBzbHVnKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldE5leHRTYWZlU2x1ZyhzbHVnLCBvcHRpb25zLmRyeXJ1bik7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnRleHRSZW5kZXJlciA9IG5ldyBUZXh0UmVuZGVyZXIoKTtcbiAgICB0aGlzLnNsdWdnZXIgPSBuZXcgU2x1Z2dlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIExvb3BcbiAgICovXG4gIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgIGxldCBvdXQgPSAnJyxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIGwyLFxuICAgICAgbDMsXG4gICAgICByb3csXG4gICAgICBjZWxsLFxuICAgICAgaGVhZGVyLFxuICAgICAgYm9keSxcbiAgICAgIHRva2VuLFxuICAgICAgb3JkZXJlZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgbG9vc2UsXG4gICAgICBpdGVtQm9keSxcbiAgICAgIGl0ZW0sXG4gICAgICBjaGVja2VkLFxuICAgICAgdGFzayxcbiAgICAgIGNoZWNrYm94LFxuICAgICAgcmV0O1xuXG4gICAgY29uc3QgbCA9IHRva2Vucy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgdG9rZW4pO1xuICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyh0b2tlbi50eXBlKSkge1xuICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hyJzoge1xuICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKFxuICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpLFxuICAgICAgICAgICAgdG9rZW4uZGVwdGgsXG4gICAgICAgICAgICB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSxcbiAgICAgICAgICAgIHRoaXMuc2x1Z2dlcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsXG4gICAgICAgICAgICB0b2tlbi5sYW5nLFxuICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgaGVhZGVyID0gJyc7XG5cbiAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgICB0aGlzLnBhcnNlSW5saW5lKHRva2VuLmhlYWRlcltqXS50b2tlbnMpLFxuICAgICAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgIGwyID0gdG9rZW4ucm93cy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgIHJvdyA9IHRva2VuLnJvd3Nbal07XG5cbiAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgIGwzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsMzsgaysrKSB7XG4gICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSxcbiAgICAgICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0b2tlbi5hbGlnbltrXSB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgIHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgY2hlY2tlZCA9IGl0ZW0uY2hlY2tlZDtcbiAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcbiAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAvLyBUT0RPIHBhcnNlIGlubGluZSBjb250ZW50IGlmIHBhcmFtZXRlciBtYXJrZG93bj0xXG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcbiAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgKi9cbiAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgb3V0ID0gJycsXG4gICAgICBpLFxuICAgICAgdG9rZW4sXG4gICAgICByZXQ7XG5cbiAgICBjb25zdCBsID0gdG9rZW5zLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCB0b2tlbik7XG4gICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdlc2NhcGUnOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaW5rJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRva2VuLnRleHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VtJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4odG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYnInOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdDtcbiAgICBvcHQgPSBudWxsO1xuICB9XG5cbiAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCk7XG5cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICBsZXQgdG9rZW5zO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGxldCBvdXQ7XG5cbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuICAgICAgcmV0dXJuIGVyclxuICAgICAgICA/IGNhbGxiYWNrKGVycilcbiAgICAgICAgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgIH07XG5cbiAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuIGRvbmUoKTtcblxuICAgIGxldCBwZW5kaW5nID0gMDtcbiAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgIHBlbmRpbmcrKztcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCAmJiBjb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpO1xuICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmdldERlZmF1bHRzID0gZ2V0RGVmYXVsdHM7XG5cbm1hcmtlZC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG4vKipcbiAqIFVzZSBFeHRlbnNpb25cbiAqL1xuXG5tYXJrZWQudXNlID0gZnVuY3Rpb24oLi4uYXJncykge1xuICBjb25zdCBvcHRzID0gbWVyZ2Uoe30sIC4uLmFyZ3MpO1xuICBjb25zdCBleHRlbnNpb25zID0gbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwgeyByZW5kZXJlcnM6IHt9LCBjaGlsZFRva2Vuczoge30gfTtcbiAgbGV0IGhhc0V4dGVuc2lvbnM7XG5cbiAgYXJncy5mb3JFYWNoKChwYWNrKSA9PiB7XG4gICAgLy8gPT0tLSBQYXJzZSBcImFkZG9uXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgaWYgKHBhY2suZXh0ZW5zaW9ucykge1xuICAgICAgaGFzRXh0ZW5zaW9ucyA9IHRydWU7XG4gICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgIGlmICghZXh0Lm5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dC5yZW5kZXJlcikgeyAvLyBSZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnMgPyBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gOiBudWxsO1xuICAgICAgICAgIGlmIChwcmV2UmVuZGVyZXIpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgZXh0ZW5zaW9uIHdpdGggZnVuYyB0byBydW4gbmV3IGV4dGVuc2lvbiBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIGxldCByZXQgPSBleHQucmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHQudG9rZW5pemVyKSB7IC8vIFRva2VuaXplciBFeHRlbnNpb25zXG4gICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgKGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5zaW9uIGxldmVsIG11c3QgYmUgJ2Jsb2NrJyBvciAnaW5saW5lJ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbnNbZXh0LmxldmVsXSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXSA9IFtleHQudG9rZW5pemVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dC5zdGFydCkgeyAvLyBGdW5jdGlvbiB0byBjaGVjayBmb3Igc3RhcnQgb2YgdG9rZW5cbiAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jay5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0LmNoaWxkVG9rZW5zKSB7IC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICBleHRlbnNpb25zLmNoaWxkVG9rZW5zW2V4dC5uYW1lXSA9IGV4dC5jaGlsZFRva2VucztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBcIm92ZXJ3cml0ZVwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICBjb25zdCByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3Byb3BdO1xuICAgICAgICAvLyBSZXBsYWNlIHJlbmRlcmVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgIHJlbmRlcmVyW3Byb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBsZXQgcmV0ID0gcGFjay5yZW5kZXJlcltwcm9wXS5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIGlmIChwYWNrLnRva2VuaXplcikge1xuICAgICAgY29uc3QgdG9rZW5pemVyID0gbWFya2VkLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyKCk7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgY29uc3QgcHJldlRva2VuaXplciA9IHRva2VuaXplcltwcm9wXTtcbiAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgdG9rZW5pemVyW3Byb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBsZXQgcmV0ID0gcGFjay50b2tlbml6ZXJbcHJvcF0uYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLndhbGtUb2tlbnMpIHtcbiAgICAgIGNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgIG9wdHMud2Fsa1Rva2VucyA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIHBhY2sud2Fsa1Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICAgICAgaWYgKHdhbGtUb2tlbnMpIHtcbiAgICAgICAgICB3YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChoYXNFeHRlbnNpb25zKSB7XG4gICAgICBvcHRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIG1hcmtlZC5zZXRPcHRpb25zKG9wdHMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5cbm1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24odG9rZW5zLCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgIGNhbGxiYWNrLmNhbGwobWFya2VkLCB0b2tlbik7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRva2VuLmhlYWRlcikge1xuICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdG9rZW4ucm93cykge1xuICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW4uaXRlbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmIChtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucyAmJiBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2VucyAmJiBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1t0b2tlbi50eXBlXSkgeyAvLyBXYWxrIGFueSBleHRlbnNpb25zXG4gICAgICAgICAgbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbdG9rZW4udHlwZV0uZm9yRWFjaChmdW5jdGlvbihjaGlsZFRva2Vucykge1xuICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5bY2hpbGRUb2tlbnNdLCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW4udG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2UgSW5saW5lXG4gKi9cbm1hcmtlZC5wYXJzZUlubGluZSA9IGZ1bmN0aW9uKHNyYywgb3B0KSB7XG4gIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICB9XG5cbiAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbnMgPSBMZXhlci5sZXhJbmxpbmUoc3JjLCBvcHQpO1xuICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5tYXJrZWQuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5tYXJrZWQuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuXG5jb25zdCBvcHRpb25zID0gbWFya2VkLm9wdGlvbnM7XG5jb25zdCBzZXRPcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnM7XG5jb25zdCB1c2UgPSBtYXJrZWQudXNlO1xuY29uc3Qgd2Fsa1Rva2VucyA9IG1hcmtlZC53YWxrVG9rZW5zO1xuY29uc3QgcGFyc2VJbmxpbmUgPSBtYXJrZWQucGFyc2VJbmxpbmU7XG5jb25zdCBwYXJzZSA9IG1hcmtlZDtcbmNvbnN0IHBhcnNlciA9IFBhcnNlci5wYXJzZTtcbmNvbnN0IGxleGVyID0gTGV4ZXIubGV4O1xuXG5leHBvcnQgeyBMZXhlciwgUGFyc2VyLCBSZW5kZXJlciwgU2x1Z2dlciwgVGV4dFJlbmRlcmVyLCBUb2tlbml6ZXIsIGRlZmF1bHRzLCBnZXREZWZhdWx0cywgbGV4ZXIsIG1hcmtlZCwgb3B0aW9ucywgcGFyc2UsIHBhcnNlSW5saW5lLCBwYXJzZXIsIHNldE9wdGlvbnMsIHVzZSwgd2Fsa1Rva2VucyB9O1xuIiwgImV4cG9ydCBjb25zdCBkb3dubG9hZF9tZHggPSBgLS0tXG50aXRsZTogRG93bmxvYWQgVW5pS2V5XG4tLS1cbiMgRG93bmxvYWQgVW5pS2V5XG5cblRyXHUwMUIwXHUxRURCYyBraGkgY2hcdTFFQTF5IFVuaUtleSBsXHUxRUE3biBcdTAxMTFcdTFFQTd1IHRpXHUwMEVBbiwgYlx1MUVBMW4gaFx1MDBFM3kgeGVtIGhcdTAxQjBcdTFFREJuZyBkXHUxRUFCbiB2XHUxRUMxIHZpXHUxRUM3YyAqKmNoXHUxRUU5bmcgdGhcdTFFRjFjIFVuaUtleSB2XHUxRURCaSBjaFx1MUVFRiBrXHUwMEZEIFx1MDExMWlcdTFFQzduIHRcdTFFRUQqKiBcdTAxMTFcdTFFQzMgY2hcdTFFQUZjIGNoXHUxRUFGbiBiXHUxRUExbiBcdTAxMTFhbmcgZFx1MDBGOW5nIGJcdTFFQTNuIFVuaUtleSBzXHUxRUExY2gsIHh1XHUxRUE1dCBwaFx1MDBFMXQgdFx1MUVFQiB0XHUwMEUxYyBnaVx1MUVBMy5cblxuIyMjIFVuaUtleSA0LjMgUkM1XG5cblx1MDExMFx1MDBFMnkgbFx1MDBFMCBwaGlcdTAwRUFuIGJcdTFFQTNuIFVuaUtleSBtXHUxRURCaSBuaFx1MUVBNXQuXG5cbiogQ1x1MDBFMWMgdGhheSBcdTAxMTFcdTFFRDVpIGNcdTFFQTNpIHRpXHUxRUJGbiBjXHUxRUU3YSBwaGlcdTAwRUFuIGJcdTFFQTNuIG5cdTAwRTB5OiBbWGVtIHRcdTFFQTFpIFx1MDExMVx1MDBFMnldKC8pXG4qIFtVbmlLZXkgNC4zIFJDNSwgNjQgYml0LCBaSVAgZmlsZV0oLyk6IEJ1aWxkIDIwMDkyOS4gSFx1MUVENyB0clx1MUVFMyBXaW5kb3dzIDY0LWJpdC5cbiogW1VuaUtleSA0LjMgUkM1LCAzMiBiaXQsIFpJUCBmaWxlXSgvKTogQnVpbGQgMjAwOTI5LiBIXHUxRUQ3IHRyXHUxRUUzIFdpbmRvd3MgMzItYml0IHZcdTAwRTAgNjQtYml0LlxuKiBOXHUxRUJGdSBiXHUxRUExbiB0XHUwMEVDbSB0aFx1MUVBNXkgbFx1MUVEN2kgdHJvbmcgVW5pS2V5LCBbeGluIGhcdTAwRTN5IGJcdTAwRTFvIGxcdTFFRDdpIHRcdTFFQTFpIFx1MDExMVx1MDBFMnldKC8pLlxuXG4jIyMgVW5pS2V5IDQuMyBSQzRcblxuXHUwMTEwXHUwMEUyeSBsXHUwMEUwIHBoaVx1MDBFQW4gYlx1MUVBM24gY1x1MDE2OSwgXHUxRUQ1biBcdTAxMTFcdTFFQ0JuaCwgXHUwMTExXHUwMUIwXHUxRUUzYyBwaFx1MDBFMXQgaFx1MDBFMG5oIHRcdTFFRUIgdGhcdTAwRTFuZyA3LCBuXHUwMTAzbSAyMDE4LlxuXG4qIFtVbmlLZXkgNC4zIFJDNCwgNjQgYml0LCBaSVAgZmlsZV0oLyk6IEJ1aWxkIDE4MDcxNC4gSFx1MUVENyB0clx1MUVFMyBXaW5kb3dzIDY0LWJpdC5cbiogW1VuaUtleSA0LjMgUkM0LCAzMiBiaXQsIFpJUCBmaWxlXSgvKTogQnVpbGQgMTgwNzE0LiBIXHUxRUQ3IHRyXHUxRUUzIFdpbmRvd3MgMzItYml0LlxuXG4jIyMgVVZDb252ZXJ0ZXJcblxuVVZDb252ZXJ0ZXIgbFx1MDBFMCBtXHUxRUQ5dCBjaFx1MDFCMFx1MDFBMW5nIHRyXHUwMEVDbmggZFx1MDBGMm5nIGxcdTFFQzduaCBcdTAxMTFhIG5cdTAxMDNuZyBkXHUwMEY5bmcgXHUwMTExXHUxRUMzIGNodXlcdTFFQzNuIFx1MDExMVx1MUVENWkgZ2lcdTFFRUZhIGNcdTAwRTFjIGJcdTFFQTNuZyBtXHUwMEUzIHRpXHUxRUJGbmcgVmlcdTFFQzd0IGtoXHUwMEUxYyBuaGF1LihVbmljb2RlLCBVVEY4LCBUQ1ZOMywgVk5JXHUyMDI2KVxuXG5VVkNvbnZlcnRlciBjXHUwMEYzIGNcdTAwRTFjIHBoaVx1MDBFQW4gYlx1MUVBM24gZFx1MDBFMG5oIGNobyBXaW5kb3dzIHZcdTAwRTAgTGludXguXG5cbltVVkNvbnZlcnRlciAxLjEuM2IgZm9yIFdpbmRvd3MgKDEyIEtCKV0oLykuXG5bVVZDb252ZXJ0ZXIgZm9yIExpbnV4XSgvKVxuXG5gIiwgImV4cG9ydCB7IGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudCwgbW90aW9uIH0gZnJvbSAnLi9yZW5kZXIvZG9tL21vdGlvbi5tanMnO1xuZXhwb3J0IHsgbSB9IGZyb20gJy4vcmVuZGVyL2RvbS9tb3Rpb24tbWluaW1hbC5tanMnO1xuZXhwb3J0IHsgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnLi9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS9pbmRleC5tanMnO1xuZXhwb3J0IHsgQW5pbWF0ZVNoYXJlZExheW91dCB9IGZyb20gJy4vY29tcG9uZW50cy9BbmltYXRlU2hhcmVkTGF5b3V0Lm1qcyc7XG5leHBvcnQgeyBNb3Rpb25Db25maWcgfSBmcm9tICcuL2NvbXBvbmVudHMvTW90aW9uQ29uZmlnL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBMYXp5TW90aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0xhenlNb3Rpb24vaW5kZXgubWpzJztcbmV4cG9ydCB7IExheW91dEdyb3VwIH0gZnJvbSAnLi9jb21wb25lbnRzL0xheW91dEdyb3VwL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBSZW9yZGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL1Jlb3JkZXIvaW5kZXgubWpzJztcbmV4cG9ydCB7IGRvbUFuaW1hdGlvbiB9IGZyb20gJy4vcmVuZGVyL2RvbS9mZWF0dXJlcy1hbmltYXRpb24ubWpzJztcbmV4cG9ydCB7IGRvbU1heCB9IGZyb20gJy4vcmVuZGVyL2RvbS9mZWF0dXJlcy1tYXgubWpzJztcbmV4cG9ydCB7IHVzZU1vdGlvblZhbHVlIH0gZnJvbSAnLi92YWx1ZS91c2UtbW90aW9uLXZhbHVlLm1qcyc7XG5leHBvcnQgeyB1c2VNb3Rpb25UZW1wbGF0ZSB9IGZyb20gJy4vdmFsdWUvdXNlLW1vdGlvbi10ZW1wbGF0ZS5tanMnO1xuZXhwb3J0IHsgTW90aW9uVmFsdWUsIG1vdGlvblZhbHVlIH0gZnJvbSAnLi92YWx1ZS9pbmRleC5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZU1vdGlvblZhbHVlIH0gZnJvbSAnLi92YWx1ZS91dGlscy9yZXNvbHZlLW1vdGlvbi12YWx1ZS5tanMnO1xuZXhwb3J0IHsgdXNlVHJhbnNmb3JtIH0gZnJvbSAnLi92YWx1ZS91c2UtdHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyB1c2VTcHJpbmcgfSBmcm9tICcuL3ZhbHVlL3VzZS1zcHJpbmcubWpzJztcbmV4cG9ydCB7IHVzZVZlbG9jaXR5IH0gZnJvbSAnLi92YWx1ZS91c2UtdmVsb2NpdHkubWpzJztcbmV4cG9ydCB7IHVzZUVsZW1lbnRTY3JvbGwgfSBmcm9tICcuL3ZhbHVlL3Njcm9sbC91c2UtZWxlbWVudC1zY3JvbGwubWpzJztcbmV4cG9ydCB7IHVzZVZpZXdwb3J0U2Nyb2xsIH0gZnJvbSAnLi92YWx1ZS9zY3JvbGwvdXNlLXZpZXdwb3J0LXNjcm9sbC5tanMnO1xuZXhwb3J0IHsgdXNlVGltZSB9IGZyb20gJy4vdmFsdWUvdXNlLXRpbWUubWpzJztcbmV4cG9ydCB7IHVzZVJlZHVjZWRNb3Rpb24sIHVzZVJlZHVjZWRNb3Rpb25Db25maWcgfSBmcm9tICcuL3V0aWxzL3VzZS1yZWR1Y2VkLW1vdGlvbi5tanMnO1xuZXhwb3J0IHsgYW5pbWF0aW9uQ29udHJvbHMgfSBmcm9tICcuL2FuaW1hdGlvbi9hbmltYXRpb24tY29udHJvbHMubWpzJztcbmV4cG9ydCB7IHVzZUFuaW1hdGlvbiB9IGZyb20gJy4vYW5pbWF0aW9uL3VzZS1hbmltYXRpb24ubWpzJztcbmV4cG9ydCB7IHVzZUFuaW1hdGlvbkZyYW1lIH0gZnJvbSAnLi91dGlscy91c2UtYW5pbWF0aW9uLWZyYW1lLm1qcyc7XG5leHBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi9hbmltYXRpb24vYW5pbWF0ZS5tanMnO1xuZXhwb3J0IHsgYW5pbWF0ZVZpc3VhbEVsZW1lbnQgfSBmcm9tICcuL3JlbmRlci91dGlscy9hbmltYXRpb24ubWpzJztcbmV4cG9ydCB7IHVzZUN5Y2xlIH0gZnJvbSAnLi91dGlscy91c2UtY3ljbGUubWpzJztcbmV4cG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gJy4vdXRpbHMvdHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyBpc1ZhbGlkTW90aW9uUHJvcCB9IGZyb20gJy4vbW90aW9uL3V0aWxzL3ZhbGlkLXByb3AubWpzJztcbmV4cG9ydCB7IHVzZUlzUHJlc2VudCwgdXNlUHJlc2VuY2UgfSBmcm9tICcuL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL3VzZS1wcmVzZW5jZS5tanMnO1xuZXhwb3J0IHsgRHJhZ0NvbnRyb2xzLCB1c2VEcmFnQ29udHJvbHMgfSBmcm9tICcuL2dlc3R1cmVzL2RyYWcvdXNlLWRyYWctY29udHJvbHMubWpzJztcbmV4cG9ydCB7IHVzZURvbUV2ZW50IH0gZnJvbSAnLi9ldmVudHMvdXNlLWRvbS1ldmVudC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlTW90aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9tb3Rpb24vaW5kZXgubWpzJztcbmV4cG9ydCB7IHZpc3VhbEVsZW1lbnQgfSBmcm9tICcuL3JlbmRlci9pbmRleC5tanMnO1xuZXhwb3J0IHsgYWRkU2NhbGVDb3JyZWN0b3IgfSBmcm9tICcuL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzJztcbmV4cG9ydCB7IHVzZUluc3RhbnRUcmFuc2l0aW9uIH0gZnJvbSAnLi91dGlscy91c2UtaW5zdGFudC10cmFuc2l0aW9uLm1qcyc7XG5leHBvcnQgeyB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbiB9IGZyb20gJy4vcHJvamVjdGlvbi91c2UtaW5zdGFudC1sYXlvdXQtdHJhbnNpdGlvbi5tanMnO1xuZXhwb3J0IHsgdXNlUmVzZXRQcm9qZWN0aW9uIH0gZnJvbSAnLi9wcm9qZWN0aW9uL3VzZS1yZXNldC1wcm9qZWN0aW9uLm1qcyc7XG5leHBvcnQgeyBNb3Rpb25Db250ZXh0LCB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCB9IGZyb20gJy4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5leHBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmV4cG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcbmV4cG9ydCB7IExheW91dEdyb3VwQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzJztcbmV4cG9ydCB7IERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuL2NvbnRleHQvRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dC5tanMnO1xuZXhwb3J0IHsgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0L1N3aXRjaExheW91dEdyb3VwQ29udGV4dC5tanMnO1xuZXhwb3J0IHsgRmxhdFRyZWUgfSBmcm9tICcuL3JlbmRlci91dGlscy9mbGF0LXRyZWUubWpzJztcbmV4cG9ydCB7IHVzZUFuaW1hdGVkU3RhdGUgYXMgdXNlRGVwcmVjYXRlZEFuaW1hdGVkU3RhdGUgfSBmcm9tICcuL2FuaW1hdGlvbi91c2UtYW5pbWF0ZWQtc3RhdGUubWpzJztcbmV4cG9ydCB7IHVzZUludmVydGVkU2NhbGUgYXMgdXNlRGVwcmVjYXRlZEludmVydGVkU2NhbGUgfSBmcm9tICcuL3ZhbHVlL3VzZS1pbnZlcnRlZC1zY2FsZS5tanMnO1xuZXhwb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4vcmVuZGVyL3V0aWxzL3R5cGVzLm1qcyc7XG5leHBvcnQgeyBhbmltYXRpb25zIH0gZnJvbSAnLi9tb3Rpb24vZmVhdHVyZXMvYW5pbWF0aW9ucy5tanMnO1xuZXhwb3J0IHsgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMgfSBmcm9tICcuL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVCb3ggfSBmcm9tICcuL3Byb2plY3Rpb24vZ2VvbWV0cnkvbW9kZWxzLm1qcyc7XG5leHBvcnQgeyBjYWxjTGVuZ3RoIH0gZnJvbSAnLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcbmV4cG9ydCB7IGZpbHRlclByb3BzIH0gZnJvbSAnLi9yZW5kZXIvZG9tL3V0aWxzL2ZpbHRlci1wcm9wcy5tanMnO1xuZXhwb3J0IHsgbWFrZVVzZVZpc3VhbFN0YXRlIH0gZnJvbSAnLi9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanMnO1xuZXhwb3J0IHsgaXNEcmFnQWN0aXZlIH0gZnJvbSAnLi9nZXN0dXJlcy9kcmFnL3V0aWxzL2xvY2subWpzJztcbmV4cG9ydCB7IGFkZFBvaW50ZXJFdmVudCB9IGZyb20gJy4vZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qcyc7XG5leHBvcnQgeyB3cmFwSGFuZGxlciB9IGZyb20gJy4vZXZlbnRzL2V2ZW50LWluZm8ubWpzJztcbmV4cG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuZXhwb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi91dGlscy9pcy1icm93c2VyLm1qcyc7XG5leHBvcnQgeyB1c2VVbm1vdW50RWZmZWN0IH0gZnJvbSAnLi91dGlscy91c2UtdW5tb3VudC1lZmZlY3QubWpzJztcbmV4cG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanMnO1xuZXhwb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tICcuL3V0aWxzL3VzZS1mb3JjZS11cGRhdGUubWpzJztcbiIsICJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGNyZWF0ZU1vdGlvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL21vdGlvbi9pbmRleC5tanMnO1xuaW1wb3J0IHsgY3JlYXRlTW90aW9uUHJveHkgfSBmcm9tICcuL21vdGlvbi1wcm94eS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlRG9tTW90aW9uQ29uZmlnIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtY29uZmlnLm1qcyc7XG5pbXBvcnQgeyBnZXN0dXJlQW5pbWF0aW9ucyB9IGZyb20gJy4uLy4uL21vdGlvbi9mZWF0dXJlcy9nZXN0dXJlcy5tanMnO1xuaW1wb3J0IHsgYW5pbWF0aW9ucyB9IGZyb20gJy4uLy4uL21vdGlvbi9mZWF0dXJlcy9hbmltYXRpb25zLm1qcyc7XG5pbXBvcnQgeyBkcmFnIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2RyYWcubWpzJztcbmltcG9ydCB7IGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgfSBmcm9tICcuL2NyZWF0ZS12aXN1YWwtZWxlbWVudC5tanMnO1xuaW1wb3J0IHsgbGF5b3V0RmVhdHVyZXMgfSBmcm9tICcuLi8uLi9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIVE1MUHJvamVjdGlvbk5vZGUgfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL25vZGUvSFRNTFByb2plY3Rpb25Ob2RlLm1qcyc7XG5cbnZhciBmZWF0dXJlQnVuZGxlID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGFuaW1hdGlvbnMpLCBnZXN0dXJlQW5pbWF0aW9ucyksIGRyYWcpLCBsYXlvdXRGZWF0dXJlcyk7XG4vKipcbiAqIEhUTUwgJiBTVkcgY29tcG9uZW50cywgb3B0aW1pc2VkIGZvciB1c2Ugd2l0aCBnZXN0dXJlcyBhbmQgYW5pbWF0aW9uLiBUaGVzZSBjYW4gYmUgdXNlZCBhc1xuICogZHJvcC1pbiByZXBsYWNlbWVudHMgZm9yIGFueSBIVE1MICYgU1ZHIGNvbXBvbmVudCwgYWxsIENTUyAmIFNWRyBwcm9wZXJ0aWVzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgbW90aW9uID0gLypAX19QVVJFX18qLyBjcmVhdGVNb3Rpb25Qcm94eShmdW5jdGlvbiAoQ29tcG9uZW50LCBjb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlRG9tTW90aW9uQ29uZmlnKENvbXBvbmVudCwgY29uZmlnLCBmZWF0dXJlQnVuZGxlLCBjcmVhdGVEb21WaXN1YWxFbGVtZW50LCBIVE1MUHJvamVjdGlvbk5vZGUpO1xufSk7XG4vKipcbiAqIENyZWF0ZSBhIERPTSBgbW90aW9uYCBjb21wb25lbnQgd2l0aCB0aGUgcHJvdmlkZWQgc3RyaW5nLiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZFxuICogYXMgYSBmdWxsIGFsdGVybmF0aXZlIHRvIGBtb3Rpb25gIGZvciBjb25zdW1lcnMgd2hvIGhhdmUgdG8gc3VwcG9ydCBlbnZpcm9ubWVudHMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBgUHJveHlgLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudCB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBjb25zdCBtb3Rpb24gPSB7XG4gKiAgIGRpdjogY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50KCdkaXYnKVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVEb21Nb3Rpb25Db21wb25lbnQoa2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChjcmVhdGVEb21Nb3Rpb25Db25maWcoa2V5LCB7IGZvcndhcmRNb3Rpb25Qcm9wczogZmFsc2UgfSwgZmVhdHVyZUJ1bmRsZSwgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCwgSFRNTFByb2plY3Rpb25Ob2RlKSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudCwgbW90aW9uIH07XG4iLCAiaW1wb3J0IHRzbGliIGZyb20gJy4uL3RzbGliLmpzJztcclxuY29uc3Qge1xyXG4gICAgX19leHRlbmRzLFxyXG4gICAgX19hc3NpZ24sXHJcbiAgICBfX3Jlc3QsXHJcbiAgICBfX2RlY29yYXRlLFxyXG4gICAgX19wYXJhbSxcclxuICAgIF9fbWV0YWRhdGEsXHJcbiAgICBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcixcclxuICAgIF9fZXhwb3J0U3RhcixcclxuICAgIF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fdmFsdWVzLFxyXG4gICAgX19yZWFkLFxyXG4gICAgX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5cyxcclxuICAgIF9fc3ByZWFkQXJyYXksXHJcbiAgICBfX2F3YWl0LFxyXG4gICAgX19hc3luY0dlbmVyYXRvcixcclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IsXHJcbiAgICBfX2FzeW5jVmFsdWVzLFxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QsXHJcbiAgICBfX2ltcG9ydFN0YXIsXHJcbiAgICBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxufSA9IHRzbGliO1xyXG5leHBvcnQge1xyXG4gICAgX19leHRlbmRzLFxyXG4gICAgX19hc3NpZ24sXHJcbiAgICBfX3Jlc3QsXHJcbiAgICBfX2RlY29yYXRlLFxyXG4gICAgX19wYXJhbSxcclxuICAgIF9fbWV0YWRhdGEsXHJcbiAgICBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcixcclxuICAgIF9fZXhwb3J0U3RhcixcclxuICAgIF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fdmFsdWVzLFxyXG4gICAgX19yZWFkLFxyXG4gICAgX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5cyxcclxuICAgIF9fc3ByZWFkQXJyYXksXHJcbiAgICBfX2F3YWl0LFxyXG4gICAgX19hc3luY0dlbmVyYXRvcixcclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IsXHJcbiAgICBfX2FzeW5jVmFsdWVzLFxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QsXHJcbiAgICBfX2ltcG9ydFN0YXIsXHJcbiAgICBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxufTtcclxuIiwgImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZlYXR1cmVzIH0gZnJvbSAnLi9mZWF0dXJlcy91c2UtZmVhdHVyZXMubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbnRleHQvaW5kZXgubWpzJztcbmltcG9ydCB7IHVzZVZpc3VhbEVsZW1lbnQgfSBmcm9tICcuL3V0aWxzL3VzZS12aXN1YWwtZWxlbWVudC5tanMnO1xuaW1wb3J0IHsgdXNlTW90aW9uUmVmIH0gZnJvbSAnLi91dGlscy91c2UtbW90aW9uLXJlZi5tanMnO1xuaW1wb3J0IHsgdXNlQ3JlYXRlTW90aW9uQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUubWpzJztcbmltcG9ydCB7IGxvYWRGZWF0dXJlcywgZmVhdHVyZURlZmluaXRpb25zIH0gZnJvbSAnLi9mZWF0dXJlcy9kZWZpbml0aW9ucy5tanMnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi4vdXRpbHMvaXMtYnJvd3Nlci5tanMnO1xuaW1wb3J0IHsgdXNlUHJvamVjdGlvbklkIH0gZnJvbSAnLi4vcHJvamVjdGlvbi9ub2RlL2lkLm1qcyc7XG5pbXBvcnQgeyBMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgdXNlUHJvamVjdGlvbiB9IGZyb20gJy4vZmVhdHVyZXMvdXNlLXByb2plY3Rpb24ubWpzJztcbmltcG9ydCB7IFZpc3VhbEVsZW1lbnRIYW5kbGVyIH0gZnJvbSAnLi91dGlscy9WaXN1YWxFbGVtZW50SGFuZGxlci5tanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGBtb3Rpb25gIGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYSBDb21wb25lbnQgYXJndW1lbnQsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgKGllIFwiZGl2XCJcbiAqIGZvciBgbW90aW9uLmRpdmApLCBvciBhbiBhY3R1YWwgUmVhY3QgY29tcG9uZW50LlxuICpcbiAqIEFsb25nc2lkZSB0aGlzIGlzIGEgY29uZmlnIG9wdGlvbiB3aGljaCBwcm92aWRlcyBhIHdheSBvZiByZW5kZXJpbmcgdGhlIHByb3ZpZGVkXG4gKiBjb21wb25lbnQgXCJvZmZsaW5lXCIsIG9yIG91dHNpZGUgdGhlIFJlYWN0IHJlbmRlciBjeWNsZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW90aW9uQ29tcG9uZW50KF9hKSB7XG4gICAgdmFyIHByZWxvYWRlZEZlYXR1cmVzID0gX2EucHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQgPSBfYS5jcmVhdGVWaXN1YWxFbGVtZW50LCBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yID0gX2EucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgdXNlUmVuZGVyID0gX2EudXNlUmVuZGVyLCB1c2VWaXN1YWxTdGF0ZSA9IF9hLnVzZVZpc3VhbFN0YXRlLCBDb21wb25lbnQgPSBfYS5Db21wb25lbnQ7XG4gICAgcHJlbG9hZGVkRmVhdHVyZXMgJiYgbG9hZEZlYXR1cmVzKHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgICBmdW5jdGlvbiBNb3Rpb25Db21wb25lbnQocHJvcHMsIGV4dGVybmFsUmVmKSB7XG4gICAgICAgIHZhciBsYXlvdXRJZCA9IHVzZUxheW91dElkKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMpLCB7IGxheW91dElkOiBsYXlvdXRJZCB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIHJlbmRlcmluZyBpbiBhIHN0YXRpYyBlbnZpcm9ubWVudCwgd2Ugb25seSB2aXN1YWxseSB1cGRhdGUgdGhlIGNvbXBvbmVudFxuICAgICAgICAgKiBhcyBhIHJlc3VsdCBvZiBhIFJlYWN0LXJlcmVuZGVyIHJhdGhlciB0aGFuIGludGVyYWN0aW9ucyBvciBhbmltYXRpb25zLiBUaGlzXG4gICAgICAgICAqIG1lYW5zIHdlIGRvbid0IG5lZWQgdG8gbG9hZCBhZGRpdGlvbmFsIG1lbW9yeSBzdHJ1Y3R1cmVzIGxpa2UgVmlzdWFsRWxlbWVudCxcbiAgICAgICAgICogb3IgYW55IGdlc3R1cmUvYW5pbWF0aW9uIGZlYXR1cmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNvbmZpZyA9IHVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCk7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IG51bGw7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdXNlQ3JlYXRlTW90aW9uQ29udGV4dChwcm9wcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB1bmlxdWUgcHJvamVjdGlvbiBJRCBmb3IgdGhpcyBjb21wb25lbnQuIElmIGEgbmV3IGNvbXBvbmVudCBpcyBhZGRlZFxuICAgICAgICAgKiBkdXJpbmcgYSBsYXlvdXQgYW5pbWF0aW9uIHdlJ2xsIHVzZSB0aGlzIHRvIHF1ZXJ5IHRoZSBET00gYW5kIGh5ZHJhdGUgaXRzIHJlZiBlYXJseSwgYWxsb3dpbmdcbiAgICAgICAgICogdXMgdG8gbWVhc3VyZSBpdCBhcyBzb29uIGFzIGFueSBsYXlvdXQgZWZmZWN0IGZsdXNoZXMgcGVuZGluZyBsYXlvdXQgYW5pbWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogUGVyZm9ybWFuY2Ugbm90ZTogSXQnZCBiZSBiZXR0ZXIgbm90IHRvIGhhdmUgdG8gc2VhcmNoIHRoZSBET00gZm9yIHRoZXNlIGVsZW1lbnRzLlxuICAgICAgICAgKiBGb3IgbmV3bHktZW50ZXJpbmcgY29tcG9uZW50cyBpdCBjb3VsZCBiZSBlbm91Z2ggdG8gb25seSBjb3JyZWN0IHRyZWVTY2FsZSwgaW4gd2hpY2hcbiAgICAgICAgICogY2FzZSB3ZSBjb3VsZCBtb3VudCBpbiBhIHNjYWxlLWNvcnJlY3Rpb24gbW9kZS4gVGhpcyB3b3VsZG4ndCBiZSBlbm91Z2ggZm9yXG4gICAgICAgICAqIHNoYXJlZCBlbGVtZW50IHRyYW5zaXRpb25zIGhvd2V2ZXIuIFBlcmhhcHMgZm9yIHRob3NlIHdlIGNvdWxkIHJldmVydCB0byBhIHJvb3Qgbm9kZVxuICAgICAgICAgKiB0aGF0IGdldHMgZm9yY2VSZW5kZXJlZCBhbmQgbGF5b3V0IGFuaW1hdGlvbnMgYXJlIHRyaWdnZXJlZCBvbiBpdHMgbGF5b3V0IGVmZmVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBwcm9qZWN0aW9uSWQgPSBjb25maWcuaXNTdGF0aWMgPyB1bmRlZmluZWQgOiB1c2VQcm9qZWN0aW9uSWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdmlzdWFsU3RhdGUgPSB1c2VWaXN1YWxTdGF0ZShwcm9wcywgY29uZmlnLmlzU3RhdGljKTtcbiAgICAgICAgaWYgKCFjb25maWcuaXNTdGF0aWMgJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZSBhIFZpc3VhbEVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50LiBBIFZpc3VhbEVsZW1lbnQgcHJvdmlkZXMgYSBjb21tb25cbiAgICAgICAgICAgICAqIGludGVyZmFjZSB0byByZW5kZXJlci1zcGVjaWZpYyBBUElzIChpZSBET00vVGhyZWUuanMgZXRjKSBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgKiBwcm92aWRpbmcgYSB3YXkgb2YgcmVuZGVyaW5nIHRvIHRoZXNlIEFQSXMgb3V0c2lkZSBvZiB0aGUgUmVhY3QgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgICAqIGZvciBtb3JlIHBlcmZvcm1hbnQgYW5pbWF0aW9ucyBhbmQgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnRleHQudmlzdWFsRWxlbWVudCA9IHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB2aXN1YWxTdGF0ZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbmZpZyksIHByb3BzKSwgY3JlYXRlVmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICB1c2VQcm9qZWN0aW9uKHByb2plY3Rpb25JZCwgcHJvcHMsIGNvbnRleHQudmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciB8fFxuICAgICAgICAgICAgICAgIGZlYXR1cmVEZWZpbml0aW9ucy5wcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTG9hZCBNb3Rpb24gZ2VzdHVyZSBhbmQgYW5pbWF0aW9uIGZlYXR1cmVzLiBUaGVzZSBhcmUgcmVuZGVyZWQgYXMgcmVuZGVybGVzc1xuICAgICAgICAgICAgICogY29tcG9uZW50cyBzbyBlYWNoIGZlYXR1cmUgY2FuIG9wdGlvbmFsbHkgbWFrZSB1c2Ugb2YgUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZlYXR1cmVzID0gdXNlRmVhdHVyZXMocHJvcHMsIGNvbnRleHQudmlzdWFsRWxlbWVudCwgcHJlbG9hZGVkRmVhdHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW91bnQgb3JkZXIgYW5kIGhpZXJhcmNoeSBpcyBzcGVjaWZpYyB0byBlbnN1cmUgb3VyIGVsZW1lbnQgcmVmXG4gICAgICAgICAqIGlzIGh5ZHJhdGVkIGJ5IHRoZSB0aW1lIGZlYXR1cmVzIGZpcmUgdGhlaXIgZWZmZWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChWaXN1YWxFbGVtZW50SGFuZGxlciwgeyB2aXN1YWxFbGVtZW50OiBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIHByb3BzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29uZmlnKSwgcHJvcHMpIH0sXG4gICAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW90aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCB1c2VSZW5kZXIoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCB1c2VNb3Rpb25SZWYodmlzdWFsU3RhdGUsIGNvbnRleHQudmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpLCB2aXN1YWxTdGF0ZSwgY29uZmlnLmlzU3RhdGljLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZm9yd2FyZFJlZihNb3Rpb25Db21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0SWQoX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIGxheW91dElkID0gX2EubGF5b3V0SWQ7XG4gICAgdmFyIGxheW91dEdyb3VwSWQgPSAoX2IgPSB1c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZDtcbiAgICByZXR1cm4gbGF5b3V0R3JvdXBJZCAmJiBsYXlvdXRJZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGF5b3V0R3JvdXBJZCArIFwiLVwiICsgbGF5b3V0SWRcbiAgICAgICAgOiBsYXlvdXRJZDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTW90aW9uQ29tcG9uZW50IH07XG4iLCAiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmVhdHVyZURlZmluaXRpb25zIH0gZnJvbSAnLi9kZWZpbml0aW9ucy5tanMnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgeyBMYXp5Q29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvTGF6eUNvbnRleHQubWpzJztcblxudmFyIGZlYXR1cmVOYW1lcyA9IE9iamVjdC5rZXlzKGZlYXR1cmVEZWZpbml0aW9ucyk7XG52YXIgbnVtRmVhdHVyZXMgPSBmZWF0dXJlTmFtZXMubGVuZ3RoO1xuLyoqXG4gKiBMb2FkIGZlYXR1cmVzIHZpYSByZW5kZXJsZXNzIGNvbXBvbmVudHMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIE1vdGlvblByb3BzLlxuICovXG5mdW5jdGlvbiB1c2VGZWF0dXJlcyhwcm9wcywgdmlzdWFsRWxlbWVudCwgcHJlbG9hZGVkRmVhdHVyZXMpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICB2YXIgbGF6eUNvbnRleHQgPSB1c2VDb250ZXh0KExhenlDb250ZXh0KTtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIGluIGRldmVsb3BtZW50IG1vZGUsIGNoZWNrIHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3QgcmVuZGVyaW5nIGEgbW90aW9uIGNvbXBvbmVudFxuICAgICAqIGFzIGEgY2hpbGQgb2YgTGF6eU1vdGlvbiwgYXMgdGhpcyB3aWxsIGJyZWFrIHRoZSBmaWxlLXNpemUgYmVuZWZpdHMgb2YgdXNpbmcgaXQuXG4gICAgICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJlxuICAgICAgICBwcmVsb2FkZWRGZWF0dXJlcyAmJlxuICAgICAgICBsYXp5Q29udGV4dC5zdHJpY3QpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCBcIllvdSBoYXZlIHJlbmRlcmVkIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGhpbiBhIGBMYXp5TW90aW9uYCBjb21wb25lbnQuIFRoaXMgd2lsbCBicmVhayB0cmVlIHNoYWtpbmcuIEltcG9ydCBhbmQgcmVuZGVyIGEgYG1gIGNvbXBvbmVudCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GZWF0dXJlczsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSBmZWF0dXJlTmFtZXNbaV07XG4gICAgICAgIHZhciBfYSA9IGZlYXR1cmVEZWZpbml0aW9uc1tuYW1lXzFdLCBpc0VuYWJsZWQgPSBfYS5pc0VuYWJsZWQsIENvbXBvbmVudCA9IF9hLkNvbXBvbmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IG1pZ2h0IGJlIHBvc3NpYmxlIGluIHRoZSBmdXR1cmUgdG8gdXNlIHRoaXMgbW9tZW50IHRvXG4gICAgICAgICAqIGR5bmFtaWNhbGx5IHJlcXVlc3QgZnVuY3Rpb25hbGl0eS4gSW4gaW5pdGlhbCB0ZXN0cyB0aGlzXG4gICAgICAgICAqIHdhcyBwcm9kdWNpbmcgYSBsb3Qgb2YgZHVwbGljYXRpb24gYW1vbmdzdCBidW5kbGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzRW5hYmxlZChwcm9wcykgJiYgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfX2Fzc2lnbih7IGtleTogbmFtZV8xIH0sIHByb3BzLCB7IHZpc3VhbEVsZW1lbnQ6IHZpc3VhbEVsZW1lbnQgfSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmV4cG9ydCB7IHVzZUZlYXR1cmVzIH07XG4iLCAidmFyIGNyZWF0ZURlZmluaXRpb24gPSBmdW5jdGlvbiAocHJvcE5hbWVzKSB7IHJldHVybiAoe1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBwcm9wTmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gISFwcm9wc1tuYW1lXTsgfSk7IH0sXG59KTsgfTtcbnZhciBmZWF0dXJlRGVmaW5pdGlvbnMgPSB7XG4gICAgbWVhc3VyZUxheW91dDogY3JlYXRlRGVmaW5pdGlvbihbXCJsYXlvdXRcIiwgXCJsYXlvdXRJZFwiLCBcImRyYWdcIl0pLFxuICAgIGFuaW1hdGlvbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgICAgIFwiYW5pbWF0ZVwiLFxuICAgICAgICBcImV4aXRcIixcbiAgICAgICAgXCJ2YXJpYW50c1wiLFxuICAgICAgICBcIndoaWxlSG92ZXJcIixcbiAgICAgICAgXCJ3aGlsZVRhcFwiLFxuICAgICAgICBcIndoaWxlRm9jdXNcIixcbiAgICAgICAgXCJ3aGlsZURyYWdcIixcbiAgICAgICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIF0pLFxuICAgIGV4aXQ6IGNyZWF0ZURlZmluaXRpb24oW1wiZXhpdFwiXSksXG4gICAgZHJhZzogY3JlYXRlRGVmaW5pdGlvbihbXCJkcmFnXCIsIFwiZHJhZ0NvbnRyb2xzXCJdKSxcbiAgICBmb2N1czogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUZvY3VzXCJdKSxcbiAgICBob3ZlcjogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUhvdmVyXCIsIFwib25Ib3ZlclN0YXJ0XCIsIFwib25Ib3ZlckVuZFwiXSksXG4gICAgdGFwOiBjcmVhdGVEZWZpbml0aW9uKFtcIndoaWxlVGFwXCIsIFwib25UYXBcIiwgXCJvblRhcFN0YXJ0XCIsIFwib25UYXBDYW5jZWxcIl0pLFxuICAgIHBhbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgICAgIFwib25QYW5cIixcbiAgICAgICAgXCJvblBhblN0YXJ0XCIsXG4gICAgICAgIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgICAgICAgXCJvblBhbkVuZFwiLFxuICAgIF0pLFxuICAgIGluVmlldzogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgICAgIFwid2hpbGVJblZpZXdcIixcbiAgICAgICAgXCJvblZpZXdwb3J0RW50ZXJcIixcbiAgICAgICAgXCJvblZpZXdwb3J0TGVhdmVcIixcbiAgICBdKSxcbn07XG5mdW5jdGlvbiBsb2FkRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmVhdHVyZXMpIHtcbiAgICAgICAgaWYgKGZlYXR1cmVzW2tleV0gPT09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGZlYXR1cmVEZWZpbml0aW9ucy5wcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yID0gZmVhdHVyZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZlYXR1cmVEZWZpbml0aW9uc1trZXldLkNvbXBvbmVudCA9IGZlYXR1cmVzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGZlYXR1cmVEZWZpbml0aW9ucywgbG9hZEZlYXR1cmVzIH07XG4iLCAidmFyIHdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7IH07XHJcbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gKGNoZWNrLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGVjayAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoY2hlY2ssIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIWNoZWNrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmV4cG9ydCB7IGludmFyaWFudCwgd2FybmluZyB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBMYXp5Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoeyBzdHJpY3Q6IGZhbHNlIH0pO1xuXG5leHBvcnQgeyBMYXp5Q29udGV4dCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG52YXIgTW90aW9uQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIHRyYW5zZm9ybVBhZ2VQb2ludDogZnVuY3Rpb24gKHApIHsgcmV0dXJuIHA7IH0sXG4gICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgIHJlZHVjZWRNb3Rpb246IFwibmV2ZXJcIixcbn0pO1xuXG5leHBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxudmFyIE1vdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpLnZpc3VhbEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IE1vdGlvbkNvbnRleHQsIHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0IH07XG4iLCAiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcmVzZW5jZUNvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L1ByZXNlbmNlQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgdXNlVmlzdWFsRWxlbWVudENvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L01vdGlvbkNvbnRleHQvaW5kZXgubWpzJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi8uLi91dGlscy91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzJztcbmltcG9ydCB7IExhenlDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9MYXp5Q29udGV4dC5tanMnO1xuaW1wb3J0IHsgdXNlUmVkdWNlZE1vdGlvbkNvbmZpZyB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1yZWR1Y2VkLW1vdGlvbi5tanMnO1xuXG5mdW5jdGlvbiB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIHByb3BzLCBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIGxhenlDb250ZXh0ID0gdXNlQ29udGV4dChMYXp5Q29udGV4dCk7XG4gICAgdmFyIHBhcmVudCA9IHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCk7XG4gICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcbiAgICB2YXIgc2hvdWxkUmVkdWNlTW90aW9uID0gdXNlUmVkdWNlZE1vdGlvbkNvbmZpZygpO1xuICAgIHZhciB2aXN1YWxFbGVtZW50UmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZW4ndCBwcmVsb2FkZWQgYSByZW5kZXJlciwgY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgb25lIGxhenktbG9hZGVkXG4gICAgICovXG4gICAgaWYgKCFjcmVhdGVWaXN1YWxFbGVtZW50KVxuICAgICAgICBjcmVhdGVWaXN1YWxFbGVtZW50ID0gbGF6eUNvbnRleHQucmVuZGVyZXI7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQgJiYgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICAgICAgICB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQgPSBjcmVhdGVWaXN1YWxFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgICAgICAgdmlzdWFsU3RhdGU6IHZpc3VhbFN0YXRlLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICBwcmVzZW5jZUlkOiBwcmVzZW5jZUNvbnRleHQgPT09IG51bGwgfHwgcHJlc2VuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVzZW5jZUNvbnRleHQuaWQsXG4gICAgICAgICAgICBibG9ja0luaXRpYWxBbmltYXRpb246IChwcmVzZW5jZUNvbnRleHQgPT09IG51bGwgfHwgcHJlc2VuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVzZW5jZUNvbnRleHQuaW5pdGlhbCkgPT09IGZhbHNlLFxuICAgICAgICAgICAgc2hvdWxkUmVkdWNlTW90aW9uOiBzaG91bGRSZWR1Y2VNb3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudDtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaW1hdGVDaGFuZ2VzKCk7XG4gICAgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQubm90aWZ5VW5tb3VudCgpOyB9OyB9LCBbXSk7XG4gICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IHVzZVZpc3VhbEVsZW1lbnQgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByZXNlbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmV4cG9ydCB7IFByZXNlbmNlQ29udGV4dCB9O1xuIiwgImltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi9pcy1icm93c2VyLm1qcyc7XG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gaXNCcm93c2VyID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5leHBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH07XG4iLCAidmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG5cbmV4cG9ydCB7IGlzQnJvd3NlciB9O1xuIiwgImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTW90aW9uQ29uZmlnQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvTW90aW9uQ29uZmlnQ29udGV4dC5tanMnO1xuXG4vLyBEb2VzIHRoaXMgZGV2aWNlIHByZWZlciByZWR1Y2VkIG1vdGlvbj8gUmV0dXJucyBgbnVsbGAgc2VydmVyLXNpZGUuXG52YXIgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB7IGN1cnJlbnQ6IG51bGwgfTtcbnZhciBoYXNEZXRlY3RlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCkge1xuICAgIGhhc0RldGVjdGVkID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICB2YXIgbW90aW9uTWVkaWFRdWVyeV8xID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XG4gICAgICAgIHZhciBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBtb3Rpb25NZWRpYVF1ZXJ5XzEubWF0Y2hlcyk7XG4gICAgICAgIH07XG4gICAgICAgIG1vdGlvbk1lZGlhUXVlcnlfMS5hZGRMaXN0ZW5lcihzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMpO1xuICAgICAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEEgaG9vayB0aGF0IHJldHVybnMgYHRydWVgIGlmIHdlIHNob3VsZCBiZSB1c2luZyByZWR1Y2VkIG1vdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBkZXZpY2UncyBSZWR1Y2VkIE1vdGlvbiBzZXR0aW5nLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGNoYW5nZXMgdG8geW91ciBVSSBiYXNlZCBvbiBSZWR1Y2VkIE1vdGlvbi4gRm9yIGluc3RhbmNlLCByZXBsYWNpbmcgbW90aW9uLXNpY2tuZXNzIGluZHVjaW5nXG4gKiBgeGAvYHlgIGFuaW1hdGlvbnMgd2l0aCBgb3BhY2l0eWAsIGRpc2FibGluZyB0aGUgYXV0b3BsYXkgb2YgYmFja2dyb3VuZCB2aWRlb3MsIG9yIHR1cm5pbmcgb2ZmIHBhcmFsbGF4IG1vdGlvbi5cbiAqXG4gKiBJdCB3aWxsIGFjdGl2ZWx5IHJlc3BvbmQgdG8gY2hhbmdlcyBhbmQgcmUtcmVuZGVyIHlvdXIgY29tcG9uZW50cyB3aXRoIHRoZSBsYXRlc3Qgc2V0dGluZy5cbiAqXG4gKiBgYGBqc3hcbiAqIGV4cG9ydCBmdW5jdGlvbiBTaWRlYmFyKHsgaXNPcGVuIH0pIHtcbiAqICAgY29uc3Qgc2hvdWxkUmVkdWNlTW90aW9uID0gdXNlUmVkdWNlZE1vdGlvbigpXG4gKiAgIGNvbnN0IGNsb3NlZFggPSBzaG91bGRSZWR1Y2VNb3Rpb24gPyAwIDogXCItMTAwJVwiXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxtb3Rpb24uZGl2IGFuaW1hdGU9e3tcbiAqICAgICAgIG9wYWNpdHk6IGlzT3BlbiA/IDEgOiAwLFxuICogICAgICAgeDogaXNPcGVuID8gMCA6IGNsb3NlZFhcbiAqICAgICB9fSAvPlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVJlZHVjZWRNb3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogTGF6eSBpbml0aWFsaXNhdGlvbiBvZiBwcmVmZXJzUmVkdWNlZE1vdGlvblxuICAgICAqL1xuICAgICFoYXNEZXRlY3RlZCAmJiBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKTtcbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGUocHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudCksIDEpLCBzaG91bGRSZWR1Y2VNb3Rpb24gPSBfYVswXTtcbiAgICAvKipcbiAgICAgKiBUT0RPIFNlZSBpZiBwZW9wbGUgbWlzcyBhdXRvbWF0aWNhbGx5IHVwZGF0aW5nIHNob3VsZFJlZHVjZU1vdGlvbiBzZXR0aW5nXG4gICAgICovXG4gICAgcmV0dXJuIHNob3VsZFJlZHVjZU1vdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZWRNb3Rpb25Db25maWcoKSB7XG4gICAgdmFyIHJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlID0gdXNlUmVkdWNlZE1vdGlvbigpO1xuICAgIHZhciByZWR1Y2VkTW90aW9uID0gdXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KS5yZWR1Y2VkTW90aW9uO1xuICAgIGlmIChyZWR1Y2VkTW90aW9uID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWR1Y2VkTW90aW9uID09PSBcImFsd2F5c1wiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgdXNlUmVkdWNlZE1vdGlvbiwgdXNlUmVkdWNlZE1vdGlvbkNvbmZpZyB9O1xuIiwgImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNSZWZPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscy9pcy1yZWYtb2JqZWN0Lm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlZiBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaHlkcmF0ZXMgdGhlIHByb3ZpZGVkXG4gKiBleHRlcm5hbCByZWYgYW5kIFZpc3VhbEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgdmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaW5zdGFuY2UgJiYgKChfYSA9IHZpc3VhbFN0YXRlLm1vdW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2aXN1YWxTdGF0ZSwgaW5zdGFuY2UpKTtcbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgPyB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKVxuICAgICAgICAgICAgICAgIDogdmlzdWFsRWxlbWVudC51bm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZihpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZk9iamVjdChleHRlcm5hbFJlZikpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvKipcbiAgICAgKiBPbmx5IHBhc3MgYSBuZXcgcmVmIGNhbGxiYWNrIHRvIFJlYWN0IGlmIHdlJ3ZlIHJlY2VpdmVkIGEgdmlzdWFsIGVsZW1lbnRcbiAgICAgKiBmYWN0b3J5LiBPdGhlcndpc2Ugd2UnbGwgYmUgbW91bnRpbmcvcmVtb3VudGluZyBldmVyeSB0aW1lIGV4dGVybmFsUmVmXG4gICAgICogb3Igb3RoZXIgZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBbdmlzdWFsRWxlbWVudF0pO1xufVxuXG5leHBvcnQgeyB1c2VNb3Rpb25SZWYgfTtcbiIsICJmdW5jdGlvbiBpc1JlZk9iamVjdChyZWYpIHtcbiAgICByZXR1cm4gKHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpKTtcbn1cblxuZXhwb3J0IHsgaXNSZWZPYmplY3QgfTtcbiIsICJpbXBvcnQgeyB1c2VNZW1vLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTW90aW9uQ29udGV4dCB9IGZyb20gJy4vaW5kZXgubWpzJztcbmltcG9ydCB7IGdldEN1cnJlbnRUcmVlVmFyaWFudHMgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpIHtcbiAgICB2YXIgX2EgPSBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpKSwgaW5pdGlhbCA9IF9hLmluaXRpYWwsIGFuaW1hdGUgPSBfYS5hbmltYXRlO1xuICAgIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IGluaXRpYWw6IGluaXRpYWwsIGFuaW1hdGU6IGFuaW1hdGUgfSk7IH0sIFt2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGluaXRpYWwpLCB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGFuaW1hdGUpXSk7XG59XG5mdW5jdGlvbiB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KHByb3ApIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3Auam9pbihcIiBcIikgOiBwcm9wO1xufVxuXG5leHBvcnQgeyB1c2VDcmVhdGVNb3Rpb25Db250ZXh0IH07XG4iLCAiaW1wb3J0IHsgY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMsIGlzVmFyaWFudExhYmVsIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL3ZhcmlhbnRzLm1qcyc7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmVlVmFyaWFudHMocHJvcHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpKSB7XG4gICAgICAgIHZhciBpbml0aWFsID0gcHJvcHMuaW5pdGlhbCwgYW5pbWF0ZSA9IHByb3BzLmFuaW1hdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbml0aWFsOiBpbml0aWFsID09PSBmYWxzZSB8fCBpc1ZhcmlhbnRMYWJlbChpbml0aWFsKVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZTogaXNWYXJpYW50TGFiZWwoYW5pbWF0ZSkgPyBhbmltYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UgPyBjb250ZXh0IDoge307XG59XG5cbmV4cG9ydCB7IGdldEN1cnJlbnRUcmVlVmFyaWFudHMgfTtcbiIsICIvKipcbiAqIERlY2lkZXMgaWYgdGhlIHN1cHBsaWVkIHZhcmlhYmxlIGlzIGFuIGFycmF5IG9mIHZhcmlhbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGlzVmFyaWFudExhYmVscyh2KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59XG4vKipcbiAqIERlY2lkZXMgaWYgdGhlIHN1cHBsaWVkIHZhcmlhYmxlIGlzIHZhcmlhbnQgbGFiZWxcbiAqL1xuZnVuY3Rpb24gaXNWYXJpYW50TGFiZWwodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiB8fCBpc1ZhcmlhbnRMYWJlbHModik7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxhdGVzdCBzdGF0ZSBvZiBldmVyeSBNb3Rpb25WYWx1ZSBvbiBhIFZpc3VhbEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudCh2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB7fTtcbiAgICB2aXN1YWxFbGVtZW50LmZvckVhY2hWYWx1ZShmdW5jdGlvbiAodmFsdWUsIGtleSkgeyByZXR1cm4gKGN1cnJlbnRba2V5XSA9IHZhbHVlLmdldCgpKTsgfSk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBldmVyeSBNb3Rpb25WYWx1ZSBvbiBhIFZpc3VhbEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkodmlzdWFsRWxlbWVudCkge1xuICAgIHZhciB2ZWxvY2l0eSA9IHt9O1xuICAgIHZpc3VhbEVsZW1lbnQuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiAodmVsb2NpdHlba2V5XSA9IHZhbHVlLmdldFZlbG9jaXR5KCkpOyB9KTtcbiAgICByZXR1cm4gdmVsb2NpdHk7XG59XG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbiwgY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZXMgPT09IHZvaWQgMCkgeyBjdXJyZW50VmFsdWVzID0ge307IH1cbiAgICBpZiAoY3VycmVudFZlbG9jaXR5ID09PSB2b2lkIDApIHsgY3VycmVudFZlbG9jaXR5ID0ge307IH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBkZWZpbml0aW9uIGlzIGEgZnVuY3Rpb24sIHJlc29sdmUuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24oY3VzdG9tICE9PSBudWxsICYmIGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBkZWZpbml0aW9uIGlzIGEgdmFyaWFudCBsYWJlbCwgb3JcbiAgICAgKiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYSB2YXJpYW50IGxhYmVsLCByZXNvbHZlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkZWZpbml0aW9uID0gKF9hID0gcHJvcHMudmFyaWFudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtkZWZpbml0aW9uXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSd2ZSByZXNvbHZlZCBib3RoIGZ1bmN0aW9ucyBhbmQgdmFyaWFudCBsYWJlbHMsXG4gICAgICogYnV0IHRoZSByZXNvbHZlZCB2YXJpYW50IGxhYmVsIG1pZ2h0IGl0c2VsZiBoYXZlIGJlZW4gYSBmdW5jdGlvbi5cbiAgICAgKiBJZiBzbywgcmVzb2x2ZS4gVGhpcyBjYW4gb25seSBoYXZlIHJldHVybmVkIGEgdmFsaWQgdGFyZ2V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IG51bGwgJiYgY3VzdG9tICE9PSB2b2lkIDAgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGN1cnJlbnRWYWx1ZXMsIGN1cnJlbnRWZWxvY2l0eSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgY3VzdG9tKSB7XG4gICAgdmFyIHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgIHJldHVybiByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbiwgY3VzdG9tICE9PSBudWxsICYmIGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBnZXRDdXJyZW50KHZpc3VhbEVsZW1lbnQpLCBnZXRWZWxvY2l0eSh2aXN1YWxFbGVtZW50KSk7XG59XG5mdW5jdGlvbiBjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHR5cGVvZiAoKF9hID0gcHJvcHMuYW5pbWF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0KSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLmluaXRpYWwpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLmFuaW1hdGUpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLndoaWxlSG92ZXIpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLndoaWxlRHJhZykgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVUYXApIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLndoaWxlRm9jdXMpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLmV4aXQpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZWYXJpYW50Tm9kZShwcm9wcykge1xuICAgIHJldHVybiBCb29sZWFuKGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB8fCBwcm9wcy52YXJpYW50cyk7XG59XG5cbmV4cG9ydCB7IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzLCBjaGVja0lmVmFyaWFudE5vZGUsIGlzVmFyaWFudExhYmVsLCBpc1ZhcmlhbnRMYWJlbHMsIHJlc29sdmVWYXJpYW50LCByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyB9O1xuIiwgImltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyc7XG5pbXBvcnQgeyBnbG9iYWxQcm9qZWN0aW9uU3RhdGUgfSBmcm9tICcuL2NyZWF0ZS1wcm9qZWN0aW9uLW5vZGUubWpzJztcblxudmFyIGlkID0gMTtcbmZ1bmN0aW9uIHVzZVByb2plY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0V2ZXJVcGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQrKztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgeyB1c2VQcm9qZWN0aW9uSWQgfTtcbiIsICJpbXBvcnQgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0YW50IHZhbHVlIG92ZXIgdGhlIGxpZmVjeWNsZSBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBFdmVuIGlmIGB1c2VNZW1vYCBpcyBwcm92aWRlZCBhbiBlbXB0eSBhcnJheSBhcyBpdHMgZmluYWwgYXJndW1lbnQsIGl0IGRvZXNuJ3Qgb2ZmZXJcbiAqIGEgZ3VhcmFudGVlIHRoYXQgaXQgd29uJ3QgcmUtcnVuIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGxhdGVyIG9uLiBCeSB1c2luZyBgdXNlQ29uc3RhbnRgXG4gKiB5b3UgY2FuIGVuc3VyZSB0aGF0IGluaXRpYWxpc2VycyBkb24ndCBleGVjdXRlIHR3aWNlIG9yIG1vcmUuXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbnN0YW50KGluaXQpIHtcbiAgICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGlmIChyZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyB1c2VDb25zdGFudCB9O1xuIiwgImltcG9ydCB7IF9fc3ByZWFkQXJyYXksIF9fcmVhZCwgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgc3luYywgeyBjYW5jZWxTeW5jLCBmbHVzaFN5bmMgfSBmcm9tICdmcmFtZXN5bmMnO1xuaW1wb3J0IHsgbWl4IH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vYW5pbWF0ZS5tanMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uTWFuYWdlciB9IGZyb20gJy4uLy4uL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBtaXhWYWx1ZXMgfSBmcm9tICcuLi9hbmltYXRpb24vbWl4LXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgY29weUJveEludG8gfSBmcm9tICcuLi9nZW9tZXRyeS9jb3B5Lm1qcyc7XG5pbXBvcnQgeyB0cmFuc2xhdGVBeGlzLCB0cmFuc2Zvcm1Cb3gsIGFwcGx5Qm94RGVsdGEsIGFwcGx5VHJlZURlbHRhcyB9IGZyb20gJy4uL2dlb21ldHJ5L2RlbHRhLWFwcGx5Lm1qcyc7XG5pbXBvcnQgeyBjYWxjUmVsYXRpdmVQb3NpdGlvbiwgY2FsY1JlbGF0aXZlQm94LCBjYWxjQm94RGVsdGEsIGNhbGNMZW5ndGggfSBmcm9tICcuLi9nZW9tZXRyeS9kZWx0YS1jYWxjLm1qcyc7XG5pbXBvcnQgeyByZW1vdmVCb3hUcmFuc2Zvcm1zIH0gZnJvbSAnLi4vZ2VvbWV0cnkvZGVsdGEtcmVtb3ZlLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVCb3gsIGNyZWF0ZURlbHRhIH0gZnJvbSAnLi4vZ2VvbWV0cnkvbW9kZWxzLm1qcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZVRyYW5zaXRpb24gfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvdHJhbnNpdGlvbnMubWpzJztcbmltcG9ydCB7IGJveEVxdWFscywgaXNEZWx0YVplcm8gfSBmcm9tICcuLi9nZW9tZXRyeS91dGlscy5tanMnO1xuaW1wb3J0IHsgTm9kZVN0YWNrIH0gZnJvbSAnLi4vc2hhcmVkL3N0YWNrLm1qcyc7XG5pbXBvcnQgeyBzY2FsZUNvcnJlY3RvcnMgfSBmcm9tICcuLi9zdHlsZXMvc2NhbGUtY29ycmVjdGlvbi5tanMnO1xuaW1wb3J0IHsgYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtIH0gZnJvbSAnLi4vc3R5bGVzL3RyYW5zZm9ybS5tanMnO1xuaW1wb3J0IHsgZWFjaEF4aXMgfSBmcm9tICcuLi91dGlscy9lYWNoLWF4aXMubWpzJztcbmltcG9ydCB7IGhhc1RyYW5zZm9ybSwgaGFzU2NhbGUgfSBmcm9tICcuLi91dGlscy9oYXMtdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1BeGVzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBGbGF0VHJlZSB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9mbGF0LXRyZWUubWpzJztcbmltcG9ydCB7IHJlc29sdmVNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL3Jlc29sdmUtbW90aW9uLXZhbHVlLm1qcyc7XG5cbi8qKlxuICogV2UgdXNlIDEwMDAgYXMgdGhlIGFuaW1hdGlvbiB0YXJnZXQgYXMgMC0xMDAwIG1hcHMgYmV0dGVyIHRvIHBpeGVscyB0aGFuIDAtMVxuICogd2hpY2ggaGFzIGEgbm90aWNlYWJsZSBkaWZmZXJlbmNlIGluIHNwcmluZyBhbmltYXRpb25zXG4gKi9cbnZhciBhbmltYXRpb25UYXJnZXQgPSAxMDAwO1xuLyoqXG4gKiBUaGlzIHNob3VsZCBvbmx5IGV2ZXIgYmUgbW9kaWZpZWQgb24gdGhlIGNsaWVudCBvdGhlcndpc2UgaXQnbGxcbiAqIHBlcnNpc3QgdGhyb3VnaCBzZXJ2ZXIgcmVxdWVzdHMuIElmIHdlIG5lZWQgaW5zdGFuY2VkIHN0YXRlcyB3ZVxuICogY291bGQgbGF6eS1pbml0IHZpYSByb290LlxuICovXG52YXIgZ2xvYmFsUHJvamVjdGlvblN0YXRlID0ge1xuICAgIC8qKlxuICAgICAqIEdsb2JhbCBmbGFnIGFzIHRvIHdoZXRoZXIgdGhlIHRyZWUgaGFzIGFuaW1hdGVkIHNpbmNlIHRoZSBsYXN0IHRpbWVcbiAgICAgKiB3ZSByZXNpemVkIHRoZSB3aW5kb3dcbiAgICAgKi9cbiAgICBoYXNBbmltYXRlZFNpbmNlUmVzaXplOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFdlIHNldCB0aGlzIHRvIHRydWUgb25jZSwgb24gdGhlIGZpcnN0IHVwZGF0ZS4gQW55IG5vZGVzIGFkZGVkIHRvIHRoZSB0cmVlIGJleW9uZCB0aGF0XG4gICAgICogdXBkYXRlIHdpbGwgYmUgZ2l2ZW4gYSBgZGF0YS1wcm9qZWN0aW9uLWlkYCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgaGFzRXZlclVwZGF0ZWQ6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3Rpb25Ob2RlKF9hKSB7XG4gICAgdmFyIGF0dGFjaFJlc2l6ZUxpc3RlbmVyID0gX2EuYXR0YWNoUmVzaXplTGlzdGVuZXIsIGRlZmF1bHRQYXJlbnQgPSBfYS5kZWZhdWx0UGFyZW50LCBtZWFzdXJlU2Nyb2xsID0gX2EubWVhc3VyZVNjcm9sbCwgcmVzZXRUcmFuc2Zvcm0gPSBfYS5yZXNldFRyYW5zZm9ybTtcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9qZWN0aW9uTm9kZShpZCwgbGF0ZXN0VmFsdWVzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAobGF0ZXN0VmFsdWVzID09PSB2b2lkIDApIHsgbGF0ZXN0VmFsdWVzID0ge307IH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBkZWZhdWx0UGFyZW50ID09PSBudWxsIHx8IGRlZmF1bHRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRQYXJlbnQoKTsgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIFNldCBjb250YWluaW5nIGFsbCB0aGlzIGNvbXBvbmVudCdzIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgdG8gaXRlcmF0ZVxuICAgICAgICAgICAgICogdGhyb3VnaCB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogVGhpcyBjb3VsZCBiZSBmYXN0ZXIgdG8gaXRlcmF0ZSBhcyBhIGZsYXQgYXJyYXkgc3RvcmVkIG9uIHRoZSByb290IG5vZGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBub2RlLiBXZSB1c2UgdGhpcyB0byBjb25maWd1cmUgd2hhdCBraW5kIG9mIGxheW91dCBhbmltYXRpb25zXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgcGVyZm9ybSAoaWYgYW55KS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHVzZSB0aGlzIHRvIGRldGVjdCB3aGVuIGl0cyBzYWZlIHRvIHNodXQgZG93biBwYXJ0IG9mIGEgcHJvamVjdGlvbiB0cmVlLlxuICAgICAgICAgICAgICogV2UgaGF2ZSB0byBrZWVwIHByb2plY3RpbmcgY2hpbGRyZW4gZm9yIHNjYWxlIGNvcnJlY3Rpb24gYW5kIHJlbGF0aXZlIHByb2plY3Rpb25cbiAgICAgICAgICAgICAqIHVudGlsIGFsbCB0aGVpciBwYXJlbnRzIHN0b3AgcGVyZm9ybWluZyBsYXlvdXQgYW5pbWF0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpb25CbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gdHJ1ZSBpZiB3ZSB0aGluayB0aGlzIGxheW91dCBoYXMgYmVlbiBjaGFuZ2VkLiBXZSBjYW4ndCBhbHdheXMga25vdyB0aGlzLFxuICAgICAgICAgICAgICogY3VycmVudGx5IHdlIHNldCBpdCB0byB0cnVlIGV2ZXJ5IHRpbWUgYSBjb21wb25lbnQgcmVuZGVycywgb3IgaWYgaXQgaGFzIGEgbGF5b3V0RGVwZW5kZW5jeVxuICAgICAgICAgICAgICogaWYgdGhhdCBoYXMgY2hhbmdlZCBiZXR3ZWVuIHJlbmRlcnMuIEFkZGl0aW9uYWxseSwgY29tcG9uZW50cyBjYW4gYmUgZ3JvdXBlZCBieSBMYXlvdXRHcm91cFxuICAgICAgICAgICAgICogYW5kIGlmIG9uZSBub2RlIGlzIGRpcnRpZWQsIHRoZXkgYWxsIGFyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJsb2NrIGxheW91dCB1cGRhdGVzIGZvciBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9ucyB0aHJvdWdob3V0IHRoZSB0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRvIHRydWUgYmV0d2VlbiB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGB3aWxsVXBkYXRlYCBjYWxsIGFuZCB0aGUgZW5kIG9mIHRoZSBgZGlkVXBkYXRlYFxuICAgICAgICAgICAgICogY2FsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gU1ZHIGVsZW1lbnQgd2UgY3VycmVudGx5IGRpc2FibGUgcHJvamVjdGlvbiB0cmFuc2Zvcm1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIChkdXJpbmcgcHJvbW90aW9uKSBpZiBhIG5vZGUgZG9pbmcgYW4gaW5zdGFudCBsYXlvdXQgdHJhbnNpdGlvbiBuZWVkcyB0byByZXNldFxuICAgICAgICAgICAgICogaXRzIHByb2plY3Rpb24gc3R5bGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZ3Mgd2hldGhlciB0aGlzIG5vZGUgc2hvdWxkIGhhdmUgaXRzIHRyYW5zZm9ybSByZXNldCBwcmlvciB0byBtZWFzdXJpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY2FsY3VsYXRlZCBjb250ZXh0dWFsL2FjY3VtdWxhdGVkL3RyZWUgc2NhbGUuXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYmUgdXNlZCB0byBzY2FsZSBjYWxjdWxjYXRlZCBwcm9qZWN0aW9uIHRyYW5zZm9ybXMsIGFzIHRoZXNlIGFyZVxuICAgICAgICAgICAgICogY2FsY3VsYXRlZCBpbiBzY3JlZW4tc3BhY2UgYnV0IG5lZWQgdG8gYmUgc2NhbGVkIGZvciBlbGVtZW50cyB0byBhY3R1YWxseVxuICAgICAgICAgICAgICogbWFrZSBpdCB0byB0aGVpciBjYWxjdWxhdGVkIGRlc3RpbmF0aW9ucy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBMYXp5LWluaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVXBkYXRlRmFpbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLmZvckVhY2gocmVzb2x2ZVRhcmdldERlbHRhKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlcy5mb3JFYWNoKGNhbGNQcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNoYXJlZCBsYXlvdXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVE9ETyBPbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCB8fCBwYXJlbnQgOiB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGFyZW50ID8gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocGFyZW50LnBhdGgpLCBmYWxzZSksIFtwYXJlbnRdLCBmYWxzZSkgOiBbXTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgICAgICAgaWQgJiYgdGhpcy5yb290LnJlZ2lzdGVyUG90ZW50aWFsTm9kZShpZCwgdGhpcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aFtpXS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSBuZXcgRmxhdFRyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRIYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMuc2V0KG5hbWUsIG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSkuYWRkKGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUubm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uTWFuYWdlciA9IHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25NYW5hZ2VyID09PSBudWxsIHx8IHN1YnNjcmlwdGlvbk1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvbk1hbmFnZXIubm90aWZ5LmFwcGx5KHN1YnNjcmlwdGlvbk1hbmFnZXIsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlZ2lzdGVyUG90ZW50aWFsTm9kZSA9IGZ1bmN0aW9uIChpZCwgbm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5zZXQoaWQsIG5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlmZWN5Y2xlc1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBpc0xheW91dERpcnR5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGlzTGF5b3V0RGlydHkgPT09IHZvaWQgMCkgeyBpc0xheW91dERpcnR5ID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPVxuICAgICAgICAgICAgICAgIGluc3RhbmNlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBpbnN0YW5jZS50YWdOYW1lICE9PSBcInN2Z1wiO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBsYXlvdXRJZCA9IF9iLmxheW91dElkLCBsYXlvdXQgPSBfYi5sYXlvdXQsIHZpc3VhbEVsZW1lbnQgPSBfYi52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgIXZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKSkge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGRyZW4uYWRkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pZCAmJiB0aGlzLnJvb3QucG90ZW50aWFsTm9kZXMuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgaWYgKGlzTGF5b3V0RGlydHkgJiYgKGxheW91dCB8fCBsYXlvdXRJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dGFjaFJlc2l6ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuYmxvY2tUaW1lb3V0XzE7XG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZVVuYmxvY2tVcGRhdGVfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF0dGFjaFJlc2l6ZUxpc3RlbmVyKGluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHVuYmxvY2tUaW1lb3V0XzEpO1xuICAgICAgICAgICAgICAgICAgICB1bmJsb2NrVGltZW91dF8xID0gd2luZG93LnNldFRpbWVvdXQocmVzaXplVW5ibG9ja1VwZGF0ZV8xLCAyNTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlcy5mb3JFYWNoKGZpbmlzaEFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSByZWdpc3RlciB0aGUgaGFuZGxlciBpZiBpdCByZXF1aXJlcyBsYXlvdXQgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIChsYXlvdXRJZCB8fCBsYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBfYS5kZWx0YSwgaGFzTGF5b3V0Q2hhbmdlZCA9IF9hLmhhc0xheW91dENoYW5nZWQsIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IF9hLmhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCwgbmV3TGF5b3V0ID0gX2EubGF5b3V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBoZXJlIGlmIGFuIGFuaW1hdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dFRyYW5zaXRpb24gPSAoX2MgPSAoX2IgPSBfdGhpcy5vcHRpb25zLnRyYW5zaXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdExheW91dFRyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgdGFyZ2V0IGxheW91dCBvZiB0aGUgZWxlbWVudCBtaWdodCBzdGF5IHRoZSBzYW1lLFxuICAgICAgICAgICAgICAgICAgICAgKiBidXQgaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2hhbmdlZCA9ICFfdGhpcy50YXJnZXRMYXlvdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFib3hFcXVhbHMoX3RoaXMudGFyZ2V0TGF5b3V0LCBuZXdMYXlvdXQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBzZWVtZWQgdG8gaGF2ZSBjaGFuZ2VkLCBpdCBtaWdodCBiZSB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IGlzIHZpc3VhbGx5IGluIHRoZSBzYW1lIHBsYWNlIGluIHRoZSBkb2N1bWVudCBidXQgaXRzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGluZGVlZCBjaGFuZ2VkLiBTbyBoZXJlIHdlIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSAhaGFzTGF5b3V0Q2hhbmdlZCAmJiBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9kID0gX3RoaXMucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmluc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc0xheW91dENoYW5nZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0Q2hhbmdlZCB8fCAhX3RoaXMuY3VycmVudEFuaW1hdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtaW5nRnJvbSA9IF90aGlzLnJlc3VtZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdW1pbmdGcm9tLnJlc3VtaW5nRnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRWYWx1ZVRyYW5zaXRpb24obGF5b3V0VHJhbnNpdGlvbiwgXCJsYXlvdXRcIikpLCB7IG9uQ29tcGxldGU6IG9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLnR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0QW5pbWF0aW9uKGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBjaGFuZ2VkIGFuZCB3ZSBoYXZlIGFuIGFuaW1hdGlvbiB0aGF0IGhhc24ndCBzdGFydGVkIHlldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGZpbmlzaCBpdCBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgYW5pbWF0aW5nIGZyb20gYSBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhhdCB3YXMgcHJvYmFibHkgbmV2ZXIgY29tbWl0ZWQgdG8gc2NyZWVuIGFuZCBsb29rIGxpa2UgYSBqdW1weSBib3guXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzTGF5b3V0Q2hhbmdlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvblByb2dyZXNzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmluaXNoQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xlYWQoKSAmJiAoKF9mID0gKF9lID0gX3RoaXMub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGFyZ2V0TGF5b3V0ID0gbmV3TGF5b3V0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0SWQgJiYgdGhpcy53aWxsVXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaGlsZHJlbi5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuY2VsU3luYy5wcmVSZW5kZXIodGhpcy51cGRhdGVQcm9qZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb25seSBvbiB0aGUgcm9vdFxuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuYmxvY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS51bmJsb2NrVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmlzVXBkYXRlQmxvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCB8fCB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNBbmltYXRpb25CbG9ja2VkIHx8XG4gICAgICAgICAgICAgICAgKChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB8fFxuICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnN0YXJ0VXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVcGRhdGVCbG9ja2VkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMubm9kZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKHJlc2V0Um90YXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUud2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIChzaG91bGROb3RpZnlMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeUxpc3RlbmVycyA9PT0gdm9pZCAwKSB7IHNob3VsZE5vdGlmeUxpc3RlbmVycyA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QuaXNVcGRhdGVCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIXRoaXMucm9vdC5pc1VwZGF0aW5nICYmIHRoaXMucm9vdC5zdGFydFVwZGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMYXlvdXREaXJ0eSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBub2RlLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUT0RPOiBDaGVjayB3ZSBoYXZlbid0IHVwZGF0ZWQgdGhlIHNjcm9sbFxuICAgICAgICAgICAgICAgICAqIHNpbmNlIHRoZSBsYXN0IGRpZFVwZGF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2QgPSB0aGlzLm9wdGlvbnMsIGxheW91dElkID0gX2QubGF5b3V0SWQsIGxheW91dCA9IF9kLmxheW91dDtcbiAgICAgICAgICAgIGlmIChsYXlvdXRJZCA9PT0gdW5kZWZpbmVkICYmICFsYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlID0gKF9jID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlID09PSBudWxsIHx8IHRyYW5zZm9ybVRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICBzaG91bGROb3RpZnlMaXN0ZW5lcnMgJiYgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJ3aWxsVXBkYXRlXCIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOb3RlOiBDdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVdhc0Jsb2NrZWQgPSB0aGlzLmlzVXBkYXRlQmxvY2tlZCgpO1xuICAgICAgICAgICAgLy8gV2hlbiBkb2luZyBhbiBpbnN0YW50IHRyYW5zaXRpb24sIHdlIHNraXAgdGhlIGxheW91dCB1cGRhdGUsXG4gICAgICAgICAgICAvLyBidXQgc2hvdWxkIHN0aWxsIGNsZWFuIHVwIHRoZSBtZWFzdXJlbWVudHMgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gc25hcHNob3QgY291bGQgYmUgdGFrZW4gY29ycmVjdGx5LlxuICAgICAgICAgICAgaWYgKHVwZGF0ZVdhc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYmxvY2tVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFyTWVhc3VyZW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNVcGRhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VhcmNoIGZvciBhbmQgbW91bnQgbmV3bHktYWRkZWQgcHJvamVjdGlvbiBlbGVtZW50cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBFdmVyeSB0aW1lIGEgbmV3IGNvbXBvbmVudCBpcyByZW5kZXJlZCB3ZSBjb3VsZCBzZWFyY2ggdXAgdGhlIHRyZWUgZm9yXG4gICAgICAgICAgICAgKiB0aGUgY2xvc2VzdCBtb3VudGVkIG5vZGUgYW5kIHF1ZXJ5IGZyb20gdGhlcmUgcmF0aGVyIHRoYW4gZG9jdW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvdGVudGlhbE5vZGVzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvdGVudGlhbE5vZGVzLmZvckVhY2gobW91bnROb2RlRWFybHkpO1xuICAgICAgICAgICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV3JpdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc2V0VHJhbnNmb3JtU3R5bGUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWFkID09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBVcGRhdGUgbGF5b3V0IG1lYXN1cmVtZW50cyBvZiB1cGRhdGVkIGNoaWxkcmVuXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2godXBkYXRlTGF5b3V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV3JpdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gTm90aWZ5IGxpc3RlbmVycyB0aGF0IHRoZSBsYXlvdXQgaXMgdXBkYXRlZFxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vdGlmeUxheW91dFVwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICAgICAgICAvLyBGbHVzaCBhbnkgc2NoZWR1bGVkIHVwZGF0ZXNcbiAgICAgICAgICAgIGZsdXNoU3luYy51cGRhdGUoKTtcbiAgICAgICAgICAgIGZsdXNoU3luYy5wcmVSZW5kZXIoKTtcbiAgICAgICAgICAgIGZsdXNoU3luYy5yZW5kZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmNsZWFyQWxsU25hcHNob3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFyU25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5zaGFyZWROb2Rlcy5mb3JFYWNoKHJlbW92ZUxlYWRTbmFwc2hvdHMpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3luYy5wcmVSZW5kZXIodGhpcy51cGRhdGVQcm9qZWN0aW9uLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHVubW91bnRpbmcgbm9kZSBpcyBpbiBhIGxheW91dEdyb3VwIGFuZCBkaWQgdHJpZ2dlciBhIHdpbGxVcGRhdGUsXG4gICAgICAgICAgICAgKiB3ZSBtYW51YWxseSBjYWxsIGRpZFVwZGF0ZSB0byBnaXZlIGEgY2hhbmNlIHRvIHRoZSBzaWJsaW5ncyB0byBhbmltYXRlLlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlLCBjbGVhbnVwIGFsbCBzbmFwc2hvdHMgdG8gcHJldmVudHMgZnV0dXJlIG5vZGVzIGZyb20gcmV1c2luZyB0aGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzeW5jLnBvc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0xheW91dERpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb290LmNoZWNrVXBkYXRlRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgbWVhc3VyZW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUudXBkYXRlU25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zbmFwc2hvdCB8fCAhdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbWVhc3VyZWQgPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLnJlbW92ZVRyYW5zZm9ybSh0aGlzLnJlbW92ZUVsZW1lbnRTY3JvbGwobWVhc3VyZWQpKTtcbiAgICAgICAgICAgIHJvdW5kQm94KGxheW91dCk7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0ge1xuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiBtZWFzdXJlZCxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBUT0RPOiBJbmNvcnBvcmF0ZSBpbnRvIGEgZm9yd2FyZGVkIHNjcm9sbCBvZmZzZXRcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWx3YXlzTWVhc3VyZUxheW91dCAmJiB0aGlzLmlzTGVhZCgpKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBub2RlIGlzIG1vdW50ZWQsIGl0IHNpbXBseSByZXN1bWVzIGZyb20gdGhlIHByZXZMZWFkJ3NcbiAgICAgICAgICAgICAqIHNuYXBzaG90IGluc3RlYWQgb2YgdGFraW5nIGEgbmV3IG9uZSwgYnV0IHRoZSBhbmNlc3RvcnMgc2Nyb2xsXG4gICAgICAgICAgICAgKiBtaWdodCBoYXZlIHVwZGF0ZWQgd2hpbGUgdGhlIHByZXZMZWFkIGlzIHVubW91bnRlZC4gV2UgbmVlZCB0b1xuICAgICAgICAgICAgICogdXBkYXRlIHRoZSBzY3JvbGwgYWdhaW4gdG8gbWFrZSBzdXJlIHRoZSBsYXlvdXQgd2UgbWVhc3VyZSBpc1xuICAgICAgICAgICAgICogdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSAmJiAhdGhpcy5yZXN1bWVGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1lYXN1cmVkID0gdGhpcy5tZWFzdXJlKCk7XG4gICAgICAgICAgICByb3VuZEJveChtZWFzdXJlZCk7XG4gICAgICAgICAgICB2YXIgcHJldkxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSB7XG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IG1lYXN1cmVkLFxuICAgICAgICAgICAgICAgIGFjdHVhbDogdGhpcy5yZW1vdmVFbGVtZW50U2Nyb2xsKG1lYXN1cmVkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxheW91dENvcnJlY3RlZCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwibWVhc3VyZVwiLCB0aGlzLmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub3RpZnlMYXlvdXRNZWFzdXJlKHRoaXMubGF5b3V0LmFjdHVhbCwgcHJldkxheW91dCA9PT0gbnVsbCB8fCBwcmV2TGF5b3V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2TGF5b3V0LmFjdHVhbCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS51cGRhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dFNjcm9sbCAmJiB0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGwgPSBtZWFzdXJlU2Nyb2xsKHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXJlc2V0VHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc1Jlc2V0UmVxdWVzdGVkID0gdGhpcy5pc0xheW91dERpcnR5IHx8IHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm07XG4gICAgICAgICAgICB2YXIgaGFzUHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbkRlbHRhICYmICFpc0RlbHRhWmVybyh0aGlzLnByb2plY3Rpb25EZWx0YSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlID09PSBudWxsIHx8IHRyYW5zZm9ybVRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIik7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGVIYXNDaGFuZ2VkID0gdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSAhPT0gdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1Jlc2V0UmVxdWVzdGVkICYmXG4gICAgICAgICAgICAgICAgKGhhc1Byb2plY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSB8fFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQpKSB7XG4gICAgICAgICAgICAgICAgcmVzZXRUcmFuc2Zvcm0odGhpcy5pbnN0YW5jZSwgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLm1lYXN1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlzdWFsRWxlbWVudCA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIHZhciBib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHZpZXdwb3J0IHNjcm9sbCB0byBnaXZlIHBhZ2UtcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHZhciBzY3JvbGwgPSB0aGlzLnJvb3Quc2Nyb2xsO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LngsIHNjcm9sbC54KTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC55LCBzY3JvbGwueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94O1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVtb3ZlRWxlbWVudFNjcm9sbCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICAgICAgICAgIHZhciBib3hXaXRob3V0U2Nyb2xsID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQZXJmb3JtYW5jZSBUT0RPOiBLZWVwIGEgY3VtdWxhdGl2ZSBzY3JvbGwgb2Zmc2V0IGRvd24gdGhlIHRyZWVcbiAgICAgICAgICAgICAqIHJhdGhlciB0aGFuIGxvb3AgYmFjayB1cCB0aGUgcGF0aC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsXzEgPSBub2RlLnNjcm9sbCwgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290ICYmIHNjcm9sbF8xICYmIG9wdGlvbnMubGF5b3V0U2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCBzY3JvbGxfMS54KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIHNjcm9sbF8xLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib3hXaXRob3V0U2Nyb2xsO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYm94LCB0cmFuc2Zvcm1Pbmx5KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtT25seSA9PT0gdm9pZCAwKSB7IHRyYW5zZm9ybU9ubHkgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byh3aXRoVHJhbnNmb3JtcywgYm94KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Pbmx5ICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zY3JvbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZSAhPT0gbm9kZS5yb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3Jtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogLW5vZGUuc2Nyb2xsLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwueSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3JtcywgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhUcmFuc2Zvcm1zO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVtb3ZlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGJveCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGJveFdpdGhvdXRUcmFuc2Zvcm0gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRUcmFuc2Zvcm0sIGJveCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBoYXNTY2FsZShub2RlLmxhdGVzdFZhbHVlcykgJiYgbm9kZS51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VCb3ggPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUJveCA9IG5vZGUubWVhc3VyZSgpO1xuICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHNvdXJjZUJveCwgbm9kZUJveCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCBub2RlLmxhdGVzdFZhbHVlcywgKF9hID0gbm9kZS5zbmFwc2hvdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dCwgc291cmNlQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFRyYW5zZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc2V0VGFyZ2V0RGVsdGEgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpLCB7IGNyb3NzZmFkZTogKF9hID0gb3B0aW9ucy5jcm9zc2ZhZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5jbGVhck1lYXN1cmVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRnJhbWUgY2FsY3VsYXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVzb2x2ZVRhcmdldERlbHRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBsYXlvdXQgPSBfYi5sYXlvdXQsIGxheW91dElkID0gX2IubGF5b3V0SWQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gbGF5b3V0LCB3ZSBjYW4ndCBwZXJmb3JtIHByb2plY3Rpb24sIHNvIGVhcmx5IHJldHVyblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGRvbid0IGhhdmUgYSB0YXJnZXREZWx0YSBidXQgZG8gaGF2ZSBhIGxheW91dCwgd2UgY2FuIGF0dGVtcHQgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICogYSByZWxhdGl2ZVBhcmVudC4gVGhpcyB3aWxsIGFsbG93IGEgY29tcG9uZW50IHRvIHBlcmZvcm0gc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICogZXZlbiBpZiBubyBhbmltYXRpb24gaGFzIHN0YXJ0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIFRPRE8gSWYgdGhpcyBpcyB1bnN1Y2Nlc3NmdWwgdGhpcyBjdXJyZW50bHkgaGFwcGVucyBldmVyeSBmcmFtZVxuICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldERlbHRhICYmICF0aGlzLnJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhIHNlbWktcmVwZXRpdGlvbiBvZiBmdXJ0aGVyIGRvd24gdGhpcyBmdW5jdGlvbiwgbWFrZSBEUllcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlUGFyZW50ICYmIHRoaXMucmVsYXRpdmVQYXJlbnQubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLmxheW91dC5hY3R1YWwsIHRoaXMucmVsYXRpdmVQYXJlbnQubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyByZWxhdGl2ZSB0YXJnZXQgb3Igbm8gdGFyZ2V0IGRlbHRhIG91ciB0YXJnZXQgaXNuJ3QgdmFsaWRcbiAgICAgICAgICAgICAqIGZvciB0aGlzIGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVUYXJnZXQgJiYgIXRoaXMudGFyZ2V0RGVsdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMYXp5LWluaXQgdGFyZ2V0IGRhdGEgc3RydWN0dXJlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UndmUgZ290IGEgcmVsYXRpdmUgYm94IGZvciB0aGlzIGNvbXBvbmVudCwgcmVzb2x2ZSBpdCBpbnRvIGEgdGFyZ2V0IHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLnJlbGF0aXZlUGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZUJveCh0aGlzLnRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3ZlIG9ubHkgZ290IGEgdGFyZ2V0RGVsdGEsIHJlc29sdmUgaXQgaW50byBhIHRhcmdldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXREZWx0YSkge1xuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGNyZWF0aW5nIGEgbmV3IG9iamVjdCBldmVyeSBmcmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0odGhpcy5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBseUJveERlbHRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldERlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIG5vIHRhcmdldCwgdXNlIG93biBsYXlvdXQgYXMgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3ZlIGJlZW4gdG9sZCB0byBhdHRlbXB0IHRvIHJlc29sdmUgYSByZWxhdGl2ZSB0YXJnZXQsIGRvIHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbih0aGlzLnJlbGF0aXZlUGFyZW50LnJlc3VtaW5nRnJvbSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5yZWxhdGl2ZVBhcmVudC5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy50YXJnZXQsIHRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8IGhhc1RyYW5zZm9ybSh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRoaXMucGFyZW50LnJlbGF0aXZlVGFyZ2V0IHx8IHRoaXMucGFyZW50LnRhcmdldERlbHRhKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxheW91dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY2FsY1Byb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGxheW91dCA9IF9iLmxheW91dCwgbGF5b3V0SWQgPSBfYi5sYXlvdXRJZDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBzZWN0aW9uIG9mIHRoZSB0cmVlIGlzbid0IGFuaW1hdGluZyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGRlbGV0ZSBvdXIgdGFyZ2V0IHNvdXJjZXMgZm9yIHRoZSBmb2xsb3dpbmcgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gQm9vbGVhbigoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1RyZWVBbmltYXRpbmcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RyZWVBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc2V0IHRoZSBjb3JyZWN0ZWQgYm94IHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBib3gsIGFzIHdlJ3JlIHRoZW4gZ29pbmdcbiAgICAgICAgICAgICAqIHRvIHBlcmZvcm0gbXV0YXRpdmUgb3BlcmF0aW9ucyBvbiBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29weUJveEludG8odGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFwcGx5IGFsbCB0aGUgcGFyZW50IGRlbHRhcyB0byB0aGlzIGJveCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0ZWQgYm94LiBUaGlzXG4gICAgICAgICAgICAgKiBpcyB0aGUgbGF5b3V0IGJveCwgYXMgaXQgd2lsbCBhcHBlYXIgb24gc2NyZWVuIGFzIGEgcmVzdWx0IG9mIHRoZSB0cmFuc2Zvcm1zIG9mIGl0cyBwYXJlbnRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhcHBseVRyZWVEZWx0YXModGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMudHJlZVNjYWxlLCB0aGlzLnBhdGgsIEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pIHx8IHRoaXMgIT09IGxlYWQpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGxlYWQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0gPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZUcmVlU2NhbGVYID0gdGhpcy50cmVlU2NhbGUueDtcbiAgICAgICAgICAgIHZhciBwcmV2VHJlZVNjYWxlWSA9IHRoaXMudHJlZVNjYWxlLnk7XG4gICAgICAgICAgICB2YXIgcHJldlByb2plY3Rpb25UcmFuc2Zvcm0gPSB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY29ycmVjdGVkIGJveCBhbmQgdGhlIHRhcmdldCBib3ggYmVmb3JlIHVzZXItc2V0IHRyYW5zZm9ybXMgd2VyZSBhcHBsaWVkLlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGFsbG93IHVzIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdGVkIGJvcmRlclJhZGl1cyBhbmQgYm94U2hhZG93IHRvIGNvbXBlbnNhdGVcbiAgICAgICAgICAgICAqIGZvciBvdXIgbGF5b3V0IHJlcHJvamVjdGlvbiwgYnV0IHN0aWxsIGFsbG93IHRoZW0gdG8gYmUgc2NhbGVkIGNvcnJlY3RseSBieSB0aGUgdXNlci5cbiAgICAgICAgICAgICAqIEl0IG1pZ2h0IGJlIHRoYXQgdG8gc2ltcGxpZnkgdGhpcyB3ZSBtYXkgd2FudCB0byBhY2NlcHQgdGhhdCB1c2VyLXNldCBzY2FsZSBpcyBhbHNvIGNvcnJlY3RlZFxuICAgICAgICAgICAgICogYW5kIHdlIHdvdWxkbid0IGhhdmUgdG8ga2VlcCBhbmQgY2FsYyBib3RoIGRlbHRhcywgT1Igd2UgY291bGQgc3VwcG9ydCBhIHVzZXIgc2V0dGluZ1xuICAgICAgICAgICAgICogdG8gYWxsb3cgcGVvcGxlIHRvIGNob29zZSB3aGV0aGVyIHRoZXNlIHN0eWxlcyBhcmUgY29ycmVjdGVkIGJhc2VkIG9uIGp1c3QgdGhlXG4gICAgICAgICAgICAgKiBsYXlvdXQgcmVwcm9qZWN0aW9uIG9yIHRoZSBmaW5hbCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldCwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKHRoaXMucHJvamVjdGlvbkRlbHRhLCB0aGlzLnRyZWVTY2FsZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtICE9PSBwcmV2UHJvamVjdGlvblRyYW5zZm9ybSB8fFxuICAgICAgICAgICAgICAgIHRoaXMudHJlZVNjYWxlLnggIT09IHByZXZUcmVlU2NhbGVYIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUueSAhPT0gcHJldlRyZWVTY2FsZVkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwicHJvamVjdGlvblVwZGF0ZVwiLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2hlZHVsZSByZW5kZXJcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2hlZHVsZSByZW5kZXJcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNjaGVkdWxlUmVuZGVyID0gZnVuY3Rpb24gKG5vdGlmeUFsbCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAobm90aWZ5QWxsID09PSB2b2lkIDApIHsgbm90aWZ5QWxsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5zY2hlZHVsZVJlbmRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICAgICAgbm90aWZ5QWxsICYmICgoX2MgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zY2hlZHVsZVJlbmRlcigpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSAmJiAhdGhpcy5yZXN1bWluZ0Zyb20uaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNldEFuaW1hdGlvbk9yaWdpbiA9IGZ1bmN0aW9uIChkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID09PSB2b2lkIDApIHsgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90TGF0ZXN0VmFsdWVzID0gKHNuYXBzaG90ID09PSBudWxsIHx8IHNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbmFwc2hvdC5sYXRlc3RWYWx1ZXMpIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG1peGVkVmFsdWVzID0gX19hc3NpZ24oe30sIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gIWhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIHZhciBpc1NoYXJlZExheW91dEFuaW1hdGlvbiA9IHNuYXBzaG90ID09PSBudWxsIHx8IHNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbmFwc2hvdC5pc1NoYXJlZDtcbiAgICAgICAgICAgIHZhciBpc09ubHlNZW1iZXIgPSAoKChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lbWJlcnMubGVuZ3RoKSB8fCAwKSA8PSAxO1xuICAgICAgICAgICAgdmFyIHNob3VsZENyb3NzZmFkZU9wYWNpdHkgPSBCb29sZWFuKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzT25seU1lbWJlciAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jcm9zc2ZhZGUgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5wYXRoLnNvbWUoaGFzT3BhY2l0eUNyb3NzZmFkZSkpO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhID0gZnVuY3Rpb24gKGxhdGVzdCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBsYXRlc3QgLyAxMDAwO1xuICAgICAgICAgICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS54LCBkZWx0YS54LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLnksIGRlbHRhLnksIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRUYXJnZXREZWx0YSh0YXJnZXREZWx0YSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxheW91dCAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gX3RoaXMucmVsYXRpdmVQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlTGF5b3V0LCBfdGhpcy5sYXlvdXQuYWN0dWFsLCBfdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbWl4Qm94KF90aGlzLnJlbGF0aXZlVGFyZ2V0LCBfdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgcmVsYXRpdmVMYXlvdXQsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvblZhbHVlcyA9IG1peGVkVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICBtaXhWYWx1ZXMobWl4ZWRWYWx1ZXMsIHNuYXBzaG90TGF0ZXN0VmFsdWVzLCBfdGhpcy5sYXRlc3RWYWx1ZXMsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhKDApO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc3RhcnRBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGNhbmNlbFN5bmMudXBkYXRlKHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uIGluIHRoZSBuZXh0IGZyYW1lIHRvIGhhdmUgYSBmcmFtZSB3aXRoIHByb2dyZXNzIDAsXG4gICAgICAgICAgICAgKiB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydGVkLCBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIGNvcnJlY3RseSBmb3IgaW5zdGFudCB0cmFuc2l0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gc3luYy51cGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZSgwLCBhbmltYXRpb25UYXJnZXQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBvblVwZGF0ZTogZnVuY3Rpb24gKGxhdGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWl4VGFyZ2V0RGVsdGEobGF0ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IG9wdGlvbnMub25VcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IG9wdGlvbnMub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gX3RoaXMuY3VycmVudEFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0FuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY29tcGxldGVBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4aXRBbmltYXRpb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVmFsdWVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uQ29tcGxldGVcIik7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5maW5pc2hBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5taXhUYXJnZXREZWx0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgYW5pbWF0aW9uVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmdldExlYWQoKSwgdGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBfYS50YXJnZXRXaXRoVHJhbnNmb3JtcywgdGFyZ2V0ID0gX2EudGFyZ2V0LCBsYXlvdXQgPSBfYS5sYXlvdXQsIGxhdGVzdFZhbHVlcyA9IF9hLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIGlmICghdGFyZ2V0V2l0aFRyYW5zZm9ybXMgfHwgIXRhcmdldCB8fCAhbGF5b3V0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSB0aGUgbGF0ZXN0IHVzZXItc2V0IHRyYW5zZm9ybXMgdG8gdGhlIHRhcmdldEJveCB0byBwcm9kdWNlIHRoZSB0YXJnZXRCb3hGaW5hbC5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgdGhlIGZpbmFsIGJveCB0aGF0IHdlIHdpbGwgdGhlbiBwcm9qZWN0IGludG8gYnkgY2FsY3VsYXRpbmcgYSB0cmFuc2Zvcm0gZGVsdGEgYW5kXG4gICAgICAgICAgICAgKiBhcHBseWluZyBpdCB0byB0aGUgY29ycmVjdGVkIGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KHRhcmdldFdpdGhUcmFuc2Zvcm1zLCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGNvcnJlY3RlZCBib3ggYW5kIHRoZSBmaW5hbCB0YXJnZXQgYm94LCBhZnRlclxuICAgICAgICAgICAgICogdXNlci1zZXQgdHJhbnNmb3JtcyBhcmUgYXBwbGllZCB0byBpdC4gVGhpcyB3aWxsIGJlIHVzZWQgYnkgdGhlIHJlbmRlcmVyIHRvXG4gICAgICAgICAgICAgKiBjcmVhdGUgYSB0cmFuc2Zvcm0gc3R5bGUgdGhhdCB3aWxsIHJlcHJvamVjdCB0aGUgZWxlbWVudCBmcm9tIGl0cyBhY3R1YWwgbGF5b3V0XG4gICAgICAgICAgICAgKiBpbnRvIHRoZSBkZXNpcmVkIGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldFdpdGhUcmFuc2Zvcm1zLCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVnaXN0ZXJTaGFyZWROb2RlID0gZnVuY3Rpb24gKGxheW91dElkLCBub2RlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFyZWROb2Rlcy5oYXMobGF5b3V0SWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZWROb2Rlcy5zZXQobGF5b3V0SWQsIG5ldyBOb2RlU3RhY2soKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgICAgICBzdGFjay5hZGQobm9kZSk7XG4gICAgICAgICAgICBub2RlLnByb21vdGUoe1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IChfYSA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6IChfYyA9IChfYiA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hvdWxkUHJlc2VydmVGb2xsb3dPcGFjaXR5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgbm9kZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmlzTGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjayA/IHN0YWNrLmxlYWQgPT09IHRoaXMgOiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZ2V0TGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRJZCA9IHRoaXMub3B0aW9ucy5sYXlvdXRJZDtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRJZCA/ICgoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZWFkKSB8fCB0aGlzIDogdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmdldFByZXZMZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGxheW91dElkID0gdGhpcy5vcHRpb25zLmxheW91dElkO1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dElkID8gKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJldkxlYWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXRJZCA9IHRoaXMub3B0aW9ucy5sYXlvdXRJZDtcbiAgICAgICAgICAgIGlmIChsYXlvdXRJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5wcm9tb3RlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbmVlZHNSZXNldCA9IF9iLm5lZWRzUmVzZXQsIHRyYW5zaXRpb24gPSBfYi50cmFuc2l0aW9uLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkgPSBfYi5wcmVzZXJ2ZUZvbGxvd09wYWNpdHk7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2spXG4gICAgICAgICAgICAgICAgc3RhY2sucHJvbW90ZSh0aGlzLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpO1xuICAgICAgICAgICAgaWYgKG5lZWRzUmVzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlbGVnYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnJlbGVnYXRlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVzZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aXN1YWxFbGVtZW50ID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBkZXRlY3RlZCByb3RhdGlvbiB2YWx1ZXMsIHdlIGNhbiBlYXJseSByZXR1cm4gd2l0aG91dCBhIGZvcmNlZCByZW5kZXIuXG4gICAgICAgICAgICB2YXIgaGFzUm90YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBLZWVwIGEgcmVjb3JkIG9mIGFsbCB0aGUgdmFsdWVzIHdlJ3ZlIHJlc2V0XG4gICAgICAgICAgICB2YXIgcmVzZXRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSByb3RhdGUgdmFsdWUgb2YgYWxsIGF4ZXMgYW5kIHJlc2V0IHRvIDBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtQXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gdHJhbnNmb3JtQXhlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gXCJyb3RhdGVcIiArIGF4aXM7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyByb3RhdGlvbiBkb2Vzbid0IGV4aXN0IGFzIGEgbW90aW9uIHZhbHVlLCB0aGVuIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZXNldCBpdFxuICAgICAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNSb3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgcm90YXRpb24gYW5kIHRoZW4gdGVtcG9yYXJpbHkgc2V0IGl0IHRvIDBcbiAgICAgICAgICAgICAgICByZXNldFZhbHVlc1trZXldID0gdmlzdWFsRWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcm90YXRpb24gdmFsdWVzLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueSBtb3JlLlxuICAgICAgICAgICAgaWYgKCFoYXNSb3RhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRm9yY2UgYSByZW5kZXIgb2YgdGhpcyBlbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gd2l0aCBhbGwgcm90YXRpb25zXG4gICAgICAgICAgICAvLyBzZXQgdG8gMC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgICAgICAgICAvLyBQdXQgYmFjayBhbGwgdGhlIHZhbHVlcyB3ZSByZXNldFxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHJlc2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIHJlc2V0VmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBuZXh0IGZyYW1lLiBUaGlzIGVuc3VyZXMgd2Ugd29uJ3QgdmlzdWFsbHlcbiAgICAgICAgICAgIC8vIHNlZSB0aGUgZWxlbWVudCB3aXRoIHRoZSByZXNldCByb3RhdGUgdmFsdWUgYXBwbGllZC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmdldFByb2plY3Rpb25TdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVQcm9wKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmIChzdHlsZVByb3AgPT09IHZvaWQgMCkgeyBzdHlsZVByb3AgPSB7fTsgfVxuICAgICAgICAgICAgLy8gVE9ETzogUmV0dXJuIGxpZmVjeWNsZS1wZXJzaXN0ZW50IG9iamVjdFxuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlIHx8IHRoaXMuaXNTVkcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSB8fCAhdGhpcy5sYXlvdXQgfHwgIWxlYWQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtcHR5U3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy5vcGFjaXR5ID0gKF9iID0gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1Byb2plY3RlZCAmJiAhaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVN0eWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZXNUb1JlbmRlciA9IGxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IGxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpO1xuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMudHJlZVNjYWxlLCB2YWx1ZXNUb1JlbmRlcik7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUodmFsdWVzVG9SZW5kZXIsIHN0eWxlcy50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9nID0gdGhpcy5wcm9qZWN0aW9uRGVsdGEsIHggPSBfZy54LCB5ID0gX2cueTtcbiAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm1PcmlnaW4gPSBcIlwiLmNvbmNhdCh4Lm9yaWdpbiAqIDEwMCwgXCIlIFwiKS5jb25jYXQoeS5vcmlnaW4gKiAxMDAsIFwiJSAwXCIpO1xuICAgICAgICAgICAgaWYgKGxlYWQuYW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGxlYWQgY29tcG9uZW50IGlzIGFuaW1hdGluZywgYXNzaWduIHRoaXMgZWl0aGVyIHRoZSBlbnRlcmluZy9sZWF2aW5nXG4gICAgICAgICAgICAgICAgICogb3BhY2l0eVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoX2QgPSAoX2MgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJlc2VydmVPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9yIHdlJ3JlIG5vdCBhbmltYXRpbmcgYXQgYWxsLCBzZXQgdGhlIGxlYWQgY29tcG9uZW50IHRvIGl0cyBhY3R1YWxcbiAgICAgICAgICAgICAgICAgKiBvcGFjaXR5IGFuZCBvdGhlciBjb21wb25lbnRzIHRvIGhpZGRlbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9lID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoX2YgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2NhbGVDb3JyZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1RvUmVuZGVyW2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIF9oID0gc2NhbGVDb3JyZWN0b3JzW2tleV0sIGNvcnJlY3QgPSBfaC5jb3JyZWN0LCBhcHBseVRvID0gX2guYXBwbHlUbztcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdGVkID0gY29ycmVjdCh2YWx1ZXNUb1JlbmRlcltrZXldLCBsZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbHlUbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gYXBwbHlUby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1thcHBseVRvW2ldXSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW2tleV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNhYmxlIHBvaW50ZXIgZXZlbnRzIG9uIGZvbGxvdyBjb21wb25lbnRzLiBUaGlzIGlzIHRvIGVuc3VyZVxuICAgICAgICAgICAgICogdGhhdCBpZiBhIGZvbGxvdyBjb21wb25lbnQgY292ZXJzIGEgbGVhZCBjb21wb25lbnQgaXQgZG9lc24ndCBibG9ja1xuICAgICAgICAgICAgICogcG9pbnRlciBldmVudHMgb24gdGhlIGxlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmNsZWFyU25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZUZyb20gPSB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICAvLyBPbmx5IHJ1biBvbiByb290XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZXNldFRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBub2RlLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yb290LnNoYXJlZE5vZGVzLmNsZWFyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9qZWN0aW9uTm9kZTtcbiAgICB9KCkpO1xufVxuZnVuY3Rpb24gdXBkYXRlTGF5b3V0KG5vZGUpIHtcbiAgICBub2RlLnVwZGF0ZUxheW91dCgpO1xufVxuZnVuY3Rpb24gbm90aWZ5TGF5b3V0VXBkYXRlKG5vZGUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgdmFyIHNuYXBzaG90ID0gKF9iID0gKF9hID0gbm9kZS5yZXN1bWVGcm9tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc25hcHNob3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5vZGUuc25hcHNob3Q7XG4gICAgaWYgKG5vZGUuaXNMZWFkKCkgJiZcbiAgICAgICAgbm9kZS5sYXlvdXQgJiZcbiAgICAgICAgc25hcHNob3QgJiZcbiAgICAgICAgbm9kZS5oYXNMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIikpIHtcbiAgICAgICAgdmFyIF9lID0gbm9kZS5sYXlvdXQsIGxheW91dF8xID0gX2UuYWN0dWFsLCBtZWFzdXJlZExheW91dCA9IF9lLm1lYXN1cmVkO1xuICAgICAgICAvLyBUT0RPIE1heWJlIHdlIHdhbnQgdG8gYWxzbyByZXNpemUgdGhlIGxheW91dCBzbmFwc2hvdCBzbyB3ZSBkb24ndCB0cmlnZ2VyXG4gICAgICAgIC8vIGFuaW1hdGlvbnMgZm9yIGluc3RhbmNlIGlmIGxheW91dD1cInNpemVcIiBhbmQgYW4gZWxlbWVudCBoYXMgb25seSBjaGFuZ2VkIHBvc2l0aW9uXG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMuYW5pbWF0aW9uVHlwZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNTbmFwc2hvdCA9IHNuYXBzaG90LmlzU2hhcmVkXG4gICAgICAgICAgICAgICAgICAgID8gc25hcHNob3QubWVhc3VyZWRbYXhpc11cbiAgICAgICAgICAgICAgICAgICAgOiBzbmFwc2hvdC5sYXlvdXRbYXhpc107XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGNhbGNMZW5ndGgoYXhpc1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWluID0gbGF5b3V0XzFbYXhpc10ubWluO1xuICAgICAgICAgICAgICAgIGF4aXNTbmFwc2hvdC5tYXggPSBheGlzU25hcHNob3QubWluICsgbGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5vcHRpb25zLmFuaW1hdGlvblR5cGUgPT09IFwicG9zaXRpb25cIikge1xuICAgICAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1NuYXBzaG90ID0gc25hcHNob3QuaXNTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5tZWFzdXJlZFtheGlzXVxuICAgICAgICAgICAgICAgICAgICA6IHNuYXBzaG90LmxheW91dFtheGlzXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gY2FsY0xlbmd0aChsYXlvdXRfMVtheGlzXSk7XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5b3V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICBjYWxjQm94RGVsdGEobGF5b3V0RGVsdGEsIGxheW91dF8xLCBzbmFwc2hvdC5sYXlvdXQpO1xuICAgICAgICB2YXIgdmlzdWFsRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICBpZiAoc25hcHNob3QuaXNTaGFyZWQpIHtcbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbm9kZS5hcHBseVRyYW5zZm9ybShtZWFzdXJlZExheW91dCwgdHJ1ZSksIHNuYXBzaG90Lm1lYXN1cmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbGF5b3V0XzEsIHNuYXBzaG90LmxheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc0xheW91dENoYW5nZWQgPSAhaXNEZWx0YVplcm8obGF5b3V0RGVsdGEpO1xuICAgICAgICB2YXIgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICghbm9kZS5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICBub2RlLnJlbGF0aXZlUGFyZW50ID0gbm9kZS5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgcmVsYXRpdmVQYXJlbnQgaXMgaXRzZWxmIHJlc3VtaW5nIGZyb20gYSBkaWZmZXJlbnQgZWxlbWVudCB0aGVuXG4gICAgICAgICAgICAgKiB0aGUgcmVsYXRpdmUgc25hcHNob3QgaXMgbm90IHJlbGF2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChub2RlLnJlbGF0aXZlUGFyZW50ICYmICFub2RlLnJlbGF0aXZlUGFyZW50LnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2YgPSBub2RlLnJlbGF0aXZlUGFyZW50LCBwYXJlbnRTbmFwc2hvdCA9IF9mLnNuYXBzaG90LCBwYXJlbnRMYXlvdXQgPSBfZi5sYXlvdXQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNuYXBzaG90ICYmIHBhcmVudExheW91dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVsYXRpdmVTbmFwc2hvdCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZVNuYXBzaG90LCBzbmFwc2hvdC5sYXlvdXQsIHBhcmVudFNuYXBzaG90LmxheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgbGF5b3V0XzEsIHBhcmVudExheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJveEVxdWFscyhyZWxhdGl2ZVNuYXBzaG90LCByZWxhdGl2ZUxheW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub3RpZnlMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIiwge1xuICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXRfMSxcbiAgICAgICAgICAgIHNuYXBzaG90OiBzbmFwc2hvdCxcbiAgICAgICAgICAgIGRlbHRhOiB2aXN1YWxEZWx0YSxcbiAgICAgICAgICAgIGxheW91dERlbHRhOiBsYXlvdXREZWx0YSxcbiAgICAgICAgICAgIGhhc0xheW91dENoYW5nZWQ6IGhhc0xheW91dENoYW5nZWQsXG4gICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ6IGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuaXNMZWFkKCkpIHtcbiAgICAgICAgKF9kID0gKF9jID0gbm9kZS5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcmluZyB0cmFuc2l0aW9uXG4gICAgICogVE9ETzogSW52ZXN0aWdhdGUgd2h5IHRoaXMgdHJhbnNpdGlvbiBpcyBiZWluZyBwYXNzZWQgaW4gYXMge3R5cGU6IGZhbHNlIH0gZnJvbSBGcmFtZXJcbiAgICAgKiBhbmQgd2h5IHdlIG5lZWQgaXQgYXQgYWxsXG4gICAgICovXG4gICAgbm9kZS5vcHRpb25zLnRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjbGVhclNuYXBzaG90KG5vZGUpIHtcbiAgICBub2RlLmNsZWFyU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyTWVhc3VyZW1lbnRzKG5vZGUpIHtcbiAgICBub2RlLmNsZWFyTWVhc3VyZW1lbnRzKCk7XG59XG5mdW5jdGlvbiByZXNldFRyYW5zZm9ybVN0eWxlKG5vZGUpIHtcbiAgICB2YXIgdmlzdWFsRWxlbWVudCA9IG5vZGUub3B0aW9ucy52aXN1YWxFbGVtZW50O1xuICAgIGlmICh2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5vbkJlZm9yZUxheW91dE1lYXN1cmUpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5ub3RpZnlCZWZvcmVMYXlvdXRNZWFzdXJlKCk7XG4gICAgfVxuICAgIG5vZGUucmVzZXRUcmFuc2Zvcm0oKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEFuaW1hdGlvbihub2RlKSB7XG4gICAgbm9kZS5maW5pc2hBbmltYXRpb24oKTtcbiAgICBub2RlLnRhcmdldERlbHRhID0gbm9kZS5yZWxhdGl2ZVRhcmdldCA9IG5vZGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldERlbHRhKG5vZGUpIHtcbiAgICBub2RlLnJlc29sdmVUYXJnZXREZWx0YSgpO1xufVxuZnVuY3Rpb24gY2FsY1Byb2plY3Rpb24obm9kZSkge1xuICAgIG5vZGUuY2FsY1Byb2plY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIHJlc2V0Um90YXRpb24obm9kZSkge1xuICAgIG5vZGUucmVzZXRSb3RhdGlvbigpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGVhZFNuYXBzaG90cyhzdGFjaykge1xuICAgIHN0YWNrLnJlbW92ZUxlYWRTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gbWl4QXhpc0RlbHRhKG91dHB1dCwgZGVsdGEsIHApIHtcbiAgICBvdXRwdXQudHJhbnNsYXRlID0gbWl4KGRlbHRhLnRyYW5zbGF0ZSwgMCwgcCk7XG4gICAgb3V0cHV0LnNjYWxlID0gbWl4KGRlbHRhLnNjYWxlLCAxLCBwKTtcbiAgICBvdXRwdXQub3JpZ2luID0gZGVsdGEub3JpZ2luO1xuICAgIG91dHB1dC5vcmlnaW5Qb2ludCA9IGRlbHRhLm9yaWdpblBvaW50O1xufVxuZnVuY3Rpb24gbWl4QXhpcyhvdXRwdXQsIGZyb20sIHRvLCBwKSB7XG4gICAgb3V0cHV0Lm1pbiA9IG1peChmcm9tLm1pbiwgdG8ubWluLCBwKTtcbiAgICBvdXRwdXQubWF4ID0gbWl4KGZyb20ubWF4LCB0by5tYXgsIHApO1xufVxuZnVuY3Rpb24gbWl4Qm94KG91dHB1dCwgZnJvbSwgdG8sIHApIHtcbiAgICBtaXhBeGlzKG91dHB1dC54LCBmcm9tLngsIHRvLngsIHApO1xuICAgIG1peEF4aXMob3V0cHV0LnksIGZyb20ueSwgdG8ueSwgcCk7XG59XG5mdW5jdGlvbiBoYXNPcGFjaXR5Q3Jvc3NmYWRlKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuYW5pbWF0aW9uVmFsdWVzICYmIG5vZGUuYW5pbWF0aW9uVmFsdWVzLm9wYWNpdHlFeGl0ICE9PSB1bmRlZmluZWQpO1xufVxudmFyIGRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uID0ge1xuICAgIGR1cmF0aW9uOiAwLjQ1LFxuICAgIGVhc2U6IFswLjQsIDAsIDAuMSwgMV0sXG59O1xuZnVuY3Rpb24gbW91bnROb2RlRWFybHkobm9kZSwgaWQpIHtcbiAgICAvKipcbiAgICAgKiBSYXRoZXIgdGhhbiBzZWFyY2hpbmcgdGhlIERPTSBmcm9tIGRvY3VtZW50IHdlIGNhbiBzZWFyY2ggdGhlXG4gICAgICogcGF0aCBmb3IgdGhlIGRlZXBlc3QgbW91bnRlZCBhbmNlc3RvciBhbmQgc2VhcmNoIGZyb20gdGhlcmVcbiAgICAgKi9cbiAgICB2YXIgc2VhcmNoTm9kZSA9IG5vZGUucm9vdDtcbiAgICBmb3IgKHZhciBpID0gbm9kZS5wYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChCb29sZWFuKG5vZGUucGF0aFtpXS5pbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHNlYXJjaE5vZGUgPSBub2RlLnBhdGhbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2VhcmNoRWxlbWVudCA9IHNlYXJjaE5vZGUgJiYgc2VhcmNoTm9kZSAhPT0gbm9kZS5yb290ID8gc2VhcmNoTm9kZS5pbnN0YW5jZSA6IGRvY3VtZW50O1xuICAgIHZhciBlbGVtZW50ID0gc2VhcmNoRWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcHJvamVjdGlvbi1pZD1cXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJdXCIpKTtcbiAgICBpZiAoZWxlbWVudClcbiAgICAgICAgbm9kZS5tb3VudChlbGVtZW50LCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHJvdW5kQXhpcyhheGlzKSB7XG4gICAgYXhpcy5taW4gPSBNYXRoLnJvdW5kKGF4aXMubWluKTtcbiAgICBheGlzLm1heCA9IE1hdGgucm91bmQoYXhpcy5tYXgpO1xufVxuZnVuY3Rpb24gcm91bmRCb3goYm94KSB7XG4gICAgcm91bmRBeGlzKGJveC54KTtcbiAgICByb3VuZEF4aXMoYm94LnkpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVQcm9qZWN0aW9uTm9kZSwgZ2xvYmFsUHJvamVjdGlvblN0YXRlLCBtaXhBeGlzLCBtaXhBeGlzRGVsdGEsIG1peEJveCB9O1xuIiwgImltcG9ydCB7IG9uTmV4dEZyYW1lLCBkZWZhdWx0VGltZXN0ZXAgfSBmcm9tICcuL29uLW5leHQtZnJhbWUubWpzJztcbmltcG9ydCB7IGNyZWF0ZVJlbmRlclN0ZXAgfSBmcm9tICcuL2NyZWF0ZS1yZW5kZXItc3RlcC5tanMnO1xuXG5jb25zdCBtYXhFbGFwc2VkID0gNDA7XG5sZXQgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xubGV0IHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xubGV0IGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuY29uc3QgZnJhbWUgPSB7XG4gICAgZGVsdGE6IDAsXG4gICAgdGltZXN0YW1wOiAwLFxufTtcbmNvbnN0IHN0ZXBzT3JkZXIgPSBbXG4gICAgXCJyZWFkXCIsXG4gICAgXCJ1cGRhdGVcIixcbiAgICBcInByZVJlbmRlclwiLFxuICAgIFwicmVuZGVyXCIsXG4gICAgXCJwb3N0UmVuZGVyXCIsXG5dO1xuY29uc3Qgc3RlcHMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IGNyZWF0ZVJlbmRlclN0ZXAoKCkgPT4gKHJ1bk5leHRGcmFtZSA9IHRydWUpKTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuY29uc3Qgc3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1trZXldO1xuICAgIGFjY1trZXldID0gKHByb2Nlc3MsIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAoIXJ1bk5leHRGcmFtZSlcbiAgICAgICAgICAgIHN0YXJ0TG9vcCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5zY2hlZHVsZShwcm9jZXNzLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuY29uc3QgY2FuY2VsU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gc3RlcHNba2V5XS5jYW5jZWw7XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbmNvbnN0IGZsdXNoU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gKCkgPT4gc3RlcHNba2V5XS5wcm9jZXNzKGZyYW1lKTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuY29uc3QgcHJvY2Vzc1N0ZXAgPSAoc3RlcElkKSA9PiBzdGVwc1tzdGVwSWRdLnByb2Nlc3MoZnJhbWUpO1xuY29uc3QgcHJvY2Vzc0ZyYW1lID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgIHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xuICAgIGZyYW1lLmRlbHRhID0gdXNlRGVmYXVsdEVsYXBzZWRcbiAgICAgICAgPyBkZWZhdWx0VGltZXN0ZXBcbiAgICAgICAgOiBNYXRoLm1heChNYXRoLm1pbih0aW1lc3RhbXAgLSBmcmFtZS50aW1lc3RhbXAsIG1heEVsYXBzZWQpLCAxKTtcbiAgICBmcmFtZS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICBzdGVwc09yZGVyLmZvckVhY2gocHJvY2Vzc1N0ZXApO1xuICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIGlmIChydW5OZXh0RnJhbWUpIHtcbiAgICAgICAgdXNlRGVmYXVsdEVsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgb25OZXh0RnJhbWUocHJvY2Vzc0ZyYW1lKTtcbiAgICB9XG59O1xuY29uc3Qgc3RhcnRMb29wID0gKCkgPT4ge1xuICAgIHJ1bk5leHRGcmFtZSA9IHRydWU7XG4gICAgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xuICAgIGlmICghaXNQcm9jZXNzaW5nKVxuICAgICAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xufTtcbmNvbnN0IGdldEZyYW1lRGF0YSA9ICgpID0+IGZyYW1lO1xuXG5leHBvcnQgZGVmYXVsdCBzeW5jO1xuZXhwb3J0IHsgY2FuY2VsU3luYywgZmx1c2hTeW5jLCBnZXRGcmFtZURhdGEgfTtcbiIsICJjb25zdCBkZWZhdWx0VGltZXN0ZXAgPSAoMSAvIDYwKSAqIDEwMDA7XG5jb25zdCBnZXRDdXJyZW50VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5jb25zdCBvbk5leHRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IChjYWxsYmFjaykgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaylcbiAgICA6IChjYWxsYmFjaykgPT4gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayhnZXRDdXJyZW50VGltZSgpKSwgZGVmYXVsdFRpbWVzdGVwKTtcblxuZXhwb3J0IHsgZGVmYXVsdFRpbWVzdGVwLCBvbk5leHRGcmFtZSB9O1xuIiwgImZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0ZXAocnVuTmV4dEZyYW1lKSB7XG4gICAgbGV0IHRvUnVuID0gW107XG4gICAgbGV0IHRvUnVuTmV4dEZyYW1lID0gW107XG4gICAgbGV0IG51bVRvUnVuID0gMDtcbiAgICBsZXQgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgbGV0IGZsdXNoTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgY29uc3QgdG9LZWVwQWxpdmUgPSBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHN0ZXAgPSB7XG4gICAgICAgIHNjaGVkdWxlOiAoY2FsbGJhY2ssIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkVG9DdXJyZW50RnJhbWUgPSBpbW1lZGlhdGUgJiYgaXNQcm9jZXNzaW5nO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYWRkVG9DdXJyZW50RnJhbWUgPyB0b1J1biA6IHRvUnVuTmV4dEZyYW1lO1xuICAgICAgICAgICAgaWYgKGtlZXBBbGl2ZSlcbiAgICAgICAgICAgICAgICB0b0tlZXBBbGl2ZS5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZFRvQ3VycmVudEZyYW1lICYmIGlzUHJvY2Vzc2luZylcbiAgICAgICAgICAgICAgICAgICAgbnVtVG9SdW4gPSB0b1J1bi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRvUnVuTmV4dEZyYW1lLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICB0b1J1bk5leHRGcmFtZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdG9LZWVwQWxpdmUuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2VzczogKGZyYW1lRGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIGZsdXNoTmV4dEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgW3RvUnVuLCB0b1J1bk5leHRGcmFtZV0gPSBbdG9SdW5OZXh0RnJhbWUsIHRvUnVuXTtcbiAgICAgICAgICAgIHRvUnVuTmV4dEZyYW1lLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBudW1Ub1J1biA9IHRvUnVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChudW1Ub1J1bikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVG9SdW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRvUnVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhmcmFtZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9LZWVwQWxpdmUuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcC5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5OZXh0RnJhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZsdXNoTmV4dEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGVwLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBzdGVwO1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZW5kZXJTdGVwIH07XG4iLCAiZXhwb3J0IHsgYW5pbWF0ZSB9IGZyb20gJy4vYW5pbWF0aW9ucy9pbmRleC5tanMnO1xuZXhwb3J0IHsgaW5lcnRpYSB9IGZyb20gJy4vYW5pbWF0aW9ucy9pbmVydGlhLm1qcyc7XG5leHBvcnQgeyBkZWNheSB9IGZyb20gJy4vYW5pbWF0aW9ucy9nZW5lcmF0b3JzL2RlY2F5Lm1qcyc7XG5leHBvcnQgeyBzcHJpbmcgfSBmcm9tICcuL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9zcHJpbmcubWpzJztcbmV4cG9ydCB7IGtleWZyYW1lcyB9IGZyb20gJy4vYW5pbWF0aW9ucy9nZW5lcmF0b3JzL2tleWZyYW1lcy5tanMnO1xuZXhwb3J0IHsgYW5nbGUgfSBmcm9tICcuL3V0aWxzL2FuZ2xlLm1qcyc7XG5leHBvcnQgeyBhcHBseU9mZnNldCB9IGZyb20gJy4vdXRpbHMvYXBwbHktb2Zmc2V0Lm1qcyc7XG5leHBvcnQgeyBhdHRyYWN0LCBhdHRyYWN0RXhwbywgY3JlYXRlQXR0cmFjdG9yIH0gZnJvbSAnLi91dGlscy9hdHRyYWN0Lm1qcyc7XG5leHBvcnQgeyBjbGFtcCB9IGZyb20gJy4vdXRpbHMvY2xhbXAubWpzJztcbmV4cG9ydCB7IGRlZ3JlZXNUb1JhZGlhbnMgfSBmcm9tICcuL3V0aWxzL2RlZ3JlZXMtdG8tcmFkaWFucy5tanMnO1xuZXhwb3J0IHsgZGlzdGFuY2UgfSBmcm9tICcuL3V0aWxzL2Rpc3RhbmNlLm1qcyc7XG5leHBvcnQgeyBpbnRlcnBvbGF0ZSB9IGZyb20gJy4vdXRpbHMvaW50ZXJwb2xhdGUubWpzJztcbmV4cG9ydCB7IGlzUG9pbnQzRCB9IGZyb20gJy4vdXRpbHMvaXMtcG9pbnQtM2QubWpzJztcbmV4cG9ydCB7IGlzUG9pbnQgfSBmcm9tICcuL3V0aWxzL2lzLXBvaW50Lm1qcyc7XG5leHBvcnQgeyBtaXhDb2xvciB9IGZyb20gJy4vdXRpbHMvbWl4LWNvbG9yLm1qcyc7XG5leHBvcnQgeyBtaXhDb21wbGV4IH0gZnJvbSAnLi91dGlscy9taXgtY29tcGxleC5tanMnO1xuZXhwb3J0IHsgbWl4IH0gZnJvbSAnLi91dGlscy9taXgubWpzJztcbmV4cG9ydCB7IHBpcGUgfSBmcm9tICcuL3V0aWxzL3BpcGUubWpzJztcbmV4cG9ydCB7IHBvaW50RnJvbVZlY3RvciB9IGZyb20gJy4vdXRpbHMvcG9pbnQtZnJvbS12ZWN0b3IubWpzJztcbmV4cG9ydCB7IHByb2dyZXNzIH0gZnJvbSAnLi91dGlscy9wcm9ncmVzcy5tanMnO1xuZXhwb3J0IHsgcmFkaWFuc1RvRGVncmVlcyB9IGZyb20gJy4vdXRpbHMvcmFkaWFucy10by1kZWdyZWVzLm1qcyc7XG5leHBvcnQgeyBzbW9vdGhGcmFtZSB9IGZyb20gJy4vdXRpbHMvc21vb3RoLWZyYW1lLm1qcyc7XG5leHBvcnQgeyBzbW9vdGggfSBmcm9tICcuL3V0aWxzL3Ntb290aC5tanMnO1xuZXhwb3J0IHsgc25hcCB9IGZyb20gJy4vdXRpbHMvc25hcC5tanMnO1xuZXhwb3J0IHsgdG9EZWNpbWFsIH0gZnJvbSAnLi91dGlscy90by1kZWNpbWFsLm1qcyc7XG5leHBvcnQgeyB2ZWxvY2l0eVBlckZyYW1lIH0gZnJvbSAnLi91dGlscy92ZWxvY2l0eS1wZXItZnJhbWUubWpzJztcbmV4cG9ydCB7IHZlbG9jaXR5UGVyU2Vjb25kIH0gZnJvbSAnLi91dGlscy92ZWxvY2l0eS1wZXItc2Vjb25kLm1qcyc7XG5leHBvcnQgeyB3cmFwIH0gZnJvbSAnLi91dGlscy93cmFwLm1qcyc7XG5leHBvcnQgeyBhbnRpY2lwYXRlLCBiYWNrSW4sIGJhY2tJbk91dCwgYmFja091dCwgYm91bmNlSW4sIGJvdW5jZUluT3V0LCBib3VuY2VPdXQsIGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0LCBlYXNlSW4sIGVhc2VJbk91dCwgZWFzZU91dCwgbGluZWFyIH0gZnJvbSAnLi9lYXNpbmcvaW5kZXgubWpzJztcbmV4cG9ydCB7IGN1YmljQmV6aWVyIH0gZnJvbSAnLi9lYXNpbmcvY3ViaWMtYmV6aWVyLm1qcyc7XG5leHBvcnQgeyBzdGVwcyB9IGZyb20gJy4vZWFzaW5nL3N0ZXBzLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVBbnRpY2lwYXRlLCBjcmVhdGVCYWNrSW4sIGNyZWF0ZUV4cG9JbiwgbWlycm9yRWFzaW5nLCByZXZlcnNlRWFzaW5nIH0gZnJvbSAnLi9lYXNpbmcvdXRpbHMubWpzJztcbiIsICJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyB9IGZyb20gJy4vdXRpbHMvZGV0ZWN0LWFuaW1hdGlvbi1mcm9tLW9wdGlvbnMubWpzJztcbmltcG9ydCBzeW5jLCB7IGNhbmNlbFN5bmMgfSBmcm9tICdmcmFtZXN5bmMnO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGUgfSBmcm9tICcuLi91dGlscy9pbnRlcnBvbGF0ZS5tanMnO1xuaW1wb3J0IHsgaGFzUmVwZWF0RGVsYXlFbGFwc2VkLCByZXZlcnNlRWxhcHNlZCwgbG9vcEVsYXBzZWQgfSBmcm9tICcuL3V0aWxzL2VsYXBzZWQubWpzJztcblxuY29uc3QgZnJhbWVzeW5jID0gKHVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IHBhc3NUaW1lc3RhbXAgPSAoeyBkZWx0YSB9KSA9PiB1cGRhdGUoZGVsdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAoKSA9PiBzeW5jLnVwZGF0ZShwYXNzVGltZXN0YW1wLCB0cnVlKSxcbiAgICAgICAgc3RvcDogKCkgPT4gY2FuY2VsU3luYy51cGRhdGUocGFzc1RpbWVzdGFtcCksXG4gICAgfTtcbn07XG5mdW5jdGlvbiBhbmltYXRlKF9hKSB7XG4gICAgdmFyIF9iLCBfYztcbiAgICB2YXIgeyBmcm9tLCBhdXRvcGxheSA9IHRydWUsIGRyaXZlciA9IGZyYW1lc3luYywgZWxhcHNlZCA9IDAsIHJlcGVhdDogcmVwZWF0TWF4ID0gMCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiLCByZXBlYXREZWxheSA9IDAsIG9uUGxheSwgb25TdG9wLCBvbkNvbXBsZXRlLCBvblJlcGVhdCwgb25VcGRhdGUgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwiYXV0b3BsYXlcIiwgXCJkcml2ZXJcIiwgXCJlbGFwc2VkXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0VHlwZVwiLCBcInJlcGVhdERlbGF5XCIsIFwib25QbGF5XCIsIFwib25TdG9wXCIsIFwib25Db21wbGV0ZVwiLCBcIm9uUmVwZWF0XCIsIFwib25VcGRhdGVcIl0pO1xuICAgIGxldCB7IHRvIH0gPSBvcHRpb25zO1xuICAgIGxldCBkcml2ZXJDb250cm9scztcbiAgICBsZXQgcmVwZWF0Q291bnQgPSAwO1xuICAgIGxldCBjb21wdXRlZER1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgICBsZXQgbGF0ZXN0O1xuICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgbGV0IGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZTtcbiAgICBsZXQgaW50ZXJwb2xhdGVGcm9tTnVtYmVyO1xuICAgIGNvbnN0IGFuaW1hdG9yID0gZGV0ZWN0QW5pbWF0aW9uRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKChfYyA9IChfYiA9IGFuaW1hdG9yKS5uZWVkc0ludGVycG9sYXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBmcm9tLCB0bykpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVGcm9tTnVtYmVyID0gaW50ZXJwb2xhdGUoWzAsIDEwMF0sIFtmcm9tLCB0b10sIHtcbiAgICAgICAgICAgIGNsYW1wOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZyb20gPSAwO1xuICAgICAgICB0byA9IDEwMDtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gYW5pbWF0b3IoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmcm9tLCB0byB9KSk7XG4gICAgZnVuY3Rpb24gcmVwZWF0KCkge1xuICAgICAgICByZXBlYXRDb3VudCsrO1xuICAgICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgICAgICAgIGlzRm9yd2FyZFBsYXliYWNrID0gcmVwZWF0Q291bnQgJSAyID09PSAwO1xuICAgICAgICAgICAgZWxhcHNlZCA9IHJldmVyc2VFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5LCBpc0ZvcndhcmRQbGF5YmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGFwc2VkID0gbG9vcEVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXkpO1xuICAgICAgICAgICAgaWYgKHJlcGVhdFR5cGUgPT09IFwibWlycm9yXCIpXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmZsaXBUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIG9uUmVwZWF0ICYmIG9uUmVwZWF0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBkcml2ZXJDb250cm9scy5zdG9wKCk7XG4gICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCFpc0ZvcndhcmRQbGF5YmFjaylcbiAgICAgICAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgICAgICBlbGFwc2VkICs9IGRlbHRhO1xuICAgICAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYW5pbWF0aW9uLm5leHQoTWF0aC5tYXgoMCwgZWxhcHNlZCkpO1xuICAgICAgICAgICAgbGF0ZXN0ID0gc3RhdGUudmFsdWU7XG4gICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGVGcm9tTnVtYmVyKVxuICAgICAgICAgICAgICAgIGxhdGVzdCA9IGludGVycG9sYXRlRnJvbU51bWJlcihsYXRlc3QpO1xuICAgICAgICAgICAgaXNDb21wbGV0ZSA9IGlzRm9yd2FyZFBsYXliYWNrID8gc3RhdGUuZG9uZSA6IGVsYXBzZWQgPD0gMDtcbiAgICAgICAgfVxuICAgICAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUobGF0ZXN0KTtcbiAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGlmIChyZXBlYXRDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBjb21wdXRlZER1cmF0aW9uICE9PSBudWxsICYmIGNvbXB1dGVkRHVyYXRpb24gIT09IHZvaWQgMCA/IGNvbXB1dGVkRHVyYXRpb24gOiAoY29tcHV0ZWREdXJhdGlvbiA9IGVsYXBzZWQpO1xuICAgICAgICAgICAgaWYgKHJlcGVhdENvdW50IDwgcmVwZWF0TWF4KSB7XG4gICAgICAgICAgICAgICAgaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5LCBpc0ZvcndhcmRQbGF5YmFjaykgJiYgcmVwZWF0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgIG9uUGxheSA9PT0gbnVsbCB8fCBvblBsYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUGxheSgpO1xuICAgICAgICBkcml2ZXJDb250cm9scyA9IGRyaXZlcih1cGRhdGUpO1xuICAgICAgICBkcml2ZXJDb250cm9scy5zdGFydCgpO1xuICAgIH1cbiAgICBhdXRvcGxheSAmJiBwbGF5KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgb25TdG9wID09PSBudWxsIHx8IG9uU3RvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25TdG9wKCk7XG4gICAgICAgICAgICBkcml2ZXJDb250cm9scy5zdG9wKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgYW5pbWF0ZSB9O1xuIiwgImltcG9ydCB0c2xpYiBmcm9tICcuLi90c2xpYi5qcyc7XHJcbmNvbnN0IHtcclxuICAgIF9fZXh0ZW5kcyxcclxuICAgIF9fYXNzaWduLFxyXG4gICAgX19yZXN0LFxyXG4gICAgX19kZWNvcmF0ZSxcclxuICAgIF9fcGFyYW0sXHJcbiAgICBfX21ldGFkYXRhLFxyXG4gICAgX19hd2FpdGVyLFxyXG4gICAgX19nZW5lcmF0b3IsXHJcbiAgICBfX2V4cG9ydFN0YXIsXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcsXHJcbiAgICBfX3ZhbHVlcyxcclxuICAgIF9fcmVhZCxcclxuICAgIF9fc3ByZWFkLFxyXG4gICAgX19zcHJlYWRBcnJheXMsXHJcbiAgICBfX3NwcmVhZEFycmF5LFxyXG4gICAgX19hd2FpdCxcclxuICAgIF9fYXN5bmNHZW5lcmF0b3IsXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yLFxyXG4gICAgX19hc3luY1ZhbHVlcyxcclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxyXG4gICAgX19pbXBvcnRTdGFyLFxyXG4gICAgX19pbXBvcnREZWZhdWx0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXHJcbn0gPSB0c2xpYjtcclxuZXhwb3J0IHtcclxuICAgIF9fZXh0ZW5kcyxcclxuICAgIF9fYXNzaWduLFxyXG4gICAgX19yZXN0LFxyXG4gICAgX19kZWNvcmF0ZSxcclxuICAgIF9fcGFyYW0sXHJcbiAgICBfX21ldGFkYXRhLFxyXG4gICAgX19hd2FpdGVyLFxyXG4gICAgX19nZW5lcmF0b3IsXHJcbiAgICBfX2V4cG9ydFN0YXIsXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcsXHJcbiAgICBfX3ZhbHVlcyxcclxuICAgIF9fcmVhZCxcclxuICAgIF9fc3ByZWFkLFxyXG4gICAgX19zcHJlYWRBcnJheXMsXHJcbiAgICBfX3NwcmVhZEFycmF5LFxyXG4gICAgX19hd2FpdCxcclxuICAgIF9fYXN5bmNHZW5lcmF0b3IsXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yLFxyXG4gICAgX19hc3luY1ZhbHVlcyxcclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxyXG4gICAgX19pbXBvcnRTdGFyLFxyXG4gICAgX19pbXBvcnREZWZhdWx0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXHJcbn07XHJcbiIsICJpbXBvcnQgeyBzcHJpbmcgfSBmcm9tICcuLi9nZW5lcmF0b3JzL3NwcmluZy5tanMnO1xuaW1wb3J0IHsga2V5ZnJhbWVzIH0gZnJvbSAnLi4vZ2VuZXJhdG9ycy9rZXlmcmFtZXMubWpzJztcbmltcG9ydCB7IGRlY2F5IH0gZnJvbSAnLi4vZ2VuZXJhdG9ycy9kZWNheS5tanMnO1xuXG5jb25zdCB0eXBlcyA9IHsga2V5ZnJhbWVzLCBzcHJpbmcsIGRlY2F5IH07XG5mdW5jdGlvbiBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyhjb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcudG8pKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVzW2NvbmZpZy50eXBlXSkge1xuICAgICAgICByZXR1cm4gdHlwZXNbY29uZmlnLnR5cGVdO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhjb25maWcpKTtcbiAgICBpZiAoa2V5cy5oYXMoXCJlYXNlXCIpIHx8XG4gICAgICAgIChrZXlzLmhhcyhcImR1cmF0aW9uXCIpICYmICFrZXlzLmhhcyhcImRhbXBpbmdSYXRpb1wiKSkpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lcztcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5cy5oYXMoXCJkYW1waW5nUmF0aW9cIikgfHxcbiAgICAgICAga2V5cy5oYXMoXCJzdGlmZm5lc3NcIikgfHxcbiAgICAgICAga2V5cy5oYXMoXCJtYXNzXCIpIHx8XG4gICAgICAgIGtleXMuaGFzKFwiZGFtcGluZ1wiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcInJlc3RTcGVlZFwiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcInJlc3REZWx0YVwiKSkge1xuICAgICAgICByZXR1cm4gc3ByaW5nO1xuICAgIH1cbiAgICByZXR1cm4ga2V5ZnJhbWVzO1xufVxuXG5leHBvcnQgeyBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGZpbmRTcHJpbmcsIGNhbGNBbmd1bGFyRnJlcSB9IGZyb20gJy4uL3V0aWxzL2ZpbmQtc3ByaW5nLm1qcyc7XG5cbmNvbnN0IGR1cmF0aW9uS2V5cyA9IFtcImR1cmF0aW9uXCIsIFwiYm91bmNlXCJdO1xuY29uc3QgcGh5c2ljc0tleXMgPSBbXCJzdGlmZm5lc3NcIiwgXCJkYW1waW5nXCIsIFwibWFzc1wiXTtcbmZ1bmN0aW9uIGlzU3ByaW5nVHlwZShvcHRpb25zLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMuc29tZSgoa2V5KSA9PiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBsZXQgc3ByaW5nT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB2ZWxvY2l0eTogMC4wLCBzdGlmZm5lc3M6IDEwMCwgZGFtcGluZzogMTAsIG1hc3M6IDEuMCwgaXNSZXNvbHZlZEZyb21EdXJhdGlvbjogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgaWYgKCFpc1NwcmluZ1R5cGUob3B0aW9ucywgcGh5c2ljc0tleXMpICYmXG4gICAgICAgIGlzU3ByaW5nVHlwZShvcHRpb25zLCBkdXJhdGlvbktleXMpKSB7XG4gICAgICAgIGNvbnN0IGRlcml2ZWQgPSBmaW5kU3ByaW5nKG9wdGlvbnMpO1xuICAgICAgICBzcHJpbmdPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNwcmluZ09wdGlvbnMpLCBkZXJpdmVkKSwgeyB2ZWxvY2l0eTogMC4wLCBtYXNzOiAxLjAgfSk7XG4gICAgICAgIHNwcmluZ09wdGlvbnMuaXNSZXNvbHZlZEZyb21EdXJhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzcHJpbmdPcHRpb25zO1xufVxuZnVuY3Rpb24gc3ByaW5nKF9hKSB7XG4gICAgdmFyIHsgZnJvbSA9IDAuMCwgdG8gPSAxLjAsIHJlc3RTcGVlZCA9IDIsIHJlc3REZWx0YSB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJ0b1wiLCBcInJlc3RTcGVlZFwiLCBcInJlc3REZWx0YVwiXSk7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICAgIGxldCB7IHN0aWZmbmVzcywgZGFtcGluZywgbWFzcywgdmVsb2NpdHksIGR1cmF0aW9uLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uLCB9ID0gZ2V0U3ByaW5nT3B0aW9ucyhvcHRpb25zKTtcbiAgICBsZXQgcmVzb2x2ZVNwcmluZyA9IHplcm87XG4gICAgbGV0IHJlc29sdmVWZWxvY2l0eSA9IHplcm87XG4gICAgZnVuY3Rpb24gY3JlYXRlU3ByaW5nKCkge1xuICAgICAgICBjb25zdCBpbml0aWFsVmVsb2NpdHkgPSB2ZWxvY2l0eSA/IC0odmVsb2NpdHkgLyAxMDAwKSA6IDAuMDtcbiAgICAgICAgY29uc3QgaW5pdGlhbERlbHRhID0gdG8gLSBmcm9tO1xuICAgICAgICBjb25zdCBkYW1waW5nUmF0aW8gPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICAgICAgICBjb25zdCB1bmRhbXBlZEFuZ3VsYXJGcmVxID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpIC8gMTAwMDtcbiAgICAgICAgaWYgKHJlc3REZWx0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN0RGVsdGEgPSBNYXRoLm1pbihNYXRoLmFicyh0byAtIGZyb20pIC8gMTAwLCAwLjQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgICAgICBjb25zdCBhbmd1bGFyRnJlcSA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEFuZ3VsYXJGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAodG8gLVxuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoKChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRnJlcSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlVmVsb2NpdHkgPSAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRhbXBpbmdSYXRpbyAqXG4gICAgICAgICAgICAgICAgICAgIHVuZGFtcGVkQW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICgoTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW8gKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckZyZXEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSkgLVxuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYW1waW5nUmF0aW8gPT09IDEpIHtcbiAgICAgICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4gdG8gLVxuICAgICAgICAgICAgICAgIE1hdGguZXhwKC11bmRhbXBlZEFuZ3VsYXJGcmVxICogdCkgKlxuICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbERlbHRhICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsVmVsb2NpdHkgKyB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkYW1wZWRBbmd1bGFyRnJlcSA9IHVuZGFtcGVkQW5ndWxhckZyZXEgKiBNYXRoLnNxcnQoZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvIC0gMSk7XG4gICAgICAgICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlcUZvclQgPSBNYXRoLm1pbihkYW1wZWRBbmd1bGFyRnJlcSAqIHQsIDMwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0byAtXG4gICAgICAgICAgICAgICAgICAgIChlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luaChmcmVxRm9yVCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3NoKGZyZXFGb3JUKSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBlZEFuZ3VsYXJGcmVxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU3ByaW5nKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSByZXNvbHZlU3ByaW5nKHQpO1xuICAgICAgICAgICAgaWYgKCFpc1Jlc29sdmVkRnJvbUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0gcmVzb2x2ZVZlbG9jaXR5KHQpICogMTAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgPSBNYXRoLmFicyhjdXJyZW50VmVsb2NpdHkpIDw9IHJlc3RTcGVlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkID0gTWF0aC5hYnModG8gLSBjdXJyZW50KSA8PSByZXN0RGVsdGE7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCAmJiBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0byA6IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gLXZlbG9jaXR5O1xuICAgICAgICAgICAgW2Zyb20sIHRvXSA9IFt0bywgZnJvbV07XG4gICAgICAgICAgICBjcmVhdGVTcHJpbmcoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuc3ByaW5nLm5lZWRzSW50ZXJwb2xhdGlvbiA9IChhLCBiKSA9PiB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IHplcm8gPSAoX3QpID0+IDA7XG5cbmV4cG9ydCB7IHNwcmluZyB9O1xuIiwgImltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICdoZXktbGlzdGVuJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xhbXAubWpzJztcblxuY29uc3Qgc2FmZU1pbiA9IDAuMDAxO1xuY29uc3QgbWluRHVyYXRpb24gPSAwLjAxO1xuY29uc3QgbWF4RHVyYXRpb24gPSAxMC4wO1xuY29uc3QgbWluRGFtcGluZyA9IDAuMDU7XG5jb25zdCBtYXhEYW1waW5nID0gMTtcbmZ1bmN0aW9uIGZpbmRTcHJpbmcoeyBkdXJhdGlvbiA9IDgwMCwgYm91bmNlID0gMC4yNSwgdmVsb2NpdHkgPSAwLCBtYXNzID0gMSwgfSkge1xuICAgIGxldCBlbnZlbG9wZTtcbiAgICBsZXQgZGVyaXZhdGl2ZTtcbiAgICB3YXJuaW5nKGR1cmF0aW9uIDw9IG1heER1cmF0aW9uICogMTAwMCwgXCJTcHJpbmcgZHVyYXRpb24gbXVzdCBiZSAxMCBzZWNvbmRzIG9yIGxlc3NcIik7XG4gICAgbGV0IGRhbXBpbmdSYXRpbyA9IDEgLSBib3VuY2U7XG4gICAgZGFtcGluZ1JhdGlvID0gY2xhbXAobWluRGFtcGluZywgbWF4RGFtcGluZywgZGFtcGluZ1JhdGlvKTtcbiAgICBkdXJhdGlvbiA9IGNsYW1wKG1pbkR1cmF0aW9uLCBtYXhEdXJhdGlvbiwgZHVyYXRpb24gLyAxMDAwKTtcbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBleHBvbmVudGlhbERlY2F5IC0gdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBiID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVNaW4gLSAoYSAvIGIpICogYztcbiAgICAgICAgfTtcbiAgICAgICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkZWx0YSAqIHZlbG9jaXR5ICsgdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBlID0gTWF0aC5wb3coZGFtcGluZ1JhdGlvLCAyKSAqIE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgY29uc3QgZyA9IGNhbGNBbmd1bGFyRnJlcShNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gLWVudmVsb3BlKHVuZGFtcGVkRnJlcSkgKyBzYWZlTWluID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiAoZmFjdG9yICogKChkIC0gZSkgKiBmKSkgLyBnO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW52ZWxvcGUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodW5kYW1wZWRGcmVxIC0gdmVsb2NpdHkpICogZHVyYXRpb24gKyAxO1xuICAgICAgICAgICAgcmV0dXJuIC1zYWZlTWluICsgYSAqIGI7XG4gICAgICAgIH07XG4gICAgICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodmVsb2NpdHkgLSB1bmRhbXBlZEZyZXEpICogKGR1cmF0aW9uICogZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsR3Vlc3MgPSA1IC8gZHVyYXRpb247XG4gICAgY29uc3QgdW5kYW1wZWRGcmVxID0gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpO1xuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gKiAxMDAwO1xuICAgIGlmIChpc05hTih1bmRhbXBlZEZyZXEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgICAgICAgIGRhbXBpbmc6IDEwLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdGlmZm5lc3MgPSBNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpICogbWFzcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0aWZmbmVzcyxcbiAgICAgICAgICAgIGRhbXBpbmc6IGRhbXBpbmdSYXRpbyAqIDIgKiBNYXRoLnNxcnQobWFzcyAqIHN0aWZmbmVzcyksXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCByb290SXRlcmF0aW9ucyA9IDEyO1xuZnVuY3Rpb24gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gaW5pdGlhbEd1ZXNzO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm9vdEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgLSBlbnZlbG9wZShyZXN1bHQpIC8gZGVyaXZhdGl2ZShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKSB7XG4gICAgcmV0dXJuIHVuZGFtcGVkRnJlcSAqIE1hdGguc3FydCgxIC0gZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvKTtcbn1cblxuZXhwb3J0IHsgY2FsY0FuZ3VsYXJGcmVxLCBmaW5kU3ByaW5nLCBtYXhEYW1waW5nLCBtYXhEdXJhdGlvbiwgbWluRGFtcGluZywgbWluRHVyYXRpb24gfTtcbiIsICJjb25zdCBjbGFtcCA9IChtaW4sIG1heCwgdikgPT4gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcblxuZXhwb3J0IHsgY2xhbXAgfTtcbiIsICJpbXBvcnQgeyBpbnRlcnBvbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2ludGVycG9sYXRlLm1qcyc7XG5pbXBvcnQgeyBlYXNlSW5PdXQgfSBmcm9tICcuLi8uLi9lYXNpbmcvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gZGVmYXVsdEVhc2luZyh2YWx1ZXMsIGVhc2luZykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCgpID0+IGVhc2luZyB8fCBlYXNlSW5PdXQpLnNwbGljZSgwLCB2YWx1ZXMubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0KHZhbHVlcykge1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKF92YWx1ZSwgaSkgPT4gaSAhPT0gMCA/IGkgLyAobnVtVmFsdWVzIC0gMSkgOiAwKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gb2Zmc2V0Lm1hcCgobykgPT4gbyAqIGR1cmF0aW9uKTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyh7IGZyb20gPSAwLCB0byA9IDEsIGVhc2UsIG9mZnNldCwgZHVyYXRpb24gPSAzMDAsIH0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh0bykgPyB0byA6IFtmcm9tLCB0b107XG4gICAgY29uc3QgdGltZXMgPSBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhvZmZzZXQgJiYgb2Zmc2V0Lmxlbmd0aCA9PT0gdmFsdWVzLmxlbmd0aFxuICAgICAgICA/IG9mZnNldFxuICAgICAgICA6IGRlZmF1bHRPZmZzZXQodmFsdWVzKSwgZHVyYXRpb24pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKHRpbWVzLCB2YWx1ZXMsIHtcbiAgICAgICAgICAgIGVhc2U6IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlIDogZGVmYXVsdEVhc2luZyh2YWx1ZXMsIGVhc2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcigpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IGludGVycG9sYXRvcih0KTtcbiAgICAgICAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaW50ZXJwb2xhdG9yID0gY3JlYXRlSW50ZXJwb2xhdG9yKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgY29udmVydE9mZnNldFRvVGltZXMsIGRlZmF1bHRFYXNpbmcsIGRlZmF1bHRPZmZzZXQsIGtleWZyYW1lcyB9O1xuIiwgImltcG9ydCB7IHByb2dyZXNzIH0gZnJvbSAnLi9wcm9ncmVzcy5tanMnO1xuaW1wb3J0IHsgbWl4IH0gZnJvbSAnLi9taXgubWpzJztcbmltcG9ydCB7IG1peENvbG9yIH0gZnJvbSAnLi9taXgtY29sb3IubWpzJztcbmltcG9ydCB7IG1peENvbXBsZXgsIG1peEFycmF5LCBtaXhPYmplY3QgfSBmcm9tICcuL21peC1jb21wbGV4Lm1qcyc7XG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9jbGFtcC5tanMnO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJy4vcGlwZS5tanMnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5cbmNvbnN0IG1peE51bWJlciA9IChmcm9tLCB0bykgPT4gKHApID0+IG1peChmcm9tLCB0bywgcCk7XG5mdW5jdGlvbiBkZXRlY3RNaXhlckZhY3Rvcnkodikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG1peE51bWJlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjb2xvci50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4Q29tcGxleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHJldHVybiBtaXhBcnJheTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBtaXhPYmplY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgY3VzdG9tTWl4ZXIpIHtcbiAgICBjb25zdCBtaXhlcnMgPSBbXTtcbiAgICBjb25zdCBtaXhlckZhY3RvcnkgPSBjdXN0b21NaXhlciB8fCBkZXRlY3RNaXhlckZhY3Rvcnkob3V0cHV0WzBdKTtcbiAgICBjb25zdCBudW1NaXhlcnMgPSBvdXRwdXQubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1peGVyczsgaSsrKSB7XG4gICAgICAgIGxldCBtaXhlciA9IG1peGVyRmFjdG9yeShvdXRwdXRbaV0sIG91dHB1dFtpICsgMV0pO1xuICAgICAgICBpZiAoZWFzZSkge1xuICAgICAgICAgICAgY29uc3QgZWFzaW5nRnVuY3Rpb24gPSBBcnJheS5pc0FycmF5KGVhc2UpID8gZWFzZVtpXSA6IGVhc2U7XG4gICAgICAgICAgICBtaXhlciA9IHBpcGUoZWFzaW5nRnVuY3Rpb24sIG1peGVyKTtcbiAgICAgICAgfVxuICAgICAgICBtaXhlcnMucHVzaChtaXhlcik7XG4gICAgfVxuICAgIHJldHVybiBtaXhlcnM7XG59XG5mdW5jdGlvbiBmYXN0SW50ZXJwb2xhdGUoW2Zyb20sIHRvXSwgW21peGVyXSkge1xuICAgIHJldHVybiAodikgPT4gbWl4ZXIocHJvZ3Jlc3MoZnJvbSwgdG8sIHYpKTtcbn1cbmZ1bmN0aW9uIHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKSB7XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdElucHV0SW5kZXggPSBpbnB1dExlbmd0aCAtIDE7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGxldCBtaXhlckluZGV4ID0gMDtcbiAgICAgICAgbGV0IGZvdW5kTWl4ZXJJbmRleCA9IGZhbHNlO1xuICAgICAgICBpZiAodiA8PSBpbnB1dFswXSkge1xuICAgICAgICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IGlucHV0W2xhc3RJbnB1dEluZGV4XSkge1xuICAgICAgICAgICAgbWl4ZXJJbmRleCA9IGxhc3RJbnB1dEluZGV4IC0gMTtcbiAgICAgICAgICAgIGZvdW5kTWl4ZXJJbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZE1peGVySW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaW5wdXRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFtpXSA+IHYgfHwgaSA9PT0gbGFzdElucHV0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWl4ZXJJbmRleCA9IGkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyZXNzSW5SYW5nZSA9IHByb2dyZXNzKGlucHV0W21peGVySW5kZXhdLCBpbnB1dFttaXhlckluZGV4ICsgMV0sIHYpO1xuICAgICAgICByZXR1cm4gbWl4ZXJzW21peGVySW5kZXhdKHByb2dyZXNzSW5SYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBvdXRwdXQsIHsgY2xhbXA6IGlzQ2xhbXAgPSB0cnVlLCBlYXNlLCBtaXhlciB9ID0ge30pIHtcbiAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBpbnZhcmlhbnQoaW5wdXRMZW5ndGggPT09IG91dHB1dC5sZW5ndGgsICdCb3RoIGlucHV0IGFuZCBvdXRwdXQgcmFuZ2VzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgaW52YXJpYW50KCFlYXNlIHx8ICFBcnJheS5pc0FycmF5KGVhc2UpIHx8IGVhc2UubGVuZ3RoID09PSBpbnB1dExlbmd0aCAtIDEsICdBcnJheSBvZiBlYXNpbmcgZnVuY3Rpb25zIG11c3QgYmUgb2YgbGVuZ3RoIGBpbnB1dC5sZW5ndGggLSAxYCwgYXMgaXQgYXBwbGllcyB0byB0aGUgdHJhbnNpdGlvbnMgKipiZXR3ZWVuKiogdGhlIGRlZmluZWQgdmFsdWVzLicpO1xuICAgIGlmIChpbnB1dFswXSA+IGlucHV0W2lucHV0TGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgaW5wdXQgPSBbXS5jb25jYXQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQgPSBbXS5jb25jYXQob3V0cHV0KTtcbiAgICAgICAgaW5wdXQucmV2ZXJzZSgpO1xuICAgICAgICBvdXRwdXQucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBjb25zdCBtaXhlcnMgPSBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBtaXhlcik7XG4gICAgY29uc3QgaW50ZXJwb2xhdG9yID0gaW5wdXRMZW5ndGggPT09IDJcbiAgICAgICAgPyBmYXN0SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycylcbiAgICAgICAgOiBzbG93SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycyk7XG4gICAgcmV0dXJuIGlzQ2xhbXBcbiAgICAgICAgPyAodikgPT4gaW50ZXJwb2xhdG9yKGNsYW1wKGlucHV0WzBdLCBpbnB1dFtpbnB1dExlbmd0aCAtIDFdLCB2KSlcbiAgICAgICAgOiBpbnRlcnBvbGF0b3I7XG59XG5cbmV4cG9ydCB7IGludGVycG9sYXRlIH07XG4iLCAiY29uc3QgcHJvZ3Jlc3MgPSAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdG9Gcm9tRGlmZmVyZW5jZSA9IHRvIC0gZnJvbTtcbiAgICByZXR1cm4gdG9Gcm9tRGlmZmVyZW5jZSA9PT0gMCA/IDEgOiAodmFsdWUgLSBmcm9tKSAvIHRvRnJvbURpZmZlcmVuY2U7XG59O1xuXG5leHBvcnQgeyBwcm9ncmVzcyB9O1xuIiwgImNvbnN0IG1peCA9IChmcm9tLCB0bywgcHJvZ3Jlc3MpID0+IC1wcm9ncmVzcyAqIGZyb20gKyBwcm9ncmVzcyAqIHRvICsgZnJvbTtcblxuZXhwb3J0IHsgbWl4IH07XG4iLCAiaW1wb3J0IHsgbWl4IH0gZnJvbSAnLi9taXgubWpzJztcbmltcG9ydCB7IGhzbGEsIHJnYmEsIGhleCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0IHsgaHNsYVRvUmdiYSB9IGZyb20gJy4vaHNsYS10by1yZ2JhLm1qcyc7XG5cbmNvbnN0IG1peExpbmVhckNvbG9yID0gKGZyb20sIHRvLCB2KSA9PiB7XG4gICAgY29uc3QgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgICBjb25zdCB0b0V4cG8gPSB0byAqIHRvO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgdiAqICh0b0V4cG8gLSBmcm9tRXhwbykgKyBmcm9tRXhwbykpO1xufTtcbmNvbnN0IGNvbG9yVHlwZXMgPSBbaGV4LCByZ2JhLCBoc2xhXTtcbmNvbnN0IGdldENvbG9yVHlwZSA9ICh2KSA9PiBjb2xvclR5cGVzLmZpbmQoKHR5cGUpID0+IHR5cGUudGVzdCh2KSk7XG5jb25zdCBub3RBbmltYXRhYmxlID0gKGNvbG9yKSA9PiBgJyR7Y29sb3J9JyBpcyBub3QgYW4gYW5pbWF0YWJsZSBjb2xvci4gVXNlIHRoZSBlcXVpdmFsZW50IGNvbG9yIGNvZGUgaW5zdGVhZC5gO1xuY29uc3QgbWl4Q29sb3IgPSAoZnJvbSwgdG8pID0+IHtcbiAgICBsZXQgZnJvbUNvbG9yVHlwZSA9IGdldENvbG9yVHlwZShmcm9tKTtcbiAgICBsZXQgdG9Db2xvclR5cGUgPSBnZXRDb2xvclR5cGUodG8pO1xuICAgIGludmFyaWFudCghIWZyb21Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUoZnJvbSkpO1xuICAgIGludmFyaWFudCghIXRvQ29sb3JUeXBlLCBub3RBbmltYXRhYmxlKHRvKSk7XG4gICAgbGV0IGZyb21Db2xvciA9IGZyb21Db2xvclR5cGUucGFyc2UoZnJvbSk7XG4gICAgbGV0IHRvQ29sb3IgPSB0b0NvbG9yVHlwZS5wYXJzZSh0byk7XG4gICAgaWYgKGZyb21Db2xvclR5cGUgPT09IGhzbGEpIHtcbiAgICAgICAgZnJvbUNvbG9yID0gaHNsYVRvUmdiYShmcm9tQ29sb3IpO1xuICAgICAgICBmcm9tQ29sb3JUeXBlID0gcmdiYTtcbiAgICB9XG4gICAgaWYgKHRvQ29sb3JUeXBlID09PSBoc2xhKSB7XG4gICAgICAgIHRvQ29sb3IgPSBoc2xhVG9SZ2JhKHRvQ29sb3IpO1xuICAgICAgICB0b0NvbG9yVHlwZSA9IHJnYmE7XG4gICAgfVxuICAgIGNvbnN0IGJsZW5kZWQgPSBPYmplY3QuYXNzaWduKHt9LCBmcm9tQ29sb3IpO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZGVkKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcImFscGhhXCIpIHtcbiAgICAgICAgICAgICAgICBibGVuZGVkW2tleV0gPSBtaXhMaW5lYXJDb2xvcihmcm9tQ29sb3Jba2V5XSwgdG9Db2xvcltrZXldLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBibGVuZGVkLmFscGhhID0gbWl4KGZyb21Db2xvci5hbHBoYSwgdG9Db2xvci5hbHBoYSwgdik7XG4gICAgICAgIHJldHVybiBmcm9tQ29sb3JUeXBlLnRyYW5zZm9ybShibGVuZGVkKTtcbiAgICB9O1xufTtcblxuZXhwb3J0IHsgbWl4Q29sb3IsIG1peExpbmVhckNvbG9yIH07XG4iLCAiZXhwb3J0IHsgYWxwaGEsIG51bWJlciwgc2NhbGUgfSBmcm9tICcuL251bWJlcnMvaW5kZXgubWpzJztcbmV4cG9ydCB7IGRlZ3JlZXMsIHBlcmNlbnQsIHByb2dyZXNzUGVyY2VudGFnZSwgcHgsIHZoLCB2dyB9IGZyb20gJy4vbnVtYmVycy91bml0cy5tanMnO1xuZXhwb3J0IHsgaHNsYSB9IGZyb20gJy4vY29sb3IvaHNsYS5tanMnO1xuZXhwb3J0IHsgcmdiVW5pdCwgcmdiYSB9IGZyb20gJy4vY29sb3IvcmdiYS5tanMnO1xuZXhwb3J0IHsgaGV4IH0gZnJvbSAnLi9jb2xvci9oZXgubWpzJztcbmV4cG9ydCB7IGNvbG9yIH0gZnJvbSAnLi9jb2xvci9pbmRleC5tanMnO1xuZXhwb3J0IHsgY29tcGxleCB9IGZyb20gJy4vY29tcGxleC9pbmRleC5tanMnO1xuZXhwb3J0IHsgZmlsdGVyIH0gZnJvbSAnLi9jb21wbGV4L2ZpbHRlci5tanMnO1xuIiwgImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vdXRpbHMubWpzJztcblxuY29uc3QgbnVtYmVyID0ge1xuICAgIHRlc3Q6ICh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicsXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gdixcbn07XG5jb25zdCBhbHBoYSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06IGNsYW1wKDAsIDEpIH0pO1xuY29uc3Qgc2NhbGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlciksIHsgZGVmYXVsdDogMSB9KTtcblxuZXhwb3J0IHsgYWxwaGEsIG51bWJlciwgc2NhbGUgfTtcbiIsICJjb25zdCBjbGFtcCA9IChtaW4sIG1heCkgPT4gKHYpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIG1heCksIG1pbik7XG5jb25zdCBzYW5pdGl6ZSA9ICh2KSA9PiAodiAlIDEgPyBOdW1iZXIodi50b0ZpeGVkKDUpKSA6IHYpO1xuY29uc3QgZmxvYXRSZWdleCA9IC8oLSk/KFtcXGRdKlxcLj9bXFxkXSkrL2c7XG5jb25zdCBjb2xvclJlZ2V4ID0gLygjWzAtOWEtZl17Nn18I1swLTlhLWZdezN9fCMoPzpbMC05YS1mXXsyfSl7Miw0fXwocmdifGhzbClhP1xcKCgtP1tcXGRcXC5dKyU/WyxcXHNdKyl7MiwzfVxccypcXC8qXFxzKltcXGRcXC5dKyU/XFwpKS9naTtcbmNvbnN0IHNpbmdsZUNvbG9yUmVnZXggPSAvXigjWzAtOWEtZl17M318Iyg/OlswLTlhLWZdezJ9KXsyLDR9fChyZ2J8aHNsKWE/XFwoKC0/W1xcZFxcLl0rJT9bLFxcc10rKXsyLDN9XFxzKlxcLypcXHMqW1xcZFxcLl0rJT9cXCkpJC9pO1xuZnVuY3Rpb24gaXNTdHJpbmcodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCB7IGNsYW1wLCBjb2xvclJlZ2V4LCBmbG9hdFJlZ2V4LCBpc1N0cmluZywgc2FuaXRpemUsIHNpbmdsZUNvbG9yUmVnZXggfTtcbiIsICJpbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XG5cbmNvbnN0IGNyZWF0ZVVuaXRUeXBlID0gKHVuaXQpID0+ICh7XG4gICAgdGVzdDogKHYpID0+IGlzU3RyaW5nKHYpICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdCgnICcpLmxlbmd0aCA9PT0gMSxcbiAgICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiBgJHt2fSR7dW5pdH1gLFxufSk7XG5jb25zdCBkZWdyZWVzID0gY3JlYXRlVW5pdFR5cGUoJ2RlZycpO1xuY29uc3QgcGVyY2VudCA9IGNyZWF0ZVVuaXRUeXBlKCclJyk7XG5jb25zdCBweCA9IGNyZWF0ZVVuaXRUeXBlKCdweCcpO1xuY29uc3QgdmggPSBjcmVhdGVVbml0VHlwZSgndmgnKTtcbmNvbnN0IHZ3ID0gY3JlYXRlVW5pdFR5cGUoJ3Z3Jyk7XG5jb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBlcmNlbnQpLCB7IHBhcnNlOiAodikgPT4gcGVyY2VudC5wYXJzZSh2KSAvIDEwMCwgdHJhbnNmb3JtOiAodikgPT4gcGVyY2VudC50cmFuc2Zvcm0odiAqIDEwMCkgfSk7XG5cbmV4cG9ydCB7IGRlZ3JlZXMsIHBlcmNlbnQsIHByb2dyZXNzUGVyY2VudGFnZSwgcHgsIHZoLCB2dyB9O1xuIiwgImltcG9ydCB7IGFscGhhIH0gZnJvbSAnLi4vbnVtYmVycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcGVyY2VudCB9IGZyb20gJy4uL251bWJlcnMvdW5pdHMubWpzJztcbmltcG9ydCB7IHNhbml0aXplIH0gZnJvbSAnLi4vdXRpbHMubWpzJztcbmltcG9ydCB7IGlzQ29sb3JTdHJpbmcsIHNwbGl0Q29sb3IgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNvbnN0IGhzbGEgPSB7XG4gICAgdGVzdDogaXNDb2xvclN0cmluZygnaHNsJywgJ2h1ZScpLFxuICAgIHBhcnNlOiBzcGxpdENvbG9yKCdodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnKSxcbiAgICB0cmFuc2Zvcm06ICh7IGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYTogYWxwaGEkMSA9IDEgfSkgPT4ge1xuICAgICAgICByZXR1cm4gKCdoc2xhKCcgK1xuICAgICAgICAgICAgTWF0aC5yb3VuZChodWUpICtcbiAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUoc2F0dXJhdGlvbikpICtcbiAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUobGlnaHRuZXNzKSkgK1xuICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICBzYW5pdGl6ZShhbHBoYS50cmFuc2Zvcm0oYWxwaGEkMSkpICtcbiAgICAgICAgICAgICcpJyk7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGhzbGEgfTtcbiIsICJpbXBvcnQgeyBpc1N0cmluZywgc2luZ2xlQ29sb3JSZWdleCwgZmxvYXRSZWdleCB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XG5cbmNvbnN0IGlzQ29sb3JTdHJpbmcgPSAodHlwZSwgdGVzdFByb3ApID0+ICh2KSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKGlzU3RyaW5nKHYpICYmIHNpbmdsZUNvbG9yUmVnZXgudGVzdCh2KSAmJiB2LnN0YXJ0c1dpdGgodHlwZSkpIHx8XG4gICAgICAgICh0ZXN0UHJvcCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodiwgdGVzdFByb3ApKSk7XG59O1xuY29uc3Qgc3BsaXRDb2xvciA9IChhTmFtZSwgYk5hbWUsIGNOYW1lKSA9PiAodikgPT4ge1xuICAgIGlmICghaXNTdHJpbmcodikpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFthLCBiLCBjLCBhbHBoYV0gPSB2Lm1hdGNoKGZsb2F0UmVnZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFthTmFtZV06IHBhcnNlRmxvYXQoYSksXG4gICAgICAgIFtiTmFtZV06IHBhcnNlRmxvYXQoYiksXG4gICAgICAgIFtjTmFtZV06IHBhcnNlRmxvYXQoYyksXG4gICAgICAgIGFscGhhOiBhbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyc2VGbG9hdChhbHBoYSkgOiAxLFxuICAgIH07XG59O1xuXG5leHBvcnQgeyBpc0NvbG9yU3RyaW5nLCBzcGxpdENvbG9yIH07XG4iLCAiaW1wb3J0IHsgbnVtYmVyLCBhbHBoYSB9IGZyb20gJy4uL251bWJlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IHNhbml0aXplLCBjbGFtcCB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBpc0NvbG9yU3RyaW5nLCBzcGxpdENvbG9yIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5jb25zdCBjbGFtcFJnYlVuaXQgPSBjbGFtcCgwLCAyNTUpO1xuY29uc3QgcmdiVW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06ICh2KSA9PiBNYXRoLnJvdW5kKGNsYW1wUmdiVW5pdCh2KSkgfSk7XG5jb25zdCByZ2JhID0ge1xuICAgIHRlc3Q6IGlzQ29sb3JTdHJpbmcoJ3JnYicsICdyZWQnKSxcbiAgICBwYXJzZTogc3BsaXRDb2xvcigncmVkJywgJ2dyZWVuJywgJ2JsdWUnKSxcbiAgICB0cmFuc2Zvcm06ICh7IHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhOiBhbHBoYSQxID0gMSB9KSA9PiAncmdiYSgnICtcbiAgICAgICAgcmdiVW5pdC50cmFuc2Zvcm0ocmVkKSArXG4gICAgICAgICcsICcgK1xuICAgICAgICByZ2JVbml0LnRyYW5zZm9ybShncmVlbikgK1xuICAgICAgICAnLCAnICtcbiAgICAgICAgcmdiVW5pdC50cmFuc2Zvcm0oYmx1ZSkgK1xuICAgICAgICAnLCAnICtcbiAgICAgICAgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArXG4gICAgICAgICcpJyxcbn07XG5cbmV4cG9ydCB7IHJnYlVuaXQsIHJnYmEgfTtcbiIsICJpbXBvcnQgeyByZ2JhIH0gZnJvbSAnLi9yZ2JhLm1qcyc7XG5pbXBvcnQgeyBpc0NvbG9yU3RyaW5nIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5mdW5jdGlvbiBwYXJzZUhleCh2KSB7XG4gICAgbGV0IHIgPSAnJztcbiAgICBsZXQgZyA9ICcnO1xuICAgIGxldCBiID0gJyc7XG4gICAgbGV0IGEgPSAnJztcbiAgICBpZiAodi5sZW5ndGggPiA1KSB7XG4gICAgICAgIHIgPSB2LnN1YnN0cigxLCAyKTtcbiAgICAgICAgZyA9IHYuc3Vic3RyKDMsIDIpO1xuICAgICAgICBiID0gdi5zdWJzdHIoNSwgMik7XG4gICAgICAgIGEgPSB2LnN1YnN0cig3LCAyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHIgPSB2LnN1YnN0cigxLCAxKTtcbiAgICAgICAgZyA9IHYuc3Vic3RyKDIsIDEpO1xuICAgICAgICBiID0gdi5zdWJzdHIoMywgMSk7XG4gICAgICAgIGEgPSB2LnN1YnN0cig0LCAxKTtcbiAgICAgICAgciArPSByO1xuICAgICAgICBnICs9IGc7XG4gICAgICAgIGIgKz0gYjtcbiAgICAgICAgYSArPSBhO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWQ6IHBhcnNlSW50KHIsIDE2KSxcbiAgICAgICAgZ3JlZW46IHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgYmx1ZTogcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBhbHBoYTogYSA/IHBhcnNlSW50KGEsIDE2KSAvIDI1NSA6IDEsXG4gICAgfTtcbn1cbmNvbnN0IGhleCA9IHtcbiAgICB0ZXN0OiBpc0NvbG9yU3RyaW5nKCcjJyksXG4gICAgcGFyc2U6IHBhcnNlSGV4LFxuICAgIHRyYW5zZm9ybTogcmdiYS50cmFuc2Zvcm0sXG59O1xuXG5leHBvcnQgeyBoZXggfTtcbiIsICJpbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBoZXggfSBmcm9tICcuL2hleC5tanMnO1xuaW1wb3J0IHsgaHNsYSB9IGZyb20gJy4vaHNsYS5tanMnO1xuaW1wb3J0IHsgcmdiYSB9IGZyb20gJy4vcmdiYS5tanMnO1xuXG5jb25zdCBjb2xvciA9IHtcbiAgICB0ZXN0OiAodikgPT4gcmdiYS50ZXN0KHYpIHx8IGhleC50ZXN0KHYpIHx8IGhzbGEudGVzdCh2KSxcbiAgICBwYXJzZTogKHYpID0+IHtcbiAgICAgICAgaWYgKHJnYmEudGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJnYmEucGFyc2Uodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHNsYS50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHNsYS5wYXJzZSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zZm9ybTogKHYpID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHYpXG4gICAgICAgICAgICA/IHZcbiAgICAgICAgICAgIDogdi5oYXNPd25Qcm9wZXJ0eSgncmVkJylcbiAgICAgICAgICAgICAgICA/IHJnYmEudHJhbnNmb3JtKHYpXG4gICAgICAgICAgICAgICAgOiBoc2xhLnRyYW5zZm9ybSh2KTtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgY29sb3IgfTtcbiIsICJpbXBvcnQgeyBjb2xvciB9IGZyb20gJy4uL2NvbG9yL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBudW1iZXIgfSBmcm9tICcuLi9udW1iZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc1N0cmluZywgZmxvYXRSZWdleCwgY29sb3JSZWdleCwgc2FuaXRpemUgfSBmcm9tICcuLi91dGlscy5tanMnO1xuXG5jb25zdCBjb2xvclRva2VuID0gJyR7Y30nO1xuY29uc3QgbnVtYmVyVG9rZW4gPSAnJHtufSc7XG5mdW5jdGlvbiB0ZXN0KHYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIChpc05hTih2KSAmJlxuICAgICAgICBpc1N0cmluZyh2KSAmJlxuICAgICAgICAoKF9iID0gKF9hID0gdi5tYXRjaChmbG9hdFJlZ2V4KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKyAoKF9kID0gKF9jID0gdi5tYXRjaChjb2xvclJlZ2V4KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCkgPiAwKTtcbn1cbmZ1bmN0aW9uIGFuYWx5c2Uodikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpXG4gICAgICAgIHYgPSBgJHt2fWA7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IG51bUNvbG9ycyA9IDA7XG4gICAgY29uc3QgY29sb3JzID0gdi5tYXRjaChjb2xvclJlZ2V4KTtcbiAgICBpZiAoY29sb3JzKSB7XG4gICAgICAgIG51bUNvbG9ycyA9IGNvbG9ycy5sZW5ndGg7XG4gICAgICAgIHYgPSB2LnJlcGxhY2UoY29sb3JSZWdleCwgY29sb3JUb2tlbik7XG4gICAgICAgIHZhbHVlcy5wdXNoKC4uLmNvbG9ycy5tYXAoY29sb3IucGFyc2UpKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVycyA9IHYubWF0Y2goZmxvYXRSZWdleCk7XG4gICAgaWYgKG51bWJlcnMpIHtcbiAgICAgICAgdiA9IHYucmVwbGFjZShmbG9hdFJlZ2V4LCBudW1iZXJUb2tlbik7XG4gICAgICAgIHZhbHVlcy5wdXNoKC4uLm51bWJlcnMubWFwKG51bWJlci5wYXJzZSkpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWx1ZXMsIG51bUNvbG9ycywgdG9rZW5pc2VkOiB2IH07XG59XG5mdW5jdGlvbiBwYXJzZSh2KSB7XG4gICAgcmV0dXJuIGFuYWx5c2UodikudmFsdWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtZXIodikge1xuICAgIGNvbnN0IHsgdmFsdWVzLCBudW1Db2xvcnMsIHRva2VuaXNlZCB9ID0gYW5hbHlzZSh2KTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBsZXQgb3V0cHV0ID0gdG9rZW5pc2VkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShpIDwgbnVtQ29sb3JzID8gY29sb3JUb2tlbiA6IG51bWJlclRva2VuLCBpIDwgbnVtQ29sb3JzID8gY29sb3IudHJhbnNmb3JtKHZbaV0pIDogc2FuaXRpemUodltpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cbmNvbnN0IGNvbnZlcnROdW1iZXJzVG9aZXJvID0gKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IDAgOiB2O1xuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZU5vbmUodikge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHYpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlVHJhbnNmb3JtZXIodik7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyKHBhcnNlZC5tYXAoY29udmVydE51bWJlcnNUb1plcm8pKTtcbn1cbmNvbnN0IGNvbXBsZXggPSB7IHRlc3QsIHBhcnNlLCBjcmVhdGVUcmFuc2Zvcm1lciwgZ2V0QW5pbWF0YWJsZU5vbmUgfTtcblxuZXhwb3J0IHsgY29tcGxleCB9O1xuIiwgImltcG9ydCB7IGNvbXBsZXggfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBmbG9hdFJlZ2V4IH0gZnJvbSAnLi4vdXRpbHMubWpzJztcblxuY29uc3QgbWF4RGVmYXVsdHMgPSBuZXcgU2V0KFsnYnJpZ2h0bmVzcycsICdjb250cmFzdCcsICdzYXR1cmF0ZScsICdvcGFjaXR5J10pO1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0RmlsdGVyKHYpIHtcbiAgICBsZXQgW25hbWUsIHZhbHVlXSA9IHYuc2xpY2UoMCwgLTEpLnNwbGl0KCcoJyk7XG4gICAgaWYgKG5hbWUgPT09ICdkcm9wLXNoYWRvdycpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFtudW1iZXJdID0gdmFsdWUubWF0Y2goZmxvYXRSZWdleCkgfHwgW107XG4gICAgaWYgKCFudW1iZXIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IHVuaXQgPSB2YWx1ZS5yZXBsYWNlKG51bWJlciwgJycpO1xuICAgIGxldCBkZWZhdWx0VmFsdWUgPSBtYXhEZWZhdWx0cy5oYXMobmFtZSkgPyAxIDogMDtcbiAgICBpZiAobnVtYmVyICE9PSB2YWx1ZSlcbiAgICAgICAgZGVmYXVsdFZhbHVlICo9IDEwMDtcbiAgICByZXR1cm4gbmFtZSArICcoJyArIGRlZmF1bHRWYWx1ZSArIHVuaXQgKyAnKSc7XG59XG5jb25zdCBmdW5jdGlvblJlZ2V4ID0gLyhbYS16LV0qKVxcKC4qP1xcKS9nO1xuY29uc3QgZmlsdGVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21wbGV4KSwgeyBnZXRBbmltYXRhYmxlTm9uZTogKHYpID0+IHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gdi5tYXRjaChmdW5jdGlvblJlZ2V4KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucyA/IGZ1bmN0aW9ucy5tYXAoYXBwbHlEZWZhdWx0RmlsdGVyKS5qb2luKCcgJykgOiB2O1xuICAgIH0gfSk7XG5cbmV4cG9ydCB7IGZpbHRlciB9O1xuIiwgImZ1bmN0aW9uIGh1ZVRvUmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApXG4gICAgICAgIHQgKz0gMTtcbiAgICBpZiAodCA+IDEpXG4gICAgICAgIHQgLT0gMTtcbiAgICBpZiAodCA8IDEgLyA2KVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICBpZiAodCA8IDEgLyAyKVxuICAgICAgICByZXR1cm4gcTtcbiAgICBpZiAodCA8IDIgLyAzKVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xhVG9SZ2JhKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhIH0pIHtcbiAgICBodWUgLz0gMzYwO1xuICAgIHNhdHVyYXRpb24gLz0gMTAwO1xuICAgIGxpZ2h0bmVzcyAvPSAxMDA7XG4gICAgbGV0IHJlZCA9IDA7XG4gICAgbGV0IGdyZWVuID0gMDtcbiAgICBsZXQgYmx1ZSA9IDA7XG4gICAgaWYgKCFzYXR1cmF0aW9uKSB7XG4gICAgICAgIHJlZCA9IGdyZWVuID0gYmx1ZSA9IGxpZ2h0bmVzcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHEgPSBsaWdodG5lc3MgPCAwLjVcbiAgICAgICAgICAgID8gbGlnaHRuZXNzICogKDEgKyBzYXR1cmF0aW9uKVxuICAgICAgICAgICAgOiBsaWdodG5lc3MgKyBzYXR1cmF0aW9uIC0gbGlnaHRuZXNzICogc2F0dXJhdGlvbjtcbiAgICAgICAgY29uc3QgcCA9IDIgKiBsaWdodG5lc3MgLSBxO1xuICAgICAgICByZWQgPSBodWVUb1JnYihwLCBxLCBodWUgKyAxIC8gMyk7XG4gICAgICAgIGdyZWVuID0gaHVlVG9SZ2IocCwgcSwgaHVlKTtcbiAgICAgICAgYmx1ZSA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSAtIDEgLyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiBNYXRoLnJvdW5kKHJlZCAqIDI1NSksXG4gICAgICAgIGdyZWVuOiBNYXRoLnJvdW5kKGdyZWVuICogMjU1KSxcbiAgICAgICAgYmx1ZTogTWF0aC5yb3VuZChibHVlICogMjU1KSxcbiAgICAgICAgYWxwaGEsXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgaHNsYVRvUmdiYSB9O1xuIiwgImltcG9ydCB7IGNvbXBsZXgsIGNvbG9yIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgbWl4IH0gZnJvbSAnLi9taXgubWpzJztcbmltcG9ydCB7IG1peENvbG9yIH0gZnJvbSAnLi9taXgtY29sb3IubWpzJztcbmltcG9ydCB7IGlzTnVtIH0gZnJvbSAnLi9pbmMubWpzJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICcuL3BpcGUubWpzJztcbmltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICdoZXktbGlzdGVuJztcblxuZnVuY3Rpb24gZ2V0TWl4ZXIob3JpZ2luLCB0YXJnZXQpIHtcbiAgICBpZiAoaXNOdW0ob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gKHYpID0+IG1peChvcmlnaW4sIHRhcmdldCwgdik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yLnRlc3Qob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gbWl4Q29sb3Iob3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1peENvbXBsZXgob3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbn1cbmNvbnN0IG1peEFycmF5ID0gKGZyb20sIHRvKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gWy4uLmZyb21dO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG91dHB1dC5sZW5ndGg7XG4gICAgY29uc3QgYmxlbmRWYWx1ZSA9IGZyb20ubWFwKChmcm9tVGhpcywgaSkgPT4gZ2V0TWl4ZXIoZnJvbVRoaXMsIHRvW2ldKSk7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IGJsZW5kVmFsdWVbaV0odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufTtcbmNvbnN0IG1peE9iamVjdCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luKSwgdGFyZ2V0KTtcbiAgICBjb25zdCBibGVuZFZhbHVlID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3V0cHV0KSB7XG4gICAgICAgIGlmIChvcmlnaW5ba2V5XSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsZW5kVmFsdWVba2V5XSA9IGdldE1peGVyKG9yaWdpbltrZXldLCB0YXJnZXRba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGJsZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gYmxlbmRWYWx1ZVtrZXldKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn07XG5mdW5jdGlvbiBhbmFseXNlKHZhbHVlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gY29tcGxleC5wYXJzZSh2YWx1ZSk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gcGFyc2VkLmxlbmd0aDtcbiAgICBsZXQgbnVtTnVtYmVycyA9IDA7XG4gICAgbGV0IG51bVJHQiA9IDA7XG4gICAgbGV0IG51bUhTTCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICBpZiAobnVtTnVtYmVycyB8fCB0eXBlb2YgcGFyc2VkW2ldID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBudW1OdW1iZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkW2ldLmh1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbnVtSFNMKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBudW1SR0IrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBwYXJzZWQsIG51bU51bWJlcnMsIG51bVJHQiwgbnVtSFNMIH07XG59XG5jb25zdCBtaXhDb21wbGV4ID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBjb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKHRhcmdldCk7XG4gICAgY29uc3Qgb3JpZ2luU3RhdHMgPSBhbmFseXNlKG9yaWdpbik7XG4gICAgY29uc3QgdGFyZ2V0U3RhdHMgPSBhbmFseXNlKHRhcmdldCk7XG4gICAgY29uc3QgY2FuSW50ZXJwb2xhdGUgPSBvcmlnaW5TdGF0cy5udW1IU0wgPT09IHRhcmdldFN0YXRzLm51bUhTTCAmJlxuICAgICAgICBvcmlnaW5TdGF0cy5udW1SR0IgPT09IHRhcmdldFN0YXRzLm51bVJHQiAmJlxuICAgICAgICBvcmlnaW5TdGF0cy5udW1OdW1iZXJzID49IHRhcmdldFN0YXRzLm51bU51bWJlcnM7XG4gICAgaWYgKGNhbkludGVycG9sYXRlKSB7XG4gICAgICAgIHJldHVybiBwaXBlKG1peEFycmF5KG9yaWdpblN0YXRzLnBhcnNlZCwgdGFyZ2V0U3RhdHMucGFyc2VkKSwgdGVtcGxhdGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2FybmluZyh0cnVlLCBgQ29tcGxleCB2YWx1ZXMgJyR7b3JpZ2lufScgYW5kICcke3RhcmdldH0nIHRvbyBkaWZmZXJlbnQgdG8gbWl4LiBFbnN1cmUgYWxsIGNvbG9ycyBhcmUgb2YgdGhlIHNhbWUgdHlwZSwgYW5kIHRoYXQgZWFjaCBjb250YWlucyB0aGUgc2FtZSBxdWFudGl0eSBvZiBudW1iZXIgYW5kIGNvbG9yIHZhbHVlcy4gRmFsbGluZyBiYWNrIHRvIGluc3RhbnQgdHJhbnNpdGlvbi5gKTtcbiAgICAgICAgcmV0dXJuIChwKSA9PiBgJHtwID4gMCA/IHRhcmdldCA6IG9yaWdpbn1gO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IG1peEFycmF5LCBtaXhDb21wbGV4LCBtaXhPYmplY3QgfTtcbiIsICJjb25zdCB6ZXJvUG9pbnQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHo6IDBcbn07XG5jb25zdCBpc051bSA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcic7XG5cbmV4cG9ydCB7IGlzTnVtLCB6ZXJvUG9pbnQgfTtcbiIsICJjb25zdCBjb21iaW5lRnVuY3Rpb25zID0gKGEsIGIpID0+ICh2KSA9PiBiKGEodikpO1xuY29uc3QgcGlwZSA9ICguLi50cmFuc2Zvcm1lcnMpID0+IHRyYW5zZm9ybWVycy5yZWR1Y2UoY29tYmluZUZ1bmN0aW9ucyk7XG5cbmV4cG9ydCB7IHBpcGUgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVFeHBvSW4sIHJldmVyc2VFYXNpbmcsIG1pcnJvckVhc2luZywgY3JlYXRlQmFja0luLCBjcmVhdGVBbnRpY2lwYXRlIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5jb25zdCBERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCA9IDEuNTI1O1xuY29uc3QgQk9VTkNFX0ZJUlNUX1RIUkVTSE9MRCA9IDQuMCAvIDExLjA7XG5jb25zdCBCT1VOQ0VfU0VDT05EX1RIUkVTSE9MRCA9IDguMCAvIDExLjA7XG5jb25zdCBCT1VOQ0VfVEhJUkRfVEhSRVNIT0xEID0gOS4wIC8gMTAuMDtcbmNvbnN0IGxpbmVhciA9IHAgPT4gcDtcbmNvbnN0IGVhc2VJbiA9IGNyZWF0ZUV4cG9JbigyKTtcbmNvbnN0IGVhc2VPdXQgPSByZXZlcnNlRWFzaW5nKGVhc2VJbik7XG5jb25zdCBlYXNlSW5PdXQgPSBtaXJyb3JFYXNpbmcoZWFzZUluKTtcbmNvbnN0IGNpcmNJbiA9IHAgPT4gMSAtIE1hdGguc2luKE1hdGguYWNvcyhwKSk7XG5jb25zdCBjaXJjT3V0ID0gcmV2ZXJzZUVhc2luZyhjaXJjSW4pO1xuY29uc3QgY2lyY0luT3V0ID0gbWlycm9yRWFzaW5nKGNpcmNPdXQpO1xuY29uc3QgYmFja0luID0gY3JlYXRlQmFja0luKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbmNvbnN0IGJhY2tPdXQgPSByZXZlcnNlRWFzaW5nKGJhY2tJbik7XG5jb25zdCBiYWNrSW5PdXQgPSBtaXJyb3JFYXNpbmcoYmFja0luKTtcbmNvbnN0IGFudGljaXBhdGUgPSBjcmVhdGVBbnRpY2lwYXRlKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbmNvbnN0IGNhID0gNDM1Ni4wIC8gMzYxLjA7XG5jb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG5jb25zdCBjYyA9IDE2MDYxLjAgLyAxODA1LjA7XG5jb25zdCBib3VuY2VPdXQgPSAocCkgPT4ge1xuICAgIGlmIChwID09PSAxIHx8IHAgPT09IDApXG4gICAgICAgIHJldHVybiBwO1xuICAgIGNvbnN0IHAyID0gcCAqIHA7XG4gICAgcmV0dXJuIHAgPCBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEXG4gICAgICAgID8gNy41NjI1ICogcDJcbiAgICAgICAgOiBwIDwgQk9VTkNFX1NFQ09ORF9USFJFU0hPTERcbiAgICAgICAgICAgID8gOS4wNzUgKiBwMiAtIDkuOSAqIHAgKyAzLjRcbiAgICAgICAgICAgIDogcCA8IEJPVU5DRV9USElSRF9USFJFU0hPTERcbiAgICAgICAgICAgICAgICA/IGNhICogcDIgLSBjYiAqIHAgKyBjY1xuICAgICAgICAgICAgICAgIDogMTAuOCAqIHAgKiBwIC0gMjAuNTIgKiBwICsgMTAuNzI7XG59O1xuY29uc3QgYm91bmNlSW4gPSByZXZlcnNlRWFzaW5nKGJvdW5jZU91dCk7XG5jb25zdCBib3VuY2VJbk91dCA9IChwKSA9PiBwIDwgMC41XG4gICAgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHAgKiAyLjApKVxuICAgIDogMC41ICogYm91bmNlT3V0KHAgKiAyLjAgLSAxLjApICsgMC41O1xuXG5leHBvcnQgeyBhbnRpY2lwYXRlLCBiYWNrSW4sIGJhY2tJbk91dCwgYmFja091dCwgYm91bmNlSW4sIGJvdW5jZUluT3V0LCBib3VuY2VPdXQsIGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0LCBlYXNlSW4sIGVhc2VJbk91dCwgZWFzZU91dCwgbGluZWFyIH07XG4iLCAiY29uc3QgcmV2ZXJzZUVhc2luZyA9IGVhc2luZyA9PiBwID0+IDEgLSBlYXNpbmcoMSAtIHApO1xuY29uc3QgbWlycm9yRWFzaW5nID0gZWFzaW5nID0+IHAgPT4gcCA8PSAwLjUgPyBlYXNpbmcoMiAqIHApIC8gMiA6ICgyIC0gZWFzaW5nKDIgKiAoMSAtIHApKSkgLyAyO1xuY29uc3QgY3JlYXRlRXhwb0luID0gKHBvd2VyKSA9PiBwID0+IE1hdGgucG93KHAsIHBvd2VyKTtcbmNvbnN0IGNyZWF0ZUJhY2tJbiA9IChwb3dlcikgPT4gcCA9PiBwICogcCAqICgocG93ZXIgKyAxKSAqIHAgLSBwb3dlcik7XG5jb25zdCBjcmVhdGVBbnRpY2lwYXRlID0gKHBvd2VyKSA9PiB7XG4gICAgY29uc3QgYmFja0Vhc2luZyA9IGNyZWF0ZUJhY2tJbihwb3dlcik7XG4gICAgcmV0dXJuIHAgPT4gKHAgKj0gMikgPCAxXG4gICAgICAgID8gMC41ICogYmFja0Vhc2luZyhwKVxuICAgICAgICA6IDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHAgLSAxKSkpO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlQW50aWNpcGF0ZSwgY3JlYXRlQmFja0luLCBjcmVhdGVFeHBvSW4sIG1pcnJvckVhc2luZywgcmV2ZXJzZUVhc2luZyB9O1xuIiwgImZ1bmN0aW9uIGRlY2F5KHsgdmVsb2NpdHkgPSAwLCBmcm9tID0gMCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDM1MCwgcmVzdERlbHRhID0gMC41LCBtb2RpZnlUYXJnZXQsIH0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gICAgbGV0IGFtcGxpdHVkZSA9IHBvd2VyICogdmVsb2NpdHk7XG4gICAgY29uc3QgaWRlYWwgPSBmcm9tICsgYW1wbGl0dWRlO1xuICAgIGNvbnN0IHRhcmdldCA9IG1vZGlmeVRhcmdldCA9PT0gdW5kZWZpbmVkID8gaWRlYWwgOiBtb2RpZnlUYXJnZXQoaWRlYWwpO1xuICAgIGlmICh0YXJnZXQgIT09IGlkZWFsKVxuICAgICAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBmcm9tO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IC1hbXBsaXR1ZGUgKiBNYXRoLmV4cCgtdCAvIHRpbWVDb25zdGFudCk7XG4gICAgICAgICAgICBzdGF0ZS5kb25lID0gIShkZWx0YSA+IHJlc3REZWx0YSB8fCBkZWx0YSA8IC1yZXN0RGVsdGEpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdGFyZ2V0IDogdGFyZ2V0ICsgZGVsdGE7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZsaXBUYXJnZXQ6ICgpID0+IHsgfSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBkZWNheSB9O1xuIiwgImZ1bmN0aW9uIGxvb3BFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheSA9IDApIHtcbiAgICByZXR1cm4gZWxhcHNlZCAtIGR1cmF0aW9uIC0gZGVsYXk7XG59XG5mdW5jdGlvbiByZXZlcnNlRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkgPSAwLCBpc0ZvcndhcmRQbGF5YmFjayA9IHRydWUpIHtcbiAgICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2tcbiAgICAgICAgPyBsb29wRWxhcHNlZChkdXJhdGlvbiArIC1lbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkpXG4gICAgICAgIDogZHVyYXRpb24gLSAoZWxhcHNlZCAtIGR1cmF0aW9uKSArIGRlbGF5O1xufVxuZnVuY3Rpb24gaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheSwgaXNGb3J3YXJkUGxheWJhY2spIHtcbiAgICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2sgPyBlbGFwc2VkID49IGR1cmF0aW9uICsgZGVsYXkgOiBlbGFwc2VkIDw9IC1kZWxheTtcbn1cblxuZXhwb3J0IHsgaGFzUmVwZWF0RGVsYXlFbGFwc2VkLCBsb29wRWxhcHNlZCwgcmV2ZXJzZUVsYXBzZWQgfTtcbiIsICJpbXBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi9pbmRleC5tanMnO1xuaW1wb3J0IHsgdmVsb2NpdHlQZXJTZWNvbmQgfSBmcm9tICcuLi91dGlscy92ZWxvY2l0eS1wZXItc2Vjb25kLm1qcyc7XG5pbXBvcnQgeyBnZXRGcmFtZURhdGEgfSBmcm9tICdmcmFtZXN5bmMnO1xuXG5mdW5jdGlvbiBpbmVydGlhKHsgZnJvbSA9IDAsIHZlbG9jaXR5ID0gMCwgbWluLCBtYXgsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSA3NTAsIGJvdW5jZVN0aWZmbmVzcyA9IDUwMCwgYm91bmNlRGFtcGluZyA9IDEwLCByZXN0RGVsdGEgPSAxLCBtb2RpZnlUYXJnZXQsIGRyaXZlciwgb25VcGRhdGUsIG9uQ29tcGxldGUsIG9uU3RvcCwgfSkge1xuICAgIGxldCBjdXJyZW50QW5pbWF0aW9uO1xuICAgIGZ1bmN0aW9uIGlzT3V0T2ZCb3VuZHModikge1xuICAgICAgICByZXR1cm4gKG1pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCBtaW4pIHx8IChtYXggIT09IHVuZGVmaW5lZCAmJiB2ID4gbWF4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRhcnlOZWFyZXN0KHYpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1pbiAtIHYpIDwgTWF0aC5hYnMobWF4IC0gdikgPyBtaW4gOiBtYXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkcml2ZXIsIG9uVXBkYXRlOiAodikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUodik7XG4gICAgICAgICAgICAgICAgKF9hID0gb3B0aW9ucy5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdik7XG4gICAgICAgICAgICB9LCBvbkNvbXBsZXRlLFxuICAgICAgICAgICAgb25TdG9wIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRTcHJpbmcob3B0aW9ucykge1xuICAgICAgICBzdGFydEFuaW1hdGlvbihPYmplY3QuYXNzaWduKHsgdHlwZTogXCJzcHJpbmdcIiwgc3RpZmZuZXNzOiBib3VuY2VTdGlmZm5lc3MsIGRhbXBpbmc6IGJvdW5jZURhbXBpbmcsIHJlc3REZWx0YSB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChpc091dE9mQm91bmRzKGZyb20pKSB7XG4gICAgICAgIHN0YXJ0U3ByaW5nKHsgZnJvbSwgdmVsb2NpdHksIHRvOiBib3VuZGFyeU5lYXJlc3QoZnJvbSkgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gcG93ZXIgKiB2ZWxvY2l0eSArIGZyb207XG4gICAgICAgIGlmICh0eXBlb2YgbW9kaWZ5VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdGFyZ2V0ID0gbW9kaWZ5VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gYm91bmRhcnlOZWFyZXN0KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGhlYWRpbmcgPSBib3VuZGFyeSA9PT0gbWluID8gLTEgOiAxO1xuICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGNoZWNrQm91bmRhcnkgPSAodikgPT4ge1xuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gdjtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlQZXJTZWNvbmQodiAtIHByZXYsIGdldEZyYW1lRGF0YSgpLmRlbHRhKTtcbiAgICAgICAgICAgIGlmICgoaGVhZGluZyA9PT0gMSAmJiB2ID4gYm91bmRhcnkpIHx8XG4gICAgICAgICAgICAgICAgKGhlYWRpbmcgPT09IC0xICYmIHYgPCBib3VuZGFyeSkpIHtcbiAgICAgICAgICAgICAgICBzdGFydFNwcmluZyh7IGZyb206IHYsIHRvOiBib3VuZGFyeSwgdmVsb2NpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGVjYXlcIixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgICAgIHRpbWVDb25zdGFudCxcbiAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgcmVzdERlbHRhLFxuICAgICAgICAgICAgbW9kaWZ5VGFyZ2V0LFxuICAgICAgICAgICAgb25VcGRhdGU6IGlzT3V0T2ZCb3VuZHModGFyZ2V0KSA/IGNoZWNrQm91bmRhcnkgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdG9wOiAoKSA9PiBjdXJyZW50QW5pbWF0aW9uID09PSBudWxsIHx8IGN1cnJlbnRBbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRBbmltYXRpb24uc3RvcCgpLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGluZXJ0aWEgfTtcbiIsICJmdW5jdGlvbiB2ZWxvY2l0eVBlclNlY29uZCh2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICAgIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMTAwMCAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn1cblxuZXhwb3J0IHsgdmVsb2NpdHlQZXJTZWNvbmQgfTtcbiIsICJpbXBvcnQgeyBpc1BvaW50IH0gZnJvbSAnLi9pcy1wb2ludC5tanMnO1xuaW1wb3J0IHsgaXNQb2ludDNEIH0gZnJvbSAnLi9pcy1wb2ludC0zZC5tanMnO1xuaW1wb3J0IHsgaXNOdW0gfSBmcm9tICcuL2luYy5tanMnO1xuXG5jb25zdCBkaXN0YW5jZTFEID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKTtcbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICBpZiAoaXNOdW0oYSkgJiYgaXNOdW0oYikpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlMUQoYSwgYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUG9pbnQoYSkgJiYgaXNQb2ludChiKSkge1xuICAgICAgICBjb25zdCB4RGVsdGEgPSBkaXN0YW5jZTFEKGEueCwgYi54KTtcbiAgICAgICAgY29uc3QgeURlbHRhID0gZGlzdGFuY2UxRChhLnksIGIueSk7XG4gICAgICAgIGNvbnN0IHpEZWx0YSA9IGlzUG9pbnQzRChhKSAmJiBpc1BvaW50M0QoYikgPyBkaXN0YW5jZTFEKGEueiwgYi56KSA6IDA7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeERlbHRhLCAyKSArIE1hdGgucG93KHlEZWx0YSwgMikgKyBNYXRoLnBvdyh6RGVsdGEsIDIpKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGRpc3RhbmNlIH07XG4iLCAiY29uc3QgaXNQb2ludCA9IChwb2ludCkgPT4gcG9pbnQuaGFzT3duUHJvcGVydHkoJ3gnKSAmJiBwb2ludC5oYXNPd25Qcm9wZXJ0eSgneScpO1xuXG5leHBvcnQgeyBpc1BvaW50IH07XG4iLCAiaW1wb3J0IHsgaXNQb2ludCB9IGZyb20gJy4vaXMtcG9pbnQubWpzJztcblxuY29uc3QgaXNQb2ludDNEID0gKHBvaW50KSA9PiBpc1BvaW50KHBvaW50KSAmJiBwb2ludC5oYXNPd25Qcm9wZXJ0eSgneicpO1xuXG5leHBvcnQgeyBpc1BvaW50M0QgfTtcbiIsICJpbXBvcnQgeyBsaW5lYXIgfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5cbmNvbnN0IGEgPSAoYTEsIGEyKSA9PiAxLjAgLSAzLjAgKiBhMiArIDMuMCAqIGExO1xuY29uc3QgYiA9IChhMSwgYTIpID0+IDMuMCAqIGEyIC0gNi4wICogYTE7XG5jb25zdCBjID0gKGExKSA9PiAzLjAgKiBhMTtcbmNvbnN0IGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKGEoYTEsIGEyKSAqIHQgKyBiKGExLCBhMikpICogdCArIGMoYTEpKSAqIHQ7XG5jb25zdCBnZXRTbG9wZSA9ICh0LCBhMSwgYTIpID0+IDMuMCAqIGEoYTEsIGEyKSAqIHQgKiB0ICsgMi4wICogYihhMSwgYTIpICogdCArIGMoYTEpO1xuY29uc3Qgc3ViZGl2aXNpb25QcmVjaXNpb24gPSAwLjAwMDAwMDE7XG5jb25zdCBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMgPSAxMDtcbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICAgIGxldCBjdXJyZW50WDtcbiAgICBsZXQgY3VycmVudFQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IHN1YmRpdmlzaW9uUHJlY2lzaW9uICYmXG4gICAgICAgICsraSA8IHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xufVxuY29uc3QgbmV3dG9uSXRlcmF0aW9ucyA9IDg7XG5jb25zdCBuZXd0b25NaW5TbG9wZSA9IDAuMDAxO1xuZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXd0b25JdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG59XG5jb25zdCBrU3BsaW5lVGFibGVTaXplID0gMTE7XG5jb25zdCBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5mdW5jdGlvbiBjdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpXG4gICAgICAgIHJldHVybiBsaW5lYXI7XG4gICAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICAgICAgbGV0IGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLS1jdXJyZW50U2FtcGxlO1xuICAgICAgICBjb25zdCBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvXG4gICAgICAgICAgICAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICAgIGNvbnN0IGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgICBjb25zdCBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSBuZXd0b25NaW5TbG9wZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBjYWxjQmV6aWVyKGdldFRGb3JYKHQpLCBtWTEsIG1ZMik7XG59XG5cbmV4cG9ydCB7IGN1YmljQmV6aWVyIH07XG4iLCAiaW1wb3J0IHsgbW90aW9uVmFsdWUgfSBmcm9tICcuLi92YWx1ZS9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgc3RhcnRBbmltYXRpb24gfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb25zLm1qcyc7XG5cbi8qKlxuICogQW5pbWF0ZSBhIHNpbmdsZSB2YWx1ZSBvciBhIGBNb3Rpb25WYWx1ZWAuXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGVpdGhlciBhIGBNb3Rpb25WYWx1ZWAgdG8gYW5pbWF0ZSwgb3IgYW4gaW5pdGlhbCBhbmltYXRpb24gdmFsdWUuXG4gKlxuICogVGhlIHNlY29uZCBpcyBlaXRoZXIgYSB2YWx1ZSB0byBhbmltYXRlIHRvLCBvciBhbiBhcnJheSBvZiBrZXlmcmFtZXMgdG8gYW5pbWF0ZSB0aHJvdWdoLlxuICpcbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBjYW4gYmUgZWl0aGVyIHR3ZWVuIG9yIHNwcmluZyBvcHRpb25zLCBhbmQgb3B0aW9uYWwgbGlmZWN5Y2xlIG1ldGhvZHM6IGBvblVwZGF0ZWAsIGBvblBsYXlgLCBgb25Db21wbGV0ZWAsIGBvblJlcGVhdGAgYW5kIGBvblN0b3BgLlxuICpcbiAqIFJldHVybnMgYEFuaW1hdGlvblBsYXliYWNrQ29udHJvbHNgLCBjdXJyZW50bHkganVzdCBhIGBzdG9wYCBtZXRob2QuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gKlxuICogdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgY29uc3QgY29udHJvbHMgPSBhbmltYXRlKHgsIDEwMCwge1xuICogICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gKiAgICAgc3RpZmZuZXNzOiAyMDAwLFxuICogICAgIG9uQ29tcGxldGU6IHYgPT4ge31cbiAqICAgfSlcbiAqXG4gKiAgIHJldHVybiBjb250cm9scy5zdG9wXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBhbmltYXRlKGZyb20sIHRvLCB0cmFuc2l0aW9uKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT09IHZvaWQgMCkgeyB0cmFuc2l0aW9uID0ge307IH1cbiAgICB2YXIgdmFsdWUgPSBpc01vdGlvblZhbHVlKGZyb20pID8gZnJvbSA6IG1vdGlvblZhbHVlKGZyb20pO1xuICAgIHN0YXJ0QW5pbWF0aW9uKFwiXCIsIHZhbHVlLCB0bywgdHJhbnNpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuc3RvcCgpOyB9LFxuICAgICAgICBpc0FuaW1hdGluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuaXNBbmltYXRpbmcoKTsgfSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhbmltYXRlIH07XG4iLCAiaW1wb3J0IHN5bmMsIHsgZ2V0RnJhbWVEYXRhIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IHZlbG9jaXR5UGVyU2Vjb25kIH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbk1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9zdWJzY3JpcHRpb24tbWFuYWdlci5tanMnO1xuXG52YXIgaXNGbG9hdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbi8qKlxuICogYE1vdGlvblZhbHVlYCBpcyB1c2VkIHRvIHRyYWNrIHRoZSBzdGF0ZSBhbmQgdmVsb2NpdHkgb2YgbW90aW9uIHZhbHVlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNb3Rpb25WYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW5pdCAtIFRoZSBpbml0aWF0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogLSAgYHRyYW5zZm9ybWVyYDogQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gaW5jb21pbmcgdmFsdWVzIHdpdGguXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb3Rpb25WYWx1ZShpbml0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEdXJhdGlvbiwgaW4gbWlsbGlzZWNvbmRzLCBzaW5jZSBsYXN0IHVwZGF0aW5nIGZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGltZURlbHRhID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWVzdGFtcCBvZiB0aGUgbGFzdCB0aW1lIHRoaXMgYE1vdGlvblZhbHVlYCB3YXMgdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgYE1vdGlvblZhbHVlYCB1cGRhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25zIHRvIG5vdGlmeSB3aGVuIHRoZSB2ZWxvY2l0eSB1cGRhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbnMgdG8gbm90aWZ5IHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgdXBkYXRlcyBhbmQgYHJlbmRlcmAgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyB3aGV0aGVyIHRoaXMgdmFsdWUgY2FuIG91dHB1dCBhIHZlbG9jaXR5LiBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHRydWVcbiAgICAgICAgICogaWYgdGhlIHZhbHVlIGlzIG51bWVyaWNhbCwgYnV0IHdlIG1pZ2h0IGJlIGFibGUgdG8gd2lkZW4gdGhlIHNjb3BlIGhlcmUgYW5kIHN1cHBvcnRcbiAgICAgICAgICogb3RoZXIgdmFsdWUgdHlwZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5ID0gZnVuY3Rpb24gKHYsIHJlbmRlcikge1xuICAgICAgICAgICAgaWYgKHJlbmRlciA9PT0gdm9pZCAwKSB7IHJlbmRlciA9IHRydWU7IH1cbiAgICAgICAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgX3RoaXMuY3VycmVudCA9IHY7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGltZXN0YW1wXG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRGcmFtZURhdGEoKSwgZGVsdGEgPSBfYS5kZWx0YSwgdGltZXN0YW1wID0gX2EudGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKF90aGlzLmxhc3RVcGRhdGVkICE9PSB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lRGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0VXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBzeW5jLnBvc3RSZW5kZXIoX3RoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB1cGRhdGUgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcmV2ICE9PSBfdGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHZlbG9jaXR5IHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAoX3RoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeShfdGhpcy5nZXRWZWxvY2l0eSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSByZW5kZXIgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5ub3RpZnkoX3RoaXMuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2hlZHVsZSBhIHZlbG9jaXR5IGNoZWNrIGZvciB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhbiBpbnN0YW5jZWQgYW5kIGJvdW5kIGZ1bmN0aW9uIHRvIHByZXZlbnQgZ2VuZXJhdGluZyBhIG5ld1xuICAgICAgICAgKiBmdW5jdGlvbiBvbmNlIHBlciBmcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN5bmMucG9zdFJlbmRlcihfdGhpcy52ZWxvY2l0eUNoZWNrKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYHByZXZgIHdpdGggYGN1cnJlbnRgIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgYmVlbiB1cGRhdGVkIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIFRoaXMgZW5zdXJlcyB2ZWxvY2l0eSBjYWxjdWxhdGlvbnMgcmV0dXJuIGAwYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhbiBpbnN0YW5jZWQgYW5kIGJvdW5kIGZ1bmN0aW9uIHRvIHByZXZlbnQgZ2VuZXJhdGluZyBhIG5ld1xuICAgICAgICAgKiBmdW5jdGlvbiBvbmNlIHBlciBmcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlbG9jaXR5Q2hlY2sgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBfYS50aW1lc3RhbXA7XG4gICAgICAgICAgICBpZiAodGltZXN0YW1wICE9PSBfdGhpcy5sYXN0VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgICAgIF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudCA9IGluaXQ7XG4gICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGlzRmxvYXQodGhpcy5jdXJyZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBub3RpZmllZCB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIGlzIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBJdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxpbmcgYG9uQ2hhbmdlYCBpbnNpZGUgYSBSZWFjdCBjb21wb25lbnQsIGl0IHNob3VsZCBiZSB3cmFwcGVkIHdpdGggdGhlXG4gICAgICogYHVzZUVmZmVjdGAgaG9vay4gQXMgaXQgcmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmV0dXJuZWRcbiAgICAgKiBmcm9tIHRoZSBgdXNlRWZmZWN0YCBmdW5jdGlvbiB0byBlbnN1cmUgeW91IGRvbid0IGFkZCBkdXBsaWNhdGUgc3Vic2NyaWJlcnMuLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAqICAgY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogICBjb25zdCB5ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiAgIGNvbnN0IG9wYWNpdHkgPSB1c2VNb3Rpb25WYWx1ZSgxKVxuICAgICAqXG4gICAgICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAqICAgICBmdW5jdGlvbiB1cGRhdGVPcGFjaXR5KCkge1xuICAgICAqICAgICAgIGNvbnN0IG1heFhZID0gTWF0aC5tYXgoeC5nZXQoKSwgeS5nZXQoKSlcbiAgICAgKiAgICAgICBjb25zdCBuZXdPcGFjaXR5ID0gdHJhbnNmb3JtKG1heFhZLCBbMCwgMTAwXSwgWzEsIDBdKVxuICAgICAqICAgICAgIG9wYWNpdHkuc2V0KG5ld09wYWNpdHkpXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICBjb25zdCB1bnN1YnNjcmliZVggPSB4Lm9uQ2hhbmdlKHVwZGF0ZU9wYWNpdHkpXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWSA9IHkub25DaGFuZ2UodXBkYXRlT3BhY2l0eSlcbiAgICAgKlxuICAgICAqICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWCgpXG4gICAgICogICAgICAgdW5zdWJzY3JpYmVZKClcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSwgW10pXG4gICAgICpcbiAgICAgKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyB4IH19IC8+XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGludGVybmFscmVtYXJrc1xuICAgICAqXG4gICAgICogV2UgY291bGQgbG9vayBpbnRvIGEgYHVzZU9uQ2hhbmdlYCBob29rIGlmIHRoZSBhYm92ZSBsaWZlY3ljbGUgbWFuYWdlbWVudCBwcm92ZXMgY29uZnVzaW5nLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogdXNlT25DaGFuZ2UoeCwgKCkgPT4ge30pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfTtcbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuY2xlYXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgbm90aWZpZWQgd2hlbiB0aGUgYE1vdGlvblZhbHVlYCByZXF1ZXN0cyBhIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyIC0gQSBmdW5jdGlvbiB0aGF0J3MgcHJvdmlkZWQgdGhlIGxhdGVzdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIGNhbmNlbCB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5vblJlbmRlclJlcXVlc3QgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIFJlbmRlciBpbW1lZGlhdGVseVxuICAgICAgICBzdWJzY3JpcHRpb24odGhpcy5nZXQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclN1YnNjcmliZXJzLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYSBwYXNzaXZlIGVmZmVjdCB0byB0aGUgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QgPSBwYXNzaXZlRWZmZWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGBNb3Rpb25WYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogeC5zZXQoMTApXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0ZXN0IC0gTGF0ZXN0IHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gcmVuZGVyIC0gV2hldGhlciB0byBub3RpZnkgcmVuZGVyIHN1YnNjcmliZXJzLiBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIHJlbmRlcikge1xuICAgICAgICBpZiAocmVuZGVyID09PSB2b2lkIDApIHsgcmVuZGVyID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoIXJlbmRlciB8fCAhdGhpcy5wYXNzaXZlRWZmZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSh2LCByZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0KHYsIHRoaXMudXBkYXRlQW5kTm90aWZ5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IHN0YXRlIG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuZ2V0UHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3QgdmVsb2NpdHkgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGBNb3Rpb25WYWx1ZWAuIFJldHVybnMgYDBgIGlmIHRoZSBzdGF0ZSBpcyBub24tbnVtZXJpY2FsLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBpc0Zsb2F0KHRoaXMucHJldikgJiYgaXNGbG9hdCh0aGlzLmN1cnJlbnQpLCBidXQgdGhhdCB3b3VsZCBiZSB3YXN0ZWZ1bFxuICAgICAgICByZXR1cm4gdGhpcy5jYW5UcmFja1ZlbG9jaXR5XG4gICAgICAgICAgICA/IC8vIFRoZXNlIGNhc3RzIGNvdWxkIGJlIGF2b2lkZWQgaWYgcGFyc2VGbG9hdCB3b3VsZCBiZSB0eXBlZCBiZXR0ZXJcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eVBlclNlY29uZChwYXJzZUZsb2F0KHRoaXMuY3VycmVudCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMucHJldiksIHRoaXMudGltZURlbHRhKVxuICAgICAgICAgICAgOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGFuaW1hdGlvbiB0byBjb250cm9sIHRoaXMgYE1vdGlvblZhbHVlYC4gT25seSBvbmVcbiAgICAgKiBhbmltYXRpb24gY2FuIGRyaXZlIGEgYE1vdGlvblZhbHVlYCBhdCBvbmUgdGltZS5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIHZhbHVlLnN0YXJ0KClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gLSBBIGZ1bmN0aW9uIHRoYXQgc3RhcnRzIHRoZSBwcm92aWRlZCBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuaGFzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuc3RvcEFuaW1hdGlvbiA9IGFuaW1hdGlvbihyZXNvbHZlKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbGVhckFuaW1hdGlvbigpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGN1cnJlbnRseSBhY3RpdmUgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wQW5pbWF0aW9uKVxuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuaXNBbmltYXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3RvcEFuaW1hdGlvbjtcbiAgICB9O1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5jbGVhckFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGNsZWFuIHVwIHN1YnNjcmliZXJzIHRvIHRoaXMgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgTW90aW9uVmFsdWVgIGhvb2tzIGxpa2UgYHVzZU1vdGlvblZhbHVlYCBhbmQgYHVzZVRyYW5zZm9ybWAgYXV0b21hdGljYWxseVxuICAgICAqIGhhbmRsZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByZXR1cm5lZCBgTW90aW9uVmFsdWVgLCBzbyB0aGlzIG1ldGhvZCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiB5b3UndmUgbWFudWFsbHlcbiAgICAgKiBjcmVhdGVkIGEgYE1vdGlvblZhbHVlYCB2aWEgdGhlIGBtb3Rpb25WYWx1ZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICAgIHJldHVybiBNb3Rpb25WYWx1ZTtcbn0oKSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBtb3Rpb25WYWx1ZShpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBNb3Rpb25WYWx1ZShpbml0KTtcbn1cblxuZXhwb3J0IHsgTW90aW9uVmFsdWUsIG1vdGlvblZhbHVlIH07XG4iLCAiaW1wb3J0IHsgYWRkVW5pcXVlSXRlbSwgcmVtb3ZlSXRlbSB9IGZyb20gJy4vYXJyYXkubWpzJztcblxudmFyIFN1YnNjcmlwdGlvbk1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZUl0ZW0oX3RoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7IH07XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICB2YXIgbnVtU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmICghbnVtU3Vic2NyaXB0aW9ucylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG51bVN1YnNjcmlwdGlvbnMgPT09IDEpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUncyBvbmx5IGEgc2luZ2xlIGhhbmRsZXIgd2UgY2FuIGp1c3QgY2FsbCBpdCB3aXRob3V0IGludm9raW5nIGEgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zWzBdKGEsIGIsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TdWJzY3JpcHRpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBoYW5kbGVyIGV4aXN0cyBiZWZvcmUgZmlyaW5nIGFzIGl0J3MgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3Vic2NyaXB0aW9ucyB3ZXJlIG1vZGlmaWVkIGR1cmluZyB0aGlzIGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbk1hbmFnZXI7XG59KCkpO1xuXG5leHBvcnQgeyBTdWJzY3JpcHRpb25NYW5hZ2VyIH07XG4iLCAiaW1wb3J0IHsgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGFyci5pbmRleE9mKGl0ZW0pID09PSAtMSAmJiBhcnIucHVzaChpdGVtKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaW5kZXggPiAtMSAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBhcnJheS1tb3ZlXG5mdW5jdGlvbiBtb3ZlSXRlbShfYSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgdmFyIF9iID0gX19yZWFkKF9hKSwgYXJyID0gX2Iuc2xpY2UoMCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBmcm9tSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIGZyb21JbmRleCA6IGZyb21JbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA+PSAwICYmIHN0YXJ0SW5kZXggPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRvSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIHRvSW5kZXggOiB0b0luZGV4O1xuICAgICAgICB2YXIgX2MgPSBfX3JlYWQoYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpLCAxKSwgaXRlbSA9IF9jWzBdO1xuICAgICAgICBhcnIuc3BsaWNlKGVuZEluZGV4LCAwLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IHsgYWRkVW5pcXVlSXRlbSwgbW92ZUl0ZW0sIHJlbW92ZUl0ZW0gfTtcbiIsICJ2YXIgaXNNb3Rpb25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS5nZXRWZWxvY2l0eSk7XG59O1xuXG5leHBvcnQgeyBpc01vdGlvblZhbHVlIH07XG4iLCAiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCwgX19zcHJlYWRBcnJheSwgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaW5lcnRpYSwgYW5pbWF0ZSB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgeyBzZWNvbmRzVG9NaWxsaXNlY29uZHMgfSBmcm9tICcuLi8uLi91dGlscy90aW1lLWNvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IGlzRWFzaW5nQXJyYXksIGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uIH0gZnJvbSAnLi9lYXNpbmcubWpzJztcbmltcG9ydCB7IGlzQW5pbWF0YWJsZSB9IGZyb20gJy4vaXMtYW5pbWF0YWJsZS5tanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFRyYW5zaXRpb24gfSBmcm9tICcuL2RlZmF1bHQtdHJhbnNpdGlvbnMubWpzJztcbmltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICdoZXktbGlzdGVuJztcbmltcG9ydCB7IGdldEFuaW1hdGFibGVOb25lIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9hbmltYXRhYmxlLW5vbmUubWpzJztcbmltcG9ydCB7IGluc3RhbnRBbmltYXRpb25TdGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1pbnN0YW50LXRyYW5zaXRpb24tc3RhdGUubWpzJztcbmltcG9ydCB7IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgfSBmcm9tICcuLi8uLi91dGlscy9yZXNvbHZlLXZhbHVlLm1qcyc7XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgYSB0cmFuc2l0aW9uIGlzIGRlZmluZWQgb24gYSBnaXZlbiBUcmFuc2l0aW9uLlxuICogVGhpcyBmaWx0ZXJzIG91dCBvcmNoZXN0cmF0aW9uIG9wdGlvbnMgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgYW55IG9wdGlvbnMgYXJlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkRlZmluZWQoX2EpIHtcbiAgICBfYS53aGVuOyBfYS5kZWxheTsgX2EuZGVsYXlDaGlsZHJlbjsgX2Euc3RhZ2dlckNoaWxkcmVuOyBfYS5zdGFnZ2VyRGlyZWN0aW9uOyBfYS5yZXBlYXQ7IF9hLnJlcGVhdFR5cGU7IF9hLnJlcGVhdERlbGF5OyBfYS5mcm9tOyB2YXIgdHJhbnNpdGlvbiA9IF9fcmVzdChfYSwgW1wid2hlblwiLCBcImRlbGF5XCIsIFwiZGVsYXlDaGlsZHJlblwiLCBcInN0YWdnZXJDaGlsZHJlblwiLCBcInN0YWdnZXJEaXJlY3Rpb25cIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRUeXBlXCIsIFwicmVwZWF0RGVsYXlcIiwgXCJmcm9tXCJdKTtcbiAgICByZXR1cm4gISFPYmplY3Qua2V5cyh0cmFuc2l0aW9uKS5sZW5ndGg7XG59XG52YXIgbGVnYWN5UmVwZWF0V2FybmluZyA9IGZhbHNlO1xuLyoqXG4gKiBDb252ZXJ0IEZyYW1lciBNb3Rpb24ncyBUcmFuc2l0aW9uIHR5cGUgaW50byBQb3Btb3Rpb24tY29tcGF0aWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNpdGlvblRvQW5pbWF0aW9uT3B0aW9ucyhfYSkge1xuICAgIHZhciBlYXNlID0gX2EuZWFzZSwgdGltZXMgPSBfYS50aW1lcywgeW95byA9IF9hLnlveW8sIGZsaXAgPSBfYS5mbGlwLCBsb29wID0gX2EubG9vcCwgdHJhbnNpdGlvbiA9IF9fcmVzdChfYSwgW1wiZWFzZVwiLCBcInRpbWVzXCIsIFwieW95b1wiLCBcImZsaXBcIiwgXCJsb29wXCJdKTtcbiAgICB2YXIgb3B0aW9ucyA9IF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKTtcbiAgICBpZiAodGltZXMpXG4gICAgICAgIG9wdGlvbnNbXCJvZmZzZXRcIl0gPSB0aW1lcztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFueSBleGlzdGluZyBkdXJhdGlvbnMgZnJvbSBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGlmICh0cmFuc2l0aW9uLmR1cmF0aW9uKVxuICAgICAgICBvcHRpb25zW1wiZHVyYXRpb25cIl0gPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModHJhbnNpdGlvbi5kdXJhdGlvbik7XG4gICAgaWYgKHRyYW5zaXRpb24ucmVwZWF0RGVsYXkpXG4gICAgICAgIG9wdGlvbnMucmVwZWF0RGVsYXkgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModHJhbnNpdGlvbi5yZXBlYXREZWxheSk7XG4gICAgLyoqXG4gICAgICogTWFwIGVhc2luZyBuYW1lcyB0byBQb3Btb3Rpb24ncyBlYXNpbmcgZnVuY3Rpb25zXG4gICAgICovXG4gICAgaWYgKGVhc2UpIHtcbiAgICAgICAgb3B0aW9uc1tcImVhc2VcIl0gPSBpc0Vhc2luZ0FycmF5KGVhc2UpXG4gICAgICAgICAgICA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKVxuICAgICAgICAgICAgOiBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbihlYXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBsZWdhY3kgdHJhbnNpdGlvbiBBUElcbiAgICAgKi9cbiAgICBpZiAodHJhbnNpdGlvbi50eXBlID09PSBcInR3ZWVuXCIpXG4gICAgICAgIG9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gICAgLyoqXG4gICAgICogVE9ETzogVGhlc2Ugb3B0aW9ucyBhcmUgb2ZmaWNpYWxseSByZW1vdmVkIGZyb20gdGhlIEFQSS5cbiAgICAgKi9cbiAgICBpZiAoeW95byB8fCBsb29wIHx8IGZsaXApIHtcbiAgICAgICAgd2FybmluZyghbGVnYWN5UmVwZWF0V2FybmluZywgXCJ5b3lvLCBsb29wIGFuZCBmbGlwIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIEFQSS4gUmVwbGFjZSB3aXRoIHJlcGVhdCBhbmQgcmVwZWF0VHlwZSBvcHRpb25zLlwiKTtcbiAgICAgICAgbGVnYWN5UmVwZWF0V2FybmluZyA9IHRydWU7XG4gICAgICAgIGlmICh5b3lvKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcInJldmVyc2VcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcImxvb3BcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmbGlwKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcIm1pcnJvclwiO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucmVwZWF0ID0gbG9vcCB8fCB5b3lvIHx8IGZsaXAgfHwgdHJhbnNpdGlvbi5yZXBlYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IFBvcG1vdGlvbiA5IGhhcyB0aGUgYWJpbGl0eSB0byBhdXRvbWF0aWNhbGx5IGRldGVjdCB3aGV0aGVyIHRvIHVzZVxuICAgICAqIGEga2V5ZnJhbWVzIG9yIHNwcmluZyBhbmltYXRpb24sIGJ1dCBkb2VzIHNvIGJ5IGRldGVjdGluZyB2ZWxvY2l0eSBhbmQgb3RoZXIgc3ByaW5nIG9wdGlvbnMuXG4gICAgICogSXQnZCBiZSBnb29kIHRvIGludHJvZHVjZSBhIHNpbWlsYXIgdGhpbmcgaGVyZS5cbiAgICAgKi9cbiAgICBpZiAodHJhbnNpdGlvbi50eXBlICE9PSBcInNwcmluZ1wiKVxuICAgICAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICAgIHJldHVybiBvcHRpb25zO1xufVxuLyoqXG4gKiBHZXQgdGhlIGRlbGF5IGZvciBhIHZhbHVlIGJ5IGNoZWNraW5nIFRyYW5zaXRpb24gd2l0aCBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICovXG5mdW5jdGlvbiBnZXREZWxheUZyb21UcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIHZhbHVlVHJhbnNpdGlvbiA9IGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHx8IHt9O1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB2YWx1ZVRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG59XG5mdW5jdGlvbiBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRvKSAmJiBvcHRpb25zLnRvWzBdID09PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMudG8gPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQob3B0aW9ucy50byksIGZhbHNlKTtcbiAgICAgICAgb3B0aW9ucy50b1swXSA9IG9wdGlvbnMuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHRyYW5zaXRpb24sIG9wdGlvbnMsIGtleSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRvKSkge1xuICAgICAgICAoX2EgPSB0cmFuc2l0aW9uLmR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodHJhbnNpdGlvbi5kdXJhdGlvbiA9IDAuOCk7XG4gICAgfVxuICAgIGh5ZHJhdGVLZXlmcmFtZXMob3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogR2V0IGEgZGVmYXVsdCB0cmFuc2l0aW9uIGlmIG5vbmUgaXMgZGV0ZXJtaW5lZCB0byBiZSBkZWZpbmVkLlxuICAgICAqL1xuICAgIGlmICghaXNUcmFuc2l0aW9uRGVmaW5lZCh0cmFuc2l0aW9uKSkge1xuICAgICAgICB0cmFuc2l0aW9uID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRyYW5zaXRpb24pLCBnZXREZWZhdWx0VHJhbnNpdGlvbihrZXksIG9wdGlvbnMudG8pKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbikpO1xufVxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uLCBvbkNvbXBsZXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KTtcbiAgICB2YXIgb3JpZ2luID0gKF9hID0gdmFsdWVUcmFuc2l0aW9uLmZyb20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLmdldCgpO1xuICAgIHZhciBpc1RhcmdldEFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCB0YXJnZXQpO1xuICAgIGlmIChvcmlnaW4gPT09IFwibm9uZVwiICYmIGlzVGFyZ2V0QW5pbWF0YWJsZSAmJiB0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSB0cnlpbmcgdG8gYW5pbWF0ZSBmcm9tIFwibm9uZVwiLCB0cnkgYW5kIGdldCBhbiBhbmltYXRhYmxlIHZlcnNpb25cbiAgICAgICAgICogb2YgdGhlIHRhcmdldC4gVGhpcyBjb3VsZCBiZSBpbXByb3ZlZCB0byB3b3JrIGJvdGggd2F5cy5cbiAgICAgICAgICovXG4gICAgICAgIG9yaWdpbiA9IGdldEFuaW1hdGFibGVOb25lKGtleSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNaZXJvKG9yaWdpbikgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcmlnaW4gPSBnZXRaZXJvVW5pdCh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmXG4gICAgICAgIGlzWmVybyh0YXJnZXQpICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGFyZ2V0ID0gZ2V0WmVyb1VuaXQob3JpZ2luKTtcbiAgICB9XG4gICAgdmFyIGlzT3JpZ2luQW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZShrZXksIG9yaWdpbik7XG4gICAgd2FybmluZyhpc09yaWdpbkFuaW1hdGFibGUgPT09IGlzVGFyZ2V0QW5pbWF0YWJsZSwgXCJZb3UgYXJlIHRyeWluZyB0byBhbmltYXRlIFwiLmNvbmNhdChrZXksIFwiIGZyb20gXFxcIlwiKS5jb25jYXQob3JpZ2luLCBcIlxcXCIgdG8gXFxcIlwiKS5jb25jYXQodGFyZ2V0LCBcIlxcXCIuIFwiKS5jb25jYXQob3JpZ2luLCBcIiBpcyBub3QgYW4gYW5pbWF0YWJsZSB2YWx1ZSAtIHRvIGVuYWJsZSB0aGlzIGFuaW1hdGlvbiBzZXQgXCIpLmNvbmNhdChvcmlnaW4sIFwiIHRvIGEgdmFsdWUgYW5pbWF0YWJsZSB0byBcIikuY29uY2F0KHRhcmdldCwgXCIgdmlhIHRoZSBgc3R5bGVgIHByb3BlcnR5LlwiKSk7XG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgZnJvbTogb3JpZ2luLFxuICAgICAgICAgICAgdG86IHRhcmdldCxcbiAgICAgICAgICAgIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWUuc2V0KHYpOyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IFwiaW5lcnRpYVwiIHx8XG4gICAgICAgICAgICB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gXCJkZWNheVwiXG4gICAgICAgICAgICA/IGluZXJ0aWEoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB2YWx1ZVRyYW5zaXRpb24pKVxuICAgICAgICAgICAgOiBhbmltYXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHZhbHVlVHJhbnNpdGlvbiwgb3B0aW9ucywga2V5KSksIHsgb25VcGRhdGU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwZGF0ZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZVRyYW5zaXRpb24sIHYpO1xuICAgICAgICAgICAgICAgIH0sIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdmFsdWVUcmFuc2l0aW9uLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlVHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGZpbmFsVGFyZ2V0ID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXQpO1xuICAgICAgICB2YWx1ZS5zZXQoZmluYWxUYXJnZXQpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIChfYSA9IHZhbHVlVHJhbnNpdGlvbiA9PT0gbnVsbCB8fCB2YWx1ZVRyYW5zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmFsdWVUcmFuc2l0aW9uLCBmaW5hbFRhcmdldCk7XG4gICAgICAgIChfYiA9IHZhbHVlVHJhbnNpdGlvbiA9PT0gbnVsbCB8fCB2YWx1ZVRyYW5zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh2YWx1ZVRyYW5zaXRpb24pO1xuICAgICAgICByZXR1cm4geyBzdG9wOiBmdW5jdGlvbiAoKSB7IH0gfTtcbiAgICB9XG4gICAgcmV0dXJuICFpc09yaWdpbkFuaW1hdGFibGUgfHxcbiAgICAgICAgIWlzVGFyZ2V0QW5pbWF0YWJsZSB8fFxuICAgICAgICB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gZmFsc2VcbiAgICAgICAgPyBzZXRcbiAgICAgICAgOiBzdGFydDtcbn1cbmZ1bmN0aW9uIGlzWmVybyh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPT09IDAgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgcGFyc2VGbG9hdCh2YWx1ZSkgPT09IDAgJiZcbiAgICAgICAgICAgIHZhbHVlLmluZGV4T2YoXCIgXCIpID09PSAtMSkpO1xufVxuZnVuY3Rpb24gZ2V0WmVyb1VuaXQocG90ZW50aWFsVW5pdFR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHBvdGVudGlhbFVuaXRUeXBlID09PSBcIm51bWJlclwiXG4gICAgICAgID8gMFxuICAgICAgICA6IGdldEFuaW1hdGFibGVOb25lKFwiXCIsIHBvdGVudGlhbFVuaXRUeXBlKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbltrZXldIHx8IHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8IHRyYW5zaXRpb247XG59XG4vKipcbiAqIFN0YXJ0IGFuaW1hdGlvbiBvbiBhIE1vdGlvblZhbHVlLiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGludGVyZmFjZSBiZXR3ZWVuXG4gKiBGcmFtZXIgTW90aW9uIGFuZCBQb3Btb3Rpb25cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT09IHZvaWQgMCkgeyB0cmFuc2l0aW9uID0ge307IH1cbiAgICBpZiAoaW5zdGFudEFuaW1hdGlvblN0YXRlLmN1cnJlbnQpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IHsgdHlwZTogZmFsc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnN0YXJ0KGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBkZWxheVRpbWVyO1xuICAgICAgICB2YXIgY29udHJvbHM7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSBnZXRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uLCBvbkNvbXBsZXRlKTtcbiAgICAgICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpO1xuICAgICAgICB2YXIgc3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoY29udHJvbHMgPSBhbmltYXRpb24oKSk7IH07XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgZGVsYXlUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHN0YXJ0LCBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWxheVRpbWVyKTtcbiAgICAgICAgICAgIGNvbnRyb2xzID09PSBudWxsIHx8IGNvbnRyb2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cm9scy5zdG9wKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGNvbnZlcnRUcmFuc2l0aW9uVG9BbmltYXRpb25PcHRpb25zLCBnZXREZWxheUZyb21UcmFuc2l0aW9uLCBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zLCBnZXRWYWx1ZVRyYW5zaXRpb24sIGdldFplcm9Vbml0LCBoeWRyYXRlS2V5ZnJhbWVzLCBpc1RyYW5zaXRpb25EZWZpbmVkLCBpc1plcm8sIHN0YXJ0QW5pbWF0aW9uIH07XG4iLCAiLyoqXG4gKiBDb252ZXJ0cyBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICpcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGltZSBpbiBzZWNvbmRzLlxuICogQHJldHVybiBtaWxsaXNlY29uZHMgLSBDb252ZXJ0ZWQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBzZWNvbmRzVG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbiAoc2Vjb25kcykgeyByZXR1cm4gc2Vjb25kcyAqIDEwMDA7IH07XG5cbmV4cG9ydCB7IHNlY29uZHNUb01pbGxpc2Vjb25kcyB9O1xuIiwgImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0IHsgY3ViaWNCZXppZXIsIGxpbmVhciwgZWFzZUluLCBlYXNlSW5PdXQsIGVhc2VPdXQsIGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0LCBiYWNrSW4sIGJhY2tJbk91dCwgYmFja091dCwgYW50aWNpcGF0ZSwgYm91bmNlSW4sIGJvdW5jZUluT3V0LCBib3VuY2VPdXQgfSBmcm9tICdwb3Btb3Rpb24nO1xuXG52YXIgZWFzaW5nTG9va3VwID0ge1xuICAgIGxpbmVhcjogbGluZWFyLFxuICAgIGVhc2VJbjogZWFzZUluLFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0LFxuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXG4gICAgY2lyY0luOiBjaXJjSW4sXG4gICAgY2lyY0luT3V0OiBjaXJjSW5PdXQsXG4gICAgY2lyY091dDogY2lyY091dCxcbiAgICBiYWNrSW46IGJhY2tJbixcbiAgICBiYWNrSW5PdXQ6IGJhY2tJbk91dCxcbiAgICBiYWNrT3V0OiBiYWNrT3V0LFxuICAgIGFudGljaXBhdGU6IGFudGljaXBhdGUsXG4gICAgYm91bmNlSW46IGJvdW5jZUluLFxuICAgIGJvdW5jZUluT3V0OiBib3VuY2VJbk91dCxcbiAgICBib3VuY2VPdXQ6IGJvdW5jZU91dCxcbn07XG52YXIgZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24gPSBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgICAgIC8vIElmIGN1YmljIGJlemllciBkZWZpbml0aW9uLCBjcmVhdGUgYmV6aWVyIGN1cnZlXG4gICAgICAgIGludmFyaWFudChkZWZpbml0aW9uLmxlbmd0aCA9PT0gNCwgXCJDdWJpYyBiZXppZXIgYXJyYXlzIG11c3QgY29udGFpbiBmb3VyIG51bWVyaWNhbCB2YWx1ZXMuXCIpO1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZGVmaW5pdGlvbiwgNCksIHgxID0gX2FbMF0sIHkxID0gX2FbMV0sIHgyID0gX2FbMl0sIHkyID0gX2FbM107XG4gICAgICAgIHJldHVybiBjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEVsc2UgbG9va3VwIGZyb20gdGFibGVcbiAgICAgICAgaW52YXJpYW50KGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXSAhPT0gdW5kZWZpbmVkLCBcIkludmFsaWQgZWFzaW5nIHR5cGUgJ1wiLmNvbmNhdChkZWZpbml0aW9uLCBcIidcIikpO1xuICAgICAgICByZXR1cm4gZWFzaW5nTG9va3VwW2RlZmluaXRpb25dO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG52YXIgaXNFYXNpbmdBcnJheSA9IGZ1bmN0aW9uIChlYXNlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWFzZSkgJiYgdHlwZW9mIGVhc2VbMF0gIT09IFwibnVtYmVyXCI7XG59O1xuXG5leHBvcnQgeyBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiwgaXNFYXNpbmdBcnJheSB9O1xuIiwgImltcG9ydCB7IGNvbXBsZXggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbmltYXRhYmxlLiBFeGFtcGxlczpcbiAqXG4gKiBcdTI3MDU6IDEwMCwgXCIxMDBweFwiLCBcIiNmZmZcIlxuICogXHUyNzRDOiBcImJsb2NrXCIsIFwidXJsKDIuanBnKVwiXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIGlzQW5pbWF0YWJsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIGxpc3Qgb2Yga2V5cyB0YXQgbWlnaHQgYmUgbm9uLWFuaW1hdGFibGUgZ3Jvd3MsIHJlcGxhY2Ugd2l0aCBTZXRcbiAgICBpZiAoa2V5ID09PSBcInpJbmRleFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gSWYgaXQncyBhIG51bWJlciBvciBhIGtleWZyYW1lcyBhcnJheSwgd2UgY2FuIGFuaW1hdGUgaXQuIFdlIG1pZ2h0IGF0IHNvbWUgcG9pbnRcbiAgICAvLyBuZWVkIHRvIGRvIGEgZGVlcCBpc0FuaW1hdGFibGUgY2hlY2sgb2Yga2V5ZnJhbWVzLCBvciBsZXQgUG9wbW90aW9uIGhhbmRsZSB0aGlzLFxuICAgIC8vIGJ1dCBmb3Igbm93IGxldHMgbGVhdmUgaXQgbGlrZSB0aGlzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAvLyBJdCdzIGFuaW1hdGFibGUgaWYgd2UgaGF2ZSBhIHN0cmluZ1xuICAgICAgICBjb21wbGV4LnRlc3QodmFsdWUpICYmIC8vIEFuZCBpdCBjb250YWlucyBudW1iZXJzIGFuZC9vciBjb2xvcnNcbiAgICAgICAgIXZhbHVlLnN0YXJ0c1dpdGgoXCJ1cmwoXCIpIC8vIFVubGVzcyBpdCBzdGFydHMgd2l0aCBcInVybChcIlxuICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHsgaXNBbmltYXRhYmxlIH07XG4iLCAiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpc0tleWZyYW1lc1RhcmdldCB9IGZyb20gJy4vaXMta2V5ZnJhbWVzLXRhcmdldC5tanMnO1xuXG52YXIgdW5kZXJEYW1wZWRTcHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgc3RpZmZuZXNzOiA1MDAsXG4gICAgZGFtcGluZzogMjUsXG4gICAgcmVzdFNwZWVkOiAxMCxcbn0pOyB9O1xudmFyIGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcgPSBmdW5jdGlvbiAodG8pIHsgcmV0dXJuICh7XG4gICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICBzdGlmZm5lc3M6IDU1MCxcbiAgICBkYW1waW5nOiB0byA9PT0gMCA/IDIgKiBNYXRoLnNxcnQoNTUwKSA6IDMwLFxuICAgIHJlc3RTcGVlZDogMTAsXG59KTsgfTtcbnZhciBsaW5lYXJUd2VlbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBlYXNlOiBcImxpbmVhclwiLFxuICAgIGR1cmF0aW9uOiAwLjMsXG59KTsgfTtcbnZhciBrZXlmcmFtZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7IHJldHVybiAoe1xuICAgIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gICAgZHVyYXRpb246IDAuOCxcbiAgICB2YWx1ZXM6IHZhbHVlcyxcbn0pOyB9O1xudmFyIGRlZmF1bHRUcmFuc2l0aW9ucyA9IHtcbiAgICB4OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICB5OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICB6OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICByb3RhdGU6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVo6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHNjYWxlWDogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgICBzY2FsZVk6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gICAgc2NhbGU6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gICAgb3BhY2l0eTogbGluZWFyVHdlZW4sXG4gICAgYmFja2dyb3VuZENvbG9yOiBsaW5lYXJUd2VlbixcbiAgICBjb2xvcjogbGluZWFyVHdlZW4sXG4gICAgZGVmYXVsdDogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbn07XG52YXIgZ2V0RGVmYXVsdFRyYW5zaXRpb24gPSBmdW5jdGlvbiAodmFsdWVLZXksIHRvKSB7XG4gICAgdmFyIHRyYW5zaXRpb25GYWN0b3J5O1xuICAgIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcbiAgICAgICAgdHJhbnNpdGlvbkZhY3RvcnkgPSBrZXlmcmFtZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uRmFjdG9yeSA9XG4gICAgICAgICAgICBkZWZhdWx0VHJhbnNpdGlvbnNbdmFsdWVLZXldIHx8IGRlZmF1bHRUcmFuc2l0aW9ucy5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oeyB0bzogdG8gfSwgdHJhbnNpdGlvbkZhY3RvcnkodG8pKTtcbn07XG5cbmV4cG9ydCB7IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsIGdldERlZmF1bHRUcmFuc2l0aW9uLCBsaW5lYXJUd2VlbiwgdW5kZXJEYW1wZWRTcHJpbmcgfTtcbiIsICJ2YXIgaXNLZXlmcmFtZXNUYXJnZXQgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xufTtcblxuZXhwb3J0IHsgaXNLZXlmcmFtZXNUYXJnZXQgfTtcbiIsICJpbXBvcnQgeyBmaWx0ZXIsIGNvbXBsZXggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0VmFsdWVUeXBlIH0gZnJvbSAnLi9kZWZhdWx0cy5tanMnO1xuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZShrZXksIHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkZWZhdWx0VmFsdWVUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSBmaWx0ZXIpXG4gICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgPSBjb21wbGV4O1xuICAgIC8vIElmIHZhbHVlIGlzIG5vdCByZWNvZ25pc2VkIGFzIGFuaW1hdGFibGUsIGllIFwibm9uZVwiLCBjcmVhdGUgYW4gYW5pbWF0YWJsZSB2ZXJzaW9uIG9yaWdpbiBiYXNlZCBvbiB0aGUgdGFyZ2V0XG4gICAgcmV0dXJuIChfYSA9IGRlZmF1bHRWYWx1ZVR5cGUuZ2V0QW5pbWF0YWJsZU5vbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRlZmF1bHRWYWx1ZVR5cGUsIHZhbHVlKTtcbn1cblxuZXhwb3J0IHsgZ2V0QW5pbWF0YWJsZU5vbmUgfTtcbiIsICJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGNvbG9yLCBmaWx0ZXIgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBudW1iZXJWYWx1ZVR5cGVzIH0gZnJvbSAnLi9udW1iZXIubWpzJztcblxuLyoqXG4gKiBBIG1hcCBvZiBkZWZhdWx0IHZhbHVlIHR5cGVzIGZvciBjb21tb24gdmFsdWVzXG4gKi9cbnZhciBkZWZhdWx0VmFsdWVUeXBlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBudW1iZXJWYWx1ZVR5cGVzKSwgeyBcbiAgICAvLyBDb2xvciBwcm9wc1xuICAgIGNvbG9yOiBjb2xvciwgYmFja2dyb3VuZENvbG9yOiBjb2xvciwgb3V0bGluZUNvbG9yOiBjb2xvciwgZmlsbDogY29sb3IsIHN0cm9rZTogY29sb3IsIFxuICAgIC8vIEJvcmRlciBwcm9wc1xuICAgIGJvcmRlckNvbG9yOiBjb2xvciwgYm9yZGVyVG9wQ29sb3I6IGNvbG9yLCBib3JkZXJSaWdodENvbG9yOiBjb2xvciwgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLCBib3JkZXJMZWZ0Q29sb3I6IGNvbG9yLCBmaWx0ZXI6IGZpbHRlciwgV2Via2l0RmlsdGVyOiBmaWx0ZXIgfSk7XG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgVmFsdWVUeXBlIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUga2V5XG4gKi9cbnZhciBnZXREZWZhdWx0VmFsdWVUeXBlID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVmYXVsdFZhbHVlVHlwZXNba2V5XTsgfTtcblxuZXhwb3J0IHsgZGVmYXVsdFZhbHVlVHlwZXMsIGdldERlZmF1bHRWYWx1ZVR5cGUgfTtcbiIsICJpbXBvcnQgeyBweCwgZGVncmVlcywgc2NhbGUsIGFscGhhLCBwcm9ncmVzc1BlcmNlbnRhZ2UgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBpbnQgfSBmcm9tICcuL3R5cGUtaW50Lm1qcyc7XG5cbnZhciBudW1iZXJWYWx1ZVR5cGVzID0ge1xuICAgIC8vIEJvcmRlciBwcm9wc1xuICAgIGJvcmRlcldpZHRoOiBweCxcbiAgICBib3JkZXJUb3BXaWR0aDogcHgsXG4gICAgYm9yZGVyUmlnaHRXaWR0aDogcHgsXG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHB4LFxuICAgIGJvcmRlckxlZnRXaWR0aDogcHgsXG4gICAgYm9yZGVyUmFkaXVzOiBweCxcbiAgICByYWRpdXM6IHB4LFxuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IHB4LFxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBweCxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogcHgsXG4gICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogcHgsXG4gICAgLy8gUG9zaXRpb25pbmcgcHJvcHNcbiAgICB3aWR0aDogcHgsXG4gICAgbWF4V2lkdGg6IHB4LFxuICAgIGhlaWdodDogcHgsXG4gICAgbWF4SGVpZ2h0OiBweCxcbiAgICBzaXplOiBweCxcbiAgICB0b3A6IHB4LFxuICAgIHJpZ2h0OiBweCxcbiAgICBib3R0b206IHB4LFxuICAgIGxlZnQ6IHB4LFxuICAgIC8vIFNwYWNpbmcgcHJvcHNcbiAgICBwYWRkaW5nOiBweCxcbiAgICBwYWRkaW5nVG9wOiBweCxcbiAgICBwYWRkaW5nUmlnaHQ6IHB4LFxuICAgIHBhZGRpbmdCb3R0b206IHB4LFxuICAgIHBhZGRpbmdMZWZ0OiBweCxcbiAgICBtYXJnaW46IHB4LFxuICAgIG1hcmdpblRvcDogcHgsXG4gICAgbWFyZ2luUmlnaHQ6IHB4LFxuICAgIG1hcmdpbkJvdHRvbTogcHgsXG4gICAgbWFyZ2luTGVmdDogcHgsXG4gICAgLy8gVHJhbnNmb3JtIHByb3BzXG4gICAgcm90YXRlOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVg6IGRlZ3JlZXMsXG4gICAgcm90YXRlWTogZGVncmVlcyxcbiAgICByb3RhdGVaOiBkZWdyZWVzLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBzY2FsZVg6IHNjYWxlLFxuICAgIHNjYWxlWTogc2NhbGUsXG4gICAgc2NhbGVaOiBzY2FsZSxcbiAgICBza2V3OiBkZWdyZWVzLFxuICAgIHNrZXdYOiBkZWdyZWVzLFxuICAgIHNrZXdZOiBkZWdyZWVzLFxuICAgIGRpc3RhbmNlOiBweCxcbiAgICB0cmFuc2xhdGVYOiBweCxcbiAgICB0cmFuc2xhdGVZOiBweCxcbiAgICB0cmFuc2xhdGVaOiBweCxcbiAgICB4OiBweCxcbiAgICB5OiBweCxcbiAgICB6OiBweCxcbiAgICBwZXJzcGVjdGl2ZTogcHgsXG4gICAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IHB4LFxuICAgIG9wYWNpdHk6IGFscGhhLFxuICAgIG9yaWdpblg6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBvcmlnaW5ZOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgb3JpZ2luWjogcHgsXG4gICAgLy8gTWlzY1xuICAgIHpJbmRleDogaW50LFxuICAgIC8vIFNWR1xuICAgIGZpbGxPcGFjaXR5OiBhbHBoYSxcbiAgICBzdHJva2VPcGFjaXR5OiBhbHBoYSxcbiAgICBudW1PY3RhdmVzOiBpbnQsXG59O1xuXG5leHBvcnQgeyBudW1iZXJWYWx1ZVR5cGVzIH07XG4iLCAiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBudW1iZXIgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5cbnZhciBpbnQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06IE1hdGgucm91bmQgfSk7XG5cbmV4cG9ydCB7IGludCB9O1xuIiwgInZhciBpbnN0YW50QW5pbWF0aW9uU3RhdGUgPSB7XG4gICAgY3VycmVudDogZmFsc2UsXG59O1xuXG5leHBvcnQgeyBpbnN0YW50QW5pbWF0aW9uU3RhdGUgfTtcbiIsICJpbXBvcnQgeyBpc0tleWZyYW1lc1RhcmdldCB9IGZyb20gJy4uL2FuaW1hdGlvbi91dGlscy9pcy1rZXlmcmFtZXMtdGFyZ2V0Lm1qcyc7XG5cbnZhciBpc0N1c3RvbVZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYubWl4ICYmIHYudG9WYWx1ZSk7XG59O1xudmFyIHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgPSBmdW5jdGlvbiAodikge1xuICAgIC8vIFRPRE8gbWF5YmUgdGhyb3cgaWYgdi5sZW5ndGggLSAxIGlzIHBsYWNlaG9sZGVyIHRva2VuP1xuICAgIHJldHVybiBpc0tleWZyYW1lc1RhcmdldCh2KSA/IHZbdi5sZW5ndGggLSAxXSB8fCAwIDogdjtcbn07XG5cbmV4cG9ydCB7IGlzQ3VzdG9tVmFsdWUsIHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgfTtcbiIsICJpbXBvcnQgeyBtaXgsIHByb2dyZXNzLCBsaW5lYXIsIGNpcmNPdXQgfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgcHgsIHBlcmNlbnQgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5cbnZhciBib3JkZXJzID0gW1wiVG9wTGVmdFwiLCBcIlRvcFJpZ2h0XCIsIFwiQm90dG9tTGVmdFwiLCBcIkJvdHRvbVJpZ2h0XCJdO1xudmFyIG51bUJvcmRlcnMgPSBib3JkZXJzLmxlbmd0aDtcbnZhciBhc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xufTtcbnZhciBpc1B4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBweC50ZXN0KHZhbHVlKTtcbn07XG5mdW5jdGlvbiBtaXhWYWx1ZXModGFyZ2V0LCBmb2xsb3csIGxlYWQsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHNob3VsZENyb3NzZmFkZU9wYWNpdHkpIHtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHkgPSBtaXgoMCwgXG4gICAgICAgIC8vIChmb2xsb3c/Lm9wYWNpdHkgYXMgbnVtYmVyKSA/PyAwLFxuICAgICAgICAvLyBUT0RPIFJlaW5zdGF0ZSB0aGlzIGlmIG9ubHkgY2hpbGRcbiAgICAgICAgKF9hID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLCBlYXNlQ3Jvc3NmYWRlSW4ocHJvZ3Jlc3MpKTtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHlFeGl0ID0gbWl4KChfYiA9IGZvbGxvdy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxLCAwLCBlYXNlQ3Jvc3NmYWRlT3V0KHByb2dyZXNzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT25seU1lbWJlcikge1xuICAgICAgICB0YXJnZXQub3BhY2l0eSA9IG1peCgoX2MgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMSwgKF9kID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxLCBwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1peCBib3JkZXIgcmFkaXVzXG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Cb3JkZXJzOyBpKyspIHtcbiAgICAgICAgdmFyIGJvcmRlckxhYmVsID0gXCJib3JkZXJcIi5jb25jYXQoYm9yZGVyc1tpXSwgXCJSYWRpdXNcIik7XG4gICAgICAgIHZhciBmb2xsb3dSYWRpdXMgPSBnZXRSYWRpdXMoZm9sbG93LCBib3JkZXJMYWJlbCk7XG4gICAgICAgIHZhciBsZWFkUmFkaXVzID0gZ2V0UmFkaXVzKGxlYWQsIGJvcmRlckxhYmVsKTtcbiAgICAgICAgaWYgKGZvbGxvd1JhZGl1cyA9PT0gdW5kZWZpbmVkICYmIGxlYWRSYWRpdXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb2xsb3dSYWRpdXMgfHwgKGZvbGxvd1JhZGl1cyA9IDApO1xuICAgICAgICBsZWFkUmFkaXVzIHx8IChsZWFkUmFkaXVzID0gMCk7XG4gICAgICAgIHZhciBjYW5NaXggPSBmb2xsb3dSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGxlYWRSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGlzUHgoZm9sbG93UmFkaXVzKSA9PT0gaXNQeChsZWFkUmFkaXVzKTtcbiAgICAgICAgaWYgKGNhbk1peCkge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IE1hdGgubWF4KG1peChhc051bWJlcihmb2xsb3dSYWRpdXMpLCBhc051bWJlcihsZWFkUmFkaXVzKSwgcHJvZ3Jlc3MpLCAwKTtcbiAgICAgICAgICAgIGlmIChwZXJjZW50LnRlc3QobGVhZFJhZGl1cykgfHwgcGVyY2VudC50ZXN0KGZvbGxvd1JhZGl1cykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdICs9IFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IGxlYWRSYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IHJvdGF0aW9uXG4gICAgICovXG4gICAgaWYgKGZvbGxvdy5yb3RhdGUgfHwgbGVhZC5yb3RhdGUpIHtcbiAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IG1peChmb2xsb3cucm90YXRlIHx8IDAsIGxlYWQucm90YXRlIHx8IDAsIHByb2dyZXNzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSYWRpdXModmFsdWVzLCByYWRpdXNOYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB2YWx1ZXNbcmFkaXVzTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlcy5ib3JkZXJSYWRpdXM7XG59XG4vLyAvKipcbi8vICAqIFdlIG9ubHkgd2FudCB0byBtaXggdGhlIGJhY2tncm91bmQgY29sb3IgaWYgdGhlcmUncyBhIGZvbGxvdyBlbGVtZW50XG4vLyAgKiB0aGF0IHdlJ3JlIG5vdCBjcm9zc2ZhZGluZyBvcGFjaXR5IGJldHdlZW4uIEZvciBpbnN0YW5jZSB3aXRoIHN3aXRjaFxuLy8gICogQW5pbWF0ZVNoYXJlZExheW91dCBhbmltYXRpb25zLCB0aGlzIGhlbHBzIHRoZSBpbGx1c2lvbiBvZiBhIGNvbnRpbnVvdXNcbi8vICAqIGVsZW1lbnQgYmVpbmcgYW5pbWF0ZWQgYnV0IGFsc28gY3V0cyBkb3duIG9uIHRoZSBudW1iZXIgb2YgcGFpbnRzIHRyaWdnZXJlZFxuLy8gICogZm9yIGVsZW1lbnRzIHdoZXJlIG9wYWNpdHkgaXMgZG9pbmcgdGhhdCB3b3JrIGZvciB1cy5cbi8vICAqL1xuLy8gaWYgKFxuLy8gICAgICFoYXNGb2xsb3dFbGVtZW50ICYmXG4vLyAgICAgbGF0ZXN0TGVhZFZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgJiZcbi8vICAgICBsYXRlc3RGb2xsb3dWYWx1ZXMuYmFja2dyb3VuZENvbG9yXG4vLyApIHtcbi8vICAgICAvKipcbi8vICAgICAgKiBUaGlzIGlzbid0IGlkZWFsIHBlcmZvcm1hbmNlLXdpc2UgYXMgbWl4Q29sb3IgaXMgY3JlYXRpbmcgYSBuZXcgZnVuY3Rpb24gZXZlcnkgZnJhbWUuXG4vLyAgICAgICogV2UgY291bGQgcHJvYmFibHkgY3JlYXRlIGEgbWl4ZXIgdGhhdCBydW5zIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uIGJ1dFxuLy8gICAgICAqIHRoZSBpZGVhIGJlaGluZCB0aGUgY3Jvc3NmYWRlciBpcyB0aGF0IGl0IHJ1bnMgZHluYW1pY2FsbHkgYmV0d2VlbiB0d28gcG90ZW50aWFsbHlcbi8vICAgICAgKiBjaGFuZ2luZyB0YXJnZXRzIChpZSBvcGFjaXR5IG9yIGJvcmRlclJhZGl1cyBtYXkgYmUgYW5pbWF0aW5nIGluZGVwZW5kZW50bHkgdmlhIHZhcmlhbnRzKVxuLy8gICAgICAqL1xuLy8gICAgIGxlYWRTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBmb2xsb3dTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBtaXhDb2xvcihcbi8vICAgICAgICAgbGF0ZXN0Rm9sbG93VmFsdWVzLmJhY2tncm91bmRDb2xvciBhcyBzdHJpbmcsXG4vLyAgICAgICAgIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yIGFzIHN0cmluZ1xuLy8gICAgICkocClcbi8vIH1cbnZhciBlYXNlQ3Jvc3NmYWRlSW4gPSBjb21wcmVzcygwLCAwLjUsIGNpcmNPdXQpO1xudmFyIGVhc2VDcm9zc2ZhZGVPdXQgPSBjb21wcmVzcygwLjUsIDAuOTUsIGxpbmVhcik7XG5mdW5jdGlvbiBjb21wcmVzcyhtaW4sIG1heCwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vIENvdWxkIHJlcGxhY2UgaWZzIHdpdGggY2xhbXBcbiAgICAgICAgaWYgKHAgPCBtaW4pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHAgPiBtYXgpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGVhc2luZyhwcm9ncmVzcyhtaW4sIG1heCwgcCkpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IG1peFZhbHVlcyB9O1xuIiwgIi8qKlxuICogUmVzZXQgYW4gYXhpcyB0byB0aGUgcHJvdmlkZWQgb3JpZ2luIGJveC5cbiAqXG4gKiBUaGlzIGlzIGEgbXV0YXRpdmUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjb3B5QXhpc0ludG8oYXhpcywgb3JpZ2luQXhpcykge1xuICAgIGF4aXMubWluID0gb3JpZ2luQXhpcy5taW47XG4gICAgYXhpcy5tYXggPSBvcmlnaW5BeGlzLm1heDtcbn1cbi8qKlxuICogUmVzZXQgYSBib3ggdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUJveEludG8oYm94LCBvcmlnaW5Cb3gpIHtcbiAgICBjb3B5QXhpc0ludG8oYm94LngsIG9yaWdpbkJveC54KTtcbiAgICBjb3B5QXhpc0ludG8oYm94LnksIG9yaWdpbkJveC55KTtcbn1cblxuZXhwb3J0IHsgY29weUF4aXNJbnRvLCBjb3B5Qm94SW50byB9O1xuIiwgImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IG1peCB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgeyBoYXNUcmFuc2Zvcm0gfSBmcm9tICcuLi91dGlscy9oYXMtdHJhbnNmb3JtLm1qcyc7XG5cbi8qKlxuICogU2NhbGVzIGEgcG9pbnQgYmFzZWQgb24gYSBmYWN0b3IgYW5kIGFuIG9yaWdpblBvaW50XG4gKi9cbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQsIHNjYWxlLCBvcmlnaW5Qb2ludCkge1xuICAgIHZhciBkaXN0YW5jZUZyb21PcmlnaW4gPSBwb2ludCAtIG9yaWdpblBvaW50O1xuICAgIHZhciBzY2FsZWQgPSBzY2FsZSAqIGRpc3RhbmNlRnJvbU9yaWdpbjtcbiAgICByZXR1cm4gb3JpZ2luUG9pbnQgKyBzY2FsZWQ7XG59XG4vKipcbiAqIEFwcGxpZXMgYSB0cmFuc2xhdGUvc2NhbGUgZGVsdGEgdG8gYSBwb2ludFxuICovXG5mdW5jdGlvbiBhcHBseVBvaW50RGVsdGEocG9pbnQsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIGlmIChib3hTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50ID0gc2NhbGVQb2ludChwb2ludCwgYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlUG9pbnQocG9pbnQsIHNjYWxlLCBvcmlnaW5Qb2ludCkgKyB0cmFuc2xhdGU7XG59XG4vKipcbiAqIEFwcGxpZXMgYSB0cmFuc2xhdGUvc2NhbGUgZGVsdGEgdG8gYW4gYXhpc1xuICovXG5mdW5jdGlvbiBhcHBseUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBpZiAodHJhbnNsYXRlID09PSB2b2lkIDApIHsgdHJhbnNsYXRlID0gMDsgfVxuICAgIGlmIChzY2FsZSA9PT0gdm9pZCAwKSB7IHNjYWxlID0gMTsgfVxuICAgIGF4aXMubWluID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICAgIGF4aXMubWF4ID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWF4LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGEgYm94XG4gKi9cbmZ1bmN0aW9uIGFwcGx5Qm94RGVsdGEoYm94LCBfYSkge1xuICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnk7XG4gICAgYXBwbHlBeGlzRGVsdGEoYm94LngsIHgudHJhbnNsYXRlLCB4LnNjYWxlLCB4Lm9yaWdpblBvaW50KTtcbiAgICBhcHBseUF4aXNEZWx0YShib3gueSwgeS50cmFuc2xhdGUsIHkuc2NhbGUsIHkub3JpZ2luUG9pbnQpO1xufVxuLyoqXG4gKiBBcHBseSBhIHRyZWUgb2YgZGVsdGFzIHRvIGEgYm94LiBXZSBkbyB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWZmZWN0IG9mIGFsbCB0aGUgdHJhbnNmb3Jtc1xuICogaW4gYSB0cmVlIHVwb24gb3VyIGJveCBiZWZvcmUgdGhlbiBjYWxjdWxhdGluZyBob3cgdG8gcHJvamVjdCBpdCBpbnRvIG91ciBkZXNpcmVkIHZpZXdwb3J0LXJlbGF0aXZlIGJveFxuICpcbiAqIFRoaXMgaXMgdGhlIGZpbmFsIG5lc3RlZCBsb29wIHdpdGhpbiB1cGRhdGVMYXlvdXREZWx0YSBmb3IgZnV0dXJlIHJlZmFjdG9yaW5nXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJlZURlbHRhcyhib3gsIHRyZWVTY2FsZSwgdHJlZVBhdGgsIGlzU2hhcmVkVHJhbnNpdGlvbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiA9PT0gdm9pZCAwKSB7IGlzU2hhcmVkVHJhbnNpdGlvbiA9IGZhbHNlOyB9XG4gICAgdmFyIHRyZWVMZW5ndGggPSB0cmVlUGF0aC5sZW5ndGg7XG4gICAgaWYgKCF0cmVlTGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gUmVzZXQgdGhlIHRyZWVTY2FsZVxuICAgIHRyZWVTY2FsZS54ID0gdHJlZVNjYWxlLnkgPSAxO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBkZWx0YTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWVMZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gdHJlZVBhdGhbaV07XG4gICAgICAgIGRlbHRhID0gbm9kZS5wcm9qZWN0aW9uRGVsdGE7XG4gICAgICAgIGlmICgoKF9iID0gKF9hID0gbm9kZS5pbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0eWxlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzcGxheSkgPT09IFwiY29udGVudHNcIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICBub2RlLnNjcm9sbCAmJlxuICAgICAgICAgICAgbm9kZSAhPT0gbm9kZS5yb290KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1Cb3goYm94LCB7IHg6IC1ub2RlLnNjcm9sbC54LCB5OiAtbm9kZS5zY3JvbGwueSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIEluY29wb3JhdGUgZWFjaCBhbmNlc3RvcidzIHNjYWxlIGludG8gYSBjdWxtdWxhdGl2ZSB0cmVlU2NhbGUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICB0cmVlU2NhbGUueCAqPSBkZWx0YS54LnNjYWxlO1xuICAgICAgICAgICAgdHJlZVNjYWxlLnkgKj0gZGVsdGEueS5zY2FsZTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVhY2ggYW5jZXN0b3IncyBjYWxjdWxhdGVkIGRlbHRhIGludG8gdGhpcyBjb21wb25lbnQncyByZWNvcmRlZCBsYXlvdXQgYm94XG4gICAgICAgICAgICBhcHBseUJveERlbHRhKGJveCwgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gJiYgaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNsYXRlQXhpcyhheGlzLCBkaXN0YW5jZSkge1xuICAgIGF4aXMubWluID0gYXhpcy5taW4gKyBkaXN0YW5jZTtcbiAgICBheGlzLm1heCA9IGF4aXMubWF4ICsgZGlzdGFuY2U7XG59XG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIHRvIGFuIGF4aXMgZnJvbSB0aGUgbGF0ZXN0IHJlc29sdmVkIG1vdGlvbiB2YWx1ZXMuXG4gKiBUaGlzIGZ1bmN0aW9uIGJhc2ljYWxseSBhY3RzIGFzIGEgYnJpZGdlIGJldHdlZW4gYSBmbGF0IG1vdGlvbiB2YWx1ZSBtYXBcbiAqIGFuZCBhcHBseUF4aXNEZWx0YVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1BeGlzKGF4aXMsIHRyYW5zZm9ybXMsIF9hKSB7XG4gICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwga2V5ID0gX2JbMF0sIHNjYWxlS2V5ID0gX2JbMV0sIG9yaWdpbktleSA9IF9iWzJdO1xuICAgIHZhciBheGlzT3JpZ2luID0gdHJhbnNmb3Jtc1tvcmlnaW5LZXldICE9PSB1bmRlZmluZWQgPyB0cmFuc2Zvcm1zW29yaWdpbktleV0gOiAwLjU7XG4gICAgdmFyIG9yaWdpblBvaW50ID0gbWl4KGF4aXMubWluLCBheGlzLm1heCwgYXhpc09yaWdpbik7XG4gICAgLy8gQXBwbHkgdGhlIGF4aXMgZGVsdGEgdG8gdGhlIGZpbmFsIGF4aXNcbiAgICBhcHBseUF4aXNEZWx0YShheGlzLCB0cmFuc2Zvcm1zW2tleV0sIHRyYW5zZm9ybXNbc2NhbGVLZXldLCBvcmlnaW5Qb2ludCwgdHJhbnNmb3Jtcy5zY2FsZSk7XG59XG4vKipcbiAqIFRoZSBuYW1lcyBvZiB0aGUgbW90aW9uIHZhbHVlcyB3ZSB3YW50IHRvIGFwcGx5IGFzIHRyYW5zbGF0aW9uLCBzY2FsZSBhbmQgb3JpZ2luLlxuICovXG52YXIgeEtleXMgPSBbXCJ4XCIsIFwic2NhbGVYXCIsIFwib3JpZ2luWFwiXTtcbnZhciB5S2V5cyA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuLyoqXG4gKiBBcHBseSBhIHRyYW5zZm9ybSB0byBhIGJveCBmcm9tIHRoZSBsYXRlc3QgcmVzb2x2ZWQgbW90aW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQm94KGJveCwgdHJhbnNmb3JtKSB7XG4gICAgdHJhbnNmb3JtQXhpcyhib3gueCwgdHJhbnNmb3JtLCB4S2V5cyk7XG4gICAgdHJhbnNmb3JtQXhpcyhib3gueSwgdHJhbnNmb3JtLCB5S2V5cyk7XG59XG5cbmV4cG9ydCB7IGFwcGx5QXhpc0RlbHRhLCBhcHBseUJveERlbHRhLCBhcHBseVBvaW50RGVsdGEsIGFwcGx5VHJlZURlbHRhcywgc2NhbGVQb2ludCwgdHJhbnNmb3JtQXhpcywgdHJhbnNmb3JtQm94LCB0cmFuc2xhdGVBeGlzIH07XG4iLCAiZnVuY3Rpb24gaXNJZGVudGl0eVNjYWxlKHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlID09PSB1bmRlZmluZWQgfHwgc2NhbGUgPT09IDE7XG59XG5mdW5jdGlvbiBoYXNTY2FsZShfYSkge1xuICAgIHZhciBzY2FsZSA9IF9hLnNjYWxlLCBzY2FsZVggPSBfYS5zY2FsZVgsIHNjYWxlWSA9IF9hLnNjYWxlWTtcbiAgICByZXR1cm4gKCFpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVYKSB8fFxuICAgICAgICAhaXNJZGVudGl0eVNjYWxlKHNjYWxlWSkpO1xufVxuZnVuY3Rpb24gaGFzVHJhbnNmb3JtKHZhbHVlcykge1xuICAgIHJldHVybiAoaGFzU2NhbGUodmFsdWVzKSB8fFxuICAgICAgICBoYXNUcmFuc2xhdGUodmFsdWVzLngpIHx8XG4gICAgICAgIGhhc1RyYW5zbGF0ZSh2YWx1ZXMueSkgfHxcbiAgICAgICAgdmFsdWVzLnogfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZSB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlWCB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlWSk7XG59XG5mdW5jdGlvbiBoYXNUcmFuc2xhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUgIT09IFwiMCVcIjtcbn1cblxuZXhwb3J0IHsgaGFzU2NhbGUsIGhhc1RyYW5zZm9ybSB9O1xuIiwgImltcG9ydCB7IG1peCwgZGlzdGFuY2UgfSBmcm9tICdwb3Btb3Rpb24nO1xuXG5mdW5jdGlvbiBjYWxjTGVuZ3RoKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcy5tYXggLSBheGlzLm1pbjtcbn1cbmZ1bmN0aW9uIGlzTmVhcih2YWx1ZSwgdGFyZ2V0LCBtYXhEaXN0YW5jZSkge1xuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSAwOyB9XG4gICAgaWYgKG1heERpc3RhbmNlID09PSB2b2lkIDApIHsgbWF4RGlzdGFuY2UgPSAwLjAxOyB9XG4gICAgcmV0dXJuIGRpc3RhbmNlKHZhbHVlLCB0YXJnZXQpIDwgbWF4RGlzdGFuY2U7XG59XG5mdW5jdGlvbiBjYWxjQXhpc0RlbHRhKGRlbHRhLCBzb3VyY2UsIHRhcmdldCwgb3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gdm9pZCAwKSB7IG9yaWdpbiA9IDAuNTsgfVxuICAgIGRlbHRhLm9yaWdpbiA9IG9yaWdpbjtcbiAgICBkZWx0YS5vcmlnaW5Qb2ludCA9IG1peChzb3VyY2UubWluLCBzb3VyY2UubWF4LCBkZWx0YS5vcmlnaW4pO1xuICAgIGRlbHRhLnNjYWxlID0gY2FsY0xlbmd0aCh0YXJnZXQpIC8gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIGlmIChpc05lYXIoZGVsdGEuc2NhbGUsIDEsIDAuMDAwMSkgfHwgaXNOYU4oZGVsdGEuc2NhbGUpKVxuICAgICAgICBkZWx0YS5zY2FsZSA9IDE7XG4gICAgZGVsdGEudHJhbnNsYXRlID1cbiAgICAgICAgbWl4KHRhcmdldC5taW4sIHRhcmdldC5tYXgsIGRlbHRhLm9yaWdpbikgLSBkZWx0YS5vcmlnaW5Qb2ludDtcbiAgICBpZiAoaXNOZWFyKGRlbHRhLnRyYW5zbGF0ZSkgfHwgaXNOYU4oZGVsdGEudHJhbnNsYXRlKSlcbiAgICAgICAgZGVsdGEudHJhbnNsYXRlID0gMDtcbn1cbmZ1bmN0aW9uIGNhbGNCb3hEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbikge1xuICAgIGNhbGNBeGlzRGVsdGEoZGVsdGEueCwgc291cmNlLngsIHRhcmdldC54LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWCk7XG4gICAgY2FsY0F4aXNEZWx0YShkZWx0YS55LCBzb3VyY2UueSwgdGFyZ2V0LnksIG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbi5vcmlnaW5ZKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gICAgdGFyZ2V0Lm1pbiA9IHBhcmVudC5taW4gKyByZWxhdGl2ZS5taW47XG4gICAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKHJlbGF0aXZlKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUJveCh0YXJnZXQsIHJlbGF0aXZlLCBwYXJlbnQpIHtcbiAgICBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldC54LCByZWxhdGl2ZS54LCBwYXJlbnQueCk7XG4gICAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueSwgcmVsYXRpdmUueSwgcGFyZW50LnkpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldCwgbGF5b3V0LCBwYXJlbnQpIHtcbiAgICB0YXJnZXQubWluID0gbGF5b3V0Lm1pbiAtIHBhcmVudC5taW47XG4gICAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKGxheW91dCk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gICAgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldC54LCBsYXlvdXQueCwgcGFyZW50LngpO1xuICAgIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueSwgbGF5b3V0LnksIHBhcmVudC55KTtcbn1cblxuZXhwb3J0IHsgY2FsY0F4aXNEZWx0YSwgY2FsY0JveERlbHRhLCBjYWxjTGVuZ3RoLCBjYWxjUmVsYXRpdmVBeGlzLCBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24sIGNhbGNSZWxhdGl2ZUJveCwgY2FsY1JlbGF0aXZlUG9zaXRpb24sIGlzTmVhciB9O1xuIiwgImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IG1peCB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgeyBwZXJjZW50IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgc2NhbGVQb2ludCB9IGZyb20gJy4vZGVsdGEtYXBwbHkubWpzJztcblxuLyoqXG4gKiBSZW1vdmUgYSBkZWx0YSBmcm9tIGEgcG9pbnQuIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5UG9pbnREZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVBvaW50RGVsdGEocG9pbnQsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIHBvaW50IC09IHRyYW5zbGF0ZTtcbiAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBzY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIGlmIChib3hTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50ID0gc2NhbGVQb2ludChwb2ludCwgMSAvIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhbiBheGlzLiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNEZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW4sIGJveFNjYWxlLCBvcmlnaW5BeGlzLCBzb3VyY2VBeGlzKSB7XG4gICAgaWYgKHRyYW5zbGF0ZSA9PT0gdm9pZCAwKSB7IHRyYW5zbGF0ZSA9IDA7IH1cbiAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cbiAgICBpZiAob3JpZ2luID09PSB2b2lkIDApIHsgb3JpZ2luID0gMC41OyB9XG4gICAgaWYgKG9yaWdpbkF4aXMgPT09IHZvaWQgMCkgeyBvcmlnaW5BeGlzID0gYXhpczsgfVxuICAgIGlmIChzb3VyY2VBeGlzID09PSB2b2lkIDApIHsgc291cmNlQXhpcyA9IGF4aXM7IH1cbiAgICBpZiAocGVyY2VudC50ZXN0KHRyYW5zbGF0ZSkpIHtcbiAgICAgICAgdHJhbnNsYXRlID0gcGFyc2VGbG9hdCh0cmFuc2xhdGUpO1xuICAgICAgICB2YXIgcmVsYXRpdmVQcm9ncmVzcyA9IG1peChzb3VyY2VBeGlzLm1pbiwgc291cmNlQXhpcy5tYXgsIHRyYW5zbGF0ZSAvIDEwMCk7XG4gICAgICAgIHRyYW5zbGF0ZSA9IHJlbGF0aXZlUHJvZ3Jlc3MgLSBzb3VyY2VBeGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2xhdGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgb3JpZ2luUG9pbnQgPSBtaXgob3JpZ2luQXhpcy5taW4sIG9yaWdpbkF4aXMubWF4LCBvcmlnaW4pO1xuICAgIGlmIChheGlzID09PSBvcmlnaW5BeGlzKVxuICAgICAgICBvcmlnaW5Qb2ludCAtPSB0cmFuc2xhdGU7XG4gICAgYXhpcy5taW4gPSByZW1vdmVQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICAgIGF4aXMubWF4ID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogUmVtb3ZlIGEgdHJhbnNmb3JtcyBmcm9tIGFuIGF4aXMuIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5QXhpc1RyYW5zZm9ybXMgaW4gcmV2ZXJzZVxuICogYW5kIGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBtb3Rpb24gdmFsdWVzIGFuZCByZW1vdmVBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYXhpcywgdHJhbnNmb3JtcywgX2EsIG9yaWdpbiwgc291cmNlQXhpcykge1xuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMyksIGtleSA9IF9iWzBdLCBzY2FsZUtleSA9IF9iWzFdLCBvcmlnaW5LZXkgPSBfYlsyXTtcbiAgICByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgdHJhbnNmb3Jtc1tvcmlnaW5LZXldLCB0cmFuc2Zvcm1zLnNjYWxlLCBvcmlnaW4sIHNvdXJjZUF4aXMpO1xufVxuLyoqXG4gKiBUaGUgbmFtZXMgb2YgdGhlIG1vdGlvbiB2YWx1ZXMgd2Ugd2FudCB0byBhcHBseSBhcyB0cmFuc2xhdGlvbiwgc2NhbGUgYW5kIG9yaWdpbi5cbiAqL1xudmFyIHhLZXlzID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG52YXIgeUtleXMgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbi8qKlxuICogUmVtb3ZlIGEgdHJhbnNmb3JtcyBmcm9tIGFuIGJveC4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzQm94IGluIHJldmVyc2VcbiAqIGFuZCBhY3RzIGFzIGEgYnJpZGdlIGJldHdlZW4gbW90aW9uIHZhbHVlcyBhbmQgcmVtb3ZlQXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94LCB0cmFuc2Zvcm1zLCBvcmlnaW5Cb3gsIHNvdXJjZUJveCkge1xuICAgIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC54LCB0cmFuc2Zvcm1zLCB4S2V5cywgb3JpZ2luQm94ID09PSBudWxsIHx8IG9yaWdpbkJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luQm94LngsIHNvdXJjZUJveCA9PT0gbnVsbCB8fCBzb3VyY2VCb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZUJveC54KTtcbiAgICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueSwgdHJhbnNmb3JtcywgeUtleXMsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC55LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueSk7XG59XG5cbmV4cG9ydCB7IHJlbW92ZUF4aXNEZWx0YSwgcmVtb3ZlQXhpc1RyYW5zZm9ybXMsIHJlbW92ZUJveFRyYW5zZm9ybXMsIHJlbW92ZVBvaW50RGVsdGEgfTtcbiIsICJ2YXIgY3JlYXRlQXhpc0RlbHRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICB0cmFuc2xhdGU6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgb3JpZ2luOiAwLFxuICAgIG9yaWdpblBvaW50OiAwLFxufSk7IH07XG52YXIgY3JlYXRlRGVsdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHg6IGNyZWF0ZUF4aXNEZWx0YSgpLFxuICAgIHk6IGNyZWF0ZUF4aXNEZWx0YSgpLFxufSk7IH07XG52YXIgY3JlYXRlQXhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IG1pbjogMCwgbWF4OiAwIH0pOyB9O1xudmFyIGNyZWF0ZUJveCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgeDogY3JlYXRlQXhpcygpLFxuICAgIHk6IGNyZWF0ZUF4aXMoKSxcbn0pOyB9O1xuXG5leHBvcnQgeyBjcmVhdGVBeGlzLCBjcmVhdGVBeGlzRGVsdGEsIGNyZWF0ZUJveCwgY3JlYXRlRGVsdGEgfTtcbiIsICJmdW5jdGlvbiBpc0F4aXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gZGVsdGEudHJhbnNsYXRlID09PSAwICYmIGRlbHRhLnNjYWxlID09PSAxO1xufVxuZnVuY3Rpb24gaXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gaXNBeGlzRGVsdGFaZXJvKGRlbHRhLngpICYmIGlzQXhpc0RlbHRhWmVybyhkZWx0YS55KTtcbn1cbmZ1bmN0aW9uIGJveEVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIChhLngubWluID09PSBiLngubWluICYmXG4gICAgICAgIGEueC5tYXggPT09IGIueC5tYXggJiZcbiAgICAgICAgYS55Lm1pbiA9PT0gYi55Lm1pbiAmJlxuICAgICAgICBhLnkubWF4ID09PSBiLnkubWF4KTtcbn1cblxuZXhwb3J0IHsgYm94RXF1YWxzLCBpc0RlbHRhWmVybyB9O1xuIiwgImltcG9ydCB7IGFkZFVuaXF1ZUl0ZW0sIHJlbW92ZUl0ZW0gfSBmcm9tICcuLi8uLi91dGlscy9hcnJheS5tanMnO1xuXG52YXIgTm9kZVN0YWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVTdGFjaygpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgfVxuICAgIE5vZGVTdGFjay5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgYWRkVW5pcXVlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgICAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfTtcbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMucHJldkxlYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkxlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVhZCkge1xuICAgICAgICAgICAgdmFyIHByZXZMZWFkID0gdGhpcy5tZW1iZXJzW3RoaXMubWVtYmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbW90ZShwcmV2TGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUucmVsZWdhdGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaW5kZXhPZk5vZGUgPSB0aGlzLm1lbWJlcnMuZmluZEluZGV4KGZ1bmN0aW9uIChtZW1iZXIpIHsgcmV0dXJuIG5vZGUgPT09IG1lbWJlcjsgfSk7XG4gICAgICAgIGlmIChpbmRleE9mTm9kZSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIG5leHQgcHJvamVjdGlvbiBub2RlIHRoYXQgaXMgcHJlc2VudFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHByZXZMZWFkO1xuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhPZk5vZGU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5tZW1iZXJzW2ldO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5pc1ByZXNlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldkxlYWQgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGUocHJldkxlYWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUucHJvbW90ZSA9IGZ1bmN0aW9uIChub2RlLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcHJldkxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIGlmIChub2RlID09PSBwcmV2TGVhZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wcmV2TGVhZCA9IHByZXZMZWFkO1xuICAgICAgICB0aGlzLmxlYWQgPSBub2RlO1xuICAgICAgICBub2RlLnNob3coKTtcbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICBwcmV2TGVhZC5pbnN0YW5jZSAmJiBwcmV2TGVhZC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tID0gcHJldkxlYWQ7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkxlYWQuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNuYXBzaG90ID0gcHJldkxlYWQuc25hcHNob3Q7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdC5sYXRlc3RWYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICBwcmV2TGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgcHJldkxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgICAgIG5vZGUuc25hcHNob3QuaXNTaGFyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IG5vZGUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBub2RlLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNyb3NzZmFkZSA9IG5vZGUub3B0aW9ucy5jcm9zc2ZhZGU7XG4gICAgICAgICAgICBpZiAoY3Jvc3NmYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXZMZWFkLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVE9ETzpcbiAgICAgICAgICAgICAqICAgLSBUZXN0IGJvcmRlciByYWRpdXMgd2hlbiBwcmV2aW91cyBub2RlIHdhcyBkZWxldGVkXG4gICAgICAgICAgICAgKiAgIC0gYm94U2hhZG93IG1peGluZ1xuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiBzY3JvbGxlZCBjb250YWluZXIgYW5kIGVsZW1lbnQgQiAoc2Nyb2xsIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHRyYW5zZm9ybWVkIGNvbnRhaW5lciBhbmQgZWxlbWVudCBCICh0cmFuc2Zvcm0gc3RheXMgdGhlIHNhbWUgb3IgY2hhbmdlcylcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gc2Nyb2xsZWQgcGFnZSBhbmQgZWxlbWVudCBCIChzY3JvbGwgc3RheXMgdGhlIHNhbWUgb3IgY2hhbmdlcylcbiAgICAgICAgICAgICAqIC0tLVxuICAgICAgICAgICAgICogICAtIENyb3NzZmFkZSBvcGFjaXR5IG9mIHJvb3Qgbm9kZXNcbiAgICAgICAgICAgICAqICAgLSBsYXlvdXRJZCBjaGFuZ2VzIGFmdGVyIGFuaW1hdGlvblxuICAgICAgICAgICAgICogICAtIGxheW91dElkIGNoYW5nZXMgbWlkIGFuaW1hdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUuZXhpdEFuaW1hdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IG5vZGUub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIChfZSA9IChfYyA9IG5vZGUucmVzdW1pbmdGcm9tKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9kID0gX2Mub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLnNjaGVkdWxlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5pbnN0YW5jZSAmJiBub2RlLnNjaGVkdWxlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciBhbnkgbGVhZHMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCB0aGlzIHJlbmRlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZ1xuICAgICAqIHVzZWQgaW4gZnV0dXJlIGFuaW1hdGlvbnMgYW5kIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICovXG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5yZW1vdmVMZWFkU25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlYWQgJiYgdGhpcy5sZWFkLnNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmxlYWQuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOb2RlU3RhY2s7XG59KCkpO1xuXG5leHBvcnQgeyBOb2RlU3RhY2sgfTtcbiIsICJ2YXIgc2NhbGVDb3JyZWN0b3JzID0ge307XG5mdW5jdGlvbiBhZGRTY2FsZUNvcnJlY3Rvcihjb3JyZWN0b3JzKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzY2FsZUNvcnJlY3RvcnMsIGNvcnJlY3RvcnMpO1xufVxuXG5leHBvcnQgeyBhZGRTY2FsZUNvcnJlY3Rvciwgc2NhbGVDb3JyZWN0b3JzIH07XG4iLCAidmFyIGlkZW50aXR5UHJvamVjdGlvbiA9IFwidHJhbnNsYXRlM2QoMHB4LCAwcHgsIDApIHNjYWxlKDEsIDEpXCI7XG5mdW5jdGlvbiBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0oZGVsdGEsIHRyZWVTY2FsZSwgbGF0ZXN0VHJhbnNmb3JtKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zbGF0aW9ucyB3ZSB1c2UgdG8gY2FsY3VsYXRlIGFyZSBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQnV0IHdoZW4gd2UgYXBwbHkgc2NhbGVzLCB3ZSBhbHNvIHNjYWxlIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIGFuIGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgKiBGb3IgaW5zdGFuY2UgaWYgd2UgaGF2ZSBhIHRyZWVTY2FsZSAodGhlIGN1bG1pbmF0aW9uIG9mIGFsbCBwYXJlbnQgc2NhbGVzKSBvZiAwLjUgYW5kIHdlIG5lZWRcbiAgICAgKiB0byBtb3ZlIGFuIGVsZW1lbnQgMTAwIHBpeGVscywgd2UgYWN0dWFsbHkgbmVlZCB0byBtb3ZlIGl0IDIwMCBpbiB3aXRoaW4gdGhhdCBzY2FsZWQgc3BhY2UuXG4gICAgICovXG4gICAgdmFyIHhUcmFuc2xhdGUgPSBkZWx0YS54LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS54O1xuICAgIHZhciB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQoeFRyYW5zbGF0ZSwgXCJweCwgXCIpLmNvbmNhdCh5VHJhbnNsYXRlLCBcInB4LCAwKSBcIik7XG4gICAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgcm90YXRlID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZSwgcm90YXRlWCA9IGxhdGVzdFRyYW5zZm9ybS5yb3RhdGVYLCByb3RhdGVZID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZVk7XG4gICAgICAgIGlmIChyb3RhdGUpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZSwgXCJkZWcpIFwiKTtcbiAgICAgICAgaWYgKHJvdGF0ZVgpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gXCJyb3RhdGVYKFwiLmNvbmNhdChyb3RhdGVYLCBcImRlZykgXCIpO1xuICAgICAgICBpZiAocm90YXRlWSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBcInJvdGF0ZVkoXCIuY29uY2F0KHJvdGF0ZVksIFwiZGVnKSBcIik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSArPSBcInNjYWxlKFwiLmNvbmNhdChkZWx0YS54LnNjYWxlLCBcIiwgXCIpLmNvbmNhdChkZWx0YS55LnNjYWxlLCBcIilcIik7XG4gICAgcmV0dXJuIHRyYW5zZm9ybSA9PT0gaWRlbnRpdHlQcm9qZWN0aW9uID8gXCJub25lXCIgOiB0cmFuc2Zvcm07XG59XG5cbmV4cG9ydCB7IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSwgaWRlbnRpdHlQcm9qZWN0aW9uIH07XG4iLCAiZnVuY3Rpb24gZWFjaEF4aXMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gW2NhbGxiYWNrKFwieFwiKSwgY2FsbGJhY2soXCJ5XCIpXTtcbn1cblxuZXhwb3J0IHsgZWFjaEF4aXMgfTtcbiIsICIvKipcbiAqIEEgbGlzdCBvZiBhbGwgdHJhbnNmb3JtYWJsZSBheGVzLiBXZSdsbCB1c2UgdGhpcyBsaXN0IHRvIGdlbmVyYXRlZCBhIHZlcnNpb25cbiAqIG9mIGVhY2ggYXhlcyBmb3IgZWFjaCB0cmFuc2Zvcm0uXG4gKi9cbnZhciB0cmFuc2Zvcm1BeGVzID0gW1wiXCIsIFwiWFwiLCBcIllcIiwgXCJaXCJdO1xuLyoqXG4gKiBBbiBvcmRlcmVkIGFycmF5IG9mIGVhY2ggdHJhbnNmb3JtYWJsZSB2YWx1ZS4gQnkgZGVmYXVsdCwgdHJhbnNmb3JtIHZhbHVlc1xuICogd2lsbCBiZSBzb3J0ZWQgdG8gdGhpcyBvcmRlci5cbiAqL1xudmFyIG9yZGVyID0gW1widHJhbnNsYXRlXCIsIFwic2NhbGVcIiwgXCJyb3RhdGVcIiwgXCJza2V3XCJdO1xuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgZXZlcnkgcG9zc2libGUgdHJhbnNmb3JtIGtleS5cbiAqL1xudmFyIHRyYW5zZm9ybVByb3BzID0gW1widHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCJ4XCIsIFwieVwiLCBcInpcIl07XG5vcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChvcGVyYXRpb25LZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtQXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGVzS2V5KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wcy5wdXNoKG9wZXJhdGlvbktleSArIGF4ZXNLZXkpO1xuICAgIH0pO1xufSk7XG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gdXNlIHdpdGggQXJyYXkuc29ydCB0byBzb3J0IHRyYW5zZm9ybSBrZXlzIGJ5IHRoZWlyIGRlZmF1bHQgb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHNvcnRUcmFuc2Zvcm1Qcm9wcyhhLCBiKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVByb3BzLmluZGV4T2YoYSkgLSB0cmFuc2Zvcm1Qcm9wcy5pbmRleE9mKGIpO1xufVxuLyoqXG4gKiBBIHF1aWNrIGxvb2t1cCBmb3IgdHJhbnNmb3JtIHByb3BzLlxuICovXG52YXIgdHJhbnNmb3JtUHJvcFNldCA9IG5ldyBTZXQodHJhbnNmb3JtUHJvcHMpO1xuZnVuY3Rpb24gaXNUcmFuc2Zvcm1Qcm9wKGtleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wU2V0LmhhcyhrZXkpO1xufVxuLyoqXG4gKiBBIHF1aWNrIGxvb2t1cCBmb3IgdHJhbnNmb3JtIG9yaWdpbiBwcm9wc1xuICovXG52YXIgdHJhbnNmb3JtT3JpZ2luUHJvcHMgPSBuZXcgU2V0KFtcIm9yaWdpblhcIiwgXCJvcmlnaW5ZXCIsIFwib3JpZ2luWlwiXSk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpblByb3BzLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgeyBpc1RyYW5zZm9ybU9yaWdpblByb3AsIGlzVHJhbnNmb3JtUHJvcCwgc29ydFRyYW5zZm9ybVByb3BzLCB0cmFuc2Zvcm1BeGVzLCB0cmFuc2Zvcm1Qcm9wcyB9O1xuIiwgImltcG9ydCB7IGFkZFVuaXF1ZUl0ZW0sIHJlbW92ZUl0ZW0gfSBmcm9tICcuLi8uLi91dGlscy9hcnJheS5tanMnO1xuaW1wb3J0IHsgY29tcGFyZUJ5RGVwdGggfSBmcm9tICcuL2NvbXBhcmUtYnktZGVwdGgubWpzJztcblxudmFyIEZsYXRUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZsYXRUcmVlKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICBGbGF0VHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH07XG4gICAgRmxhdFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZW1vdmVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuICAgIEZsYXRUcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSAmJiB0aGlzLmNoaWxkcmVuLnNvcnQoY29tcGFyZUJ5RGVwdGgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBGbGF0VHJlZTtcbn0oKSk7XG5cbmV4cG9ydCB7IEZsYXRUcmVlIH07XG4iLCAidmFyIGNvbXBhcmVCeURlcHRoID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5kZXB0aCAtIGIuZGVwdGg7XG59O1xuXG5leHBvcnQgeyBjb21wYXJlQnlEZXB0aCB9O1xuIiwgImltcG9ydCB7IGlzQ3VzdG9tVmFsdWUgfSBmcm9tICcuLi8uLi91dGlscy9yZXNvbHZlLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi9pcy1tb3Rpb24tdmFsdWUubWpzJztcblxuLyoqXG4gKiBJZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBNb3Rpb25WYWx1ZSwgdGhpcyByZXR1cm5zIHRoZSBhY3R1YWwgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHRoZSB2YWx1ZSBpdHNlbGZcbiAqXG4gKiBUT0RPOiBSZW1vdmUgYW5kIG1vdmUgdG8gbGlicmFyeVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZXNvbHZlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgdW53cmFwcGVkVmFsdWUgPSBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlLmdldCgpIDogdmFsdWU7XG4gICAgcmV0dXJuIGlzQ3VzdG9tVmFsdWUodW53cmFwcGVkVmFsdWUpXG4gICAgICAgID8gdW53cmFwcGVkVmFsdWUudG9WYWx1ZSgpXG4gICAgICAgIDogdW53cmFwcGVkVmFsdWU7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVNb3Rpb25WYWx1ZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBMYXlvdXRHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcblxuZXhwb3J0IHsgTGF5b3V0R3JvdXBDb250ZXh0IH07XG4iLCAiaW1wb3J0IHsgaXNSZWZPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscy9pcy1yZWYtb2JqZWN0Lm1qcyc7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9Td2l0Y2hMYXlvdXRHcm91cENvbnRleHQubWpzJztcblxuZnVuY3Rpb24gdXNlUHJvamVjdGlvbihwcm9qZWN0aW9uSWQsIF9hLCB2aXN1YWxFbGVtZW50LCBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciBsYXlvdXRJZCA9IF9hLmxheW91dElkLCBsYXlvdXQgPSBfYS5sYXlvdXQsIGRyYWcgPSBfYS5kcmFnLCBkcmFnQ29uc3RyYWludHMgPSBfYS5kcmFnQ29uc3RyYWludHMsIGxheW91dFNjcm9sbCA9IF9hLmxheW91dFNjcm9sbDtcbiAgICB2YXIgaW5pdGlhbFByb21vdGlvbkNvbmZpZyA9IHVzZUNvbnRleHQoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICBpZiAoIVByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgfHxcbiAgICAgICAgIXZpc3VhbEVsZW1lbnQgfHxcbiAgICAgICAgKHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiA9IG5ldyBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKHByb2plY3Rpb25JZCwgdmlzdWFsRWxlbWVudC5nZXRMYXRlc3RWYWx1ZXMoKSwgKF9iID0gdmlzdWFsRWxlbWVudC5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wcm9qZWN0aW9uKTtcbiAgICB2aXN1YWxFbGVtZW50LnByb2plY3Rpb24uc2V0T3B0aW9ucyh7XG4gICAgICAgIGxheW91dElkOiBsYXlvdXRJZCxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIGFsd2F5c01lYXN1cmVMYXlvdXQ6IEJvb2xlYW4oZHJhZykgfHwgKGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSxcbiAgICAgICAgdmlzdWFsRWxlbWVudDogdmlzdWFsRWxlbWVudCxcbiAgICAgICAgc2NoZWR1bGVSZW5kZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZpc3VhbEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFVwZGF0ZSBvcHRpb25zIGluIGFuIGVmZmVjdC4gVGhpcyBjb3VsZCBiZSB0cmlja3kgYXMgaXQnbGwgYmUgdG9vIGxhdGVcbiAgICAgICAgICogdG8gdXBkYXRlIGJ5IHRoZSB0aW1lIGxheW91dCBhbmltYXRpb25zIHJ1bi5cbiAgICAgICAgICogV2UgYWxzbyBuZWVkIHRvIGZpeCB0aGlzIHNhZmVUb1JlbW92ZSBieSBsaW5raW5nIGl0IHVwIHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkgdXNlUHJlc2VuY2UsXG4gICAgICAgICAqIGVuc3VyaW5nIGl0IGdldHMgY2FsbGVkIGlmIHRoZXJlJ3Mgbm8gcG90ZW50aWFsIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uVHlwZTogdHlwZW9mIGxheW91dCA9PT0gXCJzdHJpbmdcIiA/IGxheW91dCA6IFwiYm90aFwiLFxuICAgICAgICBpbml0aWFsUHJvbW90aW9uQ29uZmlnOiBpbml0aWFsUHJvbW90aW9uQ29uZmlnLFxuICAgICAgICBsYXlvdXRTY3JvbGw6IGxheW91dFNjcm9sbCxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgdXNlUHJvamVjdGlvbiB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcblxuZXhwb3J0IHsgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IH07XG4iLCAiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0IGZyb20gJ3JlYWN0JztcblxudmFyIFZpc3VhbEVsZW1lbnRIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaXN1YWxFbGVtZW50SGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaXN1YWxFbGVtZW50SGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdmlzdWFsIGVsZW1lbnQgcHJvcHMgYXMgc29vbiBhcyB3ZSBrbm93IHRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdGVkLlxuICAgICAqL1xuICAgIFZpc3VhbEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9wcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVmlzdWFsRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgcHJvcHMgPSBfYS5wcm9wcztcbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNldFByb3BzKHByb3BzKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIFZpc3VhbEVsZW1lbnRIYW5kbGVyO1xufShSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQpKTtcblxuZXhwb3J0IHsgVmlzdWFsRWxlbWVudEhhbmRsZXIgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVNb3Rpb25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9tb3Rpb24vaW5kZXgubWpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGFueSBSZWFjdCBjb21wb25lbnQgaW50byBhIGBtb3Rpb25gIGNvbXBvbmVudC4gVGhlIHByb3ZpZGVkIGNvbXBvbmVudFxuICogKiptdXN0KiogdXNlIGBSZWFjdC5mb3J3YXJkUmVmYCB0byB0aGUgdW5kZXJseWluZyBET00gY29tcG9uZW50IHlvdSB3YW50IHRvIGFuaW1hdGUuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gKiAgIHJldHVybiA8ZGl2IHJlZj17cmVmfSAvPlxuICogfSlcbiAqXG4gKiBjb25zdCBNb3Rpb25Db21wb25lbnQgPSBtb3Rpb24oQ29tcG9uZW50KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVNb3Rpb25Qcm94eShjcmVhdGVDb25maWcpIHtcbiAgICBmdW5jdGlvbiBjdXN0b20oQ29tcG9uZW50LCBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcpIHtcbiAgICAgICAgaWYgKGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZyA9PT0gdm9pZCAwKSB7IGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBjcmVhdGVNb3Rpb25Db21wb25lbnQoY3JlYXRlQ29uZmlnKENvbXBvbmVudCwgY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiBnZW5lcmF0ZWQgYG1vdGlvbmAgY29tcG9uZW50cywgZS5nIGBtb3Rpb24uZGl2YCwgYG1vdGlvbi5pbnB1dGAgZXRjLlxuICAgICAqIFJhdGhlciB0aGFuIGdlbmVyYXRpbmcgdGhlbSBhbmV3IGV2ZXJ5IHJlbmRlci5cbiAgICAgKi9cbiAgICB2YXIgY29tcG9uZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIG5ldyBQcm94eShjdXN0b20sIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGBtb3Rpb25gIGlzIHJlZmVyZW5jZWQgd2l0aCBhIHByb3A6IGBtb3Rpb24uZGl2YCwgYG1vdGlvbi5pbnB1dGAgZXRjLlxuICAgICAgICAgKiBUaGUgcHJvcCBuYW1lIGlzIHBhc3NlZCB0aHJvdWdoIGFzIGBrZXlgIGFuZCB3ZSBjYW4gdXNlIHRoYXQgdG8gZ2VuZXJhdGUgYSBgbW90aW9uYFxuICAgICAgICAgKiBET00gY29tcG9uZW50IHdpdGggdGhhdCBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoX3RhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgZWxlbWVudCBkb2Vzbid0IGV4aXN0IGluIHRoZSBjb21wb25lbnQgY2FjaGUsIGNyZWF0ZSBpdCBhbmQgY2FjaGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Q2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDYWNoZS5zZXQoa2V5LCBjdXN0b20oa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Q2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU1vdGlvblByb3h5IH07XG4iLCAiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpc1NWR0NvbXBvbmVudCB9IGZyb20gJy4vaXMtc3ZnLWNvbXBvbmVudC5tanMnO1xuaW1wb3J0IHsgY3JlYXRlVXNlUmVuZGVyIH0gZnJvbSAnLi4vdXNlLXJlbmRlci5tanMnO1xuaW1wb3J0IHsgc3ZnTW90aW9uQ29uZmlnIH0gZnJvbSAnLi4vLi4vc3ZnL2NvbmZpZy1tb3Rpb24ubWpzJztcbmltcG9ydCB7IGh0bWxNb3Rpb25Db25maWcgfSBmcm9tICcuLi8uLi9odG1sL2NvbmZpZy1tb3Rpb24ubWpzJztcblxuZnVuY3Rpb24gY3JlYXRlRG9tTW90aW9uQ29uZmlnKENvbXBvbmVudCwgX2EsIHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIF9iID0gX2EuZm9yd2FyZE1vdGlvblByb3BzLCBmb3J3YXJkTW90aW9uUHJvcHMgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICB2YXIgYmFzZUNvbmZpZyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgPyBzdmdNb3Rpb25Db25maWdcbiAgICAgICAgOiBodG1sTW90aW9uQ29uZmlnO1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYmFzZUNvbmZpZyksIHsgcHJlbG9hZGVkRmVhdHVyZXM6IHByZWxvYWRlZEZlYXR1cmVzLCB1c2VSZW5kZXI6IGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMpLCBjcmVhdGVWaXN1YWxFbGVtZW50OiBjcmVhdGVWaXN1YWxFbGVtZW50LCBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yOiBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLCBDb21wb25lbnQ6IENvbXBvbmVudCB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRG9tTW90aW9uQ29uZmlnIH07XG4iLCAiaW1wb3J0IHsgbG93ZXJjYXNlU1ZHRWxlbWVudHMgfSBmcm9tICcuLi8uLi9zdmcvbG93ZXJjYXNlLWVsZW1lbnRzLm1qcyc7XG5cbmZ1bmN0aW9uIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIGlmIChcbiAgICAvKipcbiAgICAgKiBJZiBpdCdzIG5vdCBhIHN0cmluZywgaXQncyBhIGN1c3RvbSBSZWFjdCBjb21wb25lbnQuIEN1cnJlbnRseSB3ZSBvbmx5IHN1cHBvcnRcbiAgICAgKiBIVE1MIGN1c3RvbSBSZWFjdCBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHR5cGVvZiBDb21wb25lbnQgIT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGl0IGNvbnRhaW5zIGEgZGFzaCwgdGhlIGVsZW1lbnQgaXMgYSBjdXN0b20gSFRNTCB3ZWJjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBDb21wb25lbnQuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgLyoqXG4gICAgICogSWYgaXQncyBpbiBvdXIgbGlzdCBvZiBsb3dlcmNhc2UgU1ZHIHRhZ3MsIGl0J3MgYW4gU1ZHIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGxvd2VyY2FzZVNWR0VsZW1lbnRzLmluZGV4T2YoQ29tcG9uZW50KSA+IC0xIHx8XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBpdCBjb250YWlucyBhIGNhcGl0YWwgbGV0dGVyLCBpdCdzIGFuIFNWRyBjb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIC9bQS1aXS8udGVzdChDb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGlzU1ZHQ29tcG9uZW50IH07XG4iLCAiLyoqXG4gKiBXZSBrZWVwIHRoZXNlIGxpc3RlZCBzZXBlcmF0ZWx5IGFzIHdlIHVzZSB0aGUgbG93ZXJjYXNlIHRhZyBuYW1lcyBhcyBwYXJ0XG4gKiBvZiB0aGUgcnVudGltZSBidW5kbGUgdG8gZGV0ZWN0IFNWRyBjb21wb25lbnRzXG4gKi9cbnZhciBsb3dlcmNhc2VTVkdFbGVtZW50cyA9IFtcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImNpcmNsZVwiLFxuICAgIFwiZGVmc1wiLFxuICAgIFwiZGVzY1wiLFxuICAgIFwiZWxsaXBzZVwiLFxuICAgIFwiZ1wiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImxpbmVcIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwibWFya2VyXCIsXG4gICAgXCJtYXNrXCIsXG4gICAgXCJtZXRhZGF0YVwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwicG9seWdvblwiLFxuICAgIFwicG9seWxpbmVcIixcbiAgICBcInJlY3RcIixcbiAgICBcInN0b3BcIixcbiAgICBcInN2Z1wiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcInRleHRcIixcbiAgICBcInRzcGFuXCIsXG4gICAgXCJ1c2VcIixcbiAgICBcInZpZXdcIixcbl07XG5cbmV4cG9ydCB7IGxvd2VyY2FzZVNWR0VsZW1lbnRzIH07XG4iLCAiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlSFRNTFByb3BzIH0gZnJvbSAnLi4vaHRtbC91c2UtcHJvcHMubWpzJztcbmltcG9ydCB7IGZpbHRlclByb3BzIH0gZnJvbSAnLi91dGlscy9maWx0ZXItcHJvcHMubWpzJztcbmltcG9ydCB7IGlzU1ZHQ29tcG9uZW50IH0gZnJvbSAnLi91dGlscy9pcy1zdmctY29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgeyB1c2VTVkdQcm9wcyB9IGZyb20gJy4uL3N2Zy91c2UtcHJvcHMubWpzJztcblxuZnVuY3Rpb24gY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcykge1xuICAgIGlmIChmb3J3YXJkTW90aW9uUHJvcHMgPT09IHZvaWQgMCkgeyBmb3J3YXJkTW90aW9uUHJvcHMgPSBmYWxzZTsgfVxuICAgIHZhciB1c2VSZW5kZXIgPSBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCByZWYsIF9hLCBpc1N0YXRpYykge1xuICAgICAgICB2YXIgbGF0ZXN0VmFsdWVzID0gX2EubGF0ZXN0VmFsdWVzO1xuICAgICAgICB2YXIgdXNlVmlzdWFsUHJvcHMgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgICAgICA/IHVzZVNWR1Byb3BzXG4gICAgICAgICAgICA6IHVzZUhUTUxQcm9wcztcbiAgICAgICAgdmFyIHZpc3VhbFByb3BzID0gdXNlVmlzdWFsUHJvcHMocHJvcHMsIGxhdGVzdFZhbHVlcywgaXNTdGF0aWMpO1xuICAgICAgICB2YXIgZmlsdGVyZWRQcm9wcyA9IGZpbHRlclByb3BzKHByb3BzLCB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiLCBmb3J3YXJkTW90aW9uUHJvcHMpO1xuICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGZpbHRlcmVkUHJvcHMpLCB2aXN1YWxQcm9wcyksIHsgcmVmOiByZWYgfSk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRQcm9wc1tcImRhdGEtcHJvamVjdGlvbi1pZFwiXSA9IHByb2plY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnRQcm9wcyk7XG4gICAgfTtcbiAgICByZXR1cm4gdXNlUmVuZGVyO1xufVxuXG5leHBvcnQgeyBjcmVhdGVVc2VSZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0ZvcmNlZE1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vbW90aW9uL3V0aWxzL2lzLWZvcmNlZC1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtc3R5bGVzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUubWpzJztcblxuZnVuY3Rpb24gY29weVJhd1ZhbHVlc09ubHkodGFyZ2V0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoIWlzTW90aW9uVmFsdWUoc291cmNlW2tleV0pICYmICFpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgcHJvcHMpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdXNlSW5pdGlhbE1vdGlvblZhbHVlcyhfYSwgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlID0gX2EudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBjcmVhdGVIdG1sUmVuZGVyU3RhdGUoKTtcbiAgICAgICAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogIWlzU3RhdGljIH0sIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgdmFyIHZhcnMgPSBzdGF0ZS52YXJzLCBzdHlsZSA9IHN0YXRlLnN0eWxlO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHZhcnMpLCBzdHlsZSk7XG4gICAgfSwgW3Zpc3VhbFN0YXRlXSk7XG59XG5mdW5jdGlvbiB1c2VTdHlsZShwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gICAgdmFyIHN0eWxlUHJvcCA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICAgIHZhciBzdHlsZSA9IHt9O1xuICAgIC8qKlxuICAgICAqIENvcHkgbm9uLU1vdGlvbiBWYWx1ZXMgc3RyYWlnaHQgaW50byBzdHlsZVxuICAgICAqL1xuICAgIGNvcHlSYXdWYWx1ZXNPbmx5KHN0eWxlLCBzdHlsZVByb3AsIHByb3BzKTtcbiAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpKTtcbiAgICBpZiAocHJvcHMudHJhbnNmb3JtVmFsdWVzKSB7XG4gICAgICAgIHN0eWxlID0gcHJvcHMudHJhbnNmb3JtVmFsdWVzKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gdXNlSFRNTFByb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICAvLyBUaGUgYGFueWAgaXNuJ3QgaWRlYWwgYnV0IGl0IGlzIHRoZSB0eXBlIG9mIGNyZWF0ZUVsZW1lbnQgcHJvcHMgYXJndW1lbnRcbiAgICB2YXIgaHRtbFByb3BzID0ge307XG4gICAgdmFyIHN0eWxlID0gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYyk7XG4gICAgaWYgKEJvb2xlYW4ocHJvcHMuZHJhZykgJiYgcHJvcHMuZHJhZ0xpc3RlbmVyICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBnaG9zdCBlbGVtZW50IHdoZW4gYSB1c2VyIGRyYWdzXG4gICAgICAgIGh0bWxQcm9wcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgLy8gRGlzYWJsZSB0ZXh0IHNlbGVjdGlvblxuICAgICAgICBzdHlsZS51c2VyU2VsZWN0ID1cbiAgICAgICAgICAgIHN0eWxlLldlYmtpdFVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgICAgIHN0eWxlLldlYmtpdFRvdWNoQ2FsbG91dCA9XG4gICAgICAgICAgICAgICAgICAgIFwibm9uZVwiO1xuICAgICAgICAvLyBEaXNhYmxlIHNjcm9sbGluZyBvbiB0aGUgZHJhZ2dhYmxlIGRpcmVjdGlvblxuICAgICAgICBzdHlsZS50b3VjaEFjdGlvbiA9XG4gICAgICAgICAgICBwcm9wcy5kcmFnID09PSB0cnVlXG4gICAgICAgICAgICAgICAgPyBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIDogXCJwYW4tXCIuY29uY2F0KHByb3BzLmRyYWcgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIik7XG4gICAgfVxuICAgIGh0bWxQcm9wcy5zdHlsZSA9IHN0eWxlO1xuICAgIHJldHVybiBodG1sUHJvcHM7XG59XG5cbmV4cG9ydCB7IGNvcHlSYXdWYWx1ZXNPbmx5LCB1c2VIVE1MUHJvcHMsIHVzZVN0eWxlIH07XG4iLCAiaW1wb3J0IHsgc2NhbGVDb3JyZWN0b3JzIH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtY29ycmVjdGlvbi5tanMnO1xuaW1wb3J0IHsgaXNUcmFuc2Zvcm1Qcm9wLCBpc1RyYW5zZm9ybU9yaWdpblByb3AgfSBmcm9tICcuLi8uLi9yZW5kZXIvaHRtbC91dGlscy90cmFuc2Zvcm0ubWpzJztcblxuZnVuY3Rpb24gaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIF9hKSB7XG4gICAgdmFyIGxheW91dCA9IF9hLmxheW91dCwgbGF5b3V0SWQgPSBfYS5sYXlvdXRJZDtcbiAgICByZXR1cm4gKGlzVHJhbnNmb3JtUHJvcChrZXkpIHx8XG4gICAgICAgIGlzVHJhbnNmb3JtT3JpZ2luUHJvcChrZXkpIHx8XG4gICAgICAgICgobGF5b3V0IHx8IGxheW91dElkICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoISFzY2FsZUNvcnJlY3RvcnNba2V5XSB8fCBrZXkgPT09IFwib3BhY2l0eVwiKSkpO1xufVxuXG5leHBvcnQgeyBpc0ZvcmNlZE1vdGlvblZhbHVlIH07XG4iLCAiaW1wb3J0IHsgYnVpbGRUcmFuc2Zvcm0sIGJ1aWxkVHJhbnNmb3JtT3JpZ2luIH0gZnJvbSAnLi9idWlsZC10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGlzQ1NTVmFyaWFibGUgfSBmcm9tICcuLi8uLi9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5pbXBvcnQgeyBpc1RyYW5zZm9ybVByb3AsIGlzVHJhbnNmb3JtT3JpZ2luUHJvcCB9IGZyb20gJy4vdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZUFzVHlwZSB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9nZXQtYXMtdHlwZS5tanMnO1xuaW1wb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9udW1iZXIubWpzJztcblxuZnVuY3Rpb24gYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlLCB2YXJzID0gc3RhdGUudmFycywgdHJhbnNmb3JtID0gc3RhdGUudHJhbnNmb3JtLCB0cmFuc2Zvcm1LZXlzID0gc3RhdGUudHJhbnNmb3JtS2V5cywgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xuICAgIC8vIEVtcHR5IHRoZSB0cmFuc2Zvcm1LZXlzIGFycmF5LiBBcyB3ZSdyZSB0aHJvd2luZyBvdXQgcmVmcyB0byBpdHMgaXRlbXNcbiAgICAvLyB0aGlzIG1pZ2h0IG5vdCBiZSBhcyBjaGVhcCBhcyBzdXNwZWN0ZWQuIE1heWJlIHVzaW5nIHRoZSBhcnJheSBhcyBhIGJ1ZmZlclxuICAgIC8vIHdpdGggYSBtYW51YWwgaW5jcmVtZW50YXRpb24gd291bGQgYmUgYmV0dGVyLlxuICAgIHRyYW5zZm9ybUtleXMubGVuZ3RoID0gMDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIHdlIGVuY291bnRlciBhbnkgdHJhbnNmb3JtIG9yIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMuXG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgIHZhciBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgICAvLyBEb2VzIHRoZSBjYWxjdWxhdGVkIHRyYW5zZm9ybSBlc3NlbnRpYWxseSBlcXVhbCBcIm5vbmVcIj9cbiAgICB2YXIgdHJhbnNmb3JtSXNOb25lID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBMb29wIG92ZXIgYWxsIG91ciBsYXRlc3QgYW5pbWF0ZWQgdmFsdWVzIGFuZCBkZWNpZGUgd2hldGhlciB0byBoYW5kbGUgdGhlbVxuICAgICAqIGFzIGEgc3R5bGUgb3IgQ1NTIHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVHJhbnNmb3JtcyBhbmQgdHJhbnNmb3JtIG9yaWdpbnMgYXJlIGtlcHQgc2VwZXJhdGVseSBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxuICAgICAqL1xuICAgIGZvciAodmFyIGtleSBpbiBsYXRlc3RWYWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIGEgQ1NTIHZhcmlhYmxlIHdlIGRvbid0IGRvIGFueSBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNDU1NWYXJpYWJsZShrZXkpKSB7XG4gICAgICAgICAgICB2YXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIHR5cGUsIGllIDAgLT4gXCIwcHhcIlxuICAgICAgICB2YXIgdmFsdWVUeXBlID0gbnVtYmVyVmFsdWVUeXBlc1trZXldO1xuICAgICAgICB2YXIgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUHJvcChrZXkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdHJhbnNmb3JtLCBmbGFnIHRvIGVuYWJsZSBmdXJ0aGVyIHRyYW5zZm9ybSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgdHJhbnNmb3JtW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBrbm93IHdlIGhhdmUgYSBub24tZGVmYXVsdCB0cmFuc2Zvcm0sIGVhcmx5IHJldHVyblxuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Jc05vbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgYSBkZWZhdWx0IHRyYW5zZm9ybVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAoKF9hID0gdmFsdWVUeXBlLmRlZmF1bHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApKVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlzTm9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVHJhbnNmb3JtT3JpZ2luUHJvcChrZXkpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW5ba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRyYW5zZm9ybSBvcmlnaW4sIGZsYWcgYW5kIGVuYWJsZSBmdXJ0aGVyIHRyYW5zZm9ybS1vcmlnaW4gcHJvY2Vzc2luZ1xuICAgICAgICAgICAgaGFzVHJhbnNmb3JtT3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzVHJhbnNmb3JtKSB7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGJ1aWxkVHJhbnNmb3JtKHN0YXRlLCBvcHRpb25zLCB0cmFuc2Zvcm1Jc05vbmUsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGF0ZXN0VmFsdWVzLnRyYW5zZm9ybSAmJiBzdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG4gICAgfVxuICAgIGlmIChoYXNUcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYnVpbGRUcmFuc2Zvcm1PcmlnaW4odHJhbnNmb3JtT3JpZ2luKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9O1xuIiwgImltcG9ydCB7IHNvcnRUcmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4vdHJhbnNmb3JtLm1qcyc7XG5cbnZhciB0cmFuc2xhdGVBbGlhcyA9IHtcbiAgICB4OiBcInRyYW5zbGF0ZVhcIixcbiAgICB5OiBcInRyYW5zbGF0ZVlcIixcbiAgICB6OiBcInRyYW5zbGF0ZVpcIixcbiAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogXCJwZXJzcGVjdGl2ZVwiLFxufTtcbi8qKlxuICogQnVpbGQgYSBDU1MgdHJhbnNmb3JtIHN0eWxlIGZyb20gaW5kaXZpZHVhbCB4L3kvc2NhbGUgZXRjIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBvdXRwdXRzIHdpdGggYSBkZWZhdWx0IG9yZGVyIG9mIHRyYW5zZm9ybXMvc2NhbGVzL3JvdGF0aW9ucywgdGhpcyBjYW4gYmUgY3VzdG9taXNlZCBieVxuICogcHJvdmlkaW5nIGEgdHJhbnNmb3JtVGVtcGxhdGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtKF9hLCBfYiwgdHJhbnNmb3JtSXNEZWZhdWx0LCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBfYS50cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXMgPSBfYS50cmFuc2Zvcm1LZXlzO1xuICAgIHZhciBfYyA9IF9iLmVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uLCBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gX2IuYWxsb3dUcmFuc2Zvcm1Ob25lLCBhbGxvd1RyYW5zZm9ybU5vbmUgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kO1xuICAgIC8vIFRoZSB0cmFuc2Zvcm0gc3RyaW5nIHdlJ3JlIGdvaW5nIHRvIGJ1aWxkIGludG8uXG4gICAgdmFyIHRyYW5zZm9ybVN0cmluZyA9IFwiXCI7XG4gICAgLy8gVHJhbnNmb3JtIGtleXMgaW50byB0aGVpciBkZWZhdWx0IG9yZGVyIC0gdGhpcyB3aWxsIGRldGVybWluZSB0aGUgb3V0cHV0IG9yZGVyLlxuICAgIHRyYW5zZm9ybUtleXMuc29ydChzb3J0VHJhbnNmb3JtUHJvcHMpO1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIGRlZmluZWQgdHJhbnNmb3JtIGhhcyBhIGRlZmluZWQgeiBzbyB3ZSBkb24ndCBhZGQgYVxuICAgIC8vIHNlY29uZCB0byBlbmFibGUgaGFyZHdhcmUgYWNjZWxlcmF0aW9uXG4gICAgdmFyIHRyYW5zZm9ybUhhc1ogPSBmYWxzZTtcbiAgICAvLyBMb29wIG92ZXIgZWFjaCB0cmFuc2Zvcm0gYW5kIGJ1aWxkIHRoZW0gaW50byB0cmFuc2Zvcm1TdHJpbmdcbiAgICB2YXIgbnVtVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybUtleXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVHJhbnNmb3JtS2V5czsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0cmFuc2Zvcm1LZXlzW2ldO1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJcIi5jb25jYXQodHJhbnNsYXRlQWxpYXNba2V5XSB8fCBrZXksIFwiKFwiKS5jb25jYXQodHJhbnNmb3JtW2tleV0sIFwiKSBcIik7XG4gICAgICAgIGlmIChrZXkgPT09IFwielwiKVxuICAgICAgICAgICAgdHJhbnNmb3JtSGFzWiA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdHJhbnNmb3JtSGFzWiAmJiBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbikge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJ0cmFuc2xhdGVaKDApXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1TdHJpbmcudHJpbSgpO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIGEgY3VzdG9tIGB0cmFuc2Zvcm1gIHRlbXBsYXRlLCBwYXNzIG91ciB0cmFuc2Zvcm0gdmFsdWVzIGFuZFxuICAgIC8vIGdlbmVyYXRlZCB0cmFuc2Zvcm1TdHJpbmcgdG8gdGhhdCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVRlbXBsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtSXNEZWZhdWx0ID8gXCJcIiA6IHRyYW5zZm9ybVN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93VHJhbnNmb3JtTm9uZSAmJiB0cmFuc2Zvcm1Jc0RlZmF1bHQpIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJpbmc7XG59XG4vKipcbiAqIEJ1aWxkIGEgdHJhbnNmb3JtT3JpZ2luIHN0eWxlLiBVc2VzIHRoZSBzYW1lIGRlZmF1bHRzIGFzIHRoZSBicm93c2VyIGZvclxuICogdW5kZWZpbmVkIG9yaWdpbnMuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtT3JpZ2luKF9hKSB7XG4gICAgdmFyIF9iID0gX2Eub3JpZ2luWCwgb3JpZ2luWCA9IF9iID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2IsIF9jID0gX2Eub3JpZ2luWSwgb3JpZ2luWSA9IF9jID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2MsIF9kID0gX2Eub3JpZ2luWiwgb3JpZ2luWiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG9yaWdpblgsIFwiIFwiKS5jb25jYXQob3JpZ2luWSwgXCIgXCIpLmNvbmNhdChvcmlnaW5aKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRUcmFuc2Zvcm0sIGJ1aWxkVHJhbnNmb3JtT3JpZ2luIH07XG4iLCAiLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIGtleSBpcyBhIENTUyB2YXJpYWJsZVxuICovXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlKGtleSkge1xuICAgIHJldHVybiBrZXkuc3RhcnRzV2l0aChcIi0tXCIpO1xufVxuXG5leHBvcnQgeyBpc0NTU1ZhcmlhYmxlIH07XG4iLCAiLyoqXG4gKiBQcm92aWRlZCBhIHZhbHVlIGFuZCBhIFZhbHVlVHlwZSwgcmV0dXJucyB0aGUgdmFsdWUgYXMgdGhhdCB2YWx1ZSB0eXBlLlxuICovXG52YXIgZ2V0VmFsdWVBc1R5cGUgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB0eXBlLnRyYW5zZm9ybSh2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbn07XG5cbmV4cG9ydCB7IGdldFZhbHVlQXNUeXBlIH07XG4iLCAidmFyIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgc3R5bGU6IHt9LFxuICAgIHRyYW5zZm9ybToge30sXG4gICAgdHJhbnNmb3JtS2V5czogW10sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB7fSxcbiAgICB2YXJzOiB7fSxcbn0pOyB9O1xuXG5leHBvcnQgeyBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgfTtcbiIsICJpbXBvcnQgeyBpc1ZhbGlkTW90aW9uUHJvcCB9IGZyb20gJy4uLy4uLy4uL21vdGlvbi91dGlscy92YWxpZC1wcm9wLm1qcyc7XG5cbnZhciBzaG91bGRGb3J3YXJkID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSk7IH07XG5mdW5jdGlvbiBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChpc1ZhbGlkUHJvcCkge1xuICAgIGlmICghaXNWYWxpZFByb3ApXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBFeHBsaWNpdGx5IGZpbHRlciBvdXIgZXZlbnRzXG4gICAgc2hvdWxkRm9yd2FyZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKFwib25cIikgPyAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSA6IGlzVmFsaWRQcm9wKGtleSk7XG4gICAgfTtcbn1cbi8qKlxuICogRW1vdGlvbiBhbmQgU3R5bGVkIENvbXBvbmVudHMgYm90aCBhbGxvdyB1c2VycyB0byBwYXNzIHRocm91Z2ggYXJiaXRyYXJ5IHByb3BzIHRvIHRoZWlyIGNvbXBvbmVudHNcbiAqIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlIENTUy4gVGhleSBib3RoIHVzZSB0aGUgYEBlbW90aW9uL2lzLXByb3AtdmFsaWRgIHBhY2thZ2UgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gKiBvZiB0aGVzZSBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlLlxuICpcbiAqIEhvd2V2ZXIsIHdoZW4gc3R5bGluZyBhIE1vdGlvbiBjb21wb25lbnQgYHN0eWxlZChtb3Rpb24uZGl2KWAsIGJvdGggcGFja2FnZXMgcGFzcyB0aHJvdWdoICphbGwqIHByb3BzXG4gKiBhcyBpdCdzIHNlZW4gYXMgYW4gYXJiaXRyYXJ5IGNvbXBvbmVudCByYXRoZXIgdGhhbiBhIERPTSBub2RlLiBNb3Rpb24gb25seSBhbGxvd3MgYXJiaXRyYXJ5IHByb3BzXG4gKiBwYXNzZWQgdGhyb3VnaCB0aGUgYGN1c3RvbWAgcHJvcCBzbyBpdCBkb2Vzbid0ICpuZWVkKiB0aGUgcGF5bG9hZCBvciBjb21wdXRhdGlvbmFsIG92ZXJoZWFkIG9mXG4gKiBgQGVtb3Rpb24vaXMtcHJvcC12YWxpZGAsIGhvd2V2ZXIgdG8gZml4IHRoaXMgcHJvYmxlbSB3ZSBuZWVkIHRvIHVzZSBpdC5cbiAqXG4gKiBCeSBtYWtpbmcgaXQgYW4gb3B0aW9uYWxEZXBlbmRlbmN5IHdlIGNhbiBvZmZlciB0aGlzIGZ1bmN0aW9uYWxpdHkgb25seSBpbiB0aGUgc2l0dWF0aW9ucyB3aGVyZSBpdCdzXG4gKiBhY3R1YWxseSByZXF1aXJlZC5cbiAqL1xudHJ5IHtcbiAgICAvKipcbiAgICAgKiBXZSBhdHRlbXB0IHRvIGltcG9ydCB0aGlzIHBhY2thZ2UgYnV0IHJlcXVpcmUgd29uJ3QgYmUgZGVmaW5lZCBpbiBlc20gZW52aXJvbm1lbnRzLCBpbiB0aGF0IGNhc2VcbiAgICAgKiBpc1Byb3BWYWxpZCB3aWxsIGhhdmUgdG8gYmUgcHJvdmlkZWQgdmlhIGBNb3Rpb25Db250ZXh0YC4gSW4gYSA2LjAuMCB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSByZW1vdmVkXG4gICAgICogaW4gZmF2b3VyIG9mIGV4cGxpY2l0IGluamVjdGlvbi5cbiAgICAgKi9cbiAgICBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChyZXF1aXJlKFwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiKS5kZWZhdWx0KTtcbn1cbmNhdGNoIChfYSkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gYWN0dWFsbHkgZG8gYW55dGhpbmcgaGVyZSAtIHRoZSBmYWxsYmFjayBpcyB0aGUgZXhpc3RpbmcgYGlzUHJvcFZhbGlkYC5cbn1cbmZ1bmN0aW9uIGZpbHRlclByb3BzKHByb3BzLCBpc0RvbSwgZm9yd2FyZE1vdGlvblByb3BzKSB7XG4gICAgdmFyIGZpbHRlcmVkUHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHNob3VsZEZvcndhcmQoa2V5KSB8fFxuICAgICAgICAgICAgKGZvcndhcmRNb3Rpb25Qcm9wcyA9PT0gdHJ1ZSAmJiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpKSB8fFxuICAgICAgICAgICAgKCFpc0RvbSAmJiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSkgfHxcbiAgICAgICAgICAgIC8vIElmIHRyeWluZyB0byB1c2UgbmF0aXZlIEhUTUwgZHJhZyBldmVudHMsIGZvcndhcmQgZHJhZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIChwcm9wc1tcImRyYWdnYWJsZVwiXSAmJiBrZXkuc3RhcnRzV2l0aChcIm9uRHJhZ1wiKSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cbmV4cG9ydCB7IGZpbHRlclByb3BzLCBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcCB9O1xuIiwgIi8qKlxuICogQSBsaXN0IG9mIGFsbCB2YWxpZCBNb3Rpb25Qcm9wcy5cbiAqXG4gKiBAaW50ZXJuYWxyZW1hcmtzXG4gKiBUaGlzIGRvZXNuJ3QgdGhyb3cgaWYgYSBgTW90aW9uUHJvcGAgbmFtZSBpcyBtaXNzaW5nIC0gaXQgc2hvdWxkLlxuICovXG52YXIgdmFsaWRNb3Rpb25Qcm9wcyA9IG5ldyBTZXQoW1xuICAgIFwiaW5pdGlhbFwiLFxuICAgIFwiYW5pbWF0ZVwiLFxuICAgIFwiZXhpdFwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInZhcmlhbnRzXCIsXG4gICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgXCJ0cmFuc2Zvcm1UZW1wbGF0ZVwiLFxuICAgIFwidHJhbnNmb3JtVmFsdWVzXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImluaGVyaXRcIixcbiAgICBcImxheW91dFwiLFxuICAgIFwibGF5b3V0SWRcIixcbiAgICBcImxheW91dERlcGVuZGVuY3lcIixcbiAgICBcIm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIm9uTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwib25CZWZvcmVMYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJvbkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJvblVwZGF0ZVwiLFxuICAgIFwib25EcmFnU3RhcnRcIixcbiAgICBcIm9uRHJhZ1wiLFxuICAgIFwib25EcmFnRW5kXCIsXG4gICAgXCJvbk1lYXN1cmVEcmFnQ29uc3RyYWludHNcIixcbiAgICBcIm9uRGlyZWN0aW9uTG9ja1wiLFxuICAgIFwib25EcmFnVHJhbnNpdGlvbkVuZFwiLFxuICAgIFwiZHJhZ1wiLFxuICAgIFwiZHJhZ0NvbnRyb2xzXCIsXG4gICAgXCJkcmFnTGlzdGVuZXJcIixcbiAgICBcImRyYWdDb25zdHJhaW50c1wiLFxuICAgIFwiZHJhZ0RpcmVjdGlvbkxvY2tcIixcbiAgICBcImRyYWdTbmFwVG9PcmlnaW5cIixcbiAgICBcIl9kcmFnWFwiLFxuICAgIFwiX2RyYWdZXCIsXG4gICAgXCJkcmFnRWxhc3RpY1wiLFxuICAgIFwiZHJhZ01vbWVudHVtXCIsXG4gICAgXCJkcmFnUHJvcGFnYXRpb25cIixcbiAgICBcImRyYWdUcmFuc2l0aW9uXCIsXG4gICAgXCJ3aGlsZURyYWdcIixcbiAgICBcIm9uUGFuXCIsXG4gICAgXCJvblBhblN0YXJ0XCIsXG4gICAgXCJvblBhbkVuZFwiLFxuICAgIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgICBcIm9uVGFwXCIsXG4gICAgXCJvblRhcFN0YXJ0XCIsXG4gICAgXCJvblRhcENhbmNlbFwiLFxuICAgIFwib25Ib3ZlclN0YXJ0XCIsXG4gICAgXCJvbkhvdmVyRW5kXCIsXG4gICAgXCJ3aGlsZUZvY3VzXCIsXG4gICAgXCJ3aGlsZVRhcFwiLFxuICAgIFwid2hpbGVIb3ZlclwiLFxuICAgIFwid2hpbGVJblZpZXdcIixcbiAgICBcIm9uVmlld3BvcnRFbnRlclwiLFxuICAgIFwib25WaWV3cG9ydExlYXZlXCIsXG4gICAgXCJ2aWV3cG9ydFwiLFxuICAgIFwibGF5b3V0U2Nyb2xsXCIsXG5dKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHByb3AgbmFtZSBpcyBhIHZhbGlkIGBNb3Rpb25Qcm9wYCBrZXkuXG4gKlxuICogQHBhcmFtIGtleSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaXMga2V5IGlzIGEgdmFsaWQgYE1vdGlvblByb3BgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHZhbGlkTW90aW9uUHJvcHMuaGFzKGtleSk7XG59XG5cbmV4cG9ydCB7IGlzVmFsaWRNb3Rpb25Qcm9wIH07XG4iLCAiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29weVJhd1ZhbHVlc09ubHkgfSBmcm9tICcuLi9odG1sL3VzZS1wcm9wcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRTVkdBdHRycyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtYXR0cnMubWpzJztcbmltcG9ydCB7IGNyZWF0ZVN2Z1JlbmRlclN0YXRlIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5cbmZ1bmN0aW9uIHVzZVNWR1Byb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIHZhciB2aXN1YWxQcm9wcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBjcmVhdGVTdmdSZW5kZXJTdGF0ZSgpO1xuICAgICAgICBidWlsZFNWR0F0dHJzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlLmF0dHJzKSwgeyBzdHlsZTogX19hc3NpZ24oe30sIHN0YXRlLnN0eWxlKSB9KTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbiAgICBpZiAocHJvcHMuc3R5bGUpIHtcbiAgICAgICAgdmFyIHJhd1N0eWxlcyA9IHt9O1xuICAgICAgICBjb3B5UmF3VmFsdWVzT25seShyYXdTdHlsZXMsIHByb3BzLnN0eWxlLCBwcm9wcyk7XG4gICAgICAgIHZpc3VhbFByb3BzLnN0eWxlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJhd1N0eWxlcyksIHZpc3VhbFByb3BzLnN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc3VhbFByb3BzO1xufVxuXG5leHBvcnQgeyB1c2VTVkdQcm9wcyB9O1xuIiwgImltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvYnVpbGQtc3R5bGVzLm1qcyc7XG5pbXBvcnQgeyBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luIH0gZnJvbSAnLi90cmFuc2Zvcm0tb3JpZ2luLm1qcyc7XG5pbXBvcnQgeyBidWlsZFNWR1BhdGggfSBmcm9tICcuL3BhdGgubWpzJztcblxuLyoqXG4gKiBCdWlsZCBTVkcgdmlzdWFsIGF0dHJidXRlcywgbGlrZSBjeCBhbmQgc3R5bGUudHJhbnNmb3JtXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIF9hLCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIHZhciBhdHRyWCA9IF9hLmF0dHJYLCBhdHRyWSA9IF9hLmF0dHJZLCBvcmlnaW5YID0gX2Eub3JpZ2luWCwgb3JpZ2luWSA9IF9hLm9yaWdpblksIHBhdGhMZW5ndGggPSBfYS5wYXRoTGVuZ3RoLCBfYiA9IF9hLnBhdGhTcGFjaW5nLCBwYXRoU3BhY2luZyA9IF9iID09PSB2b2lkIDAgPyAxIDogX2IsIF9jID0gX2EucGF0aE9mZnNldCwgcGF0aE9mZnNldCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIFxuICAgIC8vIFRoaXMgaXMgb2JqZWN0IGNyZWF0aW9uLCB3aGljaCB3ZSB0cnkgdG8gYXZvaWQgcGVyLWZyYW1lLlxuICAgIGxhdGVzdCA9IF9fcmVzdChfYSwgW1wiYXR0clhcIiwgXCJhdHRyWVwiLCBcIm9yaWdpblhcIiwgXCJvcmlnaW5ZXCIsIFwicGF0aExlbmd0aFwiLCBcInBhdGhTcGFjaW5nXCIsIFwicGF0aE9mZnNldFwiXSk7XG4gICAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3QsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICBzdGF0ZS5hdHRycyA9IHN0YXRlLnN0eWxlO1xuICAgIHN0YXRlLnN0eWxlID0ge307XG4gICAgdmFyIGF0dHJzID0gc3RhdGUuYXR0cnMsIHN0eWxlID0gc3RhdGUuc3R5bGUsIGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zO1xuICAgIC8qKlxuICAgICAqIEhvd2V2ZXIsIHdlIGFwcGx5IHRyYW5zZm9ybXMgYXMgQ1NTIHRyYW5zZm9ybXMuIFNvIGlmIHdlIGRldGVjdCBhIHRyYW5zZm9ybSB3ZSB0YWtlIGl0IGZyb20gYXR0cnNcbiAgICAgKiBhbmQgY29weSBpdCBpbnRvIHN0eWxlLlxuICAgICAqL1xuICAgIGlmIChhdHRycy50cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMpXG4gICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBhdHRycy50cmFuc2Zvcm07XG4gICAgICAgIGRlbGV0ZSBhdHRycy50cmFuc2Zvcm07XG4gICAgfVxuICAgIC8vIFBhcnNlIHRyYW5zZm9ybU9yaWdpblxuICAgIGlmIChkaW1lbnNpb25zICYmXG4gICAgICAgIChvcmlnaW5YICE9PSB1bmRlZmluZWQgfHwgb3JpZ2luWSAhPT0gdW5kZWZpbmVkIHx8IHN0eWxlLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YICE9PSB1bmRlZmluZWQgPyBvcmlnaW5YIDogMC41LCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgPyBvcmlnaW5ZIDogMC41KTtcbiAgICB9XG4gICAgLy8gVHJlYXQgeC95IG5vdCBhcyBzaG9ydGN1dHMgYnV0IGFzIGFjdHVhbCBhdHRyaWJ1dGVzXG4gICAgaWYgKGF0dHJYICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGF0dHJzLnggPSBhdHRyWDtcbiAgICBpZiAoYXR0clkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMueSA9IGF0dHJZO1xuICAgIC8vIEJ1aWxkIFNWRyBwYXRoIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkXG4gICAgaWYgKHBhdGhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWlsZFNWR1BhdGgoYXR0cnMsIHBhdGhMZW5ndGgsIHBhdGhTcGFjaW5nLCBwYXRoT2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBidWlsZFNWR0F0dHJzIH07XG4iLCAiaW1wb3J0IHsgcHggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5cbmZ1bmN0aW9uIGNhbGNPcmlnaW4ob3JpZ2luLCBvZmZzZXQsIHNpemUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9yaWdpbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IG9yaWdpblxuICAgICAgICA6IHB4LnRyYW5zZm9ybShvZmZzZXQgKyBzaXplICogb3JpZ2luKTtcbn1cbi8qKlxuICogVGhlIFNWRyB0cmFuc2Zvcm0gb3JpZ2luIGRlZmF1bHRzIGFyZSBkaWZmZXJlbnQgdG8gQ1NTIGFuZCBpcyBsZXNzIGludHVpdGl2ZSxcbiAqIHNvIHdlIHVzZSB0aGUgbWVhc3VyZWQgZGltZW5zaW9ucyBvZiB0aGUgU1ZHIHRvIHJlY29uY2lsZSB0aGVzZS5cbiAqL1xuZnVuY3Rpb24gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgdmFyIHB4T3JpZ2luWCA9IGNhbGNPcmlnaW4ob3JpZ2luWCwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLndpZHRoKTtcbiAgICB2YXIgcHhPcmlnaW5ZID0gY2FsY09yaWdpbihvcmlnaW5ZLCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocHhPcmlnaW5YLCBcIiBcIikuY29uY2F0KHB4T3JpZ2luWSk7XG59XG5cbmV4cG9ydCB7IGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4gfTtcbiIsICJpbXBvcnQgeyBweCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcblxudmFyIGRhc2hLZXlzID0ge1xuICAgIG9mZnNldDogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICAgIGFycmF5OiBcInN0cm9rZS1kYXNoYXJyYXlcIixcbn07XG52YXIgY2FtZWxLZXlzID0ge1xuICAgIG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG59O1xuLyoqXG4gKiBCdWlsZCBTVkcgcGF0aCBwcm9wZXJ0aWVzLiBVc2VzIHRoZSBwYXRoJ3MgbWVhc3VyZWQgbGVuZ3RoIHRvIGNvbnZlcnRcbiAqIG91ciBjdXN0b20gcGF0aExlbmd0aCwgcGF0aFNwYWNpbmcgYW5kIHBhdGhPZmZzZXQgaW50byBzdHJva2UtZGFzaG9mZnNldFxuICogYW5kIHN0cm9rZS1kYXNoYXJyYXkgYXR0cmlidXRlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG11dGF0aXZlIHRvIHJlZHVjZSBwZXItZnJhbWUgR0MuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU1ZHUGF0aChhdHRycywgbGVuZ3RoLCBzcGFjaW5nLCBvZmZzZXQsIHVzZURhc2hDYXNlKSB7XG4gICAgaWYgKHNwYWNpbmcgPT09IHZvaWQgMCkgeyBzcGFjaW5nID0gMTsgfVxuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgaWYgKHVzZURhc2hDYXNlID09PSB2b2lkIDApIHsgdXNlRGFzaENhc2UgPSB0cnVlOyB9XG4gICAgLy8gTm9ybWFsaXNlIHBhdGggbGVuZ3RoIGJ5IHNldHRpbmcgU1ZHIGF0dHJpYnV0ZSBwYXRoTGVuZ3RoIHRvIDFcbiAgICBhdHRycy5wYXRoTGVuZ3RoID0gMTtcbiAgICAvLyBXZSB1c2UgZGFzaCBjYXNlIHdoZW4gc2V0dGluZyBhdHRyaWJ1dGVzIGRpcmVjdGx5IHRvIHRoZSBET00gbm9kZSBhbmQgY2FtZWwgY2FzZVxuICAgIC8vIHdoZW4gZGVmaW5pbmcgcHJvcHMgb24gYSBSZWFjdCBjb21wb25lbnQuXG4gICAgdmFyIGtleXMgPSB1c2VEYXNoQ2FzZSA/IGRhc2hLZXlzIDogY2FtZWxLZXlzO1xuICAgIC8vIEJ1aWxkIHRoZSBkYXNoIG9mZnNldFxuICAgIGF0dHJzW2tleXMub2Zmc2V0XSA9IHB4LnRyYW5zZm9ybSgtb2Zmc2V0KTtcbiAgICAvLyBCdWlsZCB0aGUgZGFzaCBhcnJheVxuICAgIHZhciBwYXRoTGVuZ3RoID0gcHgudHJhbnNmb3JtKGxlbmd0aCk7XG4gICAgdmFyIHBhdGhTcGFjaW5nID0gcHgudHJhbnNmb3JtKHNwYWNpbmcpO1xuICAgIGF0dHJzW2tleXMuYXJyYXldID0gXCJcIi5jb25jYXQocGF0aExlbmd0aCwgXCIgXCIpLmNvbmNhdChwYXRoU3BhY2luZyk7XG59XG5cbmV4cG9ydCB7IGJ1aWxkU1ZHUGF0aCB9O1xuIiwgImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgY3JlYXRlSHRtbFJlbmRlclN0YXRlIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5cbnZhciBjcmVhdGVTdmdSZW5kZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3JlYXRlSHRtbFJlbmRlclN0YXRlKCkpLCB7IGF0dHJzOiB7fSB9KSk7IH07XG5cbmV4cG9ydCB7IGNyZWF0ZVN2Z1JlbmRlclN0YXRlIH07XG4iLCAiaW1wb3J0IHsgcmVuZGVyU1ZHIH0gZnJvbSAnLi91dGlscy9yZW5kZXIubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcbmltcG9ydCB7IG1ha2VVc2VWaXN1YWxTdGF0ZSB9IGZyb20gJy4uLy4uL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdmdSZW5kZXJTdGF0ZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRTVkdBdHRycyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtYXR0cnMubWpzJztcblxudmFyIHN2Z01vdGlvbkNvbmZpZyA9IHtcbiAgICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICAgICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsXG4gICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVTdmdSZW5kZXJTdGF0ZSxcbiAgICAgICAgb25Nb3VudDogZnVuY3Rpb24gKHByb3BzLCBpbnN0YW5jZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IF9hLnJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMgPSBfYS5sYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmRpbWVuc2lvbnMgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UuZ2V0QkJveCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnN0YW5jZS5nZXRCQm94KClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5zdGFuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IHRyeWluZyB0byBtZWFzdXJlIGFuIHVucmVuZGVyZWQgZWxlbWVudCB1bmRlciBGaXJlZm94XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSB9LCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggZGlyZWN0IGFzc2lnbm1lbnRcbiAgICAgICAgICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUpO1xuICAgICAgICB9LFxuICAgIH0pLFxufTtcblxuZXhwb3J0IHsgc3ZnTW90aW9uQ29uZmlnIH07XG4iLCAiaW1wb3J0IHsgY2FtZWxUb0Rhc2ggfSBmcm9tICcuLi8uLi9kb20vdXRpbHMvY2FtZWwtdG8tZGFzaC5tanMnO1xuaW1wb3J0IHsgcmVuZGVySFRNTCB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvcmVuZGVyLm1qcyc7XG5pbXBvcnQgeyBjYW1lbENhc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jYW1lbC1jYXNlLWF0dHJzLm1qcyc7XG5cbmZ1bmN0aW9uIHJlbmRlclNWRyhlbGVtZW50LCByZW5kZXJTdGF0ZSkge1xuICAgIHJlbmRlckhUTUwoZWxlbWVudCwgcmVuZGVyU3RhdGUpO1xuICAgIGZvciAodmFyIGtleSBpbiByZW5kZXJTdGF0ZS5hdHRycykge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSghY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXksIHJlbmRlclN0YXRlLmF0dHJzW2tleV0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgcmVuZGVyU1ZHIH07XG4iLCAidmFyIENBTUVMX0NBU0VfUEFUVEVSTiA9IC8oW2Etel0pKFtBLVpdKS9nO1xudmFyIFJFUExBQ0VfVEVNUExBVEUgPSBcIiQxLSQyXCI7XG4vKipcbiAqIENvbnZlcnQgY2FtZWxDYXNlIHRvIGRhc2gtY2FzZSBwcm9wZXJ0aWVzLlxuICovXG52YXIgY2FtZWxUb0Rhc2ggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKENBTUVMX0NBU0VfUEFUVEVSTiwgUkVQTEFDRV9URU1QTEFURSkudG9Mb3dlckNhc2UoKTtcbn07XG5cbmV4cG9ydCB7IGNhbWVsVG9EYXNoIH07XG4iLCAiZnVuY3Rpb24gcmVuZGVySFRNTChlbGVtZW50LCBfYSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHN0eWxlID0gX2Euc3R5bGUsIHZhcnMgPSBfYS52YXJzO1xuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUsIHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5nZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCkpO1xuICAgIC8vIExvb3Agb3ZlciBhbnkgQ1NTIHZhcmlhYmxlcyBhbmQgYXNzaWduIHRob3NlLlxuICAgIGZvciAodmFyIGtleSBpbiB2YXJzKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YXJzW2tleV0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgcmVuZGVySFRNTCB9O1xuIiwgIi8qKlxuICogQSBzZXQgb2YgYXR0cmlidXRlIG5hbWVzIHRoYXQgYXJlIGFsd2F5cyByZWFkL3dyaXR0ZW4gYXMgY2FtZWwgY2FzZS5cbiAqL1xudmFyIGNhbWVsQ2FzZUF0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICBcImJhc2VGcmVxdWVuY3lcIixcbiAgICBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgIFwia2VybmVsTWF0cml4XCIsXG4gICAgXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgXCJrZXlTcGxpbmVzXCIsXG4gICAgXCJrZXlUaW1lc1wiLFxuICAgIFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICBcIm1hcmtlckhlaWdodFwiLFxuICAgIFwibWFya2VyV2lkdGhcIixcbiAgICBcIm51bU9jdGF2ZXNcIixcbiAgICBcInRhcmdldFhcIixcbiAgICBcInRhcmdldFlcIixcbiAgICBcInN1cmZhY2VTY2FsZVwiLFxuICAgIFwic3BlY3VsYXJDb25zdGFudFwiLFxuICAgIFwic3BlY3VsYXJFeHBvbmVudFwiLFxuICAgIFwic3RkRGV2aWF0aW9uXCIsXG4gICAgXCJ0YWJsZVZhbHVlc1wiLFxuICAgIFwidmlld0JveFwiLFxuICAgIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICBcInBhdGhMZW5ndGhcIixcbl0pO1xuXG5leHBvcnQgeyBjYW1lbENhc2VBdHRyaWJ1dGVzIH07XG4iLCAiaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIGFzIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuXG5mdW5jdGlvbiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgbmV3VmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzJDEocHJvcHMpO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShwcm9wc1trZXldKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEtleSA9IGtleSA9PT0gXCJ4XCIgfHwga2V5ID09PSBcInlcIiA/IFwiYXR0clwiICsga2V5LnRvVXBwZXJDYXNlKCkgOiBrZXk7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbdGFyZ2V0S2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuZXhwb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH07XG4iLCAiaW1wb3J0IHsgaXNGb3JjZWRNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uLy4uL21vdGlvbi91dGlscy9pcy1mb3JjZWQtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcykge1xuICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICAgIHZhciBuZXdWYWx1ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3R5bGUpIHtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUoc3R5bGVba2V5XSkgfHwgaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHByb3BzKSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2tleV0gPSBzdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbmV4cG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9O1xuIiwgImltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0FuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanMnO1xuaW1wb3J0IHsgUHJlc2VuY2VDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcbmltcG9ydCB7IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzLCBjaGVja0lmVmFyaWFudE5vZGUsIHJlc29sdmVWYXJpYW50RnJvbVByb3BzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL3ZhcmlhbnRzLm1qcyc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZU1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvcmVzb2x2ZS1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L01vdGlvbkNvbnRleHQvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gbWFrZVN0YXRlKF9hLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KSB7XG4gICAgdmFyIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyA9IF9hLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcywgY3JlYXRlUmVuZGVyU3RhdGUgPSBfYS5jcmVhdGVSZW5kZXJTdGF0ZSwgb25Nb3VudCA9IF9hLm9uTW91bnQ7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBsYXRlc3RWYWx1ZXM6IG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKSxcbiAgICAgICAgcmVuZGVyU3RhdGU6IGNyZWF0ZVJlbmRlclN0YXRlKCksXG4gICAgfTtcbiAgICBpZiAob25Nb3VudCkge1xuICAgICAgICBzdGF0ZS5tb3VudCA9IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gb25Nb3VudChwcm9wcywgaW5zdGFuY2UsIHN0YXRlKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxudmFyIG1ha2VVc2VWaXN1YWxTdGF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BzLCBpc1N0YXRpYykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTW90aW9uQ29udGV4dCk7XG4gICAgICAgIHZhciBwcmVzZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgICAgIHJldHVybiBpc1N0YXRpY1xuICAgICAgICAgICAgPyBtYWtlU3RhdGUoY29uZmlnLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KVxuICAgICAgICAgICAgOiB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcbn07XG5mdW5jdGlvbiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlcykge1xuICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICB2YXIgYmxvY2tJbml0aWFsQW5pbWF0aW9uID0gKHByZXNlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBwcmVzZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlbmNlQ29udGV4dC5pbml0aWFsKSA9PT0gZmFsc2U7XG4gICAgdmFyIG1vdGlvblZhbHVlcyA9IHNjcmFwZU1vdGlvblZhbHVlcyhwcm9wcyk7XG4gICAgZm9yICh2YXIga2V5IGluIG1vdGlvblZhbHVlcykge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHJlc29sdmVNb3Rpb25WYWx1ZShtb3Rpb25WYWx1ZXNba2V5XSk7XG4gICAgfVxuICAgIHZhciBpbml0aWFsID0gcHJvcHMuaW5pdGlhbCwgYW5pbWF0ZSA9IHByb3BzLmFuaW1hdGU7XG4gICAgdmFyIGlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICB2YXIgaXNWYXJpYW50Tm9kZSA9IGNoZWNrSWZWYXJpYW50Tm9kZShwcm9wcyk7XG4gICAgaWYgKGNvbnRleHQgJiZcbiAgICAgICAgaXNWYXJpYW50Tm9kZSAmJlxuICAgICAgICAhaXNDb250cm9sbGluZ1ZhcmlhbnRzICYmXG4gICAgICAgIHByb3BzLmluaGVyaXQgIT09IGZhbHNlKSB7XG4gICAgICAgIGluaXRpYWwgIT09IG51bGwgJiYgaW5pdGlhbCAhPT0gdm9pZCAwID8gaW5pdGlhbCA6IChpbml0aWFsID0gY29udGV4dC5pbml0aWFsKTtcbiAgICAgICAgYW5pbWF0ZSAhPT0gbnVsbCAmJiBhbmltYXRlICE9PSB2b2lkIDAgPyBhbmltYXRlIDogKGFuaW1hdGUgPSBjb250ZXh0LmFuaW1hdGUpO1xuICAgIH1cbiAgICB2YXIgaW5pdGlhbEFuaW1hdGlvbklzQmxvY2tlZCA9IGJsb2NrSW5pdGlhbEFuaW1hdGlvbiB8fCBpbml0aWFsID09PSBmYWxzZTtcbiAgICB2YXIgdmFyaWFudFRvU2V0ID0gaW5pdGlhbEFuaW1hdGlvbklzQmxvY2tlZCA/IGFuaW1hdGUgOiBpbml0aWFsO1xuICAgIGlmICh2YXJpYW50VG9TZXQgJiZcbiAgICAgICAgdHlwZW9mIHZhcmlhbnRUb1NldCAhPT0gXCJib29sZWFuXCIgJiZcbiAgICAgICAgIWlzQW5pbWF0aW9uQ29udHJvbHModmFyaWFudFRvU2V0KSkge1xuICAgICAgICB2YXIgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFyaWFudFRvU2V0KSA/IHZhcmlhbnRUb1NldCA6IFt2YXJpYW50VG9TZXRdO1xuICAgICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kOyByZXNvbHZlZC50cmFuc2l0aW9uOyB2YXIgdGFyZ2V0ID0gX19yZXN0KHJlc29sdmVkLCBbXCJ0cmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvblwiXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUYWtlIGZpbmFsIGtleWZyYW1lIGlmIHRoZSBpbml0aWFsIGFuaW1hdGlvbiBpcyBibG9ja2VkIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICogd2Ugd2FudCB0byBpbml0aWFsaXNlIGF0IHRoZSBlbmQgb2YgdGhhdCBibG9ja2VkIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluaXRpYWxBbmltYXRpb25Jc0Jsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVUYXJnZXQubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRhcmdldCA9IHZhbHVlVGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWVUYXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRyYW5zaXRpb25FbmQpXG4gICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuXG5leHBvcnQgeyBtYWtlVXNlVmlzdWFsU3RhdGUgfTtcbiIsICJmdW5jdGlvbiBpc0FuaW1hdGlvbkNvbnRyb2xzKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHYuc3RhcnQgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZXhwb3J0IHsgaXNBbmltYXRpb25Db250cm9scyB9O1xuIiwgImltcG9ydCB7IG1ha2VVc2VWaXN1YWxTdGF0ZSB9IGZyb20gJy4uLy4uL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfSBmcm9tICcuL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUubWpzJztcblxudmFyIGh0bWxNb3Rpb25Db25maWcgPSB7XG4gICAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLFxuICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlSHRtbFJlbmRlclN0YXRlLFxuICAgIH0pLFxufTtcblxuZXhwb3J0IHsgaHRtbE1vdGlvbkNvbmZpZyB9O1xuIiwgImltcG9ydCB7IHVzZUZvY3VzR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3VzZS1mb2N1cy1nZXN0dXJlLm1qcyc7XG5pbXBvcnQgeyB1c2VIb3Zlckdlc3R1cmUgfSBmcm9tICcuLi8uLi9nZXN0dXJlcy91c2UtaG92ZXItZ2VzdHVyZS5tanMnO1xuaW1wb3J0IHsgdXNlVGFwR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3VzZS10YXAtZ2VzdHVyZS5tanMnO1xuaW1wb3J0IHsgdXNlVmlld3BvcnQgfSBmcm9tICcuL3ZpZXdwb3J0L3VzZS12aWV3cG9ydC5tanMnO1xuaW1wb3J0IHsgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgfSBmcm9tICcuLi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qcyc7XG5cbnZhciBnZXN0dXJlQW5pbWF0aW9ucyA9IHtcbiAgICBpblZpZXc6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVZpZXdwb3J0KSxcbiAgICB0YXA6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVRhcEdlc3R1cmUpLFxuICAgIGZvY3VzOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VGb2N1c0dlc3R1cmUpLFxuICAgIGhvdmVyOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VIb3Zlckdlc3R1cmUpLFxufTtcblxuZXhwb3J0IHsgZ2VzdHVyZUFuaW1hdGlvbnMgfTtcbiIsICJpbXBvcnQgeyBBbmltYXRpb25UeXBlIH0gZnJvbSAnLi4vcmVuZGVyL3V0aWxzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyB1c2VEb21FdmVudCB9IGZyb20gJy4uL2V2ZW50cy91c2UtZG9tLWV2ZW50Lm1qcyc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBwcm9wc1xuICogQHBhcmFtIHJlZlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZUZvY3VzR2VzdHVyZShfYSkge1xuICAgIHZhciB3aGlsZUZvY3VzID0gX2Eud2hpbGVGb2N1cywgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gICAgdmFyIG9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkZvY3VzLCB0cnVlKTtcbiAgICB9O1xuICAgIHZhciBvbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkZvY3VzLCBmYWxzZSk7XG4gICAgfTtcbiAgICB1c2VEb21FdmVudCh2aXN1YWxFbGVtZW50LCBcImZvY3VzXCIsIHdoaWxlRm9jdXMgPyBvbkZvY3VzIDogdW5kZWZpbmVkKTtcbiAgICB1c2VEb21FdmVudCh2aXN1YWxFbGVtZW50LCBcImJsdXJcIiwgd2hpbGVGb2N1cyA/IG9uQmx1ciA6IHVuZGVmaW5lZCk7XG59XG5cbmV4cG9ydCB7IHVzZUZvY3VzR2VzdHVyZSB9O1xuIiwgInZhciBBbmltYXRpb25UeXBlO1xuKGZ1bmN0aW9uIChBbmltYXRpb25UeXBlKSB7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkFuaW1hdGVcIl0gPSBcImFuaW1hdGVcIjtcbiAgICBBbmltYXRpb25UeXBlW1wiSG92ZXJcIl0gPSBcIndoaWxlSG92ZXJcIjtcbiAgICBBbmltYXRpb25UeXBlW1wiVGFwXCJdID0gXCJ3aGlsZVRhcFwiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJEcmFnXCJdID0gXCJ3aGlsZURyYWdcIjtcbiAgICBBbmltYXRpb25UeXBlW1wiRm9jdXNcIl0gPSBcIndoaWxlRm9jdXNcIjtcbiAgICBBbmltYXRpb25UeXBlW1wiSW5WaWV3XCJdID0gXCJ3aGlsZUluVmlld1wiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJFeGl0XCJdID0gXCJleGl0XCI7XG59KShBbmltYXRpb25UeXBlIHx8IChBbmltYXRpb25UeXBlID0ge30pKTtcblxuZXhwb3J0IHsgQW5pbWF0aW9uVHlwZSB9O1xuIiwgImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gYWRkRG9tRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpOyB9O1xufVxuLyoqXG4gKiBBdHRhY2hlcyBhbiBldmVudCBsaXN0ZW5lciBkaXJlY3RseSB0byB0aGUgcHJvdmlkZWQgRE9NIGVsZW1lbnQuXG4gKlxuICogQnlwYXNzaW5nIFJlYWN0J3MgZXZlbnQgc3lzdGVtIGNhbiBiZSBkZXNpcmFibGUsIGZvciBpbnN0YW5jZSB3aGVuIGF0dGFjaGluZyBub24tcGFzc2l2ZVxuICogZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCByZWYgPSB1c2VSZWYobnVsbClcbiAqXG4gKiB1c2VEb21FdmVudChyZWYsICd3aGVlbCcsIG9uV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSlcbiAqXG4gKiByZXR1cm4gPGRpdiByZWY9e3JlZn0gLz5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSByZWYgLSBSZWFjdC5SZWZPYmplY3QgdGhhdCdzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gYmluZCB0aGUgbGlzdGVuZXIgdG8uXG4gKiBAcGFyYW0gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgeW91IHdhbnQgbGlzdGVuIGZvci5cbiAqIEBwYXJhbSBoYW5kbGVyIC0gRnVuY3Rpb24gdG8gZmlyZSB3aGVuIHJlY2VpdmluZyB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byBgRXZlbnQuYWRkRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VEb21FdmVudChyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChoYW5kbGVyICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGREb21FdmVudChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW3JlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zXSk7XG59XG5cbmV4cG9ydCB7IGFkZERvbUV2ZW50LCB1c2VEb21FdmVudCB9O1xuIiwgImltcG9ydCB7IGlzTW91c2VFdmVudCB9IGZyb20gJy4vdXRpbHMvZXZlbnQtdHlwZS5tanMnO1xuaW1wb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4uL3JlbmRlci91dGlscy90eXBlcy5tanMnO1xuaW1wb3J0IHsgdXNlUG9pbnRlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBpc0RyYWdBY3RpdmUgfSBmcm9tICcuL2RyYWcvdXRpbHMvbG9jay5tanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVIb3ZlckV2ZW50KHZpc3VhbEVsZW1lbnQsIGlzQWN0aXZlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWlzTW91c2VFdmVudChldmVudCkgfHwgaXNEcmFnQWN0aXZlKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnN1cmUgd2UgdHJpZ2dlciBhbmltYXRpb25zIGJlZm9yZSBmaXJpbmcgZXZlbnQgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Ib3ZlciwgaXNBY3RpdmUpO1xuICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXZlbnQsIGluZm8pO1xuICAgIH07XG59XG5mdW5jdGlvbiB1c2VIb3Zlckdlc3R1cmUoX2EpIHtcbiAgICB2YXIgb25Ib3ZlclN0YXJ0ID0gX2Eub25Ib3ZlclN0YXJ0LCBvbkhvdmVyRW5kID0gX2Eub25Ib3ZlckVuZCwgd2hpbGVIb3ZlciA9IF9hLndoaWxlSG92ZXIsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJlbnRlclwiLCBvbkhvdmVyU3RhcnQgfHwgd2hpbGVIb3ZlclxuICAgICAgICA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgdHJ1ZSwgb25Ib3ZlclN0YXJ0KVxuICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmxlYXZlXCIsIG9uSG92ZXJFbmQgfHwgd2hpbGVIb3ZlclxuICAgICAgICA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgZmFsc2UsIG9uSG92ZXJFbmQpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0IHsgdXNlSG92ZXJHZXN0dXJlIH07XG4iLCAiZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2ZW50KSB7XG4gICAgLy8gUG9pbnRlckV2ZW50IGluaGVyaXRzIGZyb20gTW91c2VFdmVudCBzbyB3ZSBjYW4ndCB1c2UgYSBzdHJhaWdodCBpbnN0YW5jZW9mIGNoZWNrLlxuICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHJldHVybiAhIShldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudDtcbn1cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICAgIHZhciBoYXNUb3VjaGVzID0gISFldmVudC50b3VjaGVzO1xuICAgIHJldHVybiBoYXNUb3VjaGVzO1xufVxuXG5leHBvcnQgeyBpc01vdXNlRXZlbnQsIGlzVG91Y2hFdmVudCB9O1xuIiwgImltcG9ydCB7IGFkZERvbUV2ZW50LCB1c2VEb21FdmVudCB9IGZyb20gJy4vdXNlLWRvbS1ldmVudC5tanMnO1xuaW1wb3J0IHsgd3JhcEhhbmRsZXIgfSBmcm9tICcuL2V2ZW50LWluZm8ubWpzJztcbmltcG9ydCB7IHN1cHBvcnRzUG9pbnRlckV2ZW50cywgc3VwcG9ydHNUb3VjaEV2ZW50cywgc3VwcG9ydHNNb3VzZUV2ZW50cyB9IGZyb20gJy4vdXRpbHMubWpzJztcblxudmFyIG1vdXNlRXZlbnROYW1lcyA9IHtcbiAgICBwb2ludGVyZG93bjogXCJtb3VzZWRvd25cIixcbiAgICBwb2ludGVybW92ZTogXCJtb3VzZW1vdmVcIixcbiAgICBwb2ludGVydXA6IFwibW91c2V1cFwiLFxuICAgIHBvaW50ZXJjYW5jZWw6IFwibW91c2VjYW5jZWxcIixcbiAgICBwb2ludGVyb3ZlcjogXCJtb3VzZW92ZXJcIixcbiAgICBwb2ludGVyb3V0OiBcIm1vdXNlb3V0XCIsXG4gICAgcG9pbnRlcmVudGVyOiBcIm1vdXNlZW50ZXJcIixcbiAgICBwb2ludGVybGVhdmU6IFwibW91c2VsZWF2ZVwiLFxufTtcbnZhciB0b3VjaEV2ZW50TmFtZXMgPSB7XG4gICAgcG9pbnRlcmRvd246IFwidG91Y2hzdGFydFwiLFxuICAgIHBvaW50ZXJtb3ZlOiBcInRvdWNobW92ZVwiLFxuICAgIHBvaW50ZXJ1cDogXCJ0b3VjaGVuZFwiLFxuICAgIHBvaW50ZXJjYW5jZWw6IFwidG91Y2hjYW5jZWxcIixcbn07XG5mdW5jdGlvbiBnZXRQb2ludGVyRXZlbnROYW1lKG5hbWUpIHtcbiAgICBpZiAoc3VwcG9ydHNQb2ludGVyRXZlbnRzKCkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN1cHBvcnRzVG91Y2hFdmVudHMoKSkge1xuICAgICAgICByZXR1cm4gdG91Y2hFdmVudE5hbWVzW25hbWVdO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdXBwb3J0c01vdXNlRXZlbnRzKCkpIHtcbiAgICAgICAgcmV0dXJuIG1vdXNlRXZlbnROYW1lc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBhZGRQb2ludGVyRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWRkRG9tRXZlbnQodGFyZ2V0LCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VQb2ludGVyRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXNlRG9tRXZlbnQocmVmLCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIGhhbmRsZXIgJiYgd3JhcEhhbmRsZXIoaGFuZGxlciwgZXZlbnROYW1lID09PSBcInBvaW50ZXJkb3duXCIpLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgYWRkUG9pbnRlckV2ZW50LCB1c2VQb2ludGVyRXZlbnQgfTtcbiIsICJpbXBvcnQgeyBpc1RvdWNoRXZlbnQgfSBmcm9tICcuLi9nZXN0dXJlcy91dGlscy9ldmVudC10eXBlLm1qcyc7XG5cbi8qKlxuICogRmlsdGVycyBvdXQgZXZlbnRzIG5vdCBhdHRhY2hlZCB0byB0aGUgcHJpbWFyeSBwb2ludGVyIChjdXJyZW50bHkgbGVmdCBtb3VzZSBidXR0b24pXG4gKiBAcGFyYW0gZXZlbnRIYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGZpbHRlclByaW1hcnlQb2ludGVyKGV2ZW50SGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzTW91c2VFdmVudCA9IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudDtcbiAgICAgICAgdmFyIGlzUHJpbWFyeVBvaW50ZXIgPSAhaXNNb3VzZUV2ZW50IHx8XG4gICAgICAgICAgICAoaXNNb3VzZUV2ZW50ICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCk7XG4gICAgICAgIGlmIChpc1ByaW1hcnlQb2ludGVyKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBkZWZhdWx0UGFnZVBvaW50ID0geyBwYWdlWDogMCwgcGFnZVk6IDAgfTtcbmZ1bmN0aW9uIHBvaW50RnJvbVRvdWNoKGUsIHBvaW50VHlwZSkge1xuICAgIGlmIChwb2ludFR5cGUgPT09IHZvaWQgMCkgeyBwb2ludFR5cGUgPSBcInBhZ2VcIjsgfVxuICAgIHZhciBwcmltYXJ5VG91Y2ggPSBlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB2YXIgcG9pbnQgPSBwcmltYXJ5VG91Y2ggfHwgZGVmYXVsdFBhZ2VQb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludFtwb2ludFR5cGUgKyBcIlhcIl0sXG4gICAgICAgIHk6IHBvaW50W3BvaW50VHlwZSArIFwiWVwiXSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcG9pbnRGcm9tTW91c2UocG9pbnQsIHBvaW50VHlwZSkge1xuICAgIGlmIChwb2ludFR5cGUgPT09IHZvaWQgMCkgeyBwb2ludFR5cGUgPSBcInBhZ2VcIjsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50W3BvaW50VHlwZSArIFwiWFwiXSxcbiAgICAgICAgeTogcG9pbnRbcG9pbnRUeXBlICsgXCJZXCJdLFxuICAgIH07XG59XG5mdW5jdGlvbiBleHRyYWN0RXZlbnRJbmZvKGV2ZW50LCBwb2ludFR5cGUpIHtcbiAgICBpZiAocG9pbnRUeXBlID09PSB2b2lkIDApIHsgcG9pbnRUeXBlID0gXCJwYWdlXCI7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogaXNUb3VjaEV2ZW50KGV2ZW50KVxuICAgICAgICAgICAgPyBwb2ludEZyb21Ub3VjaChldmVudCwgcG9pbnRUeXBlKVxuICAgICAgICAgICAgOiBwb2ludEZyb21Nb3VzZShldmVudCwgcG9pbnRUeXBlKSxcbiAgICB9O1xufVxudmFyIHdyYXBIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyKSB7XG4gICAgaWYgKHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyID09PSB2b2lkIDApIHsgc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPSBmYWxzZTsgfVxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcihldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyXG4gICAgICAgID8gZmlsdGVyUHJpbWFyeVBvaW50ZXIobGlzdGVuZXIpXG4gICAgICAgIDogbGlzdGVuZXI7XG59O1xuXG5leHBvcnQgeyBleHRyYWN0RXZlbnRJbmZvLCB3cmFwSGFuZGxlciB9O1xuIiwgImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4uL3V0aWxzL2lzLWJyb3dzZXIubWpzJztcblxuLy8gV2UgY2hlY2sgZm9yIGV2ZW50IHN1cHBvcnQgdmlhIGZ1bmN0aW9ucyBpbiBjYXNlIHRoZXkndmUgYmVlbiBtb2NrZWQgYnkgYSB0ZXN0aW5nIHN1aXRlLlxudmFyIHN1cHBvcnRzUG9pbnRlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnBvaW50ZXJkb3duID09PSBudWxsO1xufTtcbnZhciBzdXBwb3J0c1RvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc0Jyb3dzZXIgJiYgd2luZG93Lm9udG91Y2hzdGFydCA9PT0gbnVsbDtcbn07XG52YXIgc3VwcG9ydHNNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbm1vdXNlZG93biA9PT0gbnVsbDtcbn07XG5cbmV4cG9ydCB7IHN1cHBvcnRzTW91c2VFdmVudHMsIHN1cHBvcnRzUG9pbnRlckV2ZW50cywgc3VwcG9ydHNUb3VjaEV2ZW50cyB9O1xuIiwgImZ1bmN0aW9uIGNyZWF0ZUxvY2sobmFtZSkge1xuICAgIHZhciBsb2NrID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3BlbkxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NrID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxvY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvY2sgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9wZW5Mb2NrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxudmFyIGdsb2JhbEhvcml6b250YWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdIb3Jpem9udGFsXCIpO1xudmFyIGdsb2JhbFZlcnRpY2FsTG9jayA9IGNyZWF0ZUxvY2soXCJkcmFnVmVydGljYWxcIik7XG5mdW5jdGlvbiBnZXRHbG9iYWxMb2NrKGRyYWcpIHtcbiAgICB2YXIgbG9jayA9IGZhbHNlO1xuICAgIGlmIChkcmFnID09PSBcInlcIikge1xuICAgICAgICBsb2NrID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWcgPT09IFwieFwiKSB7XG4gICAgICAgIGxvY2sgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9wZW5Ib3Jpem9udGFsXzEgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgICAgICB2YXIgb3BlblZlcnRpY2FsXzEgPSBnbG9iYWxWZXJ0aWNhbExvY2soKTtcbiAgICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsXzEgJiYgb3BlblZlcnRpY2FsXzEpIHtcbiAgICAgICAgICAgIGxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb3Blbkhvcml6b250YWxfMSgpO1xuICAgICAgICAgICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVsZWFzZSB0aGUgbG9ja3MgYmVjYXVzZSB3ZSBkb24ndCB1c2UgdGhlbVxuICAgICAgICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsXzEpXG4gICAgICAgICAgICAgICAgb3Blbkhvcml6b250YWxfMSgpO1xuICAgICAgICAgICAgaWYgKG9wZW5WZXJ0aWNhbF8xKVxuICAgICAgICAgICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2s7XG59XG5mdW5jdGlvbiBpc0RyYWdBY3RpdmUoKSB7XG4gICAgLy8gQ2hlY2sgdGhlIGdlc3R1cmUgbG9jayAtIGlmIHdlIGdldCBpdCwgaXQgbWVhbnMgbm8gZHJhZyBnZXN0dXJlIGlzIGFjdGl2ZVxuICAgIC8vIGFuZCB3ZSBjYW4gc2FmZWx5IGZpcmUgdGhlIHRhcCBnZXN0dXJlLlxuICAgIHZhciBvcGVuR2VzdHVyZUxvY2sgPSBnZXRHbG9iYWxMb2NrKHRydWUpO1xuICAgIGlmICghb3Blbkdlc3R1cmVMb2NrKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBvcGVuR2VzdHVyZUxvY2soKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2ssIGdldEdsb2JhbExvY2ssIGlzRHJhZ0FjdGl2ZSB9O1xuIiwgImltcG9ydCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzTm9kZU9yQ2hpbGQgfSBmcm9tICcuL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzJztcbmltcG9ydCB7IHVzZVBvaW50ZXJFdmVudCwgYWRkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyB1c2VVbm1vdW50RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlLXVubW91bnQtZWZmZWN0Lm1qcyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IEFuaW1hdGlvblR5cGUgfSBmcm9tICcuLi9yZW5kZXIvdXRpbHMvdHlwZXMubWpzJztcbmltcG9ydCB7IGlzRHJhZ0FjdGl2ZSB9IGZyb20gJy4vZHJhZy91dGlscy9sb2NrLm1qcyc7XG5cbi8qKlxuICogQHBhcmFtIGhhbmRsZXJzIC1cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VUYXBHZXN0dXJlKF9hKSB7XG4gICAgdmFyIG9uVGFwID0gX2Eub25UYXAsIG9uVGFwU3RhcnQgPSBfYS5vblRhcFN0YXJ0LCBvblRhcENhbmNlbCA9IF9hLm9uVGFwQ2FuY2VsLCB3aGlsZVRhcCA9IF9hLndoaWxlVGFwLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudDtcbiAgICB2YXIgaGFzUHJlc3NMaXN0ZW5lcnMgPSBvblRhcCB8fCBvblRhcFN0YXJ0IHx8IG9uVGFwQ2FuY2VsIHx8IHdoaWxlVGFwO1xuICAgIHZhciBpc1ByZXNzaW5nID0gdXNlUmVmKGZhbHNlKTtcbiAgICB2YXIgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycyA9IHVzZVJlZihudWxsKTtcbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzKTtcbiAgICAgICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRW5kKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgICAgICBpc1ByZXNzaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLlRhcCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gIWlzRHJhZ0FjdGl2ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCwgaW5mbykge1xuICAgICAgICBpZiAoIWNoZWNrUG9pbnRlckVuZCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2Ugb25seSBjb3VudCB0aGlzIGFzIGEgdGFwIGdlc3R1cmUgaWYgdGhlIGV2ZW50LnRhcmdldCBpcyB0aGUgc2FtZVxuICAgICAgICAgKiBhcywgb3IgYSBjaGlsZCBvZiwgdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICAhaXNOb2RlT3JDaGlsZCh2aXN1YWxFbGVtZW50LmdldEluc3RhbmNlKCksIGV2ZW50LnRhcmdldClcbiAgICAgICAgICAgID8gb25UYXBDYW5jZWwgPT09IG51bGwgfHwgb25UYXBDYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwQ2FuY2VsKGV2ZW50LCBpbmZvKVxuICAgICAgICAgICAgOiBvblRhcCA9PT0gbnVsbCB8fCBvblRhcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25UYXAoZXZlbnQsIGluZm8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJDYW5jZWwoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgaWYgKCFjaGVja1BvaW50ZXJFbmQoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb25UYXBDYW5jZWwgPT09IG51bGwgfHwgb25UYXBDYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwQ2FuY2VsKGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgaW5mbykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgICAgICBpZiAoaXNQcmVzc2luZy5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc1ByZXNzaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBwaXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlckNhbmNlbCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5zdXJlIHdlIHRyaWdnZXIgYW5pbWF0aW9ucyBiZWZvcmUgZmlyaW5nIGV2ZW50IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuVGFwLCB0cnVlKTtcbiAgICAgICAgb25UYXBTdGFydCA9PT0gbnVsbCB8fCBvblRhcFN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblRhcFN0YXJ0KGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgaGFzUHJlc3NMaXN0ZW5lcnMgPyBvblBvaW50ZXJEb3duIDogdW5kZWZpbmVkKTtcbiAgICB1c2VVbm1vdW50RWZmZWN0KHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcik7XG59XG5cbmV4cG9ydCB7IHVzZVRhcEdlc3R1cmUgfTtcbiIsICIvKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHVwIHRoZSB0cmVlIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNoaWxkIG5vZGVcbiAqIGlzIHRoZSBwYXJlbnQgb3IgYSBkZXNjZW5kYW50IG9mIGl0LlxuICpcbiAqIEBwYXJhbSBwYXJlbnQgLSBFbGVtZW50IHRvIGZpbmRcbiAqIEBwYXJhbSBjaGlsZCAtIEVsZW1lbnQgdG8gdGVzdCBhZ2FpbnN0IHBhcmVudFxuICovXG52YXIgaXNOb2RlT3JDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudCA9PT0gY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNOb2RlT3JDaGlsZChwYXJlbnQsIGNoaWxkLnBhcmVudEVsZW1lbnQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGlzTm9kZU9yQ2hpbGQgfTtcbiIsICJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIHVzZVVubW91bnRFZmZlY3QoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH07IH0sIFtdKTtcbn1cblxuZXhwb3J0IHsgdXNlVW5tb3VudEVmZmVjdCB9O1xuIiwgImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci91dGlscy90eXBlcy5tanMnO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi8uLi91dGlscy93YXJuLW9uY2UubWpzJztcbmltcG9ydCB7IG9ic2VydmVJbnRlcnNlY3Rpb24gfSBmcm9tICcuL29ic2VydmVycy5tanMnO1xuXG5mdW5jdGlvbiB1c2VWaWV3cG9ydChfYSkge1xuICAgIHZhciB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgd2hpbGVJblZpZXcgPSBfYS53aGlsZUluVmlldywgb25WaWV3cG9ydEVudGVyID0gX2Eub25WaWV3cG9ydEVudGVyLCBvblZpZXdwb3J0TGVhdmUgPSBfYS5vblZpZXdwb3J0TGVhdmUsIF9iID0gX2Eudmlld3BvcnQsIHZpZXdwb3J0ID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgdmFyIHN0YXRlID0gdXNlUmVmKHtcbiAgICAgICAgaGFzRW50ZXJlZFZpZXc6IGZhbHNlLFxuICAgICAgICBpc0luVmlldzogZmFsc2UsXG4gICAgfSk7XG4gICAgdmFyIHNob3VsZE9ic2VydmUgPSBCb29sZWFuKHdoaWxlSW5WaWV3IHx8IG9uVmlld3BvcnRFbnRlciB8fCBvblZpZXdwb3J0TGVhdmUpO1xuICAgIGlmICh2aWV3cG9ydC5vbmNlICYmIHN0YXRlLmN1cnJlbnQuaGFzRW50ZXJlZFZpZXcpXG4gICAgICAgIHNob3VsZE9ic2VydmUgPSBmYWxzZTtcbiAgICB2YXIgdXNlT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyB1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgOiB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICB1c2VPYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZS5jdXJyZW50LCB2aXN1YWxFbGVtZW50LCB2aWV3cG9ydCk7XG59XG52YXIgdGhyZXNob2xkTmFtZXMgPSB7XG4gICAgc29tZTogMCxcbiAgICBhbGw6IDEsXG59O1xuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIF9hKSB7XG4gICAgdmFyIHJvb3QgPSBfYS5yb290LCByb290TWFyZ2luID0gX2EubWFyZ2luLCBfYiA9IF9hLmFtb3VudCwgYW1vdW50ID0gX2IgPT09IHZvaWQgMCA/IFwic29tZVwiIDogX2IsIG9uY2UgPSBfYS5vbmNlO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvdWxkT2JzZXJ2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByb290OiByb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QuY3VycmVudCxcbiAgICAgICAgICAgIHJvb3RNYXJnaW46IHJvb3RNYXJnaW4sXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGROYW1lc1thbW91bnRdLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIGJlZW4gbm8gY2hhbmdlIGluIHRoZSB2aWV3cG9ydCBzdGF0ZSwgZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNJblZpZXcgPT09IGlzSW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXRlLmlzSW5WaWV3ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZSBoYXNFbnRlcmVkVmlldy4gSWYgdGhpcyBpcyBvbmx5IG1lYW50IHRvIHJ1biBvbmNlLCBhbmRcbiAgICAgICAgICAgICAqIGVsZW1lbnQgaXNuJ3QgdmlzaWJsZSwgZWFybHkgcmV0dXJuLiBPdGhlcndpc2Ugc2V0IGhhc0VudGVyZWRWaWV3IHRvIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvbmNlICYmICFpc0ludGVyc2VjdGluZyAmJiBzdGF0ZS5oYXNFbnRlcmVkVmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkluVmlldywgaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2UgdGhlIGxhdGVzdCBjb21taXR0ZWQgcHJvcHMgcmF0aGVyIHRoYW4gdGhlIG9uZXMgaW4gc2NvcGVcbiAgICAgICAgICAgICAqIHdoZW4gdGhpcyBvYnNlcnZlciBpcyBjcmVhdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGlzSW50ZXJzZWN0aW5nXG4gICAgICAgICAgICAgICAgPyBwcm9wcy5vblZpZXdwb3J0RW50ZXJcbiAgICAgICAgICAgICAgICA6IHByb3BzLm9uVmlld3BvcnRMZWF2ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlbnRyeSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvYnNlcnZlSW50ZXJzZWN0aW9uKHZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKSwgb3B0aW9ucywgaW50ZXJzZWN0aW9uQ2FsbGJhY2spO1xuICAgIH0sIFtzaG91bGRPYnNlcnZlLCByb290LCByb290TWFyZ2luLCBhbW91bnRdKTtcbn1cbi8qKlxuICogSWYgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgbWlzc2luZywgd2UgYWN0aXZhdGUgaW5WaWV3IGFuZCBmaXJlIG9uVmlld3BvcnRFbnRlclxuICogb24gbW91bnQuIFRoaXMgd2F5LCB0aGUgcGFnZSB3aWxsIGJlIGluIHRoZSBzdGF0ZSB0aGUgYXV0aG9yIGV4cGVjdHMgdXNlcnNcbiAqIHRvIHNlZSBpdCBpbiBmb3IgZXZlcnlvbmUuXG4gKi9cbmZ1bmN0aW9uIHVzZU1pc3NpbmdJbnRlcnNlY3Rpb25PYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZSwgdmlzdWFsRWxlbWVudCwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5mYWxsYmFjaywgZmFsbGJhY2sgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvdWxkT2JzZXJ2ZSB8fCAhZmFsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGZhbHNlLCBcIkludGVyc2VjdGlvbk9ic2VydmVyIG5vdCBhdmFpbGFibGUgb24gdGhpcyBkZXZpY2UuIHdoaWxlSW5WaWV3IGFuaW1hdGlvbnMgd2lsbCB0cmlnZ2VyIG9uIG1vdW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZSB0aGlzIGluIGFuIHJBRiBiZWNhdXNlLCBhdCB0aGlzIHBvaW50LCB0aGUgYW5pbWF0aW9uIHN0YXRlXG4gICAgICAgICAqIHdvbid0IGhhdmUgZmx1c2hlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kIHRoZXJlJ3MgY2VydGFpbiBsb2dpYyBpblxuICAgICAgICAgKiB0aGVyZSB0aGF0IGJlaGF2ZXMgZGlmZmVyZW50bHkgb24gdGhlIGluaXRpYWwgYW5pbWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGhvb2sgc2hvdWxkIGJlIHF1aXRlIHJhcmVseSBjYWxsZWQgc28gc2V0dGluZyB0aGlzIGluIGFuIHJBRlxuICAgICAgICAgKiBpcyBwcmVmZXJyZWQgdG8gY2hhbmdpbmcgdGhlIGJlaGF2aW91ciBvZiB0aGUgYW5pbWF0aW9uIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHN0YXRlLmhhc0VudGVyZWRWaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvblZpZXdwb3J0RW50ZXIgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkub25WaWV3cG9ydEVudGVyO1xuICAgICAgICAgICAgb25WaWV3cG9ydEVudGVyID09PSBudWxsIHx8IG9uVmlld3BvcnRFbnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25WaWV3cG9ydEVudGVyKG51bGwpO1xuICAgICAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkluVmlldywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtzaG91bGRPYnNlcnZlXSk7XG59XG5cbmV4cG9ydCB7IHVzZVZpZXdwb3J0IH07XG4iLCAidmFyIHdhcm5lZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHdhcm5PbmNlKGNvbmRpdGlvbiwgbWVzc2FnZSwgZWxlbWVudCkge1xuICAgIGlmIChjb25kaXRpb24gfHwgd2FybmVkLmhhcyhtZXNzYWdlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICBpZiAoZWxlbWVudClcbiAgICAgICAgY29uc29sZS53YXJuKGVsZW1lbnQpO1xuICAgIHdhcm5lZC5hZGQobWVzc2FnZSk7XG59XG5cbmV4cG9ydCB7IHdhcm5PbmNlIH07XG4iLCAiaW1wb3J0IHsgX19yZXN0LCBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcblxuLyoqXG4gKiBNYXAgYW4gSW50ZXJzZWN0aW9uSGFuZGxlciBjYWxsYmFjayB0byBhbiBlbGVtZW50LiBXZSBvbmx5IGV2ZXIgbWFrZSBvbmUgaGFuZGxlciBmb3Igb25lXG4gKiBlbGVtZW50LCBzbyBldmVuIHRob3VnaCB0aGVzZSBoYW5kbGVycyBtaWdodCBhbGwgYmUgdHJpZ2dlcmVkIGJ5IGRpZmZlcmVudFxuICogb2JzZXJ2ZXJzLCB3ZSBjYW4ga2VlcCB0aGVtIGluIHRoZSBzYW1lIG1hcC5cbiAqL1xudmFyIG9ic2VydmVyQ2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogTXVsdGlwbGUgb2JzZXJ2ZXJzIGNhbiBiZSBjcmVhdGVkIGZvciBtdWx0aXBsZSBlbGVtZW50L2RvY3VtZW50IHJvb3RzLiBFYWNoIHdpdGhcbiAqIGRpZmZlcmVudCBzZXR0aW5ncy4gU28gaGVyZSB3ZSBzdG9yZSBkaWN0aW9uYXJpZXMgb2Ygb2JzZXJ2ZXJzIHRvIGVhY2ggcm9vdCxcbiAqIHVzaW5nIHNlcmlhbGlzZWQgc2V0dGluZ3MgKHRocmVzaG9sZC9tYXJnaW4pIGFzIGxvb2t1cCBrZXlzLlxuICovXG52YXIgb2JzZXJ2ZXJzID0gbmV3IFdlYWtNYXAoKTtcbnZhciBmaXJlT2JzZXJ2ZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBvYnNlcnZlckNhbGxiYWNrcy5nZXQoZW50cnkudGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKGVudHJ5KTtcbn07XG52YXIgZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICBlbnRyaWVzLmZvckVhY2goZmlyZU9ic2VydmVyQ2FsbGJhY2spO1xufTtcbmZ1bmN0aW9uIGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihfYSkge1xuICAgIHZhciByb290ID0gX2Eucm9vdCwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wicm9vdFwiXSk7XG4gICAgdmFyIGxvb2t1cFJvb3QgPSByb290IHx8IGRvY3VtZW50O1xuICAgIC8qKlxuICAgICAqIElmIHdlIGRvbid0IGhhdmUgYW4gb2JzZXJ2ZXIgbG9va3VwIG1hcCBmb3IgdGhpcyByb290LCBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIGlmICghb2JzZXJ2ZXJzLmhhcyhsb29rdXBSb290KSkge1xuICAgICAgICBvYnNlcnZlcnMuc2V0KGxvb2t1cFJvb3QsIHt9KTtcbiAgICB9XG4gICAgdmFyIHJvb3RPYnNlcnZlcnMgPSBvYnNlcnZlcnMuZ2V0KGxvb2t1cFJvb3QpO1xuICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFuIG9ic2VydmVyIGZvciB0aGlzIGNvbWJpbmF0aW9uIG9mIHJvb3QgYW5kIHNldHRpbmdzLFxuICAgICAqIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgaWYgKCFyb290T2JzZXJ2ZXJzW2tleV0pIHtcbiAgICAgICAgcm9vdE9ic2VydmVyc1trZXldID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcywgX19hc3NpZ24oeyByb290OiByb290IH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RPYnNlcnZlcnNba2V5XTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlciA9IGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihvcHRpb25zKTtcbiAgICBvYnNlcnZlckNhbGxiYWNrcy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvYnNlcnZlckNhbGxiYWNrcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IG9ic2VydmVJbnRlcnNlY3Rpb24gfTtcbiIsICJ2YXIgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaG9vayhwcm9wcyk7XG4gICAgcmV0dXJuIG51bGw7XG59OyB9O1xuXG5leHBvcnQgeyBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCB9O1xuIiwgImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzQW5pbWF0aW9uQ29udHJvbHMgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvaXMtYW5pbWF0aW9uLWNvbnRyb2xzLm1qcyc7XG5pbXBvcnQgeyB1c2VQcmVzZW5jZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL3VzZS1wcmVzZW5jZS5tanMnO1xuaW1wb3J0IHsgUHJlc2VuY2VDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcbmltcG9ydCB7IGNyZWF0ZUFuaW1hdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL2FuaW1hdGlvbi1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy90eXBlcy5tanMnO1xuaW1wb3J0IHsgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgfSBmcm9tICcuLi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qcyc7XG5cbnZhciBhbmltYXRpb25zID0ge1xuICAgIGFuaW1hdGlvbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgYW5pbWF0ZSA9IF9hLmFuaW1hdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBkeW5hbWljYWxseSBnZW5lcmF0ZSB0aGUgQW5pbWF0aW9uU3RhdGUgbWFuYWdlciBhcyBpdCBjb250YWlucyBhIHJlZmVyZW5jZVxuICAgICAgICAgKiB0byB0aGUgdW5kZXJseWluZyBhbmltYXRpb24gbGlicmFyeS4gV2Ugb25seSB3YW50IHRvIGxvYWQgdGhhdCBpZiB3ZSBsb2FkIHRoaXMsXG4gICAgICAgICAqIHNvIHBlb3BsZSBjYW4gb3B0aW9uYWxseSBjb2RlIHNwbGl0IGl0IG91dCB1c2luZyB0aGUgYG1gIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgfHwgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgPSBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJzY3JpYmUgYW55IHByb3ZpZGVkIEFuaW1hdGlvbkNvbnRyb2xzIHRvIHRoZSBjb21wb25lbnQncyBWaXN1YWxFbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNBbmltYXRpb25Db250cm9scyhhbmltYXRlKSkge1xuICAgICAgICAgICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGUuc3Vic2NyaWJlKHZpc3VhbEVsZW1lbnQpOyB9LCBbYW5pbWF0ZV0pO1xuICAgICAgICB9XG4gICAgfSksXG4gICAgZXhpdDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBjdXN0b20gPSBwcm9wcy5jdXN0b20sIHZpc3VhbEVsZW1lbnQgPSBwcm9wcy52aXN1YWxFbGVtZW50O1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodXNlUHJlc2VuY2UoKSwgMiksIGlzUHJlc2VudCA9IF9hWzBdLCBzYWZlVG9SZW1vdmUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcbiAgICAgICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRXhpdCwgIWlzUHJlc2VudCwgeyBjdXN0b206IChfYiA9IHByZXNlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBwcmVzZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlbmNlQ29udGV4dC5jdXN0b20pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGN1c3RvbSB9KTtcbiAgICAgICAgICAgICFpc1ByZXNlbnQgJiYgKGFuaW1hdGlvbiA9PT0gbnVsbCB8fCBhbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuaW1hdGlvbi50aGVuKHNhZmVUb1JlbW92ZSkpO1xuICAgICAgICB9LCBbaXNQcmVzZW50XSk7XG4gICAgfSksXG59O1xuXG5leHBvcnQgeyBhbmltYXRpb25zIH07XG4iLCAiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJlc2VuY2VDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWlkLm1qcyc7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCBpcyB0aGUgY2hpbGQgb2YgYEFuaW1hdGVQcmVzZW5jZWAsIGl0IGNhbiB1c2UgYHVzZVByZXNlbmNlYFxuICogdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IHdoZXRoZXIgaXQncyBzdGlsbCBwcmVzZW50IGluIHRoZSBSZWFjdCB0cmVlLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgdXNlUHJlc2VuY2UgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBzZXRUaW1lb3V0KHNhZmVUb1JlbW92ZSwgMTAwMClcbiAqICAgfSwgW2lzUHJlc2VudF0pXG4gKlxuICogICByZXR1cm4gPGRpdiAvPlxuICogfVxuICogYGBgXG4gKlxuICogSWYgYGlzUHJlc2VudGAgaXMgYGZhbHNlYCwgaXQgbWVhbnMgdGhhdCBhIGNvbXBvbmVudCBoYXMgYmVlbiByZW1vdmVkIHRoZSB0cmVlLCBidXRcbiAqIGBBbmltYXRlUHJlc2VuY2VgIHdvbid0IHJlYWxseSByZW1vdmUgaXQgdW50aWwgYHNhZmVUb1JlbW92ZWAgaGFzIGJlZW4gY2FsbGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlUHJlc2VuY2UoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbdHJ1ZSwgbnVsbF07XG4gICAgdmFyIGlzUHJlc2VudCA9IGNvbnRleHQuaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSA9IGNvbnRleHQub25FeGl0Q29tcGxldGUsIHJlZ2lzdGVyID0gY29udGV4dC5yZWdpc3RlcjtcbiAgICAvLyBJdCdzIHNhZmUgdG8gY2FsbCB0aGUgZm9sbG93aW5nIGhvb2tzIGNvbmRpdGlvbmFsbHkgKGFmdGVyIGFuIGVhcmx5IHJldHVybikgYmVjYXVzZSB0aGUgY29udGV4dCB3aWxsIGFsd2F5c1xuICAgIC8vIGVpdGhlciBiZSBudWxsIG9yIG5vbi1udWxsIGZvciB0aGUgbGlmZXNwYW4gb2YgdGhlIGNvbXBvbmVudC5cbiAgICAvLyBSZXBsYWNlIHdpdGggdXNlSWQgd2hlbiByZWxlYXNlZCBpbiBSZWFjdFxuICAgIHZhciBpZCA9IHVzZUlkKCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ2lzdGVyKGlkKTsgfSwgW10pO1xuICAgIHZhciBzYWZlVG9SZW1vdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvbkV4aXRDb21wbGV0ZSA9PT0gbnVsbCB8fCBvbkV4aXRDb21wbGV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FeGl0Q29tcGxldGUoaWQpOyB9O1xuICAgIHJldHVybiAhaXNQcmVzZW50ICYmIG9uRXhpdENvbXBsZXRlID8gW2ZhbHNlLCBzYWZlVG9SZW1vdmVdIDogW3RydWVdO1xufVxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VQcmVzZW5jZWAsIGV4Y2VwdCBgdXNlSXNQcmVzZW50YCBzaW1wbHkgcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHByZXNlbnQuXG4gKiBUaGVyZSBpcyBubyBgc2FmZVRvUmVtb3ZlYCBmdW5jdGlvbi5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IHVzZUlzUHJlc2VudCB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBleHBvcnQgY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBpc1ByZXNlbnQgPSB1c2VJc1ByZXNlbnQoKVxuICpcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgICAhaXNQcmVzZW50ICYmIGNvbnNvbGUubG9nKFwiSSd2ZSBiZWVuIHJlbW92ZWQhXCIpXG4gKiAgIH0sIFtpc1ByZXNlbnRdKVxuICpcbiAqICAgcmV0dXJuIDxkaXYgLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlSXNQcmVzZW50KCkge1xuICAgIHJldHVybiBpc1ByZXNlbnQodXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpKTtcbn1cbmZ1bmN0aW9uIGlzUHJlc2VudChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQgPT09IG51bGwgPyB0cnVlIDogY29udGV4dC5pc1ByZXNlbnQ7XG59XG5cbmV4cG9ydCB7IGlzUHJlc2VudCwgdXNlSXNQcmVzZW50LCB1c2VQcmVzZW5jZSB9O1xuIiwgImltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi91c2UtY29uc3RhbnQubWpzJztcblxudmFyIGNvdW50ZXIgPSAwO1xudmFyIGluY3JlbWVudElkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnRlcisrOyB9O1xudmFyIHVzZUlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXNlQ29uc3RhbnQoaW5jcmVtZW50SWQpOyB9O1xuLyoqXG4gKiBJZGVhbGx5IHdlJ2QgdXNlIHRoZSBmb2xsb3dpbmcgY29kZSB0byBzdXBwb3J0IFJlYWN0IDE4IG9wdGlvbmFsbHkuXG4gKiBCdXQgdGhpcyBmYWlybHkgZmFpbHMgaW4gV2VicGFjayAob3RoZXJ3aXNlIHRyZWVzaGFraW5nIHdvdWxkbid0IHdvcmsgYXQgYWxsKS5cbiAqIE5lZWQgdG8gY29tZSB1cCB3aXRoIGEgZGlmZmVyZW50IHdheSBvZiBmaWd1cmluZyB0aGlzIG91dC5cbiAqL1xuLy8gZXhwb3J0IGNvbnN0IHVzZUlkID0gKFJlYWN0IGFzIGFueSkudXNlSWRcbi8vICAgICA/IChSZWFjdCBhcyBhbnkpLnVzZUlkXG4vLyAgICAgOiAoKSA9PiB1c2VDb25zdGFudChpbmNyZW1lbnRJZClcblxuZXhwb3J0IHsgdXNlSWQgfTtcbiIsICJpbXBvcnQgeyBfX3NwcmVhZEFycmF5LCBfX3JlYWQsIF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpc0FuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanMnO1xuaW1wb3J0IHsgaXNLZXlmcmFtZXNUYXJnZXQgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvaXMta2V5ZnJhbWVzLXRhcmdldC5tanMnO1xuaW1wb3J0IHsgc2hhbGxvd0NvbXBhcmUgfSBmcm9tICcuLi8uLi91dGlscy9zaGFsbG93LWNvbXBhcmUubWpzJztcbmltcG9ydCB7IGFuaW1hdGVWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi9hbmltYXRpb24ubWpzJztcbmltcG9ydCB7IEFuaW1hdGlvblR5cGUgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBpc1ZhcmlhbnRMYWJlbHMsIHJlc29sdmVWYXJpYW50LCBpc1ZhcmlhbnRMYWJlbCB9IGZyb20gJy4vdmFyaWFudHMubWpzJztcblxudmFyIHZhcmlhbnRQcmlvcml0eU9yZGVyID0gW1xuICAgIEFuaW1hdGlvblR5cGUuQW5pbWF0ZSxcbiAgICBBbmltYXRpb25UeXBlLkluVmlldyxcbiAgICBBbmltYXRpb25UeXBlLkZvY3VzLFxuICAgIEFuaW1hdGlvblR5cGUuSG92ZXIsXG4gICAgQW5pbWF0aW9uVHlwZS5UYXAsXG4gICAgQW5pbWF0aW9uVHlwZS5EcmFnLFxuICAgIEFuaW1hdGlvblR5cGUuRXhpdCxcbl07XG52YXIgcmV2ZXJzZVByaW9yaXR5T3JkZXIgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmFyaWFudFByaW9yaXR5T3JkZXIpLCBmYWxzZSkucmV2ZXJzZSgpO1xudmFyIG51bUFuaW1hdGlvblR5cGVzID0gdmFyaWFudFByaW9yaXR5T3JkZXIubGVuZ3RoO1xuZnVuY3Rpb24gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX2EuYW5pbWF0aW9uLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBhbmltYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvblN0YXRlKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgYW5pbWF0ZSA9IGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpO1xuICAgIHZhciBzdGF0ZSA9IGNyZWF0ZVN0YXRlKCk7XG4gICAgdmFyIGFsbEFuaW1hdGVkS2V5cyA9IHt9O1xuICAgIHZhciBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlZHVjZSB0aGUgYW5pbWF0aW9uIGRlZmluaXRpb25zIGZvclxuICAgICAqIGVhY2ggYWN0aXZlIGFuaW1hdGlvbiB0eXBlIGludG8gYW4gb2JqZWN0IG9mIHJlc29sdmVkIHZhbHVlcyBmb3IgaXQuXG4gICAgICovXG4gICAgdmFyIGJ1aWxkUmVzb2x2ZWRUeXBlVmFsdWVzID0gZnVuY3Rpb24gKGFjYywgZGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZC50cmFuc2l0aW9uOyB2YXIgdHJhbnNpdGlvbkVuZCA9IHJlc29sdmVkLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IF9fcmVzdChyZXNvbHZlZCwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgICAgICAgICAgYWNjID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGFjYyksIHRhcmdldCksIHRyYW5zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc0FuaW1hdGVkKGtleSkge1xuICAgICAgICByZXR1cm4gYWxsQW5pbWF0ZWRLZXlzW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBqdXN0IGFsbG93cyB1cyB0byBpbmplY3QgbW9ja2VkIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBbmltYXRlRnVuY3Rpb24obWFrZUFuaW1hdG9yKSB7XG4gICAgICAgIGFuaW1hdGUgPSBtYWtlQW5pbWF0b3IodmlzdWFsRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgcmVjZWl2ZSBuZXcgcHJvcHMsIHdlIG5lZWQgdG86XG4gICAgICogMS4gQ3JlYXRlIGEgbGlzdCBvZiBwcm90ZWN0ZWQga2V5cyBmb3IgZWFjaCB0eXBlLiBUaGlzIGlzIGEgZGlyZWN0b3J5IG9mXG4gICAgICogICAgdmFsdWUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgXCJoYW5kbGVkXCIgYnkgdHlwZXMgb2YgYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgKiAgICBzbyB0aGF0IHdoZW5ldmVyIGFuIGFuaW1hdGlvbiBpcyBwbGF5ZWQgb2YgYSBnaXZlbiB0eXBlLCB0aGVzZSB2YWx1ZXMgYXJlXG4gICAgICogICAgcHJvdGVjdGVkIGZyb20gYmVpbmcgYW5pbWF0ZWQuXG4gICAgICogMi4gRGV0ZXJtaW5lIGlmIGFuIGFuaW1hdGlvbiB0eXBlIG5lZWRzIGFuaW1hdGluZy5cbiAgICAgKiAzLiBEZXRlcm1pbmUgaWYgYW55IHZhbHVlcyBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIGEgdHlwZSBhbmQgZmlndXJlIG91dFxuICAgICAqICAgIHdoYXQgdG8gYW5pbWF0ZSB0aG9zZSB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmltYXRlQ2hhbmdlcyhvcHRpb25zLCBjaGFuZ2VkQWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB2aXN1YWxFbGVtZW50LmdldFZhcmlhbnRDb250ZXh0KHRydWUpIHx8IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGFuaW1hdGlvbnMgdGhhdCB3ZSdsbCBidWlsZCBpbnRvIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIHR5cGVzLiBUaGlzIHdpbGwgZ2V0IGV4ZWN1dGVkIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXAgdHJhY2sgb2Ygd2hpY2ggdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLiBUaGVuLCBhcyB3ZSBoaXQgbG93ZXIgcHJpb3JpdHlcbiAgICAgICAgICogYW5pbWF0aW9uIHR5cGVzLCB3ZSBjYW4gY2hlY2sgaWYgdGhleSBjb250YWluIHJlbW92ZWQgdmFsdWVzIGFuZCBhbmltYXRlIHRvIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcmVtb3ZlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRpY3Rpb25hcnkgb2YgYWxsIGVuY291bnRlcmVkIGtleXMuIFRoaXMgaXMgYW4gb2JqZWN0IHRvIGxldCB1cyBidWlsZCBpbnRvIGFuZFxuICAgICAgICAgKiBjb3B5IGl0IHdpdGhvdXQgaXRlcmF0aW9uLiBFYWNoIHRpbWUgd2UgaGl0IGFuIGFuaW1hdGlvbiB0eXBlIHdlIHNldCBpdHMgcHJvdGVjdGVkXG4gICAgICAgICAqIGtleXMgLSB0aGUga2V5cyBpdHMgbm90IGFsbG93ZWQgdG8gYW5pbWF0ZSAtIHRvIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBlbmNvdW50ZXJlZEtleXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgdmFyaWFudCBoYXMgYmVlbiByZW1vdmVkIGF0IGEgZ2l2ZW4gaW5kZXgsIGFuZCB0aGlzIGNvbXBvbmVudCBpcyBjb250cm9sbGluZ1xuICAgICAgICAgKiB2YXJpYW50IGFuaW1hdGlvbnMsIHdlIHdhbnQgdG8gZW5zdXJlIGxvd2VyLXByaW9yaXR5IHZhcmlhbnRzIGFyZSBmb3JjZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByZW1vdmVkVmFyaWFudEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gcmV2ZXJzZVByaW9yaXR5T3JkZXJbaV07XG4gICAgICAgICAgICB2YXIgdHlwZVN0YXRlID0gc3RhdGVbdHlwZV07XG4gICAgICAgICAgICB2YXIgcHJvcCA9IChfYSA9IHByb3BzW3R5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250ZXh0W3R5cGVdO1xuICAgICAgICAgICAgdmFyIHByb3BJc1ZhcmlhbnQgPSBpc1ZhcmlhbnRMYWJlbChwcm9wKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyB0eXBlIGhhcyAqanVzdCogY2hhbmdlZCBpc0FjdGl2ZSBzdGF0dXMsIHNldCBhY3RpdmVEZWx0YVxuICAgICAgICAgICAgICogdG8gdGhhdCBzdGF0dXMuIE90aGVyd2lzZSBzZXQgdG8gbnVsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGFjdGl2ZURlbHRhID0gdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgPyB0eXBlU3RhdGUuaXNBY3RpdmUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZW1vdmVkVmFyaWFudEluZGV4ID0gaTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBwcm9wIGlzIGFuIGluaGVyaXRlZCB2YXJpYW50LCByYXRoZXIgdGhhbiBiZWVuIHNldCBkaXJlY3RseSBvbiB0aGVcbiAgICAgICAgICAgICAqIGNvbXBvbmVudCBpdHNlbGYsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFsbG93IHRoZSBwYXJlbnQgdG8gdHJpZ2dlciBhbmltYXRpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IENhbiBwcm9iYWJseSBjaGFuZ2UgdGhpcyB0byBhICFpc0NvbnRyb2xsaW5nVmFyaWFudHMgY2hlY2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGlzSW5oZXJpdGVkID0gcHJvcCA9PT0gY29udGV4dFt0eXBlXSAmJiBwcm9wICE9PSBwcm9wc1t0eXBlXSAmJiBwcm9wSXNWYXJpYW50O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNJbmhlcml0ZWQgJiZcbiAgICAgICAgICAgICAgICBpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgICAgICBpc0luaGVyaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIGVuY291bnRlcmVkIGtleXMgc28gZmFyIGFzIHRoZSBwcm90ZWN0ZWQga2V5cyBmb3IgdGhpcyB0eXBlLiBUaGlzIHdpbGxcbiAgICAgICAgICAgICAqIGJlIGFueSBrZXkgdGhhdCBoYXMgYmVlbiBhbmltYXRlZCBvciBvdGhlcndpc2UgaGFuZGxlZCBieSBhY3RpdmUsIGhpZ2hlci1wcmlvcnRpeSB0eXBlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXMgPSBfX2Fzc2lnbih7fSwgZW5jb3VudGVyZWRLZXlzKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBza2lwIGFuYWx5c2luZyB0aGlzIHByb3AgZWFybHlcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IGFjdGl2ZSBhbmQgaGFzbid0ICpqdXN0KiBiZWVuIHNldCBhcyBpbmFjdGl2ZVxuICAgICAgICAgICAgKCF0eXBlU3RhdGUuaXNBY3RpdmUgJiYgYWN0aXZlRGVsdGEgPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGFuZCBkb24ndCBoYXZlIGFueSBkZWZpbmVkIHByb3AgZm9yIHRoaXMgYW5pbWF0aW9uIHR5cGVcbiAgICAgICAgICAgICAgICAoIXByb3AgJiYgIXR5cGVTdGF0ZS5wcmV2UHJvcCkgfHxcbiAgICAgICAgICAgICAgICAvLyBPciBpZiB0aGUgcHJvcCBkb2Vzbid0IGRlZmluZSBhbiBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3ApIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHByb3AgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXMgd2UgZ28gbG9vayB0aHJvdWdoIHRoZSB2YWx1ZXMgZGVmaW5lZCBvbiB0aGlzIHR5cGUsIGlmIHdlIGRldGVjdFxuICAgICAgICAgICAgICogYSBjaGFuZ2VkIHZhbHVlIG9yIGEgdmFsdWUgdGhhdCB3YXMgcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSwgd2Ugc2V0XG4gICAgICAgICAgICAgKiB0aGlzIHRvIHRydWUgYW5kIGFkZCB0aGlzIHByb3AgdG8gdGhlIGFuaW1hdGlvbiBsaXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdmFyaWFudERpZENoYW5nZSA9IGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UodHlwZVN0YXRlLnByZXZQcm9wLCBwcm9wKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRBbmltYXRlVHlwZSA9IHZhcmlhbnREaWRDaGFuZ2UgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBtYWtpbmcgdGhpcyB2YXJpYW50IGFjdGl2ZSwgd2Ugd2FudCB0byBhbHdheXMgbWFrZSBpdCBhY3RpdmVcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLmlzQWN0aXZlICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0luaGVyaXRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBwcm9wSXNWYXJpYW50KSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBoaWdoZXItcHJpb3JpdHkgdmFyaWFudCAoaSBpcyBpbiByZXZlcnNlIG9yZGVyKVxuICAgICAgICAgICAgICAgIChpID4gcmVtb3ZlZFZhcmlhbnRJbmRleCAmJiBwcm9wSXNWYXJpYW50KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXMgYW5pbWF0aW9ucyBjYW4gYmUgc2V0IGFzIHZhcmlhbnQgbGlzdHMsIHZhcmlhbnRzIG9yIHRhcmdldCBvYmplY3RzLCB3ZVxuICAgICAgICAgICAgICogY29lcmNlIGV2ZXJ5dGhpbmcgdG8gYW4gYXJyYXkgaWYgaXQgaXNuJ3Qgb25lIGFscmVhZHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGRlZmluaXRpb25MaXN0ID0gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ1aWxkIGFuIG9iamVjdCBvZiBhbGwgdGhlIHJlc29sdmVkIHZhbHVlcy4gV2UnbGwgdXNlIHRoaXMgaW4gdGhlIHN1YnNlcXVlbnRcbiAgICAgICAgICAgICAqIGFuaW1hdGVDaGFuZ2VzIGNhbGxzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciByZXNvbHZlZFZhbHVlcyA9IGRlZmluaXRpb25MaXN0LnJlZHVjZShidWlsZFJlc29sdmVkVHlwZVZhbHVlcywge30pO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3cgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIHRoZSBrZXlzIGluIHRoZSBwcmV2IHByb3AgYW5kIHRoaXMgcHJvcCxcbiAgICAgICAgICAgICAqIGFuZCBkZWNpZGU6XG4gICAgICAgICAgICAgKiAxLiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDIuIElmIGl0IGhhcyBiZWVuIHJlbW92ZWQsIGFuZCBuZWVkcyBhZGRpbmcgdG8gdGhlIHJlbW92ZWRLZXlzIHNldFxuICAgICAgICAgICAgICogMy4gSWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSB0eXBlIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDQuIElmIGl0IGhhc24ndCBiZWVuIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHkgYnV0IGhhc24ndCBjaGFuZ2VkLCBhbmRcbiAgICAgICAgICAgICAqICAgIG5lZWRzIGFkZGluZyB0byB0aGUgdHlwZSdzIHByb3RlY3RlZEtleXMgbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIF9iID0gdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcywgcHJldlJlc29sdmVkVmFsdWVzID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgICAgICAgICB2YXIgYWxsS2V5cyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2UmVzb2x2ZWRWYWx1ZXMpLCByZXNvbHZlZFZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgbWFya1RvQW5pbWF0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdHlwZVN0YXRlLm5lZWRzQW5pbWF0aW5nW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSByZXNvbHZlZFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoaXMgd2UgY2FuIGp1c3Qgc2tpcCBhaGVhZFxuICAgICAgICAgICAgICAgIGlmIChlbmNvdW50ZXJlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCB3ZSBwcm9iYWJseSB3YW50IHRvIGFuaW1hdGUgaXQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIGJvdGggdmFsdWVzIGFyZSBrZXlmcmFtZXMsIHdlIG5lZWQgdG8gc2hhbGxvdyBjb21wYXJlIHRoZW0gdG9cbiAgICAgICAgICAgICAgICAgICAgICogZGV0ZWN0IHdoZXRoZXIgYW55IHZhbHVlIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXMsIHdlIGFuaW1hdGUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQobmV4dCkgJiYgaXNLZXlmcmFtZXNUYXJnZXQocHJldikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldikgfHwgdmFyaWFudERpZENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIGl0IGhhc24ndCBjaGFuZ2VkLCB3ZSB3YW50IHRvIGVuc3VyZSBpdCBkb2Vzbid0IGFuaW1hdGUgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhZGRpbmcgaXQgdG8gdGhlIGxpc3Qgb2YgcHJvdGVjdGVkIGtleXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuZXh0IGlzIGRlZmluZWQgYW5kIGRvZXNuJ3QgZXF1YWwgcHJldiwgaXQgbmVlZHMgYW5pbWF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHVuZGVmaW5lZCwgaXQncyBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgcmVtb3ZlZEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIG5leHQgaGFzbid0IGNoYW5nZWQgYW5kIGl0IGlzbid0IHVuZGVmaW5lZCwgd2Ugd2FudCB0byBjaGVjayBpZiBpdCdzXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZW4gcmVtb3ZlZCBieSBhIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIGl0IGhhc24ndCBjaGFuZ2VkLCB3ZSBhZGQgaXQgdG8gdGhlIGxpc3Qgb2YgcHJvdGVjdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgKiB0byBlbnN1cmUgaXQgZG9lc24ndCBnZXQgYW5pbWF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgdHlwZVN0YXRlIHNvIG5leHQgdGltZSBhbmltYXRlQ2hhbmdlcyBpcyBjYWxsZWQgd2UgY2FuIGNvbXBhcmUgdGhlXG4gICAgICAgICAgICAgKiBsYXRlc3QgcHJvcCBhbmQgcmVzb2x2ZWRWYWx1ZXMgdG8gdGhlc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHR5cGVTdGF0ZS5wcmV2UHJvcCA9IHByb3A7XG4gICAgICAgICAgICB0eXBlU3RhdGUucHJldlJlc29sdmVkVmFsdWVzID0gcmVzb2x2ZWRWYWx1ZXM7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlU3RhdGUuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBlbmNvdW50ZXJlZEtleXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZW5jb3VudGVyZWRLZXlzKSwgcmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJiB2aXN1YWxFbGVtZW50LmJsb2NrSW5pdGlhbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gaW5oZXJpdGVkIHByb3Agd2Ugd2FudCB0byBoYXJkLWJsb2NrIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIFRPRE86IFRlc3QgYXMgdGhpcyBzaG91bGQgcHJvYmFibHkgc3RpbGwgaGFuZGxlIGFuaW1hdGlvbnMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgKiBieSByZW1vdmVkIHZhbHVlcz9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHNob3VsZEFuaW1hdGVUeXBlICYmICFpc0luaGVyaXRlZCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaC5hcHBseShhbmltYXRpb25zLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZGVmaW5pdGlvbkxpc3QubWFwKGZ1bmN0aW9uIChhbmltYXRpb24pIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBfX2Fzc2lnbih7IHR5cGU6IHR5cGUgfSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgfSk7IH0pKSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgYW5pbWF0aW9uIHR5cGVzIGluIHJldmVyc2UgcHJpb3JpdHkgb3JkZXIuIEZvciBlYWNoLCB3ZSB3YW50IHRvXG4gICAgICAgICAqIGRldGVjdCB3aGljaCB2YWx1ZXMgaXQncyBoYW5kbGluZyBhbmQgd2hldGhlciBvciBub3QgdGhleSd2ZSBjaGFuZ2VkIChhbmQgdGhlcmVmb3JlXG4gICAgICAgICAqIG5lZWQgdG8gYmUgYW5pbWF0ZWQpLiBJZiBhbnkgdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLCB3ZSB3YW50IHRvIGRldGVjdCB0aG9zZSBpblxuICAgICAgICAgKiBsb3dlciBwcmlvcml0eSBwcm9wcyBhbmQgZmxhZyBmb3IgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BbmltYXRpb25UeXBlczsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIGFsbEFuaW1hdGVkS2V5cyA9IF9fYXNzaWduKHt9LCBlbmNvdW50ZXJlZEtleXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUgYXJlIHNvbWUgcmVtb3ZlZCB2YWx1ZSB0aGF0IGhhdmVuJ3QgYmVlbiBkZWFsdCB3aXRoLFxuICAgICAgICAgKiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBhbmltYXRpb24gdGhhdCBmYWxscyBiYWNrIGVpdGhlciB0byB0aGUgdmFsdWVcbiAgICAgICAgICogZGVmaW5lZCBpbiB0aGUgc3R5bGUgcHJvcCwgb3IgdGhlIGxhc3QgcmVhZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZW1vdmVkS2V5cy5zaXplKSB7XG4gICAgICAgICAgICB2YXIgZmFsbGJhY2tBbmltYXRpb25fMSA9IHt9O1xuICAgICAgICAgICAgcmVtb3ZlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrVGFyZ2V0ID0gdmlzdWFsRWxlbWVudC5nZXRCYXNlVGFyZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGZhbGxiYWNrVGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBbmltYXRpb25fMVtrZXldID0gZmFsbGJhY2tUYXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goeyBhbmltYXRpb246IGZhbGxiYWNrQW5pbWF0aW9uXzEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZEFuaW1hdGUgPSBCb29sZWFuKGFuaW1hdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJlxuICAgICAgICAgICAgcHJvcHMuaW5pdGlhbCA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICF2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpc0luaXRpYWxSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNob3VsZEFuaW1hdGUgPyBhbmltYXRlKGFuaW1hdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB3aGV0aGVyIGEgY2VydGFpbiBhbmltYXRpb24gdHlwZSBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gSWYgdGhlIGFjdGl2ZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZCwgd2UgY2FuIHNhZmVseSBkbyBub3RoaW5nIGhlcmVcbiAgICAgICAgaWYgKHN0YXRlW3R5cGVdLmlzQWN0aXZlID09PSBpc0FjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgLy8gUHJvcGFnYXRlIGFjdGl2ZSBjaGFuZ2UgdG8gY2hpbGRyZW5cbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBjaGlsZC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSk7IH0pO1xuICAgICAgICBzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuICAgICAgICByZXR1cm4gYW5pbWF0ZUNoYW5nZXMob3B0aW9ucywgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzQW5pbWF0ZWQ6IGlzQW5pbWF0ZWQsXG4gICAgICAgIGFuaW1hdGVDaGFuZ2VzOiBhbmltYXRlQ2hhbmdlcyxcbiAgICAgICAgc2V0QWN0aXZlOiBzZXRBY3RpdmUsXG4gICAgICAgIHNldEFuaW1hdGVGdW5jdGlvbjogc2V0QW5pbWF0ZUZ1bmN0aW9uLFxuICAgICAgICBnZXRTdGF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNWYXJpYW50TGFiZWxzKG5leHQpKSB7XG4gICAgICAgIHJldHVybiAhc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVTdGF0ZShpc0FjdGl2ZSkge1xuICAgIGlmIChpc0FjdGl2ZSA9PT0gdm9pZCAwKSB7IGlzQWN0aXZlID0gZmFsc2U7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgICAgIHByb3RlY3RlZEtleXM6IHt9LFxuICAgICAgICBuZWVkc0FuaW1hdGluZzoge30sXG4gICAgICAgIHByZXZSZXNvbHZlZFZhbHVlczoge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSB7fSxcbiAgICAgICAgX2FbQW5pbWF0aW9uVHlwZS5BbmltYXRlXSA9IGNyZWF0ZVR5cGVTdGF0ZSh0cnVlKSxcbiAgICAgICAgX2FbQW5pbWF0aW9uVHlwZS5JblZpZXddID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW0FuaW1hdGlvblR5cGUuSG92ZXJdID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW0FuaW1hdGlvblR5cGUuVGFwXSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYVtBbmltYXRpb25UeXBlLkRyYWddID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW0FuaW1hdGlvblR5cGUuRm9jdXNdID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW0FuaW1hdGlvblR5cGUuRXhpdF0gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2E7XG59XG5cbmV4cG9ydCB7IGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UsIGNyZWF0ZUFuaW1hdGlvblN0YXRlLCB2YXJpYW50UHJpb3JpdHlPcmRlciB9O1xuIiwgImZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJldikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICAgIGlmIChwcmV2TGVuZ3RoICE9PSBuZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmV2W2ldICE9PSBuZXh0W2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgc2hhbGxvd0NvbXBhcmUgfTtcbiIsICJpbXBvcnQgeyBfX3JlYWQsIF9fcmVzdCwgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBzdGFydEFuaW1hdGlvbiB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy90cmFuc2l0aW9ucy5tanMnO1xuaW1wb3J0IHsgc2V0VGFyZ2V0IH0gZnJvbSAnLi9zZXR0ZXJzLm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlVmFyaWFudCB9IGZyb20gJy4vdmFyaWFudHMubWpzJztcbmltcG9ydCB7IGlzVHJhbnNmb3JtUHJvcCB9IGZyb20gJy4uL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qcyc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZpc3VhbEVsZW1lbnQubm90aWZ5QW5pbWF0aW9uU3RhcnQoZGVmaW5pdGlvbik7XG4gICAgdmFyIGFuaW1hdGlvbjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IGRlZmluaXRpb24ubWFwKGZ1bmN0aW9uICh2YXJpYW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBhbmltYXRpb24gPSBQcm9taXNlLmFsbChhbmltYXRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzb2x2ZWREZWZpbml0aW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zLmN1c3RvbSlcbiAgICAgICAgICAgIDogZGVmaW5pdGlvbjtcbiAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZERlZmluaXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmlzdWFsRWxlbWVudC5ub3RpZnlBbmltYXRpb25Db21wbGV0ZShkZWZpbml0aW9uKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zLmN1c3RvbSk7XG4gICAgdmFyIF9iID0gKHJlc29sdmVkIHx8IHt9KS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gX2IgPT09IHZvaWQgMCA/IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB8fCB7fSA6IF9iO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb25PdmVycmlkZSkge1xuICAgICAgICB0cmFuc2l0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlIGhhdmUgYSB2YXJpYW50LCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHJ1bnMgaXQgYXMgYW4gYW5pbWF0aW9uLlxuICAgICAqIE90aGVyd2lzZSwgd2UgcmVzb2x2ZSBhIFByb21pc2UgaW1tZWRpYXRlbHkgZm9yIGEgY29tcG9zYWJsZSBuby1vcC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0QW5pbWF0aW9uID0gcmVzb2x2ZWRcbiAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkLCBvcHRpb25zKTsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIElmIHdlIGhhdmUgY2hpbGRyZW4sIGNyZWF0ZSBhIGNhbGxiYWNrIHRoYXQgcnVucyBhbGwgdGhlaXIgYW5pbWF0aW9ucy5cbiAgICAgKiBPdGhlcndpc2UsIHdlIHJlc29sdmUgYSBQcm9taXNlIGltbWVkaWF0ZWx5IGZvciBhIGNvbXBvc2FibGUgbm8tb3AuXG4gICAgICovXG4gICAgdmFyIGdldENoaWxkQW5pbWF0aW9ucyA9ICgoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpXG4gICAgICAgID8gZnVuY3Rpb24gKGZvcndhcmREZWxheSkge1xuICAgICAgICAgICAgaWYgKGZvcndhcmREZWxheSA9PT0gdm9pZCAwKSB7IGZvcndhcmREZWxheSA9IDA7IH1cbiAgICAgICAgICAgIHZhciBfYSA9IHRyYW5zaXRpb24uZGVsYXlDaGlsZHJlbiwgZGVsYXlDaGlsZHJlbiA9IF9hID09PSB2b2lkIDAgPyAwIDogX2EsIHN0YWdnZXJDaGlsZHJlbiA9IHRyYW5zaXRpb24uc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uID0gdHJhbnNpdGlvbi5zdGFnZ2VyRGlyZWN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuICsgZm9yd2FyZERlbGF5LCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH07XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRyYW5zaXRpb24gZXhwbGljaXRseSBkZWZpbmVzIGEgXCJ3aGVuXCIgb3B0aW9uLCB3ZSBuZWVkIHRvIHJlc29sdmUgZWl0aGVyXG4gICAgICogdGhpcyBhbmltYXRpb24gb3IgYWxsIGNoaWxkcmVuIGFuaW1hdGlvbnMgYmVmb3JlIHBsYXlpbmcgdGhlIG90aGVyLlxuICAgICAqL1xuICAgIHZhciB3aGVuID0gdHJhbnNpdGlvbi53aGVuO1xuICAgIGlmICh3aGVuKSB7XG4gICAgICAgIHZhciBfYyA9IF9fcmVhZCh3aGVuID09PSBcImJlZm9yZUNoaWxkcmVuXCJcbiAgICAgICAgICAgID8gW2dldEFuaW1hdGlvbiwgZ2V0Q2hpbGRBbmltYXRpb25zXVxuICAgICAgICAgICAgOiBbZ2V0Q2hpbGRBbmltYXRpb25zLCBnZXRBbmltYXRpb25dLCAyKSwgZmlyc3QgPSBfY1swXSwgbGFzdCA9IF9jWzFdO1xuICAgICAgICByZXR1cm4gZmlyc3QoKS50aGVuKGxhc3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtnZXRBbmltYXRpb24oKSwgZ2V0Q2hpbGRBbmltYXRpb25zKG9wdGlvbnMuZGVsYXkpXSk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBfYSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgX2MgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2QgPSBfYy5kZWxheSwgZGVsYXkgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCB0cmFuc2l0aW9uT3ZlcnJpZGUgPSBfYy50cmFuc2l0aW9uT3ZlcnJpZGUsIHR5cGUgPSBfYy50eXBlO1xuICAgIHZhciBfZSA9IHZpc3VhbEVsZW1lbnQubWFrZVRhcmdldEFuaW1hdGFibGUoZGVmaW5pdGlvbiksIF9mID0gX2UudHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IF9mID09PSB2b2lkIDAgPyB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCkgOiBfZiwgdHJhbnNpdGlvbkVuZCA9IF9lLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IF9fcmVzdChfZSwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgIGlmICh0cmFuc2l0aW9uT3ZlcnJpZGUpXG4gICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uT3ZlcnJpZGU7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcbiAgICB2YXIgYW5pbWF0aW9uVHlwZVN0YXRlID0gdHlwZSAmJiAoKF9iID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFN0YXRlKClbdHlwZV0pO1xuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICB2YXIgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgdmFsdWVUYXJnZXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKGFuaW1hdGlvblR5cGVTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZEJsb2NrQW5pbWF0aW9uKGFuaW1hdGlvblR5cGVTdGF0ZSwga2V5KSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZVRyYW5zaXRpb24gPSBfX2Fzc2lnbih7IGRlbGF5OiBkZWxheSB9LCB0cmFuc2l0aW9uKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2UgYW5pbWF0aW9uIGluc3RhbnQgaWYgdGhpcyBpcyBhIHRyYW5zZm9ybSBwcm9wIGFuZCB3ZSBzaG91bGQgcmVkdWNlIG1vdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbiAmJiBpc1RyYW5zZm9ybVByb3Aoa2V5KSkge1xuICAgICAgICAgICAgdmFsdWVUcmFuc2l0aW9uID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHZhbHVlVHJhbnNpdGlvbiksIHsgdHlwZTogZmFsc2UsIGRlbGF5OiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmltYXRpb24gPSBzdGFydEFuaW1hdGlvbihrZXksIHZhbHVlLCB2YWx1ZVRhcmdldCwgdmFsdWVUcmFuc2l0aW9uKTtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhbnNpdGlvbkVuZCAmJiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgdHJhbnNpdGlvbkVuZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKGRlbGF5Q2hpbGRyZW4gPT09IHZvaWQgMCkgeyBkZWxheUNoaWxkcmVuID0gMDsgfVxuICAgIGlmIChzdGFnZ2VyQ2hpbGRyZW4gPT09IHZvaWQgMCkgeyBzdGFnZ2VyQ2hpbGRyZW4gPSAwOyB9XG4gICAgaWYgKHN0YWdnZXJEaXJlY3Rpb24gPT09IHZvaWQgMCkgeyBzdGFnZ2VyRGlyZWN0aW9uID0gMTsgfVxuICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgdmFyIG1heFN0YWdnZXJEdXJhdGlvbiA9ICh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbi5zaXplIC0gMSkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgdmFyIGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uID0gc3RhZ2dlckRpcmVjdGlvbiA9PT0gMVxuICAgICAgICA/IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gdm9pZCAwKSB7IGkgPSAwOyB9XG4gICAgICAgICAgICByZXR1cm4gaSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gdm9pZCAwKSB7IGkgPSAwOyB9XG4gICAgICAgICAgICByZXR1cm4gbWF4U3RhZ2dlckR1cmF0aW9uIC0gaSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgICAgICAgfTtcbiAgICBBcnJheS5mcm9tKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKVxuICAgICAgICAuc29ydChzb3J0QnlUcmVlT3JkZXIpXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0ZVZhcmlhbnQoY2hpbGQsIHZhcmlhbnQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkZWxheTogZGVsYXlDaGlsZHJlbiArIGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uKGkpIH0pKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoaWxkLm5vdGlmeUFuaW1hdGlvbkNvbXBsZXRlKHZhcmlhbnQpOyB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xufVxuZnVuY3Rpb24gc3RvcEFuaW1hdGlvbih2aXN1YWxFbGVtZW50KSB7XG4gICAgdmlzdWFsRWxlbWVudC5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5zdG9wKCk7IH0pO1xufVxuZnVuY3Rpb24gc29ydEJ5VHJlZU9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYS5zb3J0Tm9kZVBvc2l0aW9uKGIpO1xufVxuLyoqXG4gKiBEZWNpZGUgd2hldGhlciB3ZSBzaG91bGQgYmxvY2sgdGhpcyBhbmltYXRpb24uIFByZXZpb3VzbHksIHdlIGFjaGlldmVkIHRoaXNcbiAqIGp1c3QgYnkgY2hlY2tpbmcgd2hldGhlciB0aGUga2V5IHdhcyBsaXN0ZWQgaW4gcHJvdGVjdGVkS2V5cywgYnV0IHRoaXNcbiAqIHBvc2VkIHByb2JsZW1zIGlmIGFuIGFuaW1hdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGFmdGVyQ2hpbGRyZW4gYW5kIHByb3RlY3RlZEtleXNcbiAqIGhhZCBiZWVuIHNldCB0byB0cnVlIGluIHRoZSBtZWFudGltZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQmxvY2tBbmltYXRpb24oX2EsIGtleSkge1xuICAgIHZhciBwcm90ZWN0ZWRLZXlzID0gX2EucHJvdGVjdGVkS2V5cywgbmVlZHNBbmltYXRpbmcgPSBfYS5uZWVkc0FuaW1hdGluZztcbiAgICB2YXIgc2hvdWxkQmxvY2sgPSBwcm90ZWN0ZWRLZXlzLmhhc093blByb3BlcnR5KGtleSkgJiYgbmVlZHNBbmltYXRpbmdba2V5XSAhPT0gdHJ1ZTtcbiAgICBuZWVkc0FuaW1hdGluZ1trZXldID0gZmFsc2U7XG4gICAgcmV0dXJuIHNob3VsZEJsb2NrO1xufVxuXG5leHBvcnQgeyBhbmltYXRlVmlzdWFsRWxlbWVudCwgc29ydEJ5VHJlZU9yZGVyLCBzdG9wQW5pbWF0aW9uIH07XG4iLCAiaW1wb3J0IHsgX19yZXN0LCBfX2Fzc2lnbiwgX19zcHJlYWRBcnJheSwgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgY29tcGxleCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IGlzTnVtZXJpY2FsU3RyaW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtbnVtZXJpY2FsLXN0cmluZy5tanMnO1xuaW1wb3J0IHsgaXNaZXJvVmFsdWVTdHJpbmcgfSBmcm9tICcuLi8uLi91dGlscy9pcy16ZXJvLXZhbHVlLXN0cmluZy5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyB9IGZyb20gJy4uLy4uL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzJztcbmltcG9ydCB7IG1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvaW5kZXgubWpzJztcbmltcG9ydCB7IGdldEFuaW1hdGFibGVOb25lIH0gZnJvbSAnLi4vZG9tL3ZhbHVlLXR5cGVzL2FuaW1hdGFibGUtbm9uZS5tanMnO1xuaW1wb3J0IHsgZmluZFZhbHVlVHlwZSB9IGZyb20gJy4uL2RvbS92YWx1ZS10eXBlcy9maW5kLm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlVmFyaWFudCB9IGZyb20gJy4vdmFyaWFudHMubWpzJztcblxuLyoqXG4gKiBTZXQgVmlzdWFsRWxlbWVudCdzIE1vdGlvblZhbHVlLCBjcmVhdGluZyBhIG5ldyBNb3Rpb25WYWx1ZSBmb3IgaXQgaWZcbiAqIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KS5zZXQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICB2YXIgX2EgPSByZXNvbHZlZCA/IHZpc3VhbEVsZW1lbnQubWFrZVRhcmdldEFuaW1hdGFibGUocmVzb2x2ZWQsIGZhbHNlKSA6IHt9LCBfYiA9IF9hLnRyYW5zaXRpb25FbmQsIHRyYW5zaXRpb25FbmQgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjsgX2EudHJhbnNpdGlvbjsgdmFyIHRhcmdldCA9IF9fcmVzdChfYSwgW1widHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25cIl0pO1xuICAgIHRhcmdldCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YXJnZXQpLCB0cmFuc2l0aW9uRW5kKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0W2tleV0pO1xuICAgICAgICBzZXRNb3Rpb25WYWx1ZSh2aXN1YWxFbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCB2YXJpYW50TGFiZWxzKSB7XG4gICAgdmFyIHJldmVyc2VkTGFiZWxzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHZhcmlhbnRMYWJlbHMpLCBmYWxzZSkucmV2ZXJzZSgpO1xuICAgIHJldmVyc2VkTGFiZWxzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB2YXJpYW50ID0gdmlzdWFsRWxlbWVudC5nZXRWYXJpYW50KGtleSk7XG4gICAgICAgIHZhcmlhbnQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQpO1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBzZXRWYXJpYW50cyhjaGlsZCwgdmFyaWFudExhYmVscyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVzKHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2V0VmFyaWFudHModmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCBbZGVmaW5pdGlvbl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdmFyIF9kO1xuICAgIHZhciBuZXdWYWx1ZUtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhdmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpOyB9KTtcbiAgICB2YXIgbnVtTmV3VmFsdWVzID0gbmV3VmFsdWVLZXlzLmxlbmd0aDtcbiAgICBpZiAoIW51bU5ld1ZhbHVlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTmV3VmFsdWVzOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld1ZhbHVlS2V5c1tpXTtcbiAgICAgICAgdmFyIHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGEgc2VyaWVzIG9mIGtleWZyYW1lcywgd2UgY2FuIHVzZSB0aGUgZmlyc3QgdmFsdWVcbiAgICAgICAgICogaW4gdGhlIGFycmF5LiBJZiB0aGlzIGZpcnN0IHZhbHVlIGlzIG51bGwsIHdlJ2xsIHN0aWxsIG5lZWQgdG8gcmVhZCBmcm9tIHRoZSBET00uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0VmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB0YXJnZXQgaXNuJ3Qga2V5ZnJhbWVzLCBvciB0aGUgZmlyc3Qga2V5ZnJhbWUgd2FzIG51bGwsIHdlIG5lZWQgdG9cbiAgICAgICAgICogZmlyc3QgY2hlY2sgaWYgYW4gb3JpZ2luIHZhbHVlIHdhcyBleHBsaWNpdGx5IGRlZmluZWQgaW4gdGhlIHRyYW5zaXRpb24gYXMgXCJmcm9tXCIsXG4gICAgICAgICAqIGlmIG5vdCByZWFkIHRoZSB2YWx1ZSBmcm9tIHRoZSBET00uIEFzIGFuIGFic29sdXRlIGZhbGxiYWNrLCB0YWtlIHRoZSBkZWZpbmVkIHRhcmdldCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAoX2IgPSAoX2EgPSBvcmlnaW5ba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmlzdWFsRWxlbWVudC5yZWFkVmFsdWUoa2V5KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHZhbHVlIGlzIHN0aWxsIHVuZGVmaW5lZCBvciBudWxsLCBpZ25vcmUgaXQuIFByZWZlcmFibHkgdGhpcyB3b3VsZCB0aHJvdyxcbiAgICAgICAgICogYnV0IHRoaXMgd2FzIGNhdXNpbmcgaXNzdWVzIGluIEZyYW1lci5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIChpc051bWVyaWNhbFN0cmluZyh2YWx1ZSkgfHwgaXNaZXJvVmFsdWVTdHJpbmcodmFsdWUpKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG51bWJlciByZWFkIGFzIGEgc3RyaW5nLCBpZSBcIjBcIiBvciBcIjIwMFwiLCBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFmaW5kVmFsdWVUeXBlKHZhbHVlKSAmJiBjb21wbGV4LnRlc3QodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldEFuaW1hdGFibGVOb25lKGtleSwgdGFyZ2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZSh2YWx1ZSkpO1xuICAgICAgICAoX2MgPSAoX2QgPSBvcmlnaW4pW2tleV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZFtrZXldID0gdmFsdWUpO1xuICAgICAgICB2aXN1YWxFbGVtZW50LnNldEJhc2VUYXJnZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0T3JpZ2luRnJvbVRyYW5zaXRpb24oa2V5LCB0cmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0cmFuc2l0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHZhbHVlVHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xuICAgIHJldHVybiB2YWx1ZVRyYW5zaXRpb24uZnJvbTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24sIHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBvcmlnaW4gPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIG9yaWdpbltrZXldID1cbiAgICAgICAgICAgIChfYSA9IGdldE9yaWdpbkZyb21UcmFuc2l0aW9uKGtleSwgdHJhbnNpdGlvbikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luO1xufVxuXG5leHBvcnQgeyBjaGVja1RhcmdldEZvck5ld1ZhbHVlcywgZ2V0T3JpZ2luLCBnZXRPcmlnaW5Gcm9tVHJhbnNpdGlvbiwgc2V0VGFyZ2V0LCBzZXRWYWx1ZXMgfTtcbiIsICIvKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIGEgbnVtZXJpY2FsIHN0cmluZywgaWUgYSBzdHJpbmcgdGhhdCBpcyBwdXJlbHkgYSBudW1iZXIgZWcgXCIxMDBcIiBvciBcIi0xMDAuMVwiXG4gKi9cbnZhciBpc051bWVyaWNhbFN0cmluZyA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAvXlxcLT9cXGQqXFwuP1xcZCskLy50ZXN0KHYpOyB9O1xuXG5leHBvcnQgeyBpc051bWVyaWNhbFN0cmluZyB9O1xuIiwgIi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgemVybyB2YWx1ZSBzdHJpbmcgbGlrZSBcIjBweFwiIG9yIFwiMCVcIlxuICovXG52YXIgaXNaZXJvVmFsdWVTdHJpbmcgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gL14wW14uXFxzXSskLy50ZXN0KHYpOyB9O1xuXG5leHBvcnQgeyBpc1plcm9WYWx1ZVN0cmluZyB9O1xuIiwgImltcG9ydCB7IF9fc3ByZWFkQXJyYXksIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGNvbG9yLCBjb21wbGV4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgZGltZW5zaW9uVmFsdWVUeXBlcyB9IGZyb20gJy4vZGltZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgdGVzdFZhbHVlVHlwZSB9IGZyb20gJy4vdGVzdC5tanMnO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgVmFsdWVUeXBlc1xuICovXG52YXIgdmFsdWVUeXBlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGRpbWVuc2lvblZhbHVlVHlwZXMpLCBmYWxzZSksIFtjb2xvciwgY29tcGxleF0sIGZhbHNlKTtcbi8qKlxuICogVGVzdHMgYSB2YWx1ZSBhZ2FpbnN0IHRoZSBsaXN0IG9mIFZhbHVlVHlwZXNcbiAqL1xudmFyIGZpbmRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpOyB9O1xuXG5leHBvcnQgeyBmaW5kVmFsdWVUeXBlIH07XG4iLCAiaW1wb3J0IHsgbnVtYmVyLCBweCwgcGVyY2VudCwgZGVncmVlcywgdncsIHZoIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgdGVzdFZhbHVlVHlwZSB9IGZyb20gJy4vdGVzdC5tanMnO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gJy4vdHlwZS1hdXRvLm1qcyc7XG5cbi8qKlxuICogQSBsaXN0IG9mIHZhbHVlIHR5cGVzIGNvbW1vbmx5IHVzZWQgZm9yIGRpbWVuc2lvbnNcbiAqL1xudmFyIGRpbWVuc2lvblZhbHVlVHlwZXMgPSBbbnVtYmVyLCBweCwgcGVyY2VudCwgZGVncmVlcywgdncsIHZoLCBhdXRvXTtcbi8qKlxuICogVGVzdHMgYSBkaW1lbnNpb25hbCB2YWx1ZSBhZ2FpbnN0IHRoZSBsaXN0IG9mIGRpbWVuc2lvbiBWYWx1ZVR5cGVzXG4gKi9cbnZhciBmaW5kRGltZW5zaW9uVmFsdWVUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gZGltZW5zaW9uVmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xufTtcblxuZXhwb3J0IHsgZGltZW5zaW9uVmFsdWVUeXBlcywgZmluZERpbWVuc2lvblZhbHVlVHlwZSB9O1xuIiwgIi8qKlxuICogVGVzdHMgYSBwcm92aWRlZCB2YWx1ZSBhZ2FpbnN0IGEgVmFsdWVUeXBlXG4gKi9cbnZhciB0ZXN0VmFsdWVUeXBlID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnRlc3Qodik7IH07IH07XG5cbmV4cG9ydCB7IHRlc3RWYWx1ZVR5cGUgfTtcbiIsICIvKipcbiAqIFZhbHVlVHlwZSBmb3IgXCJhdXRvXCJcbiAqL1xudmFyIGF1dG8gPSB7XG4gICAgdGVzdDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IFwiYXV0b1wiOyB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdjsgfSxcbn07XG5cbmV4cG9ydCB7IGF1dG8gfTtcbiIsICJpbXBvcnQgeyB1c2VEcmFnIH0gZnJvbSAnLi4vLi4vZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5tanMnO1xuaW1wb3J0IHsgdXNlUGFuR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3VzZS1wYW4tZ2VzdHVyZS5tanMnO1xuaW1wb3J0IHsgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgfSBmcm9tICcuLi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qcyc7XG5cbnZhciBkcmFnID0ge1xuICAgIHBhbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlUGFuR2VzdHVyZSksXG4gICAgZHJhZzogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlRHJhZyksXG59O1xuXG5leHBvcnQgeyBkcmFnIH07XG4iLCAiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyB9IGZyb20gJy4vVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5tanMnO1xuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBhbGxvd3MgYW4gZWxlbWVudCB0byBiZSBkcmFnZ2VkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEcmFnKHByb3BzKSB7XG4gICAgdmFyIGdyb3VwRHJhZ0NvbnRyb2xzID0gcHJvcHMuZHJhZ0NvbnRyb2xzLCB2aXN1YWxFbGVtZW50ID0gcHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICB2YXIgZHJhZ0NvbnRyb2xzID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHModmlzdWFsRWxlbWVudCk7IH0pO1xuICAgIC8vIElmIHdlJ3ZlIGJlZW4gcHJvdmlkZWQgYSBEcmFnQ29udHJvbHMgZm9yIG1hbnVhbCBjb250cm9sIG92ZXIgdGhlIGRyYWcgZ2VzdHVyZSxcbiAgICAvLyBzdWJzY3JpYmUgdGhpcyBjb21wb25lbnQgdG8gaXQgb24gbW91bnQuXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdyb3VwRHJhZ0NvbnRyb2xzICYmIGdyb3VwRHJhZ0NvbnRyb2xzLnN1YnNjcmliZShkcmFnQ29udHJvbHMpOyB9LCBbZHJhZ0NvbnRyb2xzLCBncm91cERyYWdDb250cm9sc10pO1xuICAgIC8vIEFwcGx5IHRoZSBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGVsZW1lbnRcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gZHJhZ0NvbnRyb2xzLmFkZExpc3RlbmVycygpOyB9LCBbZHJhZ0NvbnRyb2xzXSk7XG59XG5cbmV4cG9ydCB7IHVzZURyYWcgfTtcbiIsICJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0IHsgUGFuU2Vzc2lvbiB9IGZyb20gJy4uL1BhblNlc3Npb24ubWpzJztcbmltcG9ydCB7IGdldEdsb2JhbExvY2sgfSBmcm9tICcuL3V0aWxzL2xvY2subWpzJztcbmltcG9ydCB7IGlzUmVmT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtcmVmLW9iamVjdC5tanMnO1xuaW1wb3J0IHsgYWRkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi4vLi4vZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBhcHBseUNvbnN0cmFpbnRzLCBjYWxjUmVsYXRpdmVDb25zdHJhaW50cywgcmVzb2x2ZURyYWdFbGFzdGljLCByZWJhc2VBeGlzQ29uc3RyYWludHMsIGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzLCBjYWxjT3JpZ2luLCBkZWZhdWx0RWxhc3RpYyB9IGZyb20gJy4vdXRpbHMvY29uc3RyYWludHMubWpzJztcbmltcG9ydCB7IEFuaW1hdGlvblR5cGUgfSBmcm9tICcuLi8uLi9yZW5kZXIvdXRpbHMvdHlwZXMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUJveCB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vZ2VvbWV0cnkvbW9kZWxzLm1qcyc7XG5pbXBvcnQgeyBlYWNoQXhpcyB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vdXRpbHMvZWFjaC1heGlzLm1qcyc7XG5pbXBvcnQgeyBtZWFzdXJlUGFnZUJveCB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vdXRpbHMvbWVhc3VyZS5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdEV2ZW50SW5mbyB9IGZyb20gJy4uLy4uL2V2ZW50cy9ldmVudC1pbmZvLm1qcyc7XG5pbXBvcnQgeyBzdGFydEFuaW1hdGlvbiB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy90cmFuc2l0aW9ucy5tanMnO1xuaW1wb3J0IHsgY29udmVydEJveFRvQm91bmRpbmdCb3gsIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94IH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9nZW9tZXRyeS9jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyBhZGREb21FdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50cy91c2UtZG9tLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgcGVyY2VudCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IGNhbGNMZW5ndGggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcblxudmFyIGVsZW1lbnREcmFnQ29udHJvbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKlxuICovXG4vLyBsZXQgbGF0ZXN0UG9pbnRlckV2ZW50OiBBbnlQb2ludGVyRXZlbnRcbnZhciBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHModmlzdWFsRWxlbWVudCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgZHJhZyBnZXN0dXJlIGxvY2ssIGVuc3VyaW5nIG9ubHkgb25lIGNvbXBvbmVudFxuICAgICAgICAvLyBjYW4gXCJjYXB0dXJlXCIgdGhlIGRyYWcgb2Ygb25lIG9yIGJvdGggYXhlcy5cbiAgICAgICAgLy8gVE9ETzogTG9vayBpbnRvIG1vdmluZyB0aGlzIGludG8gcGFuc2Vzc2lvbj9cbiAgICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpblBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVybWl0dGVkIGJvdW5kYXJpZXMgb2YgdHJhdmVsLCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyLWF4aXMgcmVzb2x2ZWQgZWxhc3RpYyB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsYXN0aWMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudDtcbiAgICB9XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAob3JpZ2luRXZlbnQsIF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnNuYXBUb0N1cnNvciwgc25hcFRvQ3Vyc29yID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb24ndCBzdGFydCBkcmFnZ2luZyBpZiB0aGlzIGNvbXBvbmVudCBpcyBleGl0aW5nXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LmlzUHJlc2VudCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBvblNlc3Npb25TdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gU3RvcCBhbnkgYW5pbWF0aW9ucyBvbiBib3RoIGF4aXMgdmFsdWVzIGltbWVkaWF0ZWx5LiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byB0aHJvdyBhbmQgY2F0Y2hcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICBfdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc25hcFRvQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc25hcFRvQ3Vyc29yKGV4dHJhY3RFdmVudEluZm8oZXZlbnQsIFwicGFnZVwiKS5wb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgdGhlIGdsb2JhbCBkcmFnIGdlc3R1cmUgbG9jayAtIG1heWJlIG1ha2UgdGhpcyBwYXJ0IG9mIFBhblNlc3Npb25cbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLmdldFByb3BzKCksIGRyYWcgPSBfYi5kcmFnLCBkcmFnUHJvcGFnYXRpb24gPSBfYi5kcmFnUHJvcGFnYXRpb24sIG9uRHJhZ1N0YXJ0ID0gX2Iub25EcmFnU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZHJhZyAmJiAhZHJhZ1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuR2xvYmFsTG9jaygpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9wZW5HbG9iYWxMb2NrID0gZ2V0R2xvYmFsTG9jayhkcmFnKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24gJ3QgaGF2ZSB0aGUgbG9jaywgZG9uJ3Qgc3RhcnQgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVjb3JkIGdlc3R1cmUgb3JpZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5nZXQoKSB8fCAwO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBNb3Rpb25WYWx1ZSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgY29udmVydCB0byBweFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50LnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lYXN1cmVkQXhpcyA9IChfYiA9IChfYSA9IF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjdHVhbFtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkQXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gY2FsY0xlbmd0aChtZWFzdXJlZEF4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGxlbmd0aF8xICogKHBhcnNlRmxvYXQoY3VycmVudCkgLyAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLm9yaWdpblBvaW50W2F4aXNdID0gY3VycmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRmlyZSBvbkRyYWdTdGFydCBldmVudFxuICAgICAgICAgICAgb25EcmFnU3RhcnQgPT09IG51bGwgfHwgb25EcmFnU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZ1N0YXJ0KGV2ZW50LCBpbmZvKTtcbiAgICAgICAgICAgIChfYSA9IF90aGlzLnZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5EcmFnLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgLy8gbGF0ZXN0UG9pbnRlckV2ZW50ID0gZXZlbnRcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmdldFByb3BzKCksIGRyYWdQcm9wYWdhdGlvbiA9IF9hLmRyYWdQcm9wYWdhdGlvbiwgZHJhZ0RpcmVjdGlvbkxvY2sgPSBfYS5kcmFnRGlyZWN0aW9uTG9jaywgb25EaXJlY3Rpb25Mb2NrID0gX2Eub25EaXJlY3Rpb25Mb2NrLCBvbkRyYWcgPSBfYS5vbkRyYWc7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3Qgc3VjY2Vzc2Z1bGx5IHJlY2VpdmUgdGhlIGdlc3R1cmUgbG9jaywgZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKCFkcmFnUHJvcGFnYXRpb24gJiYgIV90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpbmZvLm9mZnNldDtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZGV0ZWN0IGRyYWcgZGlyZWN0aW9uIGlmIGRpcmVjdGlvbkxvY2sgaXMgdHJ1ZVxuICAgICAgICAgICAgaWYgKGRyYWdEaXJlY3Rpb25Mb2NrICYmIF90aGlzLmN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBzZXQgYSBkaXJlY3Rpb24sIG5vdGlmeSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50RGlyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGlyZWN0aW9uTG9jayA9PT0gbnVsbCB8fCBvbkRpcmVjdGlvbkxvY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRGlyZWN0aW9uTG9jayhfdGhpcy5jdXJyZW50RGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGVhY2ggcG9pbnQgd2l0aCB0aGUgbGF0ZXN0IHBvc2l0aW9uXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBeGlzKFwieFwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXhpcyhcInlcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWRlYWxseSB3ZSB3b3VsZCBsZWF2ZSB0aGUgcmVuZGVyZXIgdG8gZmlyZSBuYXR1cmFsbHkgYXQgdGhlIGVuZCBvZlxuICAgICAgICAgICAgICogdGhpcyBmcmFtZSBidXQgaWYgdGhlIGVsZW1lbnQgaXMgYWJvdXQgdG8gY2hhbmdlIGxheW91dCBhcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgKiBvZiBhIHJlLXJlbmRlciB3ZSB3YW50IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBjYW4gcmVhZCB0aGUgbGF0ZXN0XG4gICAgICAgICAgICAgKiBib3VuZGluZyBib3ggdG8gZW5zdXJlIHRoZSBwb2ludGVyIGFuZCBlbGVtZW50IGRvbid0IGZhbGwgb3V0IG9mIHN5bmMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIG11c3QgZmlyZSBhZnRlciB0aGUgc3luY1JlbmRlciBjYWxsIGFzIGl0IG1pZ2h0IHRyaWdnZXIgYSBzdGF0ZVxuICAgICAgICAgICAgICogY2hhbmdlIHdoaWNoIGl0c2VsZiBtaWdodCB0cmlnZ2VyIGEgbGF5b3V0IHVwZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25EcmFnID09PSBudWxsIHx8IG9uRHJhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uU2Vzc2lvbkVuZCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0b3AoZXZlbnQsIGluZm8pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSBuZXcgUGFuU2Vzc2lvbihvcmlnaW5FdmVudCwge1xuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQ6IG9uU2Vzc2lvblN0YXJ0LFxuICAgICAgICAgICAgb25TdGFydDogb25TdGFydCxcbiAgICAgICAgICAgIG9uTW92ZTogb25Nb3ZlLFxuICAgICAgICAgICAgb25TZXNzaW9uRW5kOiBvblNlc3Npb25FbmQsXG4gICAgICAgIH0sIHsgdHJhbnNmb3JtUGFnZVBvaW50OiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkgfSk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgIHZhciBpc0RyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nO1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IGluZm8udmVsb2NpdHk7XG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24odmVsb2NpdHkpO1xuICAgICAgICB2YXIgb25EcmFnRW5kID0gdGhpcy5nZXRQcm9wcygpLm9uRHJhZ0VuZDtcbiAgICAgICAgb25EcmFnRW5kID09PSBudWxsIHx8IG9uRHJhZ0VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnRW5kKGV2ZW50LCBpbmZvKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5wYW5TZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kKCk7XG4gICAgICAgIHRoaXMucGFuU2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGRyYWdQcm9wYWdhdGlvbiA9IHRoaXMuZ2V0UHJvcHMoKS5kcmFnUHJvcGFnYXRpb247XG4gICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmIHRoaXMub3Blbkdsb2JhbExvY2spIHtcbiAgICAgICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2soKTtcbiAgICAgICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkRyYWcsIGZhbHNlKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnVwZGF0ZUF4aXMgPSBmdW5jdGlvbiAoYXhpcywgX3BvaW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGRyYWcgPSB0aGlzLmdldFByb3BzKCkuZHJhZztcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIHRoaXMgYXhpcywgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgICAgICBpZiAoIW9mZnNldCB8fCAhc2hvdWxkRHJhZyhheGlzLCBkcmFnLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5vcmlnaW5Qb2ludFtheGlzXSArIG9mZnNldFtheGlzXTtcbiAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMgJiYgdGhpcy5jb25zdHJhaW50c1theGlzXSkge1xuICAgICAgICAgICAgbmV4dCA9IGFwcGx5Q29uc3RyYWludHMobmV4dCwgdGhpcy5jb25zdHJhaW50c1theGlzXSwgdGhpcy5lbGFzdGljW2F4aXNdKTtcbiAgICAgICAgfVxuICAgICAgICBheGlzVmFsdWUuc2V0KG5leHQpO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUucmVzb2x2ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFByb3BzKCksIGRyYWdDb25zdHJhaW50cyA9IF9hLmRyYWdDb25zdHJhaW50cywgZHJhZ0VsYXN0aWMgPSBfYS5kcmFnRWxhc3RpYztcbiAgICAgICAgdmFyIGxheW91dCA9ICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiB8fCB7fSkubGF5b3V0O1xuICAgICAgICB2YXIgcHJldkNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgbGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzKGxheW91dC5hY3R1YWwsIGRyYWdDb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGFzdGljID0gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIG91dHB1dHRpbmcgdG8gZXh0ZXJuYWwgTW90aW9uVmFsdWVzLCB3ZSB3YW50IHRvIHJlYmFzZSB0aGUgbWVhc3VyZWQgY29uc3RyYWludHNcbiAgICAgICAgICogZnJvbSB2aWV3cG9ydC1yZWxhdGl2ZSB0byBjb21wb25lbnQtcmVsYXRpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJldkNvbnN0cmFpbnRzICE9PSB0aGlzLmNvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICBsYXlvdXQgJiZcbiAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgJiZcbiAgICAgICAgICAgICF0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cykge1xuICAgICAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnN0cmFpbnRzW2F4aXNdID0gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dC5hY3R1YWxbYXhpc10sIF90aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUucmVzb2x2ZVJlZkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFByb3BzKCksIGNvbnN0cmFpbnRzID0gX2EuZHJhZ0NvbnN0cmFpbnRzLCBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgPSBfYS5vbk1lYXN1cmVEcmFnQ29uc3RyYWludHM7XG4gICAgICAgIGlmICghY29uc3RyYWludHMgfHwgIWlzUmVmT2JqZWN0KGNvbnN0cmFpbnRzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzRWxlbWVudCA9IGNvbnN0cmFpbnRzLmN1cnJlbnQ7XG4gICAgICAgIGludmFyaWFudChjb25zdHJhaW50c0VsZW1lbnQgIT09IG51bGwsIFwiSWYgYGRyYWdDb25zdHJhaW50c2AgaXMgc2V0IGFzIGEgUmVhY3QgcmVmLCB0aGF0IHJlZiBtdXN0IGJlIHBhc3NlZCB0byBhbm90aGVyIGNvbXBvbmVudCdzIGByZWZgIHByb3AuXCIpO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIGlmICghcHJvamVjdGlvbiB8fCAhcHJvamVjdGlvbi5sYXlvdXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb25zdHJhaW50c0JveCA9IG1lYXN1cmVQYWdlQm94KGNvbnN0cmFpbnRzRWxlbWVudCwgcHJvamVjdGlvbi5yb290LCB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkpO1xuICAgICAgICB2YXIgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKHByb2plY3Rpb24ubGF5b3V0LmFjdHVhbCwgY29uc3RyYWludHNCb3gpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUncyBhbiBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgbGlzdGVuZXIgd2UgY2FsbCBpdCBhbmRcbiAgICAgICAgICogaWYgZGlmZmVyZW50IGNvbnN0cmFpbnRzIGFyZSByZXR1cm5lZCwgc2V0IGNvbnN0cmFpbnRzIHRvIHRoYXRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHZhciB1c2VyQ29uc3RyYWludHMgPSBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMoY29udmVydEJveFRvQm91bmRpbmdCb3gobWVhc3VyZWRDb25zdHJhaW50cykpO1xuICAgICAgICAgICAgdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMgPSAhIXVzZXJDb25zdHJhaW50cztcbiAgICAgICAgICAgIGlmICh1c2VyQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlZENvbnN0cmFpbnRzID0gY29udmVydEJvdW5kaW5nQm94VG9Cb3godXNlckNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVhc3VyZWRDb25zdHJhaW50cztcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24gKHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0UHJvcHMoKSwgZHJhZyA9IF9hLmRyYWcsIGRyYWdNb21lbnR1bSA9IF9hLmRyYWdNb21lbnR1bSwgZHJhZ0VsYXN0aWMgPSBfYS5kcmFnRWxhc3RpYywgZHJhZ1RyYW5zaXRpb24gPSBfYS5kcmFnVHJhbnNpdGlvbiwgZHJhZ1NuYXBUb09yaWdpbiA9IF9hLmRyYWdTbmFwVG9PcmlnaW4sIG9uRHJhZ1RyYW5zaXRpb25FbmQgPSBfYS5vbkRyYWdUcmFuc2l0aW9uRW5kO1xuICAgICAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzIHx8IHt9O1xuICAgICAgICB2YXIgbW9tZW50dW1BbmltYXRpb25zID0gZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBfdGhpcy5jdXJyZW50RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gKF9hID0gY29uc3RyYWludHMgPT09IG51bGwgfHwgY29uc3RyYWludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnN0cmFpbnRzW2F4aXNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgICAgIGlmIChkcmFnU25hcFRvT3JpZ2luKVxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gPSB7IG1pbjogMCwgbWF4OiAwIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE92ZXJkYW1wIHRoZSBib3VuZGFyeSBzcHJpbmcgaWYgYGRyYWdFbGFzdGljYCBpcyBkaXNhYmxlZC4gVGhlcmUncyBzdGlsbCBhIGZyYW1lXG4gICAgICAgICAgICAgKiBvZiBzcHJpbmcgYW5pbWF0aW9ucyBzbyB3ZSBzaG91bGQgbG9vayBpbnRvIGFkZGluZyBhIGRpc2FibGUgc3ByaW5nIG9wdGlvbiB0byBgaW5lcnRpYWAuXG4gICAgICAgICAgICAgKiBXZSBjb3VsZCBkbyBzb21ldGhpbmcgaGVyZSB3aGVyZSB3ZSBhZmZlY3QgdGhlIGBib3VuY2VTdGlmZm5lc3NgIGFuZCBgYm91bmNlRGFtcGluZ2BcbiAgICAgICAgICAgICAqIHVzaW5nIHRoZSB2YWx1ZSBvZiBgZHJhZ0VsYXN0aWNgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgYm91bmNlU3RpZmZuZXNzID0gZHJhZ0VsYXN0aWMgPyAyMDAgOiAxMDAwMDAwO1xuICAgICAgICAgICAgdmFyIGJvdW5jZURhbXBpbmcgPSBkcmFnRWxhc3RpYyA/IDQwIDogMTAwMDAwMDA7XG4gICAgICAgICAgICB2YXIgaW5lcnRpYSA9IF9fYXNzaWduKF9fYXNzaWduKHsgdHlwZTogXCJpbmVydGlhXCIsIHZlbG9jaXR5OiBkcmFnTW9tZW50dW0gPyB2ZWxvY2l0eVtheGlzXSA6IDAsIGJvdW5jZVN0aWZmbmVzczogYm91bmNlU3RpZmZuZXNzLCBib3VuY2VEYW1waW5nOiBib3VuY2VEYW1waW5nLCB0aW1lQ29uc3RhbnQ6IDc1MCwgcmVzdERlbHRhOiAxLCByZXN0U3BlZWQ6IDEwIH0sIGRyYWdUcmFuc2l0aW9uKSwgdHJhbnNpdGlvbik7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgYW5pbWF0aW5nIG9uIGFuIGV4dGVybmFsbHktcHJvdmlkZWQgYE1vdGlvblZhbHVlYCB3ZSBjYW4gdXNlIHRoZVxuICAgICAgICAgICAgLy8gY29tcG9uZW50J3MgYW5pbWF0aW9uIGNvbnRyb2xzIHdoaWNoIHdpbGwgaGFuZGxlIGludGVyYWN0aW9ucyB3aXRoIHdoaWxlSG92ZXIgKGV0YyksXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UganVzdCBoYXZlIHRvIGFuaW1hdGUgdGhlIGBNb3Rpb25WYWx1ZWAgaXRzZWxmLlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKGF4aXMsIGluZXJ0aWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUnVuIGFsbCBhbmltYXRpb25zIGFuZCB0aGVuIHJlc29sdmUgdGhlIG5ldyBkcmFnIGNvbnN0cmFpbnRzLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobW9tZW50dW1BbmltYXRpb25zKS50aGVuKG9uRHJhZ1RyYW5zaXRpb25FbmQpO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RhcnRBeGlzVmFsdWVBbmltYXRpb24gPSBmdW5jdGlvbiAoYXhpcywgdHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgIHJldHVybiBzdGFydEFuaW1hdGlvbihheGlzLCBheGlzVmFsdWUsIDAsIHRyYW5zaXRpb24pO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5zdG9wKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhZyB3b3JrcyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gd2hpY2ggcHJvcHMgYXJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogLSBJZiBfZHJhZ1ggYW5kIF9kcmFnWSBhcmUgcHJvdmlkZWQsIHdlIG91dHB1dCB0aGUgZ2VzdHVyZSBkZWx0YSBkaXJlY3RseSB0byB0aG9zZSBtb3Rpb24gdmFsdWVzLlxuICAgICAqIC0gT3RoZXJ3aXNlLCB3ZSBhcHBseSB0aGUgZGVsdGEgdG8gdGhlIHgveSBtb3Rpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLmdldEF4aXNNb3Rpb25WYWx1ZSA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBkcmFnS2V5ID0gXCJfZHJhZ1wiICsgYXhpcy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgZXh0ZXJuYWxNb3Rpb25WYWx1ZSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpW2RyYWdLZXldO1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWxNb3Rpb25WYWx1ZVxuICAgICAgICAgICAgPyBleHRlcm5hbE1vdGlvblZhbHVlXG4gICAgICAgICAgICA6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRWYWx1ZShheGlzLCAoX2IgPSAoX2EgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5pbml0aWFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYXhpc10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc25hcFRvQ3Vyc29yID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB2YXIgZHJhZyA9IF90aGlzLmdldFByb3BzKCkuZHJhZztcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkcmFnZ2luZyB0aGlzIGF4aXMsIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBfdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJvamVjdGlvbiA9IF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgICAgIHZhciBheGlzVmFsdWUgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHByb2plY3Rpb24ubGF5b3V0LmFjdHVhbFtheGlzXSwgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXg7XG4gICAgICAgICAgICAgICAgYXhpc1ZhbHVlLnNldChwb2ludFtheGlzXSAtIG1peChtaW4sIG1heCwgMC41KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgdmlld3BvcnQgcmVzaXplcyB3ZSB3YW50IHRvIGNoZWNrIGlmIHRoZSBtZWFzdXJlZCBjb25zdHJhaW50c1xuICAgICAqIGhhdmUgY2hhbmdlZCBhbmQsIGlmIHNvLCByZXBvc2l0aW9uIHRoZSBlbGVtZW50IHdpdGhpbiB0aG9zZSBuZXcgY29uc3RyYWludHNcbiAgICAgKiByZWxhdGl2ZSB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSByZXNpemUuXG4gICAgICovXG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuZ2V0UHJvcHMoKSwgZHJhZyA9IF9iLmRyYWcsIGRyYWdDb25zdHJhaW50cyA9IF9iLmRyYWdDb25zdHJhaW50cztcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgaWYgKCFpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpIHx8ICFwcm9qZWN0aW9uIHx8ICF0aGlzLmNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBjdXJyZW50IGFuaW1hdGlvbnMgYXMgdGhlcmUgY2FuIGJlIHZpc3VhbCBnbGl0Y2hpbmcgaWYgd2UgdHJ5IHRvIGRvXG4gICAgICAgICAqIHRoaXMgbWlkLWFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvcmQgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIGNvbnN0cmFpbnRzIGJveCBhbmQgc2F2ZSBhcyBhIHByb2dyZXNzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGJveFByb2dyZXNzID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB2YXIgYXhpc1ZhbHVlID0gX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgaWYgKGF4aXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXRlc3QgPSBheGlzVmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgYm94UHJvZ3Jlc3NbYXhpc10gPSBjYWxjT3JpZ2luKHsgbWluOiBsYXRlc3QsIG1heDogbGF0ZXN0IH0sIF90aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGxheW91dCBvZiB0aGlzIGVsZW1lbnQgYW5kIHJlc29sdmUgdGhlIGxhdGVzdCBkcmFnIGNvbnN0cmFpbnRzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LmdldEluc3RhbmNlKCkuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpXG4gICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAoX2EgPSBwcm9qZWN0aW9uLnJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBlYWNoIGF4aXMsIGNhbGN1bGF0ZSB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgbGF5b3V0IGF4aXNcbiAgICAgICAgICogd2l0aGluIHRoZSBuZXcgY29uc3RyYWludHMuXG4gICAgICAgICAqL1xuICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsY3VsYXRlIGEgbmV3IHRyYW5zZm9ybSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYm94IHByb2dyZXNzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBheGlzVmFsdWUgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5jb25zdHJhaW50c1theGlzXSwgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXg7XG4gICAgICAgICAgICBheGlzVmFsdWUuc2V0KG1peChtaW4sIG1heCwgYm94UHJvZ3Jlc3NbYXhpc10pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5hZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZWxlbWVudERyYWdDb250cm9scy5zZXQodGhpcy52aXN1YWxFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaCBhIHBvaW50ZXJkb3duIGV2ZW50IGxpc3RlbmVyIG9uIHRoaXMgRE9NIGVsZW1lbnQgdG8gaW5pdGlhdGUgZHJhZyB0cmFja2luZy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdG9wUG9pbnRlckxpc3RlbmVyID0gYWRkUG9pbnRlckV2ZW50KGVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5nZXRQcm9wcygpLCBkcmFnID0gX2EuZHJhZywgX2IgPSBfYS5kcmFnTGlzdGVuZXIsIGRyYWdMaXN0ZW5lciA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgICAgICAgICBkcmFnICYmIGRyYWdMaXN0ZW5lciAmJiBfdGhpcy5zdGFydChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWVhc3VyZURyYWdDb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcmFnQ29uc3RyYWludHMgPSBfdGhpcy5nZXRQcm9wcygpLmRyYWdDb25zdHJhaW50cztcbiAgICAgICAgICAgIGlmIChpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29uc3RyYWludHMgPSBfdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgdmFyIHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtZWFzdXJlXCIsIG1lYXN1cmVEcmFnQ29uc3RyYWludHMpO1xuICAgICAgICBpZiAocHJvamVjdGlvbiAmJiAhcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgIChfYSA9IHByb2plY3Rpb24ucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggYSB3aW5kb3cgcmVzaXplIGxpc3RlbmVyIHRvIHNjYWxlIHRoZSBkcmFnZ2FibGUgdGFyZ2V0IHdpdGhpbiBpdHMgZGVmaW5lZFxuICAgICAgICAgKiBjb25zdHJhaW50cyBhcyB0aGUgd2luZG93IHJlc2l6ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RvcFJlc2l6ZUxpc3RlbmVyID0gYWRkRG9tRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCdzIGxheW91dCBjaGFuZ2VzLCBjYWxjdWxhdGUgdGhlIGRlbHRhIGFuZCBhcHBseSB0aGF0IHRvXG4gICAgICAgICAqIHRoZSBkcmFnIGdlc3R1cmUncyBvcmlnaW4gcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gX2EuZGVsdGEsIGhhc0xheW91dENoYW5nZWQgPSBfYS5oYXNMYXlvdXRDaGFuZ2VkO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcgJiYgaGFzTGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3Rpb25WYWx1ZSA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3Rpb25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3JpZ2luUG9pbnRbYXhpc10gKz0gZGVsdGFbYXhpc10udHJhbnNsYXRlO1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb25WYWx1ZS5zZXQobW90aW9uVmFsdWUuZ2V0KCkgKyBkZWx0YVtheGlzXS50cmFuc2xhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdG9wUmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHN0b3BQb2ludGVyTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLmdldFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgdmFyIF9hID0gcHJvcHMuZHJhZywgZHJhZyA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IHByb3BzLmRyYWdEaXJlY3Rpb25Mb2NrLCBkcmFnRGlyZWN0aW9uTG9jayA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IHByb3BzLmRyYWdQcm9wYWdhdGlvbiwgZHJhZ1Byb3BhZ2F0aW9uID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gcHJvcHMuZHJhZ0NvbnN0cmFpbnRzLCBkcmFnQ29uc3RyYWludHMgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBwcm9wcy5kcmFnRWxhc3RpYywgZHJhZ0VsYXN0aWMgPSBfZSA9PT0gdm9pZCAwID8gZGVmYXVsdEVsYXN0aWMgOiBfZSwgX2YgPSBwcm9wcy5kcmFnTW9tZW50dW0sIGRyYWdNb21lbnR1bSA9IF9mID09PSB2b2lkIDAgPyB0cnVlIDogX2Y7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMpLCB7IGRyYWc6IGRyYWcsIGRyYWdEaXJlY3Rpb25Mb2NrOiBkcmFnRGlyZWN0aW9uTG9jaywgZHJhZ1Byb3BhZ2F0aW9uOiBkcmFnUHJvcGFnYXRpb24sIGRyYWdDb25zdHJhaW50czogZHJhZ0NvbnN0cmFpbnRzLCBkcmFnRWxhc3RpYzogZHJhZ0VsYXN0aWMsIGRyYWdNb21lbnR1bTogZHJhZ01vbWVudHVtIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHM7XG59KCkpO1xuZnVuY3Rpb24gc2hvdWxkRHJhZyhkaXJlY3Rpb24sIGRyYWcsIGN1cnJlbnREaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gKChkcmFnID09PSB0cnVlIHx8IGRyYWcgPT09IGRpcmVjdGlvbikgJiZcbiAgICAgICAgKGN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwgfHwgY3VycmVudERpcmVjdGlvbiA9PT0gZGlyZWN0aW9uKSk7XG59XG4vKipcbiAqIEJhc2VkIG9uIGFuIHgveSBvZmZzZXQgZGV0ZXJtaW5lIHRoZSBjdXJyZW50IGRyYWcgZGlyZWN0aW9uLiBJZiBib3RoIGF4aXMnIG9mZnNldHMgYXJlIGxvd2VyXG4gKiB0aGFuIHRoZSBwcm92aWRlZCB0aHJlc2hvbGQsIHJldHVybiBgbnVsbGAuXG4gKlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSB4L3kgb2Zmc2V0IGZyb20gb3JpZ2luLlxuICogQHBhcmFtIGxvY2tUaHJlc2hvbGQgLSAoT3B0aW9uYWwpIC0gdGhlIG1pbmltdW0gYWJzb2x1dGUgb2Zmc2V0IGJlZm9yZSB3ZSBjYW4gZGV0ZXJtaW5lIGEgZHJhZyBkaXJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0LCBsb2NrVGhyZXNob2xkKSB7XG4gICAgaWYgKGxvY2tUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBsb2NrVGhyZXNob2xkID0gMTA7IH1cbiAgICB2YXIgZGlyZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoTWF0aC5hYnMob2Zmc2V0LnkpID4gbG9ja1RocmVzaG9sZCkge1xuICAgICAgICBkaXJlY3Rpb24gPSBcInlcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnMob2Zmc2V0LngpID4gbG9ja1RocmVzaG9sZCkge1xuICAgICAgICBkaXJlY3Rpb24gPSBcInhcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZXhwb3J0IHsgVmlzdWFsRWxlbWVudERyYWdDb250cm9scywgZWxlbWVudERyYWdDb250cm9scyB9O1xuIiwgImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaXNNb3VzZUV2ZW50LCBpc1RvdWNoRXZlbnQgfSBmcm9tICcuL3V0aWxzL2V2ZW50LXR5cGUubWpzJztcbmltcG9ydCB7IGV4dHJhY3RFdmVudEluZm8gfSBmcm9tICcuLi9ldmVudHMvZXZlbnQtaW5mby5tanMnO1xuaW1wb3J0IHN5bmMsIHsgZ2V0RnJhbWVEYXRhLCBjYW5jZWxTeW5jIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IHNlY29uZHNUb01pbGxpc2Vjb25kcyB9IGZyb20gJy4uL3V0aWxzL3RpbWUtY29udmVyc2lvbi5tanMnO1xuaW1wb3J0IHsgYWRkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBkaXN0YW5jZSwgcGlwZSB9IGZyb20gJ3BvcG1vdGlvbic7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBQYW5TZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhblNlc3Npb24oZXZlbnQsIGhhbmRsZXJzLCBfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHJhbnNmb3JtUGFnZVBvaW50ID0gX2IudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEoX3RoaXMubGFzdE1vdmVFdmVudCAmJiBfdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZm8gPSBnZXRQYW5JbmZvKF90aGlzLmxhc3RNb3ZlRXZlbnRJbmZvLCBfdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIHZhciBpc1BhblN0YXJ0ZWQgPSBfdGhpcy5zdGFydEV2ZW50ICE9PSBudWxsO1xuICAgICAgICAgICAgLy8gT25seSBzdGFydCBwYW5uaW5nIGlmIHRoZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gMyBwaXhlbHMuIElmIHdlIG1ha2UgaXRcbiAgICAgICAgICAgIC8vIGFueSBsYXJnZXIgdGhhbiB0aGlzIHdlJ2xsIHdhbnQgdG8gcmVzZXQgdGhlIHBvaW50ZXIgaGlzdG9yeVxuICAgICAgICAgICAgLy8gb24gdGhlIGZpcnN0IHVwZGF0ZSB0byBhdm9pZCB2aXN1YWwgc25hcHBpbmcgdG8gdGhlIGN1cnNvZS5cbiAgICAgICAgICAgIHZhciBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IGRpc3RhbmNlKGluZm8ub2Zmc2V0LCB7IHg6IDAsIHk6IDAgfSkgPj0gMztcbiAgICAgICAgICAgIGlmICghaXNQYW5TdGFydGVkICYmICFpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBpbmZvLnBvaW50O1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGdldEZyYW1lRGF0YSgpLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIF90aGlzLmhpc3RvcnkucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcG9pbnQpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wIH0pKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmhhbmRsZXJzLCBvblN0YXJ0ID0gX2Eub25TdGFydCwgb25Nb3ZlID0gX2Eub25Nb3ZlO1xuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoX3RoaXMubGFzdE1vdmVFdmVudCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRFdmVudCA9IF90aGlzLmxhc3RNb3ZlRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1vdmUgJiYgb25Nb3ZlKF90aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXN0TW92ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBfdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIF90aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIFNhZmFyaSBkb2Vzbid0IHRyaWdnZXIgbW91c2V1cCBldmVudHMgd2hlbiBpdCdzIGFib3ZlIGEgYDxzZWxlY3Q+YFxuICAgICAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJVcChldmVudCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhyb3R0bGUgbW91c2UgbW92ZSBldmVudCB0byBvbmNlIHBlciBmcmFtZVxuICAgICAgICAgICAgc3luYy51cGRhdGUoX3RoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgX3RoaXMuZW5kKCk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5oYW5kbGVycywgb25FbmQgPSBfYS5vbkVuZCwgb25TZXNzaW9uRW5kID0gX2Eub25TZXNzaW9uRW5kO1xuICAgICAgICAgICAgdmFyIHBhbkluZm8gPSBnZXRQYW5JbmZvKHRyYW5zZm9ybVBvaW50KGluZm8sIF90aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCksIF90aGlzLmhpc3RvcnkpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0RXZlbnQgJiYgb25FbmQpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChldmVudCwgcGFuSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblNlc3Npb25FbmQgJiYgb25TZXNzaW9uRW5kKGV2ZW50LCBwYW5JbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHRvdWNoLCBkb24ndCBzdGFydCBkZXRlY3RpbmcgdGhpcyBnZXN0dXJlXG4gICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCA9IHRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICAgICAgdmFyIGluZm8gPSBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KTtcbiAgICAgICAgdmFyIGluaXRpYWxJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgICB2YXIgcG9pbnQgPSBpbml0aWFsSW5mby5wb2ludDtcbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGdldEZyYW1lRGF0YSgpLnRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW19fYXNzaWduKF9fYXNzaWduKHt9LCBwb2ludCksIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSldO1xuICAgICAgICB2YXIgb25TZXNzaW9uU3RhcnQgPSBoYW5kbGVycy5vblNlc3Npb25TdGFydDtcbiAgICAgICAgb25TZXNzaW9uU3RhcnQgJiZcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0KGV2ZW50LCBnZXRQYW5JbmZvKGluaXRpYWxJbmZvLCB0aGlzLmhpc3RvcnkpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgPSBwaXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcm1vdmVcIiwgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSk7XG4gICAgfVxuICAgIFBhblNlc3Npb24ucHJvdG90eXBlLnVwZGF0ZUhhbmRsZXJzID0gZnVuY3Rpb24gKGhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB9O1xuICAgIFBhblNlc3Npb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgY2FuY2VsU3luYy51cGRhdGUodGhpcy51cGRhdGVQb2ludCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFuU2Vzc2lvbjtcbn0oKSk7XG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChpbmZvLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFnZVBvaW50ID8geyBwb2ludDogdHJhbnNmb3JtUGFnZVBvaW50KGluZm8ucG9pbnQpIH0gOiBpbmZvO1xufVxuZnVuY3Rpb24gc3VidHJhY3RQb2ludChhLCBiKSB7XG4gICAgcmV0dXJuIHsgeDogYS54IC0gYi54LCB5OiBhLnkgLSBiLnkgfTtcbn1cbmZ1bmN0aW9uIGdldFBhbkluZm8oX2EsIGhpc3RvcnkpIHtcbiAgICB2YXIgcG9pbnQgPSBfYS5wb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGRlbHRhOiBzdWJ0cmFjdFBvaW50KHBvaW50LCBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSkpLFxuICAgICAgICBvZmZzZXQ6IHN1YnRyYWN0UG9pbnQocG9pbnQsIHN0YXJ0RGV2aWNlUG9pbnQoaGlzdG9yeSkpLFxuICAgICAgICB2ZWxvY2l0eTogZ2V0VmVsb2NpdHkoaGlzdG9yeSwgMC4xKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGhpc3RvcnlbMF07XG59XG5mdW5jdGlvbiBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSkge1xuICAgIHJldHVybiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRWZWxvY2l0eShoaXN0b3J5LCB0aW1lRGVsdGEpIHtcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgdmFyIGkgPSBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gICAgdmFyIHRpbWVzdGFtcGVkUG9pbnQgPSBudWxsO1xuICAgIHZhciBsYXN0UG9pbnQgPSBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSk7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICB0aW1lc3RhbXBlZFBvaW50ID0gaGlzdG9yeVtpXTtcbiAgICAgICAgaWYgKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCA+XG4gICAgICAgICAgICBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZURlbHRhKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoIXRpbWVzdGFtcGVkUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICB2YXIgdGltZSA9IChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXApIC8gMTAwMDtcbiAgICBpZiAodGltZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuICAgIHZhciBjdXJyZW50VmVsb2NpdHkgPSB7XG4gICAgICAgIHg6IChsYXN0UG9pbnQueCAtIHRpbWVzdGFtcGVkUG9pbnQueCkgLyB0aW1lLFxuICAgICAgICB5OiAobGFzdFBvaW50LnkgLSB0aW1lc3RhbXBlZFBvaW50LnkpIC8gdGltZSxcbiAgICB9O1xuICAgIGlmIChjdXJyZW50VmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY3VycmVudFZlbG9jaXR5LnggPSAwO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFZlbG9jaXR5LnkgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGN1cnJlbnRWZWxvY2l0eS55ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRWZWxvY2l0eTtcbn1cblxuZXhwb3J0IHsgUGFuU2Vzc2lvbiB9O1xuIiwgImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGNsYW1wLCBtaXgsIHByb2dyZXNzIH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IGNhbGNMZW5ndGggfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcblxuLyoqXG4gKiBBcHBseSBjb25zdHJhaW50cyB0byBhIHBvaW50LiBUaGVzZSBjb25zdHJhaW50cyBhcmUgYm90aCBwaHlzaWNhbCBhbG9uZyBhblxuICogYXhpcywgYW5kIGFuIGVsYXN0aWMgZmFjdG9yIHRoYXQgZGV0ZXJtaW5lcyBob3cgbXVjaCB0byBjb25zdHJhaW4gdGhlIHBvaW50XG4gKiBieSBpZiBpdCBkb2VzIGxpZSBvdXRzaWRlIHRoZSBkZWZpbmVkIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q29uc3RyYWludHMocG9pbnQsIF9hLCBlbGFzdGljKSB7XG4gICAgdmFyIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBwb2ludCA8IG1pbikge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWluIHBvaW50IGRlZmluZWQsIGFuZCB0aGlzIGlzIG91dHNpZGUgb2YgdGhhdCwgY29uc3RyYWluXG4gICAgICAgIHBvaW50ID0gZWxhc3RpYyA/IG1peChtaW4sIHBvaW50LCBlbGFzdGljLm1pbikgOiBNYXRoLm1heChwb2ludCwgbWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgcG9pbnQgPiBtYXgpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1heCBwb2ludCBkZWZpbmVkLCBhbmQgdGhpcyBpcyBvdXRzaWRlIG9mIHRoYXQsIGNvbnN0cmFpblxuICAgICAgICBwb2ludCA9IGVsYXN0aWMgPyBtaXgobWF4LCBwb2ludCwgZWxhc3RpYy5tYXgpIDogTWF0aC5taW4ocG9pbnQsIG1heCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuIGRlZmluZWQgcmVsYXRpdmVseSB0byB0aGVcbiAqIG1lYXN1cmVkIGF4aXMuIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSB0aGUgbmVhcmVzdCBlZGdlLCBzbyBhIG1heCBjb25zdHJhaW50IG9mIDIwMFxuICogb24gYW4gYXhpcyB3aXRoIGEgbWF4IHZhbHVlIG9mIDMwMCB3b3VsZCByZXR1cm4gYSBjb25zdHJhaW50IG9mIDUwMCAtIGF4aXMgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhheGlzLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluICE9PSB1bmRlZmluZWQgPyBheGlzLm1pbiArIG1pbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4OiBtYXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBheGlzLm1heCArIG1heCAtIChheGlzLm1heCAtIGF4aXMubWluKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuXG4gKiBkZWZpbmVkIHJlbGF0aXZlbHkgdG8gdGhlIG1lYXN1cmVkIGJvdW5kaW5nIGJveC5cbiAqL1xuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0Qm94LCBfYSkge1xuICAgIHZhciB0b3AgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0LCBib3R0b20gPSBfYS5ib3R0b20sIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBsZWZ0LCByaWdodCksXG4gICAgICAgIHk6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgdG9wLCBib3R0b20pLFxuICAgIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBheGlzXG4gKi9cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRBeGlzLCBjb25zdHJhaW50c0F4aXMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIG1pbiA9IGNvbnN0cmFpbnRzQXhpcy5taW4gLSBsYXlvdXRBeGlzLm1pbjtcbiAgICB2YXIgbWF4ID0gY29uc3RyYWludHNBeGlzLm1heCAtIGxheW91dEF4aXMubWF4O1xuICAgIC8vIElmIHRoZSBjb25zdHJhaW50cyBheGlzIGlzIGFjdHVhbGx5IHNtYWxsZXIgdGhhbiB0aGUgbGF5b3V0IGF4aXMgdGhlbiB3ZSBjYW5cbiAgICAvLyBmbGlwIHRoZSBjb25zdHJhaW50c1xuICAgIGlmIChjb25zdHJhaW50c0F4aXMubWF4IC0gY29uc3RyYWludHNBeGlzLm1pbiA8XG4gICAgICAgIGxheW91dEF4aXMubWF4IC0gbGF5b3V0QXhpcy5taW4pIHtcbiAgICAgICAgX2EgPSBfX3JlYWQoW21heCwgbWluXSwgMiksIG1pbiA9IF9hWzBdLCBtYXggPSBfYVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluOiBtaW4sIG1heDogbWF4IH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBib3hcbiAqL1xuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMobGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgY29uc3RyYWludHNCb3gueCksXG4gICAgICAgIHk6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgY29uc3RyYWludHNCb3gueSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgc291cmNlIGF4aXMsIGJldHdlZW4gMC0xLCB0aGF0IHJlc3VsdHNcbiAqIGluIGFuIGFzdGhldGljYWxseSBwbGVhc2luZyBzY2FsZS90cmFuc2Zvcm0gbmVlZGVkIHRvIHByb2plY3QgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBjYWxjT3JpZ2luKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgdmFyIG9yaWdpbiA9IDAuNTtcbiAgICB2YXIgc291cmNlTGVuZ3RoID0gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIHZhciB0YXJnZXRMZW5ndGggPSBjYWxjTGVuZ3RoKHRhcmdldCk7XG4gICAgaWYgKHRhcmdldExlbmd0aCA+IHNvdXJjZUxlbmd0aCkge1xuICAgICAgICBvcmlnaW4gPSBwcm9ncmVzcyh0YXJnZXQubWluLCB0YXJnZXQubWF4IC0gc291cmNlTGVuZ3RoLCBzb3VyY2UubWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlTGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIG9yaWdpbiA9IHByb2dyZXNzKHNvdXJjZS5taW4sIHNvdXJjZS5tYXggLSB0YXJnZXRMZW5ndGgsIHRhcmdldC5taW4pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXAoMCwgMSwgb3JpZ2luKTtcbn1cbi8qKlxuICogUmViYXNlIHRoZSBjYWxjdWxhdGVkIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHJlbGF0aXZlIHRvIHRoZSBsYXlvdXQubWluIHBvaW50LlxuICovXG5mdW5jdGlvbiByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LCBjb25zdHJhaW50cykge1xuICAgIHZhciByZWxhdGl2ZUNvbnN0cmFpbnRzID0ge307XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWluID0gY29uc3RyYWludHMubWluIC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWF4ID0gY29uc3RyYWludHMubWF4IC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF0aXZlQ29uc3RyYWludHM7XG59XG52YXIgZGVmYXVsdEVsYXN0aWMgPSAwLjM1O1xuLyoqXG4gKiBBY2NlcHRzIGEgZHJhZ0VsYXN0aWMgcHJvcCBhbmQgcmV0dXJucyByZXNvbHZlZCBlbGFzdGljIHZhbHVlcyBmb3IgZWFjaCBheGlzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMpIHtcbiAgICBpZiAoZHJhZ0VsYXN0aWMgPT09IHZvaWQgMCkgeyBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljOyB9XG4gICAgaWYgKGRyYWdFbGFzdGljID09PSBmYWxzZSkge1xuICAgICAgICBkcmFnRWxhc3RpYyA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWdFbGFzdGljID09PSB0cnVlKSB7XG4gICAgICAgIGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJsZWZ0XCIsIFwicmlnaHRcIiksXG4gICAgICAgIHk6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJ0b3BcIiwgXCJib3R0b21cIiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwsIG1heExhYmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCksXG4gICAgICAgIG1heDogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWF4TGFiZWwpLFxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBsYWJlbCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gdHlwZW9mIGRyYWdFbGFzdGljID09PSBcIm51bWJlclwiXG4gICAgICAgID8gZHJhZ0VsYXN0aWNcbiAgICAgICAgOiAoX2EgPSBkcmFnRWxhc3RpY1tsYWJlbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG59XG5cbmV4cG9ydCB7IGFwcGx5Q29uc3RyYWludHMsIGNhbGNPcmlnaW4sIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cywgY2FsY1JlbGF0aXZlQ29uc3RyYWludHMsIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cywgY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMsIGRlZmF1bHRFbGFzdGljLCByZWJhc2VBeGlzQ29uc3RyYWludHMsIHJlc29sdmVBeGlzRWxhc3RpYywgcmVzb2x2ZURyYWdFbGFzdGljLCByZXNvbHZlUG9pbnRFbGFzdGljIH07XG4iLCAiaW1wb3J0IHsgY29udmVydEJvdW5kaW5nQm94VG9Cb3gsIHRyYW5zZm9ybUJveFBvaW50cyB9IGZyb20gJy4uL2dlb21ldHJ5L2NvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IHRyYW5zbGF0ZUF4aXMgfSBmcm9tICcuLi9nZW9tZXRyeS9kZWx0YS1hcHBseS5tanMnO1xuXG5mdW5jdGlvbiBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIHRyYW5zZm9ybVBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHRyYW5zZm9ybUJveFBvaW50cyhpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJhbnNmb3JtUG9pbnQpKTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVQYWdlQm94KGVsZW1lbnQsIHJvb3RQcm9qZWN0aW9uTm9kZSwgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gICAgdmFyIHZpZXdwb3J0Qm94ID0gbWVhc3VyZVZpZXdwb3J0Qm94KGVsZW1lbnQsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgdmFyIHNjcm9sbCA9IHJvb3RQcm9qZWN0aW9uTm9kZS5zY3JvbGw7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LngsIHNjcm9sbC54KTtcbiAgICAgICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC55LCBzY3JvbGwueSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3cG9ydEJveDtcbn1cblxuZXhwb3J0IHsgbWVhc3VyZVBhZ2VCb3gsIG1lYXN1cmVWaWV3cG9ydEJveCB9O1xuIiwgIi8qKlxuICogQm91bmRpbmcgYm94ZXMgdGVuZCB0byBiZSBkZWZpbmVkIGFzIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbS4gRm9yIHZhcmlvdXMgb3BlcmF0aW9uc1xuICogaXQncyBlYXNpZXIgdG8gY29uc2lkZXIgZWFjaCBheGlzIGluZGl2aWR1YWxseS4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYm91bmRpbmcgYm94XG4gKiBhcyBhIG1hcCBvZiBzaW5nbGUtYXhpcyBtaW4vbWF4IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJvdW5kaW5nQm94VG9Cb3goX2EpIHtcbiAgICB2YXIgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgYm90dG9tID0gX2EuYm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHsgbWluOiBsZWZ0LCBtYXg6IHJpZ2h0IH0sXG4gICAgICAgIHk6IHsgbWluOiB0b3AsIG1heDogYm90dG9tIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KF9hKSB7XG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICByZXR1cm4geyB0b3A6IHkubWluLCByaWdodDogeC5tYXgsIGJvdHRvbTogeS5tYXgsIGxlZnQ6IHgubWluIH07XG59XG4vKipcbiAqIEFwcGxpZXMgYSBUcmFuc2Zvcm1Qb2ludCBmdW5jdGlvbiB0byBhIGJvdW5kaW5nIGJveC4gVHJhbnNmb3JtUG9pbnQgaXMgdXN1YWxseSBhIGZ1bmN0aW9uXG4gKiBwcm92aWRlZCBieSBGcmFtZXIgdG8gYWxsb3cgbWVhc3VyZWQgcG9pbnRzIHRvIGJlIGNvcnJlY3RlZCBmb3IgZGV2aWNlIHNjYWxpbmcuIFRoaXMgaXMgdXNlZFxuICogd2hlbiBtZWFzdXJpbmcgRE9NIGVsZW1lbnRzIGFuZCBET00gZXZlbnQgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Cb3hQb2ludHMocG9pbnQsIHRyYW5zZm9ybVBvaW50KSB7XG4gICAgaWYgKCF0cmFuc2Zvcm1Qb2ludClcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIHZhciB0b3BMZWZ0ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiBwb2ludC5sZWZ0LCB5OiBwb2ludC50b3AgfSk7XG4gICAgdmFyIGJvdHRvbVJpZ2h0ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiBwb2ludC5yaWdodCwgeTogcG9pbnQuYm90dG9tIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wTGVmdC55LFxuICAgICAgICBsZWZ0OiB0b3BMZWZ0LngsXG4gICAgICAgIGJvdHRvbTogYm90dG9tUmlnaHQueSxcbiAgICAgICAgcmlnaHQ6IGJvdHRvbVJpZ2h0LngsXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgY29udmVydEJvdW5kaW5nQm94VG9Cb3gsIGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94LCB0cmFuc2Zvcm1Cb3hQb2ludHMgfTtcbiIsICJpbXBvcnQgeyB1c2VSZWYsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZVVubW91bnRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2UtdW5tb3VudC1lZmZlY3QubWpzJztcbmltcG9ydCB7IHVzZVBvaW50ZXJFdmVudCB9IGZyb20gJy4uL2V2ZW50cy91c2UtcG9pbnRlci1ldmVudC5tanMnO1xuaW1wb3J0IHsgUGFuU2Vzc2lvbiB9IGZyb20gJy4vUGFuU2Vzc2lvbi5tanMnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gaGFuZGxlcnMgLVxuICogQHBhcmFtIHJlZiAtXG4gKlxuICogQGludGVybmFscmVtYXJrc1xuICogQ3VycmVudGx5IHRoaXMgc2V0cyBuZXcgcGFuIGdlc3R1cmUgZnVuY3Rpb25zIGV2ZXJ5IHJlbmRlci4gVGhlIG1lbW8gcm91dGUgaGFzIGJlZW4gZXhwbG9yZWRcbiAqIGluIHRoZSBwYXN0IGJ1dCB1bHRpbWF0ZWx5IHdlJ3JlIHN0aWxsIGNyZWF0aW5nIG5ldyBmdW5jdGlvbnMgZXZlcnkgcmVuZGVyLiBBbiBvcHRpbWlzYXRpb25cbiAqIHRvIGV4cGxvcmUgaXMgY3JlYXRpbmcgdGhlIHBhbiBnZXN0dXJlcyBhbmQgbG9hZGluZyB0aGVtIGludG8gYSBgcmVmYC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlUGFuR2VzdHVyZShfYSkge1xuICAgIHZhciBvblBhbiA9IF9hLm9uUGFuLCBvblBhblN0YXJ0ID0gX2Eub25QYW5TdGFydCwgb25QYW5FbmQgPSBfYS5vblBhbkVuZCwgb25QYW5TZXNzaW9uU3RhcnQgPSBfYS5vblBhblNlc3Npb25TdGFydCwgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gICAgdmFyIGhhc1BhbkV2ZW50cyA9IG9uUGFuIHx8IG9uUGFuU3RhcnQgfHwgb25QYW5FbmQgfHwgb25QYW5TZXNzaW9uU3RhcnQ7XG4gICAgdmFyIHBhblNlc3Npb24gPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IHVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIHZhciBoYW5kbGVycyA9IHtcbiAgICAgICAgb25TZXNzaW9uU3RhcnQ6IG9uUGFuU2Vzc2lvblN0YXJ0LFxuICAgICAgICBvblN0YXJ0OiBvblBhblN0YXJ0LFxuICAgICAgICBvbk1vdmU6IG9uUGFuLFxuICAgICAgICBvbkVuZDogZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgICAgICBwYW5TZXNzaW9uLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgb25QYW5FbmQgJiYgb25QYW5FbmQoZXZlbnQsIGluZm8pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHBhblNlc3Npb24uY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50LnVwZGF0ZUhhbmRsZXJzKGhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbmV3IFBhblNlc3Npb24oZXZlbnQsIGhhbmRsZXJzLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRyYW5zZm9ybVBhZ2VQb2ludCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGhhc1BhbkV2ZW50cyAmJiBvblBvaW50ZXJEb3duKTtcbiAgICB1c2VVbm1vdW50RWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhblNlc3Npb24uY3VycmVudCAmJiBwYW5TZXNzaW9uLmN1cnJlbnQuZW5kKCk7IH0pO1xufVxuXG5leHBvcnQgeyB1c2VQYW5HZXN0dXJlIH07XG4iLCAiaW1wb3J0IHsgaHRtbFZpc3VhbEVsZW1lbnQgfSBmcm9tICcuLi9odG1sL3Zpc3VhbC1lbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBzdmdWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vc3ZnL3Zpc3VhbC1lbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBpc1NWR0NvbXBvbmVudCB9IGZyb20gJy4vdXRpbHMvaXMtc3ZnLWNvbXBvbmVudC5tanMnO1xuXG52YXIgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCA9IGZ1bmN0aW9uIChDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KVxuICAgICAgICA/IHN2Z1Zpc3VhbEVsZW1lbnQob3B0aW9ucywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSlcbiAgICAgICAgOiBodG1sVmlzdWFsRWxlbWVudChvcHRpb25zLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiB0cnVlIH0pO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCB9O1xuIiwgImltcG9ydCB7IF9fcmVzdCwgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB2aXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vaW5kZXgubWpzJztcbmltcG9ydCB7IGdldE9yaWdpbiwgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMgfSBmcm9tICcuLi91dGlscy9zZXR0ZXJzLm1qcyc7XG5pbXBvcnQgeyBidWlsZEhUTUxTdHlsZXMgfSBmcm9tICcuL3V0aWxzL2J1aWxkLXN0eWxlcy5tanMnO1xuaW1wb3J0IHsgaXNDU1NWYXJpYWJsZSB9IGZyb20gJy4uL2RvbS91dGlscy9pcy1jc3MtdmFyaWFibGUubWpzJztcbmltcG9ydCB7IHBhcnNlRG9tVmFyaWFudCB9IGZyb20gJy4uL2RvbS91dGlscy9wYXJzZS1kb20tdmFyaWFudC5tanMnO1xuaW1wb3J0IHsgaXNUcmFuc2Zvcm1Qcm9wIH0gZnJvbSAnLi91dGlscy90cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcbmltcG9ydCB7IHJlbmRlckhUTUwgfSBmcm9tICcuL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFZhbHVlVHlwZSB9IGZyb20gJy4uL2RvbS92YWx1ZS10eXBlcy9kZWZhdWx0cy5tanMnO1xuaW1wb3J0IHsgbWVhc3VyZVZpZXdwb3J0Qm94IH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi91dGlscy9tZWFzdXJlLm1qcyc7XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbnZhciBodG1sQ29uZmlnID0ge1xuICAgIHRyZWVUeXBlOiBcImRvbVwiLFxuICAgIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGtleSkge1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gKChpc0NTU1ZhcmlhYmxlKGtleSlcbiAgICAgICAgICAgICAgICA/IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpXG4gICAgICAgICAgICAgICAgOiBjb21wdXRlZFN0eWxlW2tleV0pIHx8IDApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzb3J0Tm9kZVBvc2l0aW9uOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvKipcbiAgICAgICAgICogY29tcGFyZURvY3VtZW50UG9zaXRpb24gcmV0dXJucyBhIGJpdG1hc2ssIGJ5IHVzaW5nIHRoZSBiaXR3aXNlICZcbiAgICAgICAgICogd2UncmUgcmV0dXJuaW5nIHRydWUgaWYgMiBpbiB0aGF0IGJpdG1hc2sgaXMgc2V0IHRvIHRydWUuIDIgaXMgc2V0XG4gICAgICAgICAqIHRvIHRydWUgaWYgYiBwcmVjZWVkcyBhLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiAyID8gMSA6IC0xO1xuICAgIH0sXG4gICAgZ2V0QmFzZVRhcmdldDogZnVuY3Rpb24gKHByb3BzLCBrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gcHJvcHMuc3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldO1xuICAgIH0sXG4gICAgbWVhc3VyZVZpZXdwb3J0Qm94OiBmdW5jdGlvbiAoZWxlbWVudCwgX2EpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IF9hLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChlbGVtZW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHRyYW5zZm9ybSBvbiB0aGUgY3VycmVudCBFbGVtZW50LiBUaGlzIGlzIGNhbGxlZCBhcyBwYXJ0XG4gICAgICogb2YgYSBiYXRjaGVkIHByb2Nlc3MgYWNyb3NzIHRoZSBlbnRpcmUgbGF5b3V0IHRyZWUuIFRvIHJlbW92ZSB0aGlzIHdyaXRlXG4gICAgICogY3ljbGUgaXQnZCBiZSBpbnRlcmVzdGluZyB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBcInVuZG9cIiBhbGwgdGhlIGN1cnJlbnRcbiAgICAgKiBsYXlvdXQgdHJhbnNmb3JtcyB1cCB0aGUgdHJlZSBpbiB0aGUgc2FtZSB3YXkgdGhpcy5nZXRCb3VuZGluZ0JveFdpdGhvdXRUcmFuc2Zvcm1zXG4gICAgICogd29ya3NcbiAgICAgKi9cbiAgICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKGVsZW1lbnQsIGRvbUVsZW1lbnQsIHByb3BzKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgICBkb21FbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKVxuICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2hhdGV2ZXIgaGFwcGVucyBuZXh0LCB3ZSByZXN0b3JlIG91ciB0cmFuc2Zvcm0gb24gdGhlIG5leHQgZnJhbWVcbiAgICAgICAgZWxlbWVudC5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH0sXG4gICAgcmVzdG9yZVRyYW5zZm9ybTogZnVuY3Rpb24gKGluc3RhbmNlLCBtdXRhYmxlU3RhdGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3R5bGUudHJhbnNmb3JtID0gbXV0YWJsZVN0YXRlLnN0eWxlLnRyYW5zZm9ybTtcbiAgICB9LFxuICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlOiBmdW5jdGlvbiAoa2V5LCBfYSkge1xuICAgICAgICB2YXIgdmFycyA9IF9hLnZhcnMsIHN0eWxlID0gX2Euc3R5bGU7XG4gICAgICAgIGRlbGV0ZSB2YXJzW2tleV07XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgSFRNTCBhbmQgRnJhbWVyLXNwZWNpZmljIHZhbHVlIHR5cGVzIGxpa2UgYHB4YC0+YCVgIGFuZCBgQ29sb3JgXG4gICAgICogY2FuIGJlIGFuaW1hdGVkIGJ5IE1vdGlvbi5cbiAgICAgKi9cbiAgICBtYWtlVGFyZ2V0QW5pbWF0YWJsZTogZnVuY3Rpb24gKGVsZW1lbnQsIF9hLCBfYiwgaXNNb3VudGVkKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1WYWx1ZXMgPSBfYi50cmFuc2Zvcm1WYWx1ZXM7XG4gICAgICAgIGlmIChpc01vdW50ZWQgPT09IHZvaWQgMCkgeyBpc01vdW50ZWQgPSB0cnVlOyB9XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gX2EudHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZCA9IF9hLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IF9fcmVzdChfYSwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgICAgICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKHRhcmdldCwgdHJhbnNpdGlvbiB8fCB7fSwgZWxlbWVudCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBGcmFtZXIgaGFzIHByb3ZpZGVkIGEgZnVuY3Rpb24gdG8gY29udmVydCBgQ29sb3JgIGV0YyB2YWx1ZSB0eXBlcywgY29udmVydCB0aGVtXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHJhbnNmb3JtVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbkVuZClcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kID0gdHJhbnNmb3JtVmFsdWVzKHRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm1WYWx1ZXModGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4pXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gdHJhbnNmb3JtVmFsdWVzKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgICAgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMoZWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRG9tVmFyaWFudChlbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRW5kID0gcGFyc2VkLnRyYW5zaXRpb25FbmQ7XG4gICAgICAgICAgICB0YXJnZXQgPSBwYXJzZWQudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7IHRyYW5zaXRpb246IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfSwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLFxuICAgIGJ1aWxkOiBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNWaXNpYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlLnZpc2liaWxpdHkgPSBlbGVtZW50LmlzVmlzaWJsZVxuICAgICAgICAgICAgICAgID8gXCJ2aXNpYmxlXCJcbiAgICAgICAgICAgICAgICA6IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9LFxuICAgIHJlbmRlcjogcmVuZGVySFRNTCxcbn07XG52YXIgaHRtbFZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50KGh0bWxDb25maWcpO1xuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBodG1sQ29uZmlnLCBodG1sVmlzdWFsRWxlbWVudCB9O1xuIiwgImltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5LCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgc3luYywgeyBjYW5jZWxTeW5jIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IG1vdGlvblZhbHVlIH0gZnJvbSAnLi4vdmFsdWUvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IHZhcmlhbnRQcmlvcml0eU9yZGVyIH0gZnJvbSAnLi91dGlscy9hbmltYXRpb24tc3RhdGUubWpzJztcbmltcG9ydCB7IGNyZWF0ZUxpZmVjeWNsZXMgfSBmcm9tICcuL3V0aWxzL2xpZmVjeWNsZXMubWpzJztcbmltcG9ydCB7IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvbW90aW9uLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMsIGNoZWNrSWZWYXJpYW50Tm9kZSwgaXNWYXJpYW50TGFiZWwgfSBmcm9tICcuL3V0aWxzL3ZhcmlhbnRzLm1qcyc7XG5cbnZhciB2aXN1YWxFbGVtZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EudHJlZVR5cGUsIHRyZWVUeXBlID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYiwgYnVpbGQgPSBfYS5idWlsZCwgZ2V0QmFzZVRhcmdldCA9IF9hLmdldEJhc2VUYXJnZXQsIG1ha2VUYXJnZXRBbmltYXRhYmxlID0gX2EubWFrZVRhcmdldEFuaW1hdGFibGUsIG1lYXN1cmVWaWV3cG9ydEJveCA9IF9hLm1lYXN1cmVWaWV3cG9ydEJveCwgcmVuZGVySW5zdGFuY2UgPSBfYS5yZW5kZXIsIHJlYWRWYWx1ZUZyb21JbnN0YW5jZSA9IF9hLnJlYWRWYWx1ZUZyb21JbnN0YW5jZSwgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUgPSBfYS5yZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZSwgc29ydE5vZGVQb3NpdGlvbiA9IF9hLnNvcnROb2RlUG9zaXRpb24sIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyA9IF9hLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBfYS5wYXJlbnQsIHByb3BzID0gX2EucHJvcHMsIHByZXNlbmNlSWQgPSBfYS5wcmVzZW5jZUlkLCBibG9ja0luaXRpYWxBbmltYXRpb24gPSBfYS5ibG9ja0luaXRpYWxBbmltYXRpb24sIHZpc3VhbFN0YXRlID0gX2EudmlzdWFsU3RhdGUsIHNob3VsZFJlZHVjZU1vdGlvbiA9IF9hLnNob3VsZFJlZHVjZU1vdGlvbjtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbGF0ZXN0VmFsdWVzID0gdmlzdWFsU3RhdGUubGF0ZXN0VmFsdWVzLCByZW5kZXJTdGF0ZSA9IHZpc3VhbFN0YXRlLnJlbmRlclN0YXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG9mIHRoZSByZW5kZXItc3BlY2lmaWMgbm9kZSB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQgYnkgdGhlXG4gICAgICAgICAqIGV4cG9zZWQgUmVhY3QgcmVmLiBTbyBmb3IgZXhhbXBsZSwgdGhpcyB2aXN1YWwgZWxlbWVudCBjYW4gaG9zdCBhXG4gICAgICAgICAqIEhUTUxFbGVtZW50LCBwbGFpbiBvYmplY3QsIG9yIFRocmVlLmpzIG9iamVjdC4gVGhlIGZ1bmN0aW9ucyBwcm92aWRlZFxuICAgICAgICAgKiBpbiBWaXN1YWxFbGVtZW50Q29uZmlnIGFsbG93IHVzIHRvIGludGVyZmFjZSB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaW5zdGFuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBzdWJzY3JpcHRpb25zIGZvciBhIHZpc3VhbCBlbGVtZW50J3MgbGlmZWN5Y2xlLCBmb3IgaW5zdGFuY2VcbiAgICAgICAgICogb25SZW5kZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsaWZlY3ljbGVzID0gY3JlYXRlTGlmZWN5Y2xlcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgYWxsIG1vdGlvbiB2YWx1ZXMgYXR0YWNoZWQgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC4gTW90aW9uXG4gICAgICAgICAqIHZhbHVlcyBhcmUgc291cmNlIG9mIHRydXRoIGZvciBhbnkgZ2l2ZW4gYW5pbWF0ZWQgdmFsdWUuIEEgbW90aW9uXG4gICAgICAgICAqIHZhbHVlIG1pZ2h0IGJlIHByb3ZpZGVkIGV4dGVybmFsbHkgYnkgdGhlIGNvbXBvbmVudCB2aWEgcHJvcHMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgZXZlcnkgc3Vic2NyaXB0aW9uIHRoYXQgYmluZHMgdGhlIHByb3ZpZGVkIG9yIGdlbmVyYXRlZFxuICAgICAgICAgKiBtb3Rpb24gdmFsdWVzIG9uQ2hhbmdlIGxpc3RlbmVycyB0byB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHZhbHVlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91c2x5LXByb3ZpZGVkIG1vdGlvbiB2YWx1ZXMgYXMgcmV0dXJuZWRcbiAgICAgICAgICogZnJvbSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMuIFdlIHVzZSB0aGUga2V5cyBpbiBoZXJlIHRvIGRldGVybWluZVxuICAgICAgICAgKiBpZiBhbnkgbW90aW9uIHZhbHVlcyBuZWVkIHRvIGJlIHJlbW92ZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcHJldk1vdGlvblZhbHVlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB2YWx1ZXMgYXJlIHJlbW92ZWQgZnJvbSBhbGwgYW5pbWF0aW9uIHByb3BzIHdlIG5lZWQgdG8gc2VhcmNoXG4gICAgICAgICAqIGZvciBhIGZhbGxiYWNrIHZhbHVlIHRvIGFuaW1hdGUgdG8uIFRoZXNlIHZhbHVlcyBhcmUgdHJhY2tlZCBpbiBiYXNlVGFyZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGJhc2VUYXJnZXQgPSBfX2Fzc2lnbih7fSwgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uIG1vdW50LCB0aGlzIHdpbGwgYmUgaHlkcmF0ZWQgd2l0aCBhIGNhbGxiYWNrIHRvIGRpc2Nvbm5lY3RcbiAgICAgICAgICogdGhpcyB2aXN1YWwgZWxlbWVudCBmcm9tIGl0cyBwYXJlbnQgb24gdW5tb3VudC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByZW1vdmVGcm9tVmFyaWFudFRyZWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgd2l0aCB0aGUgbGF0ZXN0IHN0eWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdFxuICAgICAgICAgKiByZW5kZXIgbGlmZWN5Y2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8ICFpc01vdW50ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlckJ1aWxkKCk7XG4gICAgICAgICAgICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHByb3BzLnN0eWxlLCBlbGVtZW50LnByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJCdWlsZCgpIHtcbiAgICAgICAgICAgIGJ1aWxkKGVsZW1lbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICBsaWZlY3ljbGVzLm5vdGlmeVVwZGF0ZShsYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlbW92ZU9uQ2hhbmdlID0gdmFsdWUub25DaGFuZ2UoZnVuY3Rpb24gKGxhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICBwcm9wcy5vblVwZGF0ZSAmJiBzeW5jLnVwZGF0ZSh1cGRhdGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlbW92ZU9uUmVuZGVyUmVxdWVzdCA9IHZhbHVlLm9uUmVuZGVyUmVxdWVzdChlbGVtZW50LnNjaGVkdWxlUmVuZGVyKTtcbiAgICAgICAgICAgIHZhbHVlU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlT25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICByZW1vdmVPblJlbmRlclJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnkgbW90aW9uIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCB0byB0aGUgZWxlbWVudCB3aGVuIGNyZWF0ZWRcbiAgICAgICAgICogYXJlbid0IHlldCBib3VuZCB0byB0aGUgZWxlbWVudCwgYXMgdGhpcyB3b3VsZCB0ZWNobmljYWxseSBiZSBpbXB1cmUuXG4gICAgICAgICAqIEhvd2V2ZXIsIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgbW90aW9uIHZhbHVlcyBhbmQgc2V0IHRoZW0gdG8gdGhlXG4gICAgICAgICAqIGluaXRpYWwgdmFsdWVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogVGhpcyBpcyBpbXB1cmUgYW5kIHdlIHNob3VsZCBsb29rIGF0IGNoYW5naW5nIHRoaXMgdG8gcnVuIG9uIG1vdW50LlxuICAgICAgICAgKiBEb2luZyBzbyB3aWxsIGJyZWFrIHNvbWUgdGVzdHMgYnV0IHRoaXMgaXNuJ3QgbmVjY2Vzc2FyaWx5IGEgYnJlYWtpbmcgY2hhbmdlLFxuICAgICAgICAgKiBtb3JlIGEgcmVmbGVjdGlvbiBvZiB0aGUgdGVzdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpbml0aWFsTW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGluaXRpYWxNb3Rpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWxNb3Rpb25WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkICYmIGlzTW90aW9uVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuc2V0KGxhdGVzdFZhbHVlc1trZXldLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSB3aGF0IHJvbGUgdGhpcyB2aXN1YWwgZWxlbWVudCBzaG91bGQgdGFrZSBpbiB0aGUgdmFyaWFudCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICAgICAgdmFyIGlzVmFyaWFudE5vZGUgPSBjaGVja0lmVmFyaWFudE5vZGUocHJvcHMpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9fYXNzaWduKF9fYXNzaWduKHsgdHJlZVR5cGU6IHRyZWVUeXBlLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBpcyBhIG1pcnJvciBvZiB0aGUgaW50ZXJuYWwgaW5zdGFuY2UgcHJvcCwgd2hpY2gga2VlcHNcbiAgICAgICAgICAgICAqIFZpc3VhbEVsZW1lbnQgdHlwZS1jb21wYXRpYmxlIHdpdGggUmVhY3QncyBSZWZPYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbnQ6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGVwdGggb2YgdGhpcyB2aXN1YWwgZWxlbWVudCB3aXRoaW4gdGhlIHZpc3VhbCBlbGVtZW50IHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlcHRoOiBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMCwgcGFyZW50OiBwYXJlbnQsIGNoaWxkcmVuOiBuZXcgU2V0KCksIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmVzZW5jZUlkOiBwcmVzZW5jZUlkLCBzaG91bGRSZWR1Y2VNb3Rpb246IHNob3VsZFJlZHVjZU1vdGlvbiwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgY29tcG9uZW50IGlzIHBhcnQgb2YgdGhlIHZhcmlhbnQgdHJlZSwgaXQgc2hvdWxkIHRyYWNrXG4gICAgICAgICAgICAgKiBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBwYXJ0IG9mIHRoZSB0cmVlLiBUaGlzIGlzIGVzc2VudGlhbGx5XG4gICAgICAgICAgICAgKiBhIHNoYWRvdyB0cmVlIHRvIHNpbXBsaWZ5IGxvZ2ljIGFyb3VuZCBob3cgdG8gc3RhZ2dlciBvdmVyIGNoaWxkcmVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXJpYW50Q2hpbGRyZW46IGlzVmFyaWFudE5vZGUgPyBuZXcgU2V0KCkgOiB1bmRlZmluZWQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgaXMgdmlzaWJsZS4gVGhpcyBjYW4gYmUgY2hhbmdlZCBpbXBlcmF0aXZlbHlcbiAgICAgICAgICAgICAqIGJ5IHRoZSBwcm9qZWN0aW9uIHRyZWUsIGlzIGFuYWxvZ291cyB0byBDU1MncyB2aXNpYmlsaXR5IGluIHRoYXRcbiAgICAgICAgICAgICAqIGhpZGRlbiBlbGVtZW50cyBzaG91bGQgdGFrZSB1cCBsYXlvdXQsIGFuZCBuZWVkcyBlbmFjdGluZyBieSB0aGUgY29uZmlndXJlZFxuICAgICAgICAgICAgICogcmVuZGVyIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1Zpc2libGU6IHVuZGVmaW5lZCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vcm1hbGx5LCBpZiBhIGNvbXBvbmVudCBpcyBjb250cm9sbGVkIGJ5IGEgcGFyZW50J3MgdmFyaWFudHMsIGl0IGNhblxuICAgICAgICAgICAgICogcmVseSBvbiB0aGF0IGFuY2VzdG9yIHRvIHRyaWdnZXIgYW5pbWF0aW9ucyBmdXJ0aGVyIGRvd24gdGhlIHRyZWUuXG4gICAgICAgICAgICAgKiBIb3dldmVyLCBpZiBhIGNvbXBvbmVudCBpcyBjcmVhdGVkIGFmdGVyIGl0cyBwYXJlbnQgaXMgbW91bnRlZCwgdGhlIHBhcmVudFxuICAgICAgICAgICAgICogd29uJ3QgdHJpZ2dlciB0aGF0IG1vdW50IGFuaW1hdGlvbiBzbyB0aGUgY2hpbGQgbmVlZHMgdG8uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogVGhpcyBtaWdodCBiZSBiZXR0ZXIgcmVwbGFjZWQgd2l0aCBhIG1ldGhvZCBpc1BhcmVudE1vdW50ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFudWFsbHlBbmltYXRlT25Nb3VudDogQm9vbGVhbihwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuaXNNb3VudGVkKCkpLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBjYW4gYmUgc2V0IGJ5IEFuaW1hdGVQcmVzZW5jZSB0byBmb3JjZSBjb21wb25lbnRzIHRoYXQgbW91bnRcbiAgICAgICAgICAgICAqIGF0IHRoZSBzYW1lIHRpbWUgYXMgaXQgdG8gbW91bnQgYXMgaWYgdGhleSBoYXZlIGluaXRpYWw9e2ZhbHNlfSBzZXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGJsb2NrSW5pdGlhbEFuaW1hdGlvbjogYmxvY2tJbml0aWFsQW5pbWF0aW9uLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBjb21wb25lbnQgaGFzIG1vdW50ZWQgeWV0LiBUaGlzIGlzIG1vc3RseSB1c2VkXG4gICAgICAgICAgICAgKiBieSB2YXJpYW50IGNoaWxkcmVuIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgbmVlZCB0byB0cmlnZ2VyIHRoZWlyXG4gICAgICAgICAgICAgKiBvd24gYW5pbWF0aW9ucyBvbiBtb3VudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCb29sZWFuKGluc3RhbmNlKTsgfSwgbW91bnQ6IGZ1bmN0aW9uIChuZXdJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBlbGVtZW50LmN1cnJlbnQgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJvamVjdGlvbi5tb3VudChuZXdJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhbnROb2RlICYmIHBhcmVudCAmJiAhaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyb21WYXJpYW50VHJlZSA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5hZGRWYXJpYW50Q2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiBiaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNoaWxkcmVuLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGVsZW1lbnQucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubW91bnQoKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxTeW5jLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFN5bmMucmVuZGVyKHJlbmRlcik7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHJlbW92ZSkgeyByZXR1cm4gcmVtb3ZlKCk7IH0pO1xuICAgICAgICAgICAgICAgIHJlbW92ZUZyb21WYXJpYW50VHJlZSA9PT0gbnVsbCB8fCByZW1vdmVGcm9tVmFyaWFudFRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbW92ZUZyb21WYXJpYW50VHJlZSgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jaGlsZHJlbi5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlcy5jbGVhckFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhIGNoaWxkIHZpc3VhbCBlbGVtZW50IHRvIG91ciBzZXQgb2YgY2hpbGRyZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZFZhcmlhbnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZXN0VmFyaWFudE5vZGUgPSBlbGVtZW50LmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0VmFyaWFudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNvcnROb2RlUG9zaXRpb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZXNlIG5vZGVzIGFyZW4ndCBldmVuIG9mIHRoZSBzYW1lIHR5cGUgd2UgY2FuJ3QgY29tcGFyZSB0aGVpciBkZXB0aC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXNvcnROb2RlUG9zaXRpb24gfHwgdHJlZVR5cGUgIT09IG90aGVyLnRyZWVUeXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydE5vZGVQb3NpdGlvbihlbGVtZW50LmdldEluc3RhbmNlKCksIG90aGVyLmdldEluc3RhbmNlKCkpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGNsb3Nlc3QgdmFyaWFudCBub2RlIGluIHRoZSB0cmVlIHN0YXJ0aW5nIGZyb21cbiAgICAgICAgICAgICAqIHRoaXMgdmlzdWFsIGVsZW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldENsb3Nlc3RWYXJpYW50Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhcmlhbnROb2RlID8gZWxlbWVudCA6IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeHBvc2UgdGhlIGxhdGVzdCBsYXlvdXRJZCBwcm9wLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRMYXlvdXRJZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHMubGF5b3V0SWQ7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdGFuY2U7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQvc2V0IHRoZSBsYXRlc3Qgc3RhdGljIHZhbHVlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0U3RhdGljVmFsdWU6IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGxhdGVzdFZhbHVlc1trZXldOyB9LCBzZXRTdGF0aWNWYWx1ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgcmV0dXJuIChsYXRlc3RWYWx1ZXNba2V5XSA9IHZhbHVlKTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBtb3Rpb24gdmFsdWUgc3RhdGUuIEN1cnJlbnRseSBvbmx5IHVzZWQgdG8gdGFrZVxuICAgICAgICAgICAgICogYSBzbmFwc2hvdCBvZiB0aGUgdmlzdWFsIGVsZW1lbnQgLSBwZXJoYXBzIHRoaXMgY2FuIHJldHVybiB0aGUgd2hvbGVcbiAgICAgICAgICAgICAqIHZpc3VhbCBzdGF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRMYXRlc3RWYWx1ZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhdGVzdFZhbHVlczsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgdmlzaWJsaXR5IG9mIHRoZSB2aXN1YWwgZWxlbWVudC4gSWYgaXQncyBjaGFuZ2VkLCBzY2hlZHVsZVxuICAgICAgICAgICAgICogYSByZW5kZXIgdG8gcmVmbGVjdCB0aGVzZSBjaGFuZ2VzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRWaXNpYmlsaXR5OiBmdW5jdGlvbiAodmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmlzVmlzaWJsZSA9PT0gdmlzaWJpbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaXNWaXNpYmxlID0gdmlzaWJpbGl0eTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFrZSBhIHRhcmdldCBhbmltYXRhYmxlIGJ5IFBvcG1vdGlvbi4gRm9yIGluc3RhbmNlLCBpZiB3ZSdyZVxuICAgICAgICAgICAgICogdHJ5aW5nIHRvIGFuaW1hdGUgd2lkdGggZnJvbSAxMDBweCB0byAxMDB2dyB3ZSBuZWVkIHRvIG1lYXN1cmUgMTAwdndcbiAgICAgICAgICAgICAqIGluIHBpeGVscyB0byBkZXRlcm1pbmUgd2hhdCB3ZSByZWFsbHkgbmVlZCB0byBhbmltYXRlIHRvLiBUaGlzIGlzIGFsc29cbiAgICAgICAgICAgICAqIHBsdWdnYWJsZSB0byBzdXBwb3J0IEZyYW1lcidzIGN1c3RvbSB2YWx1ZSB0eXBlcyBsaWtlIENvbG9yLFxuICAgICAgICAgICAgICogYW5kIENTUyB2YXJpYWJsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1ha2VUYXJnZXRBbmltYXRhYmxlOiBmdW5jdGlvbiAodGFyZ2V0LCBjYW5NdXRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuTXV0YXRlID09PSB2b2lkIDApIHsgY2FuTXV0YXRlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlVGFyZ2V0QW5pbWF0YWJsZShlbGVtZW50LCB0YXJnZXQsIHByb3BzLCBjYW5NdXRhdGUpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1lYXN1cmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgYm94IHdpdGggb3Igd2l0aG91dCB0cmFuc2Zvcm1zLlxuICAgICAgICAgICAgICogT25seSBtZWFzdXJlcyBheGlzLWFsaWduZWQgYm94ZXMsIHJvdGF0ZSBhbmQgc2tldyBtdXN0IGJlIG1hbnVhbGx5XG4gICAgICAgICAgICAgKiByZW1vdmVkIHdpdGggYSByZS1yZW5kZXIgdG8gd29yay5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWVhc3VyZVZpZXdwb3J0Qm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBNb3Rpb24gdmFsdWVzID09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYSBtb3Rpb24gdmFsdWUgYW5kIGJpbmQgaXQgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkVmFsdWU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHZhbHVlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlVmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlc1trZXldID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIGEgbW90aW9uIHZhbHVlIGFuZCB1bmJpbmQgYW55IGFjdGl2ZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVWYWx1ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgKF9hID0gdmFsdWVTdWJzY3JpcHRpb25zLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxhdGVzdFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgcmVuZGVyU3RhdGUpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIG1vdGlvbiB2YWx1ZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGFzVmFsdWU6IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHZhbHVlcy5oYXMoa2V5KTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIG1vdGlvbiB2YWx1ZSBmb3IgdGhpcyBrZXkuIElmIGNhbGxlZCB3aXRoIGEgZGVmYXVsdFxuICAgICAgICAgICAgICogdmFsdWUsIHdlJ2xsIGNyZWF0ZSBvbmUgaWYgbm9uZSBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb3Rpb25WYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSXRlcmF0ZSBvdmVyIG91ciBtb3Rpb24gdmFsdWVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3JFYWNoVmFsdWU6IGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gdmFsdWVzLmZvckVhY2goY2FsbGJhY2spOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgdG8gYSBwcmV2aW91c2x5IHVuZW5jb3VudGVyZWQgdmFsdWUsXG4gICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpdCBpbiBvdXIgc3RhdGUgYW5kIGFzIGEgbGFzdCByZXNvcnQgcmVhZCBpdFxuICAgICAgICAgICAgICogZGlyZWN0bHkgZnJvbSB0aGUgaW5zdGFuY2UgKHdoaWNoIG1pZ2h0IGhhdmUgcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVhZFZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBsYXRlc3RWYWx1ZXNba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgYmFzZSB0YXJnZXQgdG8gbGF0ZXIgYW5pbWF0ZSBiYWNrIHRvLiBUaGlzIGlzIGN1cnJlbnRseVxuICAgICAgICAgICAgICogb25seSBoeWRyYXRlZCBvbiBjcmVhdGlvbiBhbmQgd2hlbiB3ZSBmaXJzdCByZWFkIGEgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYmFzZVRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmluZCB0aGUgYmFzZSB0YXJnZXQgZm9yIGEgdmFsdWUgdGhhdHMgYmVlbiByZW1vdmVkIGZyb20gYWxsIGFuaW1hdGlvblxuICAgICAgICAgICAgICogcHJvcHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0QmFzZVRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0QmFzZVRhcmdldChwcm9wcywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmICFpc01vdGlvblZhbHVlKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVRhcmdldFtrZXldO1xuICAgICAgICAgICAgfSB9LCBsaWZlY3ljbGVzKSwgeyBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQnVpbGQgdGhlIHJlbmRlcmVyIHN0YXRlIGJhc2VkIG9uIHRoZSBsYXRlc3QgdmlzdWFsIHN0YXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJCdWlsZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJTdGF0ZTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY2hlZHVsZSBhIHJlbmRlciBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNjaGVkdWxlUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3luYy5yZW5kZXIocmVuZGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3luY2hyb25vdXNseSBmaXJlIHJlbmRlci4gSXQncyBwcmVmZXJlZCB0aGF0IHdlIGJhdGNoIHJlbmRlcnMgYnV0XG4gICAgICAgICAgICAgKiBpbiBtYW55IGNpcmN1bXN0YW5jZXMsIGxpa2UgbGF5b3V0IG1lYXN1cmVtZW50LCB3ZSBuZWVkIHRvIHJ1biB0aGlzXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5LiBIb3dldmVyIGluIHRob3NlIGluc3RhbmNlcyBvdGhlciBtZWFzdXJlcyBzaG91bGQgYmUgdGFrZW5cbiAgICAgICAgICAgICAqIHRvIGJhdGNoIHJlYWRzL3dyaXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3luY1JlbmRlcjogcmVuZGVyLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSBwcm92aWRlZCBwcm9wcy4gRW5zdXJlIGFueSBuZXdseS1hZGRlZCBtb3Rpb24gdmFsdWVzIGFyZVxuICAgICAgICAgICAgICogYWRkZWQgdG8gb3VyIG1hcCwgb2xkIG9uZXMgcmVtb3ZlZCwgYW5kIGxpc3RlbmVycyB1cGRhdGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzLnRyYW5zZm9ybVRlbXBsYXRlIHx8IHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVzLnVwZGF0ZVByb3BMaXN0ZW5lcnMobmV3UHJvcHMpO1xuICAgICAgICAgICAgICAgIHByZXZNb3Rpb25WYWx1ZXMgPSB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoZWxlbWVudCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSwgcHJldk1vdGlvblZhbHVlcyk7XG4gICAgICAgICAgICB9LCBnZXRQcm9wczogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHM7IH0sIFxuICAgICAgICAgICAgLy8gVmFyaWFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiB3aXRoIGEgZ2l2ZW4gbmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VmFyaWFudDogZnVuY3Rpb24gKG5hbWUpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcHJvcHMudmFyaWFudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuYW1lXTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGRlZmluZWQgZGVmYXVsdCB0cmFuc2l0aW9uIG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXREZWZhdWx0VHJhbnNpdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHMudHJhbnNpdGlvbjsgfSwgZ2V0VHJhbnNmb3JtUGFnZVBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2VkIGJ5IGNoaWxkIHZhcmlhbnQgbm9kZXMgdG8gZ2V0IHRoZSBjbG9zZXN0IGFuY2VzdG9yIHZhcmlhbnQgcHJvcHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFZhcmlhbnRDb250ZXh0OiBmdW5jdGlvbiAoc3RhcnRBdFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEF0UGFyZW50ID09PSB2b2lkIDApIHsgc3RhcnRBdFBhcmVudCA9IGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0QXRQYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0VmFyaWFudENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dF8xID0gKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRWYXJpYW50Q29udGV4dCgpKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmluaXRpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dF8xLmluaXRpYWwgPSBwcm9wcy5pbml0aWFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0XzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYXJpYW50UHJvcHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdmFyaWFudFByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhbnRMYWJlbChwcm9wKSB8fCBwcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFtuYW1lXzFdID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG59O1xudmFyIHZhcmlhbnRQcm9wcyA9IF9fc3ByZWFkQXJyYXkoW1wiaW5pdGlhbFwiXSwgX19yZWFkKHZhcmlhbnRQcmlvcml0eU9yZGVyKSwgZmFsc2UpO1xudmFyIG51bVZhcmlhbnRQcm9wcyA9IHZhcmlhbnRQcm9wcy5sZW5ndGg7XG5cbmV4cG9ydCB7IHZpc3VhbEVsZW1lbnQgfTtcbiIsICJpbXBvcnQgeyBfX3NwcmVhZEFycmF5LCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzJztcblxudmFyIG5hbWVzID0gW1xuICAgIFwiTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiTGF5b3V0VXBkYXRlXCIsXG4gICAgXCJWaWV3cG9ydEJveFVwZGF0ZVwiLFxuICAgIFwiVXBkYXRlXCIsXG4gICAgXCJSZW5kZXJcIixcbiAgICBcIkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJMYXlvdXRBbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwiQW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIlNldEF4aXNUYXJnZXRcIixcbiAgICBcIlVubW91bnRcIixcbl07XG5mdW5jdGlvbiBjcmVhdGVMaWZlY3ljbGVzKCkge1xuICAgIHZhciBtYW5hZ2VycyA9IG5hbWVzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpOyB9KTtcbiAgICB2YXIgcHJvcFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB2YXIgbGlmZWN5Y2xlcyA9IHtcbiAgICAgICAgY2xlYXJBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hbmFnZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZXIpIHsgcmV0dXJuIG1hbmFnZXIuY2xlYXIoKTsgfSk7IH0sXG4gICAgICAgIHVwZGF0ZVByb3BMaXN0ZW5lcnM6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgb24gPSBcIm9uXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTGlzdGVuZXIgPSBwcm9wc1tvbl07XG4gICAgICAgICAgICAgICAgLy8gVW5zdWJzY3JpYmUgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgKF9hID0gcHJvcFN1YnNjcmlwdGlvbnNbbmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIGlmIChwcm9wTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFN1YnNjcmlwdGlvbnNbbmFtZV0gPSBsaWZlY3ljbGVzW29uXShwcm9wTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgbWFuYWdlcnMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlciwgaSkge1xuICAgICAgICBsaWZlY3ljbGVzW1wib25cIiArIG5hbWVzW2ldXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBtYW5hZ2VyLmFkZChoYW5kbGVyKTsgfTtcbiAgICAgICAgbGlmZWN5Y2xlc1tcIm5vdGlmeVwiICsgbmFtZXNbaV1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXIubm90aWZ5LmFwcGx5KG1hbmFnZXIsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGlmZWN5Y2xlcztcbn1cblxuZXhwb3J0IHsgY3JlYXRlTGlmZWN5Y2xlcyB9O1xuIiwgImltcG9ydCB7IG1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcblxuZnVuY3Rpb24gdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzKGVsZW1lbnQsIG5leHQsIHByZXYpIHtcbiAgICB2YXIgX2E7XG4gICAgZm9yICh2YXIga2V5IGluIG5leHQpIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IG5leHRba2V5XTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHByZXZba2V5XTtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUobmV4dFZhbHVlKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgbW90aW9uIHZhbHVlIGZvdW5kIGluIHByb3BzIG9yIHN0eWxlLCB3ZSB3YW50IHRvIGFkZCBpdFxuICAgICAgICAgICAgICogdG8gb3VyIHZpc3VhbCBlbGVtZW50J3MgbW90aW9uIHZhbHVlIG1hcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNb3Rpb25WYWx1ZShwcmV2VmFsdWUpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHN3YXBwaW5nIHRvIGEgbmV3IG1vdGlvbiB2YWx1ZSwgY3JlYXRlIGEgbmV3IG1vdGlvbiB2YWx1ZVxuICAgICAgICAgICAgICogZnJvbSB0aGF0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShuZXh0VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgZmxhdCB2YWx1ZSB0aGF0IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZVxuICAgICAgICAgICAgICogb3IgY3JlYXRlIG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBvbmx5IHdhbnQgdG8gZG8gdGhpcyBpZiB3ZSdyZVxuICAgICAgICAgICAgICogbm90IGhhbmRsaW5nIHRoZSB2YWx1ZSB3aXRoIG91ciBhbmltYXRpb24gc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBPbmx5IHVwZGF0ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgYmVpbmcgYW5pbWF0ZWQgb3IgZXZlbiBsb29rZWQgYXRcbiAgICAgICAgICAgICAgICAhZXhpc3RpbmdWYWx1ZS5oYXNBbmltYXRlZCAmJiBleGlzdGluZ1ZhbHVlLnNldChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKChfYSA9IGVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV4dFZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIHJlbW92ZWQgdmFsdWVzXG4gICAgZm9yICh2YXIga2V5IGluIHByZXYpIHtcbiAgICAgICAgaWYgKG5leHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbn1cblxuZXhwb3J0IHsgdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzIH07XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUNTU1ZhcmlhYmxlcyB9IGZyb20gJy4vY3NzLXZhcmlhYmxlcy1jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyB1bml0Q29udmVyc2lvbiB9IGZyb20gJy4vdW5pdC1jb252ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogUGFyc2UgYSBET00gdmFyaWFudCB0byBtYWtlIGl0IGFuaW1hdGFibGUuIFRoaXMgaW52b2x2ZXMgcmVzb2x2aW5nIENTUyB2YXJpYWJsZXNcbiAqIGFuZCBlbnN1cmluZyBhbmltYXRpb25zIGxpa2UgXCIyMCVcIiA9PiBcImNhbGMoNTB2dylcIiBhcmUgcGVyZm9ybWVkIGluIHBpeGVscy5cbiAqL1xudmFyIHBhcnNlRG9tVmFyaWFudCA9IGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkge1xuICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVDU1NWYXJpYWJsZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kKTtcbiAgICB0YXJnZXQgPSByZXNvbHZlZC50YXJnZXQ7XG4gICAgdHJhbnNpdGlvbkVuZCA9IHJlc29sdmVkLnRyYW5zaXRpb25FbmQ7XG4gICAgcmV0dXJuIHVuaXRDb252ZXJzaW9uKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKTtcbn07XG5cbmV4cG9ydCB7IHBhcnNlRG9tVmFyaWFudCB9O1xuIiwgImltcG9ydCB7IF9fcmVzdCwgX19hc3NpZ24sIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKFwidmFyKC0tXCIpO1xufVxuLyoqXG4gKiBQYXJzZSBGcmFtZXIncyBzcGVjaWFsIENTUyB2YXJpYWJsZSBmb3JtYXQgaW50byBhIENTUyB0b2tlbiBhbmQgYSBmYWxsYmFjay5cbiAqXG4gKiBgYGBcbiAqIGB2YXIoLS1mb28sICNmZmYpYCA9PiBbYC0tZm9vYCwgJyNmZmYnXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGN1cnJlbnRcbiAqL1xudmFyIGNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoKC0tW2EtekEtWjAtOS1fXSspLD8gPyhbYS16QS1aMC05ICgpJSMuLC1dKyk/XFwpLztcbmZ1bmN0aW9uIHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCkge1xuICAgIHZhciBtYXRjaCA9IGNzc1ZhcmlhYmxlUmVnZXguZXhlYyhjdXJyZW50KTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gWyxdO1xuICAgIHZhciBfYSA9IF9fcmVhZChtYXRjaCwgMyksIHRva2VuID0gX2FbMV0sIGZhbGxiYWNrID0gX2FbMl07XG4gICAgcmV0dXJuIFt0b2tlbiwgZmFsbGJhY2tdO1xufVxudmFyIG1heERlcHRoID0gNDtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IDE7IH1cbiAgICBpbnZhcmlhbnQoZGVwdGggPD0gbWF4RGVwdGgsIFwiTWF4IENTUyB2YXJpYWJsZSBmYWxsYmFjayBkZXB0aCBkZXRlY3RlZCBpbiBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGN1cnJlbnQsIFwiXFxcIi4gVGhpcyBtYXkgaW5kaWNhdGUgYSBjaXJjdWxhciBmYWxsYmFjayBkZXBlbmRlbmN5LlwiKSk7XG4gICAgdmFyIF9hID0gX19yZWFkKHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCksIDIpLCB0b2tlbiA9IF9hWzBdLCBmYWxsYmFjayA9IF9hWzFdO1xuICAgIC8vIE5vIENTUyB2YXJpYWJsZSBkZXRlY3RlZFxuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBBdHRlbXB0IHRvIHJlYWQgdGhpcyBDU1MgdmFyaWFibGUgb2ZmIHRoZSBlbGVtZW50XG4gICAgdmFyIHJlc29sdmVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSh0b2tlbik7XG4gICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC50cmltKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ1NTVmFyaWFibGUoZmFsbGJhY2spKSB7XG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayBtaWdodCBpdHNlbGYgYmUgYSBDU1MgdmFyaWFibGUsIGluIHdoaWNoIGNhc2Ugd2UgYXR0ZW1wdCB0byByZXNvbHZlIGl0IHRvby5cbiAgICAgICAgcmV0dXJuIGdldFZhcmlhYmxlVmFsdWUoZmFsbGJhY2ssIGVsZW1lbnQsIGRlcHRoICsgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxufVxuLyoqXG4gKiBSZXNvbHZlIENTUyB2YXJpYWJsZXMgZnJvbVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQsIF9hLCB0cmFuc2l0aW9uRW5kKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB0YXJnZXQgPSBfX3Jlc3QoX2EsIFtdKTtcbiAgICB2YXIgZWxlbWVudCA9IHZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpXG4gICAgICAgIHJldHVybiB7IHRhcmdldDogdGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XG4gICAgLy8gSWYgYHRyYW5zaXRpb25FbmRgIGlzbid0IGB1bmRlZmluZWRgLCBjbG9uZSBpdC4gV2UgY291bGQgY2xvbmUgYHRhcmdldGAgYW5kIGB0cmFuc2l0aW9uRW5kYFxuICAgIC8vIG9ubHkgaWYgdGhleSBjaGFuZ2UgYnV0IEkgdGhpbmsgdGhpcyByZWFkcyBjbGVhcmVyIGFuZCB0aGlzIGlzbid0IGEgcGVyZm9ybWFuY2UtY3JpdGljYWwgcGF0aC5cbiAgICBpZiAodHJhbnNpdGlvbkVuZCkge1xuICAgICAgICB0cmFuc2l0aW9uRW5kID0gX19hc3NpZ24oe30sIHRyYW5zaXRpb25FbmQpO1xuICAgIH1cbiAgICAvLyBHbyB0aHJvdWdoIGV4aXN0aW5nIGBNb3Rpb25WYWx1ZWBzIGFuZCBlbnN1cmUgYW55IGV4aXN0aW5nIENTUyB2YXJpYWJsZXMgYXJlIHJlc29sdmVkXG4gICAgdmlzdWFsRWxlbWVudC5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICghaXNDU1NWYXJpYWJsZShjdXJyZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgaWYgKHJlc29sdmVkKVxuICAgICAgICAgICAgdmFsdWUuc2V0KHJlc29sdmVkKTtcbiAgICB9KTtcbiAgICAvLyBDeWNsZSB0aHJvdWdoIGV2ZXJ5IHRhcmdldCBwcm9wZXJ0eSBhbmQgcmVzb2x2ZSBDU1MgdmFyaWFibGVzLiBDdXJyZW50bHlcbiAgICAvLyB3ZSBvbmx5IHJlYWQgc2luZ2xlLXZhciBwcm9wZXJ0aWVzIGxpa2UgYHZhcigtLWZvbylgLCBub3QgYGNhbGModmFyKC0tZm9vKSArIDIwcHgpYFxuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKCFpc0NTU1ZhcmlhYmxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gQ2xvbmUgdGFyZ2V0IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW5cbiAgICAgICAgdGFyZ2V0W2tleV0gPSByZXNvbHZlZDtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGFscmVhZHkgc2V0IHRoaXMga2V5IG9uIGB0cmFuc2l0aW9uRW5kYCwgc2V0IGl0IHRvIHRoZSB1bnJlc29sdmVkXG4gICAgICAgIC8vIENTUyB2YXJpYWJsZS4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIHRoZSBhbmltYXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHJlZmxlY3RcbiAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIENTUyB2YXJpYWJsZS5cbiAgICAgICAgaWYgKHRyYW5zaXRpb25FbmQpXG4gICAgICAgICAgICAoX2IgPSB0cmFuc2l0aW9uRW5kW2tleV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICh0cmFuc2l0aW9uRW5kW2tleV0gPSBjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbn1cblxuZXhwb3J0IHsgY3NzVmFyaWFibGVSZWdleCwgcGFyc2VDU1NWYXJpYWJsZSwgcmVzb2x2ZUNTU1ZhcmlhYmxlcyB9O1xuIiwgImltcG9ydCB7IF9fYXNzaWduLCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBudW1iZXIsIHB4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgaXNLZXlmcmFtZXNUYXJnZXQgfSBmcm9tICcuLi8uLi8uLi9hbmltYXRpb24vdXRpbHMvaXMta2V5ZnJhbWVzLXRhcmdldC5tanMnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBmaW5kRGltZW5zaW9uVmFsdWVUeXBlIH0gZnJvbSAnLi4vdmFsdWUtdHlwZXMvZGltZW5zaW9ucy5tanMnO1xuXG52YXIgcG9zaXRpb25hbEtleXMgPSBuZXcgU2V0KFtcbiAgICBcIndpZHRoXCIsXG4gICAgXCJoZWlnaHRcIixcbiAgICBcInRvcFwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuXSk7XG52YXIgaXNQb3NpdGlvbmFsS2V5ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcG9zaXRpb25hbEtleXMuaGFzKGtleSk7IH07XG52YXIgaGFzUG9zaXRpb25hbEtleSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5zb21lKGlzUG9zaXRpb25hbEtleSk7XG59O1xudmFyIHNldEFuZFJlc2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAodmFsdWUsIHRvKSB7XG4gICAgLy8gTG9va3Mgb2RkIGJ1dCBzZXR0aW5nIGl0IHR3aWNlIGRvZXNuJ3QgcmVuZGVyLCBpdCdsbCBqdXN0XG4gICAgLy8gc2V0IGJvdGggcHJldiBhbmQgY3VycmVudCB0byB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgdmFsdWUuc2V0KHRvLCBmYWxzZSk7XG4gICAgdmFsdWUuc2V0KHRvKTtcbn07XG52YXIgaXNOdW1PclB4VHlwZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IG51bWJlciB8fCB2ID09PSBweDtcbn07XG52YXIgQm91bmRpbmdCb3hEaW1lbnNpb247XG4oZnVuY3Rpb24gKEJvdW5kaW5nQm94RGltZW5zaW9uKSB7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJ3aWR0aFwiXSA9IFwid2lkdGhcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcImhlaWdodFwiXSA9IFwiaGVpZ2h0XCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJsZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJyaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcInRvcFwiXSA9IFwidG9wXCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJib3R0b21cIl0gPSBcImJvdHRvbVwiO1xufSkoQm91bmRpbmdCb3hEaW1lbnNpb24gfHwgKEJvdW5kaW5nQm94RGltZW5zaW9uID0ge30pKTtcbnZhciBnZXRQb3NGcm9tTWF0cml4ID0gZnVuY3Rpb24gKG1hdHJpeCwgcG9zKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XG59O1xudmFyIGdldFRyYW5zbGF0ZUZyb21NYXRyaXggPSBmdW5jdGlvbiAocG9zMiwgcG9zMykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2Jib3gsIF9hKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYS50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09IFwibm9uZVwiIHx8ICF0cmFuc2Zvcm0pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmFyIG1hdHJpeDNkID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC8pO1xuICAgICAgICBpZiAobWF0cml4M2QpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeDNkWzFdLCBwb3MzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC8pO1xuICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeFsxXSwgcG9zMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xudmFyIHRyYW5zZm9ybUtleXMgPSBuZXcgU2V0KFtcInhcIiwgXCJ5XCIsIFwielwiXSk7XG52YXIgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMgPSB0cmFuc2Zvcm1Qcm9wcy5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIXRyYW5zZm9ybUtleXMuaGFzKGtleSk7IH0pO1xuZnVuY3Rpb24gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSh2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gICAgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZWRUcmFuc2Zvcm1zLnB1c2goW2tleSwgdmFsdWUuZ2V0KCldKTtcbiAgICAgICAgICAgIHZhbHVlLnNldChrZXkuc3RhcnRzV2l0aChcInNjYWxlXCIpID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQXBwbHkgY2hhbmdlcyB0byBlbGVtZW50IGJlZm9yZSBtZWFzdXJlbWVudFxuICAgIGlmIChyZW1vdmVkVHJhbnNmb3Jtcy5sZW5ndGgpXG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgIHJldHVybiByZW1vdmVkVHJhbnNmb3Jtcztcbn1cbnZhciBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICAgIC8vIERpbWVuc2lvbnNcbiAgICB3aWR0aDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeCA9IF9hLng7XG4gICAgICAgIHZhciBfYyA9IF9iLnBhZGRpbmdMZWZ0LCBwYWRkaW5nTGVmdCA9IF9jID09PSB2b2lkIDAgPyBcIjBcIiA6IF9jLCBfZCA9IF9iLnBhZGRpbmdSaWdodCwgcGFkZGluZ1JpZ2h0ID0gX2QgPT09IHZvaWQgMCA/IFwiMFwiIDogX2Q7XG4gICAgICAgIHJldHVybiB4Lm1heCAtIHgubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nTGVmdCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdSaWdodCk7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIHkgPSBfYS55O1xuICAgICAgICB2YXIgX2MgPSBfYi5wYWRkaW5nVG9wLCBwYWRkaW5nVG9wID0gX2MgPT09IHZvaWQgMCA/IFwiMFwiIDogX2MsIF9kID0gX2IucGFkZGluZ0JvdHRvbSwgcGFkZGluZ0JvdHRvbSA9IF9kID09PSB2b2lkIDAgPyBcIjBcIiA6IF9kO1xuICAgICAgICByZXR1cm4geS5tYXggLSB5Lm1pbiAtIHBhcnNlRmxvYXQocGFkZGluZ1RvcCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdCb3R0b20pO1xuICAgIH0sXG4gICAgdG9wOiBmdW5jdGlvbiAoX2Jib3gsIF9hKSB7XG4gICAgICAgIHZhciB0b3AgPSBfYS50b3A7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRvcCk7XG4gICAgfSxcbiAgICBsZWZ0OiBmdW5jdGlvbiAoX2Jib3gsIF9hKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gX2EubGVmdDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobGVmdCk7XG4gICAgfSxcbiAgICBib3R0b206IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIHkgPSBfYS55O1xuICAgICAgICB2YXIgdG9wID0gX2IudG9wO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b3ApICsgKHkubWF4IC0geS5taW4pO1xuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIHggPSBfYS54O1xuICAgICAgICB2YXIgbGVmdCA9IF9iLmxlZnQ7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGxlZnQpICsgKHgubWF4IC0geC5taW4pO1xuICAgIH0sXG4gICAgLy8gVHJhbnNmb3JtXG4gICAgeDogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gICAgeTogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg1LCAxNCksXG59O1xudmFyIGNvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHZpc3VhbEVsZW1lbnQsIGNoYW5nZWRLZXlzKSB7XG4gICAgdmFyIG9yaWdpbkJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgIHZhciBlbGVtZW50ID0gdmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpO1xuICAgIHZhciBlbGVtZW50Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgdmFyIGRpc3BsYXkgPSBlbGVtZW50Q29tcHV0ZWRTdHlsZS5kaXNwbGF5O1xuICAgIHZhciBvcmlnaW4gPSB7fTtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgc2V0IHRvIGRpc3BsYXk6IFwibm9uZVwiLCBtYWtlIGl0IHZpc2libGUgYmVmb3JlXG4gICAgLy8gbWVhc3VyaW5nIHRoZSB0YXJnZXQgYm91bmRpbmcgYm94XG4gICAgaWYgKGRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoXCJkaXNwbGF5XCIsIHRhcmdldC5kaXNwbGF5IHx8IFwiYmxvY2tcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29yZCBvcmlnaW5zIGJlZm9yZSB3ZSByZW5kZXIgYW5kIHVwZGF0ZSBzdHlsZXNcbiAgICAgKi9cbiAgICBjaGFuZ2VkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb3JpZ2luW2tleV0gPSBwb3NpdGlvbmFsVmFsdWVzW2tleV0ob3JpZ2luQmJveCwgZWxlbWVudENvbXB1dGVkU3R5bGUpO1xuICAgIH0pO1xuICAgIC8vIEFwcGx5IHRoZSBsYXRlc3QgdmFsdWVzIChhcyBzZXQgaW4gY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMpXG4gICAgdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgdmFyIHRhcmdldEJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgIGNoYW5nZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBSZXN0b3JlIHN0eWxlcyB0byB0aGVpciAqKmNhbGN1bGF0ZWQgY29tcHV0ZWQgc3R5bGUqKiwgbm90IHRoZWlyIGFjdHVhbFxuICAgICAgICAvLyBvcmlnaW5hbGx5IHNldCBzdHlsZS4gVGhpcyBhbGxvd3MgdXMgdG8gYW5pbWF0ZSBiZXR3ZWVuIGVxdWl2YWxlbnQgcGl4ZWwgdW5pdHMuXG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgb3JpZ2luW2tleV0pO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XSh0YXJnZXRCYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMgPSBmdW5jdGlvbiAodmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgICBpZiAob3JpZ2luID09PSB2b2lkIDApIHsgb3JpZ2luID0ge307IH1cbiAgICBpZiAodHJhbnNpdGlvbkVuZCA9PT0gdm9pZCAwKSB7IHRyYW5zaXRpb25FbmQgPSB7fTsgfVxuICAgIHRhcmdldCA9IF9fYXNzaWduKHt9LCB0YXJnZXQpO1xuICAgIHRyYW5zaXRpb25FbmQgPSBfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbkVuZCk7XG4gICAgdmFyIHRhcmdldFBvc2l0aW9uYWxLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KS5maWx0ZXIoaXNQb3NpdGlvbmFsS2V5KTtcbiAgICAvLyBXZSB3YW50IHRvIHJlbW92ZSBhbnkgdHJhbnNmb3JtIHZhbHVlcyB0aGF0IGNvdWxkIGFmZmVjdCB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIGJveCBiZWZvcmVcbiAgICAvLyBpdCdzIG1lYXN1cmVkLiBXZSdsbCByZWFwcGx5IHRoZXNlIGxhdGVyLlxuICAgIHZhciByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID0gW107XG4gICAgdmFyIGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gZmFsc2U7XG4gICAgdmFyIGNoYW5nZWRWYWx1ZVR5cGVLZXlzID0gW107XG4gICAgdGFyZ2V0UG9zaXRpb25hbEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBmcm9tID0gb3JpZ2luW2tleV07XG4gICAgICAgIHZhciBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgICAgIHZhciB0byA9IHRhcmdldFtrZXldO1xuICAgICAgICB2YXIgdG9UeXBlO1xuICAgICAgICAvLyBUT0RPOiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGJhc2ljYWxseSB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgLy8gaWYgeW91IHRyeSBhbmQgZG8gdmFsdWUgY29udmVyc2lvbiB2aWEga2V5ZnJhbWVzLiBUaGVyZSdzIHByb2JhYmx5XG4gICAgICAgIC8vIGEgd2F5IG9mIGRvaW5nIHRoaXMgYnV0IHRoZSBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMgd291bGQgbmVlZCBncmVhdGVyIHNjcnV0aW55LFxuICAgICAgICAvLyBhcyBpdCdkIGJlIGRvaW5nIG11bHRpcGxlIHJlc2l6ZS1yZW1lYXN1cmUgb3BlcmF0aW9ucy5cbiAgICAgICAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KHRvKSkge1xuICAgICAgICAgICAgdmFyIG51bUtleWZyYW1lcyA9IHRvLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSB0b1swXSA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgICAgICAgZnJvbSA9IHRvW2Zyb21JbmRleF07XG4gICAgICAgICAgICBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4OyBpIDwgbnVtS2V5ZnJhbWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0b1R5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaW52YXJpYW50KHRvVHlwZSA9PT0gZnJvbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRvVHlwZSkpLCBcIktleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIGRpbWVuc2lvbiBhcyB0aGUgY3VycmVudCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFyaWFudChmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvW2ldKSA9PT0gdG9UeXBlLCBcIkFsbCBrZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tVHlwZSAhPT0gdG9UeXBlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGJvdGgganVzdCBudW1iZXIgb3IgcHgsIGNvbnZlcnQgdGhlbSBib3RoIHRvIG51bWJlcnMgcmF0aGVyIHRoYW5cbiAgICAgICAgICAgIC8vIHJlbHlpbmcgb24gcmVzaXplL3JlbWVhc3VyZSB0byBjb252ZXJ0ICh3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGlzIHNpdHVhdGlvbilcbiAgICAgICAgICAgIGlmIChpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRvVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHZhbHVlLmdldCgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zZXQocGFyc2VGbG9hdChjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0bykgJiYgdG9UeXBlID09PSBweCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHRvLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZnJvbVR5cGUgPT09IG51bGwgfHwgZnJvbVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyb21UeXBlLnRyYW5zZm9ybSkgJiZcbiAgICAgICAgICAgICAgICAodG9UeXBlID09PSBudWxsIHx8IHRvVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9UeXBlLnRyYW5zZm9ybSkgJiZcbiAgICAgICAgICAgICAgICAoZnJvbSA9PT0gMCB8fCB0byA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBvbmUgb3IgdGhlIG90aGVyIHZhbHVlIGlzIDAsIGl0J3Mgc2FmZSB0byBjb2VyY2UgaXQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHlwZSBvZiB0aGUgb3RoZXIgd2l0aG91dCBtZWFzdXJlbWVudFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNldCh0b1R5cGUudHJhbnNmb3JtKGZyb20pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZnJvbVR5cGUudHJhbnNmb3JtKHRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byBkbyB2YWx1ZSBjb252ZXJzaW9uIHZpYSBET00gbWVhc3VyZW1lbnRzLCB3ZSBmaXJzdFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVtb3ZlIG5vbi1wb3NpdGlvbmFsIHRyYW5zZm9ybSB2YWx1ZXMgdGhhdCBjb3VsZCBhZmZlY3QgdGhlIGJib3ggbWVhc3VyZW1lbnRzLlxuICAgICAgICAgICAgICAgIGlmICghaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZWRWYWx1ZVR5cGVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kW2tleV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRW5kW2tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWRWYWx1ZVR5cGVLZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIgY29udmVydGVkVGFyZ2V0ID0gY29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHRhcmdldCwgdmlzdWFsRWxlbWVudCwgY2hhbmdlZFZhbHVlVHlwZUtleXMpO1xuICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIHRyYW5zZm9ybSB2YWx1ZXMsIHJlYXBwbHkgdGhlbSBiZWZvcmUgdGhlIG5leHQgcmVuZGVyXG4gICAgICAgIGlmIChyZW1vdmVkVHJhbnNmb3JtVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGtleSA9IF9iWzBdLCB2YWx1ZSA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhcHBseSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB7IHRhcmdldDogY29udmVydGVkVGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0YXJnZXQ6IHRhcmdldCwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9O1xuICAgIH1cbn07XG4vKipcbiAqIENvbnZlcnQgdmFsdWUgdHlwZXMgZm9yIHgveS93aWR0aC9oZWlnaHQvdG9wL2xlZnQvYm90dG9tL3JpZ2h0XG4gKlxuICogQWxsb3dzIGFuaW1hdGlvbiBiZXR3ZWVuIGAnYXV0bydgIC0+IGAnMTAwJSdgIG9yIGAwYCAtPiBgJ2NhbGMoNTAlIC0gMTB2dyknYFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1bml0Q29udmVyc2lvbih2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkge1xuICAgIHJldHVybiBoYXNQb3NpdGlvbmFsS2V5KHRhcmdldClcbiAgICAgICAgPyBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZClcbiAgICAgICAgOiB7IHRhcmdldDogdGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XG59XG5cbmV4cG9ydCB7IEJvdW5kaW5nQm94RGltZW5zaW9uLCBwb3NpdGlvbmFsVmFsdWVzLCB1bml0Q29udmVyc2lvbiB9O1xuIiwgImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgdmlzdWFsRWxlbWVudCB9IGZyb20gJy4uL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfSBmcm9tICcuL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcyc7XG5pbXBvcnQgeyBodG1sQ29uZmlnIH0gZnJvbSAnLi4vaHRtbC92aXN1YWwtZWxlbWVudC5tanMnO1xuaW1wb3J0IHsgYnVpbGRTVkdBdHRycyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtYXR0cnMubWpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoIH0gZnJvbSAnLi4vZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzJztcbmltcG9ydCB7IGNhbWVsQ2FzZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3V0aWxzL2NhbWVsLWNhc2UtYXR0cnMubWpzJztcbmltcG9ydCB7IGlzVHJhbnNmb3JtUHJvcCB9IGZyb20gJy4uL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyByZW5kZXJTVkcgfSBmcm9tICcuL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFZhbHVlVHlwZSB9IGZyb20gJy4uL2RvbS92YWx1ZS10eXBlcy9kZWZhdWx0cy5tanMnO1xuXG52YXIgc3ZnVmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQoX19hc3NpZ24oX19hc3NpZ24oe30sIGh0bWxDb25maWcpLCB7IGdldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uIChwcm9wcywga2V5KSB7XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgIH0sIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVByb3Aoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0KSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9ICFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleTtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgfSwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsIGJ1aWxkOiBmdW5jdGlvbiAoX2VsZW1lbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKSB7XG4gICAgICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIH0sIHJlbmRlcjogcmVuZGVyU1ZHIH0pKTtcblxuZXhwb3J0IHsgc3ZnVmlzdWFsRWxlbWVudCB9O1xuIiwgImltcG9ydCB7IE1lYXN1cmVMYXlvdXQgfSBmcm9tICcuL01lYXN1cmVMYXlvdXQubWpzJztcblxudmFyIGxheW91dEZlYXR1cmVzID0ge1xuICAgIG1lYXN1cmVMYXlvdXQ6IE1lYXN1cmVMYXlvdXQsXG59O1xuXG5leHBvcnQgeyBsYXlvdXRGZWF0dXJlcyB9O1xuIiwgImltcG9ydCB7IF9fZXh0ZW5kcywgX19hc3NpZ24sIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBzeW5jIGZyb20gJ2ZyYW1lc3luYyc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVByZXNlbmNlIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLm1qcyc7XG5pbXBvcnQgeyBMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vY29udGV4dC9Td2l0Y2hMYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IGdsb2JhbFByb2plY3Rpb25TdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vbm9kZS9jcmVhdGUtcHJvamVjdGlvbi1ub2RlLm1qcyc7XG5pbXBvcnQgeyBjb3JyZWN0Qm9yZGVyUmFkaXVzIH0gZnJvbSAnLi4vLi4vLi4vcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtYm9yZGVyLXJhZGl1cy5tanMnO1xuaW1wb3J0IHsgY29ycmVjdEJveFNoYWRvdyB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJveC1zaGFkb3cubWpzJztcbmltcG9ydCB7IGFkZFNjYWxlQ29ycmVjdG9yIH0gZnJvbSAnLi4vLi4vLi4vcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtY29ycmVjdGlvbi5tanMnO1xuXG52YXIgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVhc3VyZUxheW91dFdpdGhDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgb25seSBtb3VudHMgcHJvamVjdGlvbiBub2RlcyBmb3IgY29tcG9uZW50cyB0aGF0XG4gICAgICogbmVlZCBtZWFzdXJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZG8gaXQgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgICogaW4gb3JkZXIgdG8gaW5jb3Jwb3JhdGUgdHJhbnNmb3Jtc1xuICAgICAqL1xuICAgIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50LCBsYXlvdXRHcm91cCA9IF9hLmxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cCA9IF9hLnN3aXRjaExheW91dEdyb3VwLCBsYXlvdXRJZCA9IF9hLmxheW91dElkO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgYWRkU2NhbGVDb3JyZWN0b3IoZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAobGF5b3V0R3JvdXAgPT09IG51bGwgfHwgbGF5b3V0R3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICAgICAgICAgIGxheW91dEdyb3VwLmdyb3VwLmFkZChwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICgoc3dpdGNoTGF5b3V0R3JvdXAgPT09IG51bGwgfHwgc3dpdGNoTGF5b3V0R3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyKSAmJiBsYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvamVjdGlvbi5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICAgICAgcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uQ29tcGxldGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNldE9wdGlvbnMoX19hc3NpZ24oX19hc3NpZ24oe30sIHByb2plY3Rpb24ub3B0aW9ucyksIHsgb25FeGl0Q29tcGxldGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNhZmVUb1JlbW92ZSgpOyB9IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzRXZlclVwZGF0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbGF5b3V0RGVwZW5kZW5jeSA9IF9hLmxheW91dERlcGVuZGVuY3ksIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50LCBkcmFnID0gX2EuZHJhZywgaXNQcmVzZW50ID0gX2EuaXNQcmVzZW50O1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgaWYgKCFwcm9qZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBXZSB1c2UgdGhpcyBkYXRhIGluIHJlbGVnYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvXG4gICAgICAgICAqIHByb21vdGUgYSBwcmV2aW91cyBlbGVtZW50LiBUaGVyZSdzIG5vIGd1YXJhbnRlZSBpdHMgcHJlc2VuY2UgZGF0YVxuICAgICAgICAgKiB3aWxsIGhhdmUgdXBkYXRlZCBieSB0aGlzIHBvaW50IC0gaWYgYSBidWcgbGlrZSB0aGlzIGFyaXNlcyBpdCB3aWxsXG4gICAgICAgICAqIGhhdmUgdG8gYmUgdGhhdCB3ZSBtYXJrRm9yUmVsZWdhdGlvbiBhbmQgdGhlbiBmaW5kIGEgbmV3IGxlYWQgc29tZSBvdGhlciB3YXksXG4gICAgICAgICAqIHBlcmhhcHMgaW4gZGlkVXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0aW9uLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbiAgICAgICAgaWYgKGRyYWcgfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5sYXlvdXREZXBlbmRlbmN5ICE9PSBsYXlvdXREZXBlbmRlbmN5IHx8XG4gICAgICAgICAgICBsYXlvdXREZXBlbmRlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ud2lsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlByb3BzLmlzUHJlc2VudCAhPT0gaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wcm9tb3RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghcHJvamVjdGlvbi5yZWxlZ2F0ZSgpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlcmUncyBhbm90aGVyIHN0YWNrIG1lbWJlciB0YWtpbmcgb3ZlciBmcm9tIHRoaXMgb25lLFxuICAgICAgICAgICAgICAgICAqIGl0J3MgaW4gY2hhcmdlIG9mIHRoZSBleGl0IGFuaW1hdGlvbiBhbmQgdGhlcmVmb3JlIHNob3VsZFxuICAgICAgICAgICAgICAgICAqIGJlIGluIGNoYXJnZSBvZiB0aGUgc2FmZSB0byByZW1vdmUuIE90aGVyd2lzZSB3ZSBjYWxsIGl0IGhlcmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3luYy5wb3N0UmVuZGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBwcm9qZWN0aW9uLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1iZXJzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnByb3BzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgIGlmICghcHJvamVjdGlvbi5jdXJyZW50QW5pbWF0aW9uICYmIHByb2plY3Rpb24uaXNMZWFkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAgPSBfYS5sYXlvdXRHcm91cCwgcHJvbW90ZUNvbnRleHQgPSBfYS5zd2l0Y2hMYXlvdXRHcm91cDtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKTtcbiAgICAgICAgICAgIGlmIChsYXlvdXRHcm91cCA9PT0gbnVsbCB8fCBsYXlvdXRHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgICAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAucmVtb3ZlKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHByb21vdGVDb250ZXh0ID09PSBudWxsIHx8IHByb21vdGVDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKVxuICAgICAgICAgICAgICAgIHByb21vdGVDb250ZXh0LmRlcmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dC5wcm90b3R5cGUuc2FmZVRvUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZVRvUmVtb3ZlID0gdGhpcy5wcm9wcy5zYWZlVG9SZW1vdmU7XG4gICAgICAgIHNhZmVUb1JlbW92ZSA9PT0gbnVsbCB8fCBzYWZlVG9SZW1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNhZmVUb1JlbW92ZSgpO1xuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dDtcbn0oUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBNZWFzdXJlTGF5b3V0KHByb3BzKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVByZXNlbmNlKCksIDIpLCBpc1ByZXNlbnQgPSBfYVswXSwgc2FmZVRvUmVtb3ZlID0gX2FbMV07XG4gICAgdmFyIGxheW91dEdyb3VwID0gdXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQsIF9fYXNzaWduKHt9LCBwcm9wcywgeyBsYXlvdXRHcm91cDogbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwOiB1c2VDb250ZXh0KFN3aXRjaExheW91dEdyb3VwQ29udGV4dCksIGlzUHJlc2VudDogaXNQcmVzZW50LCBzYWZlVG9SZW1vdmU6IHNhZmVUb1JlbW92ZSB9KSkpO1xufVxudmFyIGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMgPSB7XG4gICAgYm9yZGVyUmFkaXVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29ycmVjdEJvcmRlclJhZGl1cyksIHsgYXBwbHlUbzogW1xuICAgICAgICAgICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICAgICAgICAgIFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcbiAgICAgICAgXSB9KSxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm94U2hhZG93OiBjb3JyZWN0Qm94U2hhZG93LFxufTtcblxuZXhwb3J0IHsgTWVhc3VyZUxheW91dCB9O1xuIiwgImltcG9ydCB7IHB4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuXG5mdW5jdGlvbiBwaXhlbHNUb1BlcmNlbnQocGl4ZWxzLCBheGlzKSB7XG4gICAgaWYgKGF4aXMubWF4ID09PSBheGlzLm1pbilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChwaXhlbHMgLyAoYXhpcy5tYXggLSBheGlzLm1pbikpICogMTAwO1xufVxuLyoqXG4gKiBXZSBhbHdheXMgY29ycmVjdCBib3JkZXJSYWRpdXMgYXMgYSBwZXJjZW50YWdlIHJhdGhlciB0aGFuIHBpeGVscyB0byByZWR1Y2UgcGFpbnRzLlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBhcmUgcHJvamVjdGluZyBhIGJveCB0aGF0IGlzIDEwMHB4IHdpZGUgd2l0aCBhIDEwcHggYm9yZGVyUmFkaXVzXG4gKiBpbnRvIGEgYm94IHRoYXQgaXMgMjAwcHggd2lkZSB3aXRoIGEgMjBweCBib3JkZXJSYWRpdXMsIHRoYXQgaXMgYWN0dWFsbHkgYSAxMCVcbiAqIGJvcmRlclJhZGl1cyBpbiBib3RoIHN0YXRlcy4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGl4ZWxzIHRoYXQgd2lsbCB0cmlnZ2VyXG4gKiBhIHBhaW50IGVhY2ggdGltZS4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGVyY2VudGFnZSB3ZSdsbCBhdm9pZCBhIHBhaW50LlxuICovXG52YXIgY29ycmVjdEJvcmRlclJhZGl1cyA9IHtcbiAgICBjb3JyZWN0OiBmdW5jdGlvbiAobGF0ZXN0LCBub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS50YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGF0ZXN0IGlzIGEgc3RyaW5nLCBpZiBpdCdzIGEgcGVyY2VudGFnZSB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5IGFzIGl0J3NcbiAgICAgICAgICogZ29pbmcgdG8gYmUgc3RyZXRjaGVkIGFwcHJvcHJpYXRlbHkuIE90aGVyd2lzZSwgaWYgaXQncyBhIHBpeGVsLCBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBsYXRlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChweC50ZXN0KGxhdGVzdCkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3QgPSBwYXJzZUZsb2F0KGxhdGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsYXRlc3QgaXMgYSBudW1iZXIsIGl0J3MgYSBwaXhlbCB2YWx1ZS4gV2UgdXNlIHRoZSBjdXJyZW50IHZpZXdwb3J0Qm94IHRvIGNhbGN1bGF0ZSB0aGF0XG4gICAgICAgICAqIHBpeGVsIHZhbHVlIGFzIGEgcGVyY2VudGFnZSBvZiBlYWNoIGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIHZhciB4ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueCk7XG4gICAgICAgIHZhciB5ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueSk7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh4LCBcIiUgXCIpLmNvbmNhdCh5LCBcIiVcIik7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGNvcnJlY3RCb3JkZXJSYWRpdXMsIHBpeGVsc1RvUGVyY2VudCB9O1xuIiwgImltcG9ydCB7IG1peCB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgY3NzVmFyaWFibGVSZWdleCB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vdXRpbHMvY3NzLXZhcmlhYmxlcy1jb252ZXJzaW9uLm1qcyc7XG5cbnZhciB2YXJUb2tlbiA9IFwiXyRjc3NcIjtcbnZhciBjb3JyZWN0Qm94U2hhZG93ID0ge1xuICAgIGNvcnJlY3Q6IGZ1bmN0aW9uIChsYXRlc3QsIF9hKSB7XG4gICAgICAgIHZhciB0cmVlU2NhbGUgPSBfYS50cmVlU2NhbGUsIHByb2plY3Rpb25EZWx0YSA9IF9hLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gbGF0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgbmVlZCB0byBmaXJzdCBzdHJpcCBhbmQgc3RvcmUgQ1NTIHZhcmlhYmxlcyBmcm9tIHRoZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29udGFpbnNDU1NWYXJpYWJsZXMgPSBsYXRlc3QuaW5jbHVkZXMoXCJ2YXIoXCIpO1xuICAgICAgICB2YXIgY3NzVmFyaWFibGVzID0gW107XG4gICAgICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgICAgICAgbGF0ZXN0ID0gbGF0ZXN0LnJlcGxhY2UoY3NzVmFyaWFibGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY3NzVmFyaWFibGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJUb2tlbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkb3cgPSBjb21wbGV4LnBhcnNlKGxhdGVzdCk7XG4gICAgICAgIC8vIFRPRE86IERvZXNuJ3Qgc3VwcG9ydCBtdWx0aXBsZSBzaGFkb3dzXG4gICAgICAgIGlmIChzaGFkb3cubGVuZ3RoID4gNSlcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcihsYXRlc3QpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdHlwZW9mIHNoYWRvd1swXSAhPT0gXCJudW1iZXJcIiA/IDEgOiAwO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJhbGwgY29udGV4dCBzY2FsZVxuICAgICAgICB2YXIgeFNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICAgICAgdmFyIHlTY2FsZSA9IHByb2plY3Rpb25EZWx0YS55LnNjYWxlICogdHJlZVNjYWxlLnk7XG4gICAgICAgIHNoYWRvd1swICsgb2Zmc2V0XSAvPSB4U2NhbGU7XG4gICAgICAgIHNoYWRvd1sxICsgb2Zmc2V0XSAvPSB5U2NhbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVhbGx5IHdlJ2QgY29ycmVjdCB4IGFuZCB5IHNjYWxlcyBpbmRpdmlkdWFsbHksIGJ1dCBiZWNhdXNlIGJsdXIgYW5kXG4gICAgICAgICAqIHNwcmVhZCBhcHBseSB0byBib3RoIHdlIGhhdmUgdG8gdGFrZSBhIHNjYWxlIGF2ZXJhZ2UgYW5kIGFwcGx5IHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICogV2UgY291bGQgcG90ZW50aWFsbHkgaW1wcm92ZSB0aGUgb3V0Y29tZSBvZiB0aGlzIGJ5IGluY29ycG9yYXRpbmcgdGhlIHJhdGlvIGJldHdlZW5cbiAgICAgICAgICogdGhlIHR3byBzY2FsZXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYXZlcmFnZVNjYWxlID0gbWl4KHhTY2FsZSwgeVNjYWxlLCAwLjUpO1xuICAgICAgICAvLyBCbHVyXG4gICAgICAgIGlmICh0eXBlb2Ygc2hhZG93WzIgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgc2hhZG93WzIgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICAgICAgLy8gU3ByZWFkXG4gICAgICAgIGlmICh0eXBlb2Ygc2hhZG93WzMgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgc2hhZG93WzMgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRlbXBsYXRlKHNoYWRvdyk7XG4gICAgICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFyIGlfMSA9IDA7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSh2YXJUb2tlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjc3NWYXJpYWJsZSA9IGNzc1ZhcmlhYmxlc1tpXzFdO1xuICAgICAgICAgICAgICAgIGlfMSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBjc3NWYXJpYWJsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGNvcnJlY3RCb3hTaGFkb3cgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vY3JlYXRlLXByb2plY3Rpb24tbm9kZS5tanMnO1xuaW1wb3J0IHsgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vRG9jdW1lbnRQcm9qZWN0aW9uTm9kZS5tanMnO1xuXG52YXIgcm9vdFByb2plY3Rpb25Ob2RlID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG52YXIgSFRNTFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICAgIG1lYXN1cmVTY3JvbGw6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gKHtcbiAgICAgICAgeDogaW5zdGFuY2Uuc2Nyb2xsTGVmdCxcbiAgICAgICAgeTogaW5zdGFuY2Uuc2Nyb2xsVG9wLFxuICAgIH0pOyB9LFxuICAgIGRlZmF1bHRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyb290UHJvamVjdGlvbk5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50Tm9kZSA9IG5ldyBEb2N1bWVudFByb2plY3Rpb25Ob2RlKDAsIHt9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5tb3VudCh3aW5kb3cpO1xuICAgICAgICAgICAgZG9jdW1lbnROb2RlLnNldE9wdGlvbnMoeyBsYXlvdXRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudCA9IGRvY3VtZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQ7XG4gICAgfSxcbiAgICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKGluc3RhbmNlLCB2YWx1ZSkge1xuICAgICAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBcIm5vbmVcIjtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEhUTUxQcm9qZWN0aW9uTm9kZSwgcm9vdFByb2plY3Rpb25Ob2RlIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlUHJvamVjdGlvbk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1wcm9qZWN0aW9uLW5vZGUubWpzJztcblxudmFyIERvY3VtZW50UHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gICAgYXR0YWNoUmVzaXplTGlzdGVuZXI6IGZ1bmN0aW9uIChyZWYsIG5vdGlmeSkge1xuICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBub3RpZnksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG5vdGlmeSk7IH07XG4gICAgfSxcbiAgICBtZWFzdXJlU2Nyb2xsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICB4OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgIHk6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgfSk7IH0sXG59KTtcblxuZXhwb3J0IHsgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSB9O1xuIiwgImV4cG9ydCBjb25zdCBwYWdlTW90aW9uID0ge1xuXHRoaWRkZW46IHtcblx0XHR5OiAtMTAwLFxuXHRcdG9wYWNpdHk6IDBcblx0fSxcblx0dmlzaWJsZToge1xuXHRcdHk6IDAsXG5cdFx0b3BhY2l0eTogMSxcblx0XHR0cmFuc2l0aW9uOiB7IGVhc2U6IFwiZWFzZU91dFwifVxuXHR9XG59IiwgIlxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBMaW5rLCB1c2VMb2FkZXJEYXRhIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB0eXBlIHsgTG9hZGVyRnVuY3Rpb24sIE1ldGFGdW5jdGlvbiB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgZ2V0UGFnZURhdGEgZnJvbSBcIn4vdXRpbHMvZ2V0UGFnZURhdGFcIlxuaW1wb3J0IHsgc3VwcG9ydF9tZHggfSBmcm9tIFwifi9jb250ZW50L3N1cHBvcnQubWQuanNcIlxuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuaW1wb3J0IHsgcGFnZU1vdGlvbiB9IGZyb20gXCJ+L3V0aWxzL21vdGlvblZhcmlhbnRzXCJcblxuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHtcblx0YnJlYWRjcnVtYjogKCkgPT4gPExpbmsgdG89XCIvc3VwcG9ydFwiPlRyXHUxRUUzIGdpXHUwMEZBcDwvTGluaz5cbn1cblxuZXhwb3J0IGNvbnN0IG1ldGE6IE1ldGFGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIHsgdGl0bGU6IFwiVHJcdTFFRTMgZ2lcdTAwRkFwIHwgVW5pa2V5XCIgfVxufVxuXG5leHBvcnQgY29uc3QgbG9hZGVyOiBMb2FkZXJGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIGdldFBhZ2VEYXRhKHN1cHBvcnRfbWR4KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdXBwb3J0UGFnZSgpIHtcblx0Y29uc3QgeyBhdHRyaWJ1dGVzLCBodG1sIH0gPSB1c2VMb2FkZXJEYXRhKClcblx0cmV0dXJuIChcblx0XHQ8bW90aW9uLmRpdiB2YXJpYW50cz17cGFnZU1vdGlvbn0gaW5pdGlhbD1cImhpZGRlblwiIGFuaW1hdGU9XCJ2aXNpYmxlXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInByb3NlIHByb3NlLWE6dGV4dC1ibHVlLTYwMFwiIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fSAvPlxuXHRcdDwvbW90aW9uLmRpdj5cblx0KVxufVxuIiwgImV4cG9ydCBjb25zdCBzdXBwb3J0X21keCA9IGAtLS1cbnRpdGxlOiBUclx1MUVFMyBnaVx1MDBGQXBcbi0tLVxuIyBUclx1MUVFMyBnaVx1MDBGQXBcblxuIyMjIERcdTFFRjEgXHUwMEUxbiBVbmlLZXlcblxuQ1x1MDBFMWMgdGhcdTFFQTNvIGx1XHUxRUFEbiwgY1x1MDBFMWMgcGhpXHUwMEVBbiBiXHUxRUEzbiBVbmlLZXkgdlx1MDBFMCBtXHUwMEUzIG5ndVx1MUVEM24gXHUwMTExXHUwMUIwXHUxRUUzYyBcdTAxMTFcdTFFQjd0IHRcdTFFQTFpIHdlYnNpdGUgZFx1MUVGMSBcdTAwRTFuOiBbVW5pS2V5IFByb2plY3RdKC8pXG5cbk5cdTFFQkZ1IGdcdTFFQjdwIGxcdTFFRDdpIHZcdTFFREJpIFVuaUtleSBiXHUxRUExbiBjXHUwMEYzIHRoXHUxRUMzLCBbYlx1MDBFMW8gbFx1MUVEN2kgdFx1MUVBMWkgXHUwMTExXHUwMEUyeV0oLykuXG5cbiMjIyBDXHUwMEUxYyBjaFx1MDBGQSBcdTAwRkRcblxuMS4gWFx1MDBFMWMgdGhcdTFFRjFjIFVuaUtleVxuXG5cdFx1MDExMFx1MUVDMyB4XHUwMEUxYyBcdTAxMTFcdTFFQ0JuaCBVbmlLZXkgYlx1MUVBMW4gXHUwMTExYW5nIGRcdTAwRjluZyBjXHUwMEYzIG5ndVx1MUVEM24gZ1x1MUVEMWMgc1x1MUVBMWNoLCBraFx1MDBGNG5nIGJcdTFFQ0Igc1x1MUVFRGEgXHUwMTExXHUxRUQ1aSwgaFx1MDBFM3kgW2tpXHUxRUMzbSB0cmEgY2hcdTFFRUYga1x1MUVGOSBzXHUxRUQxIGNcdTFFRTdhIFVuaWtleV0oLylcblxuMi4gVFx1MUVGMSBcdTAxMTFcdTFFRDluZyBjaFx1MUVBMXkgVW5pS2V5IHZcdTFFREJpIHF1eVx1MUVDMW4gYWRtaW5zdHJhdG9yXG5cblx0VFx1MDBGOXkgY2hcdTFFQ0RuIEtoXHUxRURGaSBcdTAxMTFcdTFFRDluZyBjXHUwMEY5bmcgV2luZG93cyB0cm9uZyBVbmlLZXkga2hcdTAwRjRuZyBjXHUwMEYzIHRcdTAwRTFjIGRcdTFFRTVuZyBcdTAxMTFcdTFFQzMgY2hcdTFFQTF5IHZcdTFFREJpIHF1eVx1MUVDMW4gYWRtaW5pc3RyYXRvci4gQlx1MUVBMW4gY1x1MUVBN24gcGhcdTFFQTNpIGRcdTAwRjluZyBUYXNrIFNjaGVkdWxlci4gWGVtIGhcdTAxQjBcdTFFREJuZyBkXHUxRUFCbjogW0NoXHUxRUExeSBVbmlLZXkgdlx1MUVEQmkgcXV5XHUxRUMxbiBhZG1pbmlzdHJhdG9yXSgvKVxuXG4jIyMgSFx1MDFCMFx1MUVEQm5nIGRcdTFFQUJuIHNcdTFFRUQgZFx1MUVFNW5nXG5cbltIXHUwMUIwXHUxRURCbmcgZFx1MUVBQm4gc1x1MUVFRCBkXHUxRUU1bmcgVW5pS2V5XSgvKTogVFx1MDBFMGkgbGlcdTFFQzd1IG5cdTAwRTB5IFx1MDExMVx1MDBFMyBjXHUwMEYzIG5oaVx1MUVDMXUgcGhcdTFFQTduIFx1MDExMVx1MDBFMyBsXHUxRUExYyBoXHUxRUFEdS4gUlx1MUVBNXQgdGlcdTFFQkZjIHRcdTAwRjRpIGNoXHUwMUIwYSBjXHUwMEYzIHRoXHUxRUREaSBnaWFuIGNcdTFFQURwIG5oXHUxRUFEdCB0XHUwMEUwaSBsaVx1MUVDN3Ugblx1MDBFMHkuXG5cbltGQVE6IENcdTAwRTFjIGNcdTAwRTJ1IGhcdTFFQ0ZpIHRoXHUwMUIwXHUxRUREbmcgZ1x1MUVCN3Agdlx1MUVDMSBVbmlLZXldKC8pLlxuXG4jIyMgQ1x1MDBFMWMgYlx1MUVEOSBmb250IGNoXHUxRUVGIHRpXHUxRUJGbmcgVmlcdTFFQzd0XG5cbkRcdTAxQjBcdTFFREJpIFx1MDExMVx1MDBFMnkgbFx1MDBFMCBjXHUwMEUxYyBiXHUxRUQ5IGZvbnQgY2hcdTFFRUYgY1x1MDE2OSwgcmEgXHUwMTExXHUxRUREaSB0XHUxRUVCIHRyXHUwMUIwXHUxRURCYyBraGkgY1x1MDBGMyBjXHUwMEUxYyBiXHUxRUQ5IGZvbnQgdW5pY29kZSBjXHUwMEYzIGhcdTFFRDcgdHJcdTFFRTMgdGlcdTFFQkZuZyBWaVx1MUVDN3QuIEJcdTFFQTFuIGNoXHUxRUM5IG5cdTAwRUFuIGRcdTAwRjluZyBjXHUwMEUxYyBmb250IG5cdTAwRTB5IGtoaSBjXHUwMEYzIGxcdTAwRkQgZG8gdGhcdTFFRjFjIHNcdTFFRjEgY1x1MUVBN24gdGhpXHUxRUJGdC4gVHJvbmcgXHUwMTExYSBzXHUxRUQxIHRyXHUwMUIwXHUxRUREbmcgaFx1MUVFM3AsIGhcdTAwRTN5IGRcdTAwRjluZyBjXHUwMEUxYyBiXHUxRUQ5IGZvbnQgdW5pY29kZS5cblxuW1RDVk4tQUJDIGZvbnRzICgyLjUgTUIpXSgvKVxuXG5bVk5JIGZvbnRzICgzMDAgS0IpXSgvKVxuYCIsICJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGluaywgdXNlTG9hZGVyRGF0YSB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgdHlwZSB7IExvYWRlckZ1bmN0aW9uLCBNZXRhRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IGdldFBhZ2VEYXRhIGZyb20gXCJ+L3V0aWxzL2dldFBhZ2VEYXRhXCJcbmltcG9ydCB7IHNvdXJjZV9tZHggfSBmcm9tIFwifi9jb250ZW50L3NvdXJjZS5tZC5qc1wiXG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG5pbXBvcnQgeyBwYWdlTW90aW9uIH0gZnJvbSBcIn4vdXRpbHMvbW90aW9uVmFyaWFudHNcIlxuXG5leHBvcnQgY29uc3QgaGFuZGxlID0ge1xuXHRicmVhZGNydW1iOiAoKSA9PiA8TGluayB0bz1cIi9zb3VyY2VcIj5VbmlLZXkgU291cmNlIENvZGU8L0xpbms+XG59XG5cbmV4cG9ydCBjb25zdCBtZXRhOiBNZXRhRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiB7IHRpdGxlOiBcIlVuaUtleSBTb3VyY2UgQ29kZSB8IFVuaWtleVwiIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxvYWRlcjogTG9hZGVyRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiBnZXRQYWdlRGF0YShzb3VyY2VfbWR4KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTb3VyY2VQYWdlKCkge1xuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGh0bWwgfSA9IHVzZUxvYWRlckRhdGEoKVxuXHRyZXR1cm4gKFxuXHRcdDxtb3Rpb24uZGl2IHZhcmlhbnRzPXtwYWdlTW90aW9ufSBpbml0aWFsPVwiaGlkZGVuXCIgYW5pbWF0ZT1cInZpc2libGVcIj5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwicHJvc2UgbWF4LXctc2NyZWVuLWxnXCIgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBodG1sIH19IC8+XG5cdFx0PC9tb3Rpb24uZGl2PlxuXHQpXG59XG4iLCAiZXhwb3J0IGNvbnN0IHNvdXJjZV9tZHggPSBgLS0tXG50aXRsZTogVW5pS2V5IFNvdXJjZSBDb2RlXG4tLS1cbiMgVW5pS2V5IFNvdXJjZSBDb2RlXG5cbkFsbCBzb3VyY2UgY29kZSBpbiB0aGlzIHBhZ2UgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIHRlcm1zIG9mIFt0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VdKC8pLiBCeSBkb3dubG9hZGluZyBVbmlLZXkgc291cmNlIGNvZGUsIHlvdSBhZ3JlZSB3aXRoIGFsbCB0aGUgdGVybXMgb2YgdGhpcyBsaWNlbnNlLlxuXG4jIyMgVW5pS2V5IFZpZXRuYW1lc2UgSW5wdXQgTWV0aG9kXG5cbiogSW4gMjAwMSwgSSByZWxlYXNlZCB0aGUgc291cmNlIGNvZGUgb2YgdGhlIGNvcmUgZW5naW5lIFVuaUtleSBWaWV0bmFtZXNlIElucHV0IE1ldGhvZCB0b2dldGhlciB3aXRoIHRoZSB4LXVuaWtleSBsaW51eCBwYWNrYWdlLiBTaW5jZSB0aGVuLCB0aGUgVW5pS2V5IGVuZ2luZSBoYXMgYmVlbiBpbnRlZ3JhdGVkIHRvIGRpZmZlcmVudCBrZXlib2FyZCBpbnB1dCBwcm9ncmFtcyBpbiB2YXJpb3VzIHBsYXRmb3JtczogTGludXgsIFttYWNPUyBhbmQgaU9TXSgvKSwgRnJlZUJTRC4gVGhlIGNvcmUgZW5naW5lIGlzIHN0aWxsIHByZXR0eSBtdWNoIHVuY2hhbmdlZCBpbiB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgVW5pS2V5IGZvciBXaW5kb3dzLiBZb3UgY2FuIGdldCB0aGUgZW5naW5lIHNvdXJjZSBjb2RlIGluIHRoZSBvcmlnaW5hbCB4LXVuaWtleSBsaW51eCBwYWNrYWdlLlxuXG5cdFt4LXVuaWtleSBzb3VyY2UgY29kZV0oLylcblxuKiBGb3IgZWR1Y2F0aW9uYWwgcHVycG9zZXMsIEkgaGF2ZSBhbHNvIHJlbGVhc2VkIHRoZSBmdWxsIFVuaUtleSAzLjYgKGZvciBXaW5kb3dzKSBzb3VyY2UgY29kZS4gUGxlYXNlIG5vdGUgdGhhdCwgVW5pS2V5IDMuNndhcyBidWlsdCB3aXRoIGFuIG9sZCB2ZXJzaW9uIG9mIHRoZSBVbmlLZXkgSW5wdXQgRW5naW5lLiBZb3UgY2FuZCBmaW5kIHRoZSBsYXRlc3QgZW5naW5lIHNvdXJjZSBjb2RlIGluIHRoZSB4LXVuaWtleSBwYWNrYWdlIGFib3ZlLlxuXG5cdFtVbmlLZXkgMy42MiAwNTA3MTEgLSBzb3VyY2UgY29kZV0oLylcblxuIyMjIFVWQ29udmVydGVyXG5cblVWQ29udmVydGVyIGlzIGEgdW5pdmVyc2FsIGNvbW1hbmQtbGluZSBWaWV0bmFtZXNlIGVuY29kaW5nIGNvbnZlcnRlciB0aGF0IHN1cHBvcnRzIDEzIGRpZmZlcmVudCBjaGFyc2V0cy9lbmNvZGluZ3MgKFVuaWNvZGUsIFVURjgsIFRDVk4zLCBWTklcdTIwMjYpLiBVVkNvbnZlcnRlciBjYW4gYmUgYnVpbHQgaW4gV2luZG93cywgTGludXgsIE1hYyBPUyBYLlxuXG4qIFRhci5neiBmb3JtYXQgKGZvciBMaW51eCwgTWFjIE9TIFgpOiBbVVZDb252ZXJ0ZXIgMS4xLjNiXSgvKVxuKiBaaXAgZm9ybWF0IChmb3IgV2luZG93cyk6IFtVVkNvbnZlcnRlciAxLjEuM2JdKC8pXG5cbmAiLCAiXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IExpbmssIHVzZUxvYWRlckRhdGEgfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IHR5cGUgeyBMb2FkZXJGdW5jdGlvbiwgTWV0YUZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCBnZXRQYWdlRGF0YSBmcm9tIFwifi91dGlscy9nZXRQYWdlRGF0YVwiXG5pbXBvcnQgeyBhYm91dF9tZHggfSBmcm9tIFwifi9jb250ZW50L2Fib3V0Lm1kLmpzXCJcbmltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbmltcG9ydCB7IHBhZ2VNb3Rpb24gfSBmcm9tIFwifi91dGlscy9tb3Rpb25WYXJpYW50c1wiXG5cbmV4cG9ydCBjb25zdCBoYW5kbGUgPSB7XG5cdGJyZWFkY3J1bWI6ICgpID0+IDxMaW5rIHRvPVwiL2Fib3V0XCI+PC9MaW5rPlxufVxuXG5leHBvcnQgY29uc3QgbWV0YTogTWV0YUZ1bmN0aW9uID0gKCkgPT4ge1xuXHRyZXR1cm4geyB0aXRsZTogXCJHaVx1MUVEQmkgdGhpXHUxRUM3dSBVbmlrZXkgfCBVbmlrZXlcIiB9XG59XG5cbmV4cG9ydCBjb25zdCBsb2FkZXI6IExvYWRlckZ1bmN0aW9uID0gKCkgPT4ge1xuXHRyZXR1cm4gZ2V0UGFnZURhdGEoYWJvdXRfbWR4KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBYm91dFBhZ2UoKSB7XG5cdGNvbnN0IHsgYXR0cmlidXRlcywgaHRtbCB9ID0gdXNlTG9hZGVyRGF0YSgpXG5cdHJldHVybiAoXG5cdFx0PG1vdGlvbi5kaXYgdmFyaWFudHM9e3BhZ2VNb3Rpb259IGluaXRpYWw9XCJoaWRkZW5cIiBhbmltYXRlPVwidmlzaWJsZVwiPlxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJwcm9zZSBtYXgtdy1zY3JlZW4tbGdcIiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGh0bWwgfX0gLz5cblx0XHQ8L21vdGlvbi5kaXY+XG5cdClcbn1cbiIsICJleHBvcnQgY29uc3QgYWJvdXRfbWR4ID0gYC0tLVxudGl0bGU6IEdpXHUxRURCaSB0aGlcdTFFQzd1IFVuaUtleVxuLS0tXG4jIEdpXHUxRURCaSB0aGlcdTFFQzd1IFVuaUtleVxuXG5VbmlLZXkgXHUwMTExXHUwMUIwXHUxRUUzYyBjXHUwMEY0bmcgYlx1MUVEMSBsXHUxRUE3biBcdTAxMTFcdTFFQTd1IHRpXHUwMEVBbiB2XHUwMEUwbyBuXHUwMTAzbSAxOTk5LiBOZ2F5IHRcdTFFRUIga2hpIHJhIFx1MDExMVx1MUVERGksIFVuaUtleSBcdTAxMTFcdTAwRTMgXHUwMTExXHUwMUIwXHUxRUUzYyBuZ1x1MDFCMFx1MUVERGkgZFx1MDBGOW5nIFx1MDExMVx1MDBGM24gbmhcdTFFQURuIHJcdTFFQTV0IHRcdTAwRURjaCBjXHUxRUYxYyBuaFx1MUVERCB0XHUwMEVEbmggXHUwMTExXHUwMUExbiBnaVx1MUVBM24sIHRpXHUxRUM3biBkXHUxRUU1bmcsIHRcdTFFRDFjIFx1MDExMVx1MUVEOSwgdGluIGNcdTFFQUR5LiBVbmlLZXkgbmhhbmggY2hcdTAwRjNuZyB0clx1MUVERiB0aFx1MDBFMG5oIGNoXHUwMUIwXHUwMUExbmcgdHJcdTAwRUNuaCBnXHUwMEY1IHRpXHUxRUJGbmcgVmlcdTFFQzd0IHRcdTFFRDF0IG5oXHUxRUE1dCwgcGhcdTFFRDUgYmlcdTFFQkZuIG5oXHUxRUE1dCB0clx1MDBFQW4gV2luZG93cy4gSGlcdTFFQzduIG5heSBVbmlLZXkgY1x1MDBGMyBtXHUxRUI3dCBoXHUxRUE3dSBuaFx1MDFCMCB0clx1MDBFQW4gdFx1MUVBNXQgY1x1MUVBMyBjXHUwMEUxYyBtXHUwMEUxeSB0XHUwMEVEbmggY2hcdTFFQTF5IFdpbmRvd3MgY1x1MUVFN2EgbmdcdTAxQjBcdTFFRERpIFZpXHUxRUM3dC5cblxuKipVbmlLZXkgVmlldG5hbWVzZSBJbnB1dCBNZXRob2QqKiwgbW9kdWxlIGNoXHUwMEVEbmggeFx1MUVFRCBsXHUwMEZEIHRpXHUxRUJGbmcgVmlcdTFFQzd0IChnXHUxRUQzbSBjXHUwMEUxYyBwaFx1MDFCMFx1MDFBMW5nIHBoXHUwMEUxcCBnXHUwMEY1LCB0aHVcdTFFQUR0IHRvXHUwMEUxbiBjaHV5XHUxRUMzbiBcdTAxMTFcdTFFRDVpIHRpXHUxRUJGbmcgVmlcdTFFQzd0KSB0cm9uZyBVbmlLZXksIFx1MDExMVx1MDFCMFx1MUVFM2Mgb3Blbi1zb3VyY2UgdFx1MUVFQiBuXHUwMTAzbSAyMDAxLiBCXHUxRUEzbiBvcGVuLXNvdXJjZSBjXHUxRUU3YSBVbmlLZXkgY2hcdTFFQTF5IHRyXHUwMEVBbiBYLVdpbmRvdyAoTGludXgpIFx1MDExMVx1MDFCMFx1MUVFM2MgY1x1MDBGNG5nIGJcdTFFRDEgdFx1MUVFQiBuXHUwMTAzbSAyMDAxLCBkXHUwMUIwXHUxRURCaSB0XHUwMEVBbiAqKngtdW5pa2V5KiouICoqeC11bmlrZXkqKiBsXHUwMEUwIG1cdTFFRDl0IHRyb25nIG5oXHUxRUVGbmcgY2hcdTAxQjBcdTAxQTFuZyB0clx1MDBFQ25oIGdcdTAwRjUgdGlcdTFFQkZuZyBWaVx1MUVDN3QgXHUwMTExXHUxRUE3dSB0aVx1MDBFQW4gdHJcdTAwRUFuIExpbnV4LiBUXHUxRUVCIHNvdXJjZSBjb2RlIHgtdW5pa2V5LCBVbmlLZXkgSW5wdXQgRW5naW5lIFx1MDExMVx1MDBFMyBcdTAxMTFcdTAxQjBcdTFFRTNjIHNcdTFFRUQgZFx1MUVFNW5nIHZcdTAwRTAgdFx1MDBFRGNoIGhcdTFFRTNwIHZcdTAwRTBvIGNcdTAwRTFjIGJcdTFFRDkgZ1x1MDBGNSB0aVx1MUVCRm5nIFZpXHUxRUM3dCB0clx1MDBFQW4gTGludXggc2F1IG5cdTAwRTB5LiBCXHUxRUQ5IGdcdTAwRjUgcGhcdTFFRDUgYmlcdTFFQkZuIG5oXHUxRUE1dCBkXHUwMEY5bmcgbFx1MDBGNWkgVW5pS2V5IHRyXHUwMEVBbiBMaW51eCBoaVx1MUVDN24gbmF5IGxcdTAwRTAgaWJ1cy11bmlrZXkgKGRvIExcdTAwRUEgUXVcdTFFRDFjIFR1XHUxRUE1biBwaFx1MDBFMXQgdHJpXHUxRUMzbikuXG5cblRcdTFFRUIgblx1MDEwM20gMjAwNiwgdFx1MDBFMWMgZ2lcdTFFQTMgVW5pS2V5IFx1MDExMVx1MDBFMyBjaG8gcGhcdTAwRTlwIEFwcGxlIGRcdTAwRjluZyBzb3VyY2UgY29kZSB4LXVuaWtleSB0cm9uZyBjXHUwMEUxYyBzXHUxRUEzbiBwaFx1MUVBOW0gY1x1MUVFN2EgQXBwbGUgdGhlbyBjXHUwMEUxYyBcdTAxMTFpXHUxRUMxdSBraG9cdTFFQTNuIGNcdTFFRTdhIGdpXHUxRUE1eSBwaFx1MDBFOXAgVGhlIE1JVCBsaWNlbnNlLiBUXHUxRUVCIHBoaVx1MDBFQW4gYlx1MUVBM24gVGlnZXIsIGJcdTFFRDkgZ1x1MDBGNSB0aVx1MUVCRm5nIFZpXHUxRUM3dCBjXHUwMEYzIHNcdTFFQjVuIHRyXHUwMEVBbiBNYWMgT1MgWCBcdTAxMTFcdTAwRTMgYlx1MUVBRnQgXHUwMTExXHUxRUE3dSBkXHUwMEY5bmcgbFx1MDBGNWkgVW5pS2V5LiBcdTAxMTBcdTFFQkZuIG5cdTAxMDNtIDIwMTAsIHBoaVx1MDBFQW4gYlx1MUVBM24gaU9TIDQuMCBjXHUwMTY5bmcgdFx1MDBFRGNoIGhcdTFFRTNwIGxcdTAwRjVpIFVuaUtleS4gXHUwMTEwXHUxRUJGbiBuYXkgdFx1MUVBNXQgY1x1MUVBMyBjXHUwMEUxYyB0aGlcdTFFQkZ0IGJcdTFFQ0IgaVBob25lLCBpUGFkIFx1MDExMVx1MUVDMXUgXHUwMTExYW5nIHNcdTFFRUQgZFx1MUVFNW5nIFVuaUtleSBjaG8gYlx1MUVEOSBnXHUwMEY1IHRpXHUxRUJGbmcgVmlcdTFFQzd0IGNcdTAwRjMgc1x1MUVCNW4uXG5cblVuaUtleSBcdTAxMTFcdTAxQjBcdTFFRTNjIHBoXHUwMEUxdCB0cmlcdTFFQzNuIGJcdTFFREZpICpQaFx1MUVBMW0gS2ltIExvbmcqLiBXZWJzaXRlIGNoXHUwMEVEbmggdGhcdTFFRTljIGR1eSBuaFx1MUVBNXQgY1x1MUVFN2EgVW5pS2V5IGxcdTAwRTAgW2h0dHA6Ly91bmlrZXkub3JnXShodHRwOi8vdW5pa2V5Lm9yZykuIFRcdTAwRTFjIGdpXHUxRUEzIGtoXHUwMEY0bmcgY2hcdTFFQ0J1IHRyXHUwMEUxY2ggbmhpXHUxRUM3bSB2XHUxRUMxIGJcdTFFQTV0IGNcdTFFRTkgd2Vic2l0ZSBuXHUwMEUwbyBraFx1MDBFMWMgY3VuZyBjXHUxRUE1cCBjXHUwMEUxYyBwaFx1MUVBN24gbVx1MUVDMW0gVW5pS2V5LlxuYCIsICJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGluaywgdXNlTG9hZGVyRGF0YSB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgdHlwZSB7IExvYWRlckZ1bmN0aW9uLCBNZXRhRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IGdldFBhZ2VEYXRhIGZyb20gXCJ+L3V0aWxzL2dldFBhZ2VEYXRhXCJcbmltcG9ydCB7IGFwcGxlX21keCB9IGZyb20gXCJ+L2NvbnRlbnQvYXBwbGUubWQuanNcIlxuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuaW1wb3J0IHsgcGFnZU1vdGlvbiB9IGZyb20gXCJ+L3V0aWxzL21vdGlvblZhcmlhbnRzXCJcblxuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHtcblx0YnJlYWRjcnVtYjogKCkgPT4gPExpbmsgdG89XCIvYXBwbGVcIj5VbmlLZXkgY2hvIG1hY09TIHZcdTAwRTAgaU9TPC9MaW5rPlxufVxuXG5leHBvcnQgY29uc3QgbWV0YTogTWV0YUZ1bmN0aW9uID0gKCkgPT4ge1xuXHRyZXR1cm4geyB0aXRsZTogXCJVbmlLZXkgY2hvIG1hY09TIHZcdTAwRTAgaU9TIHwgVW5pa2V5XCIgfVxufVxuXG5leHBvcnQgY29uc3QgbG9hZGVyOiBMb2FkZXJGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIGdldFBhZ2VEYXRhKGFwcGxlX21keClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwbGVQYWdlKCkge1xuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGh0bWwgfSA9IHVzZUxvYWRlckRhdGEoKVxuXHRyZXR1cm4gKFxuXHRcdDxtb3Rpb24uZGl2IHZhcmlhbnRzPXtwYWdlTW90aW9ufSBpbml0aWFsPVwiaGlkZGVuXCIgYW5pbWF0ZT1cInZpc2libGVcIj5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwicHJvc2UgbWF4LXctc2NyZWVuLWxnXCIgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBodG1sIH19IC8+XG5cdFx0PC9tb3Rpb24uZGl2PlxuXHQpXG59XG4iLCAiZXhwb3J0IGNvbnN0IGFwcGxlX21keCA9IGAtLS1cbnRpdGxlOiBVbmlLZXkgY2hvIG1hY09TIHZcdTAwRTAgaU9TXG4tLS1cbiMgVW5pS2V5IGNobyBtYWNPUyB2XHUwMEUwIGlPU1xuXG5UXHUxRUVCIG5cdTAxMDNtIDIwMDYsIHRcdTAwRjRpIFx1MDExMVx1MDBFMyBjaG8gcGhcdTAwRTlwIEFwcGxlIGRcdTAwRjluZyBzb3VyY2UgY29kZSAqKngtdW5pa2V5KiogKHBoaVx1MDBFQW4gYlx1MUVBM24gVW5pS2V5IGNobyBMaW51eCwgY1x1MDBGMyBjaFx1MUVFOWEgbW9kdWxlIGxcdTAwRjVpICoqVW5pa2V5IFZpZXRuYW1lc2UgSW5wdXQgTWV0aG9kKiopIHRyb25nIGNcdTAwRTFjIHNcdTFFQTNuIHBoXHUxRUE5bSBjXHUxRUU3YSBBcHBsZSB0aGVvIGNcdTAwRTFjIFx1MDExMWlcdTFFQzF1IGtob1x1MUVBM24gY1x1MUVFN2EgZ2lcdTFFQTV5IHBoXHUwMEU5cCBUaGUgTUlUIGxpY2Vuc2UuIFRcdTFFRUIgcGhpXHUwMEVBbiBiXHUxRUEzbiBNYWNPUyBYIExlb3BhcmQsIGJcdTFFRDkgZ1x1MDBGNSB0aVx1MUVCRm5nIFZpXHUxRUM3dCBjXHUwMEYzIHNcdTFFQjVuIHRyXHUwMEVBbiBNYWMgT1MgWCBcdTAxMTFcdTAwRTMgYlx1MUVBRnQgXHUwMTExXHUxRUE3dSBkXHUwMEY5bmcgbFx1MDBGNWkgVW5pS2V5LiBcdTAxMTBcdTFFQkZuIG5cdTAxMDNtIDIwMTAsIHBoaVx1MDBFQW4gYlx1MUVBM24gaU9TIDQuMCBjXHUwMTY5bmcgdFx1MDBFRGNoIGhcdTFFRTNwIGxcdTAwRjVpIFVuaUtleS4gXHUwMTEwXHUxRUJGbiBuYXkgdFx1MUVBNXQgY1x1MUVBMyBjXHUwMEUxYyB0aGlcdTFFQkZ0IGJcdTFFQ0IgaVBob25lLCBpUGFkIFx1MDExMVx1MUVDMXUgXHUwMTExYW5nIHNcdTFFRUQgZFx1MUVFNW5nIFVuaUtleSBjaG8gYlx1MUVEOSBnXHUwMEY1IHRpXHUxRUJGbmcgVmlcdTFFQzd0IGNcdTAwRjMgc1x1MUVCNW4gdHJcdTAwRUFuIG1cdTAwRTF5LlxuXG5CXHUwMEUwbiBwaFx1MDBFRG0gdGlcdTFFQkZuZyBWaVx1MUVDN3QgdHJvbmcgbWFjT1MgY1x1MDBGMyB0XHUwMEVBbiBTaW1wbGUgVGVsZXggc1x1MUVFRCBkXHUxRUU1bmcgbFx1MDBGNWkgKipVbmlrZXkgVmlldG5hbWVzZSBJbnB1dCBNZXRob2QqKlxuXG4hW1RlbGV4IGluIE1hY09TXSgvaW1nL21hY29zLXRlbGV4LnBuZylcblxuVHJvbmcgaU9TLCB4XHUwMEUxYyBuaFx1MUVBRG4gY1x1MUVFN2EgQXBwbGUgdlx1MUVDMSB2aVx1MUVDN2MgZFx1MDBGOW5nIFVuaUtleSBjXHUwMEYzIHRoXHUxRUMzIHRcdTAwRUNtIHRoXHUxRUE1eSB0cm9uZyAqQ1x1MDBFMGkgXHUwMTExXHUxRUI3dCAtIENcdTAwRTBpIFx1MDExMVx1MUVCN3QgY2h1bmcgLSBHaVx1MUVEQmkgdGhpXHUxRUM3dSAtIFBoXHUwMEUxcCBsXHUwMEZEIC0gVGhcdTAwRjRuZyBiXHUwMEUxbyBwaFx1MDBFMXAgbFx1MDBGRCpcblxuIVtpT1MgTGVnYWwgTm90aWNlXSgvaW1nL2lvcy1sZWdhbC5qcGcpXG5cbmAiLCAiXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IExpbmssIHVzZUxvYWRlckRhdGEgfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IHR5cGUgeyBMb2FkZXJGdW5jdGlvbiB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgZ2V0UGFnZURhdGEgZnJvbSBcIn4vdXRpbHMvZ2V0UGFnZURhdGFcIlxuaW1wb3J0IHsgaW5kZXhfbWR4IH0gZnJvbSBcIn4vY29udGVudC9pbmRleC5tZC5qc1wiXG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG5pbXBvcnQgeyBwYWdlTW90aW9uIH0gZnJvbSBcIn4vdXRpbHMvbW90aW9uVmFyaWFudHNcIlxuXG5leHBvcnQgY29uc3QgaGFuZGxlID0ge1xuXHRicmVhZGNydW1iOiAoKSA9PiA8TGluayB0bz1cIi9cIj5UcmFuZyBjaFx1MUVFNzwvTGluaz5cbn1cblxuZXhwb3J0IGNvbnN0IGxvYWRlcjogTG9hZGVyRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiBnZXRQYWdlRGF0YShpbmRleF9tZHgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEluZGV4KCkge1xuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGh0bWwgfSA9IHVzZUxvYWRlckRhdGEoKVxuXHRyZXR1cm4gKFxuXHRcdDxtb3Rpb24uZGl2IHZhcmlhbnRzPXtwYWdlTW90aW9ufSBpbml0aWFsPVwiaGlkZGVuXCIgYW5pbWF0ZT1cInZpc2libGVcIj5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwicHJvc2UgbWF4LXctc2NyZWVuLWxnIHByb3NlLWE6bm8tdW5kZXJsaW5lIHByb3NlLWE6dGV4dC1ibHVlLTYwMCBob3Zlcjpwcm9zZS1hOnVuZGVybGluZVwiIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fSAvPlxuXHRcdDwvbW90aW9uLmRpdj5cblx0KVxufVxuIiwgImV4cG9ydCBjb25zdCBpbmRleF9tZHggPSBgLS0tXG50aXRsZTogVW5pS2V5IC0gQlx1MDBFMG4gcGhcdTAwRURtIHRpXHUxRUJGbmcgVmlcdTFFQzd0XG4tLS1cbiMgVW5pS2V5IC0gQlx1MDBFMG4gcGhcdTAwRURtIHRpXHUxRUJGbmcgVmlcdTFFQzd0XG5cblVuaWtleSBsXHUwMEUwIGNoXHUwMUIwXHUwMUExbmcgdHJcdTAwRUNuaCBiXHUwMEUwbiBwaFx1MDBFRG0gdGlcdTFFQkZuZyBWaVx1MUVDN3QgcGhcdTFFRDUgYmlcdTFFQkZuIG5oXHUxRUE1dCB0clx1MDBFQW4gV2luZG93cy4gUGhcdTFFQTduIGxcdTAwRjVpIHhcdTFFRUQgbFx1MDBGRCB0aVx1MUVCRm5nIFZpXHUxRUM3dCBVbmlLZXkgSW5wdXQgRW5naW5lIGNcdTAxNjluZyBcdTAxMTFcdTAxQjBcdTFFRTNjIHNcdTFFRUQgZFx1MUVFNW5nIHRyb25nIGNcdTAwRTFjIGNoXHUwMUIwXHUwMUExbmcgdHJcdTAwRUNuaCBiXHUwMEUwbiBwaFx1MDBFRG0gbVx1MUVCN2MgXHUwMTExXHUxRUNCbmggY1x1MUVFN2EgY1x1MDBFMWMgaFx1MUVDNyBcdTAxMTFpXHUxRUMxdSBoXHUwMEUwbmggTGludXgsIE1hYyBPUyBYIHZcdTAwRTAgXHUwMTExXHUxRUI3YyBiaVx1MUVDN3QgbFx1MDBFMCB0XHUxRUE1dCBjXHUxRUEzIGNcdTAwRTFjIHRoaVx1MUVCRnQgYlx1MUVDQiBkXHUwMEY5bmcgaU9TIChpUGhvbmUsIGlQYWQpLiBVbmlLZXkgSW5wdXQgRW5naW5lIGNcdTAwRjMgbVx1MDBFMyBuZ3VcdTFFRDNuIG1cdTFFREYgdGhlbyBnaVx1MUVBNXkgcGhcdTAwRTlwIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLlxuXG5VbmlrZXkub3JnIGxcdTAwRTAgd2Vic2l0ZSBjaFx1MDBFRG5oIHRoXHUxRUU5YyBkdXkgbmhcdTFFQTV0IGNcdTFFRTdhIHBoXHUxRUE3biBtXHUxRUMxbSBVbmlLZXkuIFRcdTAwRTFjIGdpXHUxRUEzIGtoXHUwMEY0bmcgY2hcdTFFQ0J1IHRyXHUwMEUxY2ggbmhpXHUxRUM3bSB2XHUxRUMxIHRcdTFFQTV0IGNcdTFFQTMgY1x1MDBFMWMgd2Vic2l0ZSBraFx1MDBFMWMgbFx1MUVBNXkgdFx1MDBFQW4gaG9cdTFFQjdjIHBoXHUwMEUybiBwaFx1MUVEMWkgc1x1MUVBM24gcGhcdTFFQTltIFVuaUtleS5cblxuIyMgVGluIHRcdTFFRTljXG5cbi0tLVxuXG4qIE5nXHUwMEUweSAxNS8xMC8yMDIwOlxuXG5cdCogUGhcdTAwRTF0IGhcdTAwRTBuaCBbVW5pS2V5IDQuMyBSQzVdKC8pIGhcdTFFRDcgdHJcdTFFRTMgdHJcdTAwRUNuaCBkdXlcdTFFQzd0IEVkZ2UgbVx1MUVEQmkgdFx1MUVEMXQgaFx1MDFBMW4uXG5cbiogTmdcdTAwRTB5IDE0LzcvMjAxODpcblxuXHQqIFBoXHUwMEUxdCBoXHUwMEUwbmggW1VuaUtleSA0LjMgUkM0XSgvKSBzXHUxRUVEYSBtXHUxRUQ5dCBsXHUxRUQ3aSBraFx1MDBGNG5nIGdcdTAwRjUgXHUwMTExXHUwMUIwXHUxRUUzYyB0cm9uZyBtXHUxRUQ5dCBzXHUxRUQxIGFwcCAoY29uc29sZSwgZ2FtZSwgVVdQIGFwcHMpLlxuXG4qIE5nXHUwMEUweSAyLzcvMjAxODpcblxuXHQqIFBoXHUwMEUxdCBoXHUwMEUwbmggW1VuaUtleSA0LjMgUkMzXSgvKSBzXHUxRUVEYSBcdTAxMTFcdTAxQjBcdTFFRTNjIGxcdTFFRDdpIHZcdTFFREJpIEV4Y2VsIHZcdTAwRTAgY1x1MDBFMWMgdHJcdTAwRUNuaCBkdXlcdTFFQzd0IChDaHJvbWUsIEVkZ2UsIEZpcmVmb3gsIEludGVybmV0IEV4cGxvcmVyKS5cblxuXHQqIENoXHUwMEZBIFx1MDBGRDogQlx1MUVBM24gNC4yIFJDMiBwaFx1MDBFMXQgaFx1MDBFMG5oIG5nXHUwMEUweSAxLzcvMjAxOCBjXHUwMEYzIGxcdTFFRDdpIHZcdTFFREJpIEVkZ2UuIExcdTFFRDdpIG5cdTAwRTB5IFx1MDExMVx1MDBFMyBcdTAxMTFcdTAxQjBcdTFFRTNjIHNcdTFFRURhIG5nYXkgdHJvbmcgYlx1MUVBM24gNC4zIFJDMy5cblxuKiBOZ1x1MDBFMHkgMjMvNi8yMDE4OlxuXG5cdCogUGhcdTAwRTF0IGhcdTAwRTBuaCBVbmlLZXkgNC4zIFJDMVxuXHRcblx0KiBLXHUxRUMzIHRcdTFFRUIgcGhpXHUwMEVBbiBiXHUxRUEzbiA0LjMsIGNcdTAwRTFjIGJcdTFFQTNuIFVuaUtleSBcdTAxMTFcdTAxQjBcdTFFRTNjIHBoXHUwMEUxdCBoXHUwMEUwbmggXHUwMTExaSBrXHUwMEU4bSB2XHUxRURCaSBjaFx1MUVFRiBrXHUwMEZEIHNcdTFFRDEgY1x1MDBGMyBjaFx1MUVFOW5nIHRoXHUxRUYxYyBcdTAxMTFcdTFFQzMgY2hcdTFFRDFuZyBwaFx1MUVBN24gbVx1MUVDMW0gZ2lcdTFFQTMgbVx1MUVBMW8uIFhlbSB0aFx1MDBFQW0gdGhcdTAwRjRuZyB0aW4gdFx1MUVBMWkgW0NoXHUxRUU5bmcgdGhcdTFFRjFjIFVuaUtleV0oLykuXG5cbiMjIENcdTAwRTFjIHRcdTAwRURuaCBuXHUwMTAzbmdcblxuLS0tXG5cblVuaUtleSBoXHUxRUQ3IHRyXHUxRUUzOlxuXG4qIFRcdTFFQTV0IGNcdTFFQTMgY1x1MDBFMWMgYlx1MUVBM25nIG1cdTAwRTMgcGhcdTFFRDUgYmlcdTFFQkZuOlxuXG5cdCogVW5pY29kZSwgVENWTiAoQUJDKVxuXG5cdCogVklRUiwgVk5JLCBWUFMsIFZJU0NJSSwgQksgSENNMSwgQksgSENNMixcdTIwMjZcblxuXHQqIFVuaWNvZGUgVVRGLTgsIFVuaWNvZGUgTkNSIC0gZm9yIFdlYiBlZGl0b3JzLlxuXG4qIDIgcGhcdTAxQjBcdTAxQTFuZyBwaFx1MDBFMXAgZ1x1MDBGNSB0aFx1MDBGNG5nIGRcdTFFRTVuZzogVEVMRVgsIFZOSVxuXG4qIENobyBwaFx1MDBFOXAgdFx1MUVGMSBcdTAxMTFcdTFFQ0JuaCBuZ2hcdTAxMjlhIGtpXHUxRUMzdSBnXHUwMEY1XG5cbiogQ2hvIHBoXHUwMEU5cCBnXHUwMEY1IHRcdTFFQUZ0IHZcdTAwRTAgXHUwMTExXHUxRUNCbmggbmdoXHUwMTI5YSBiXHUxRUEzbmcgZ1x1MDBGNSB0XHUxRUFGdC5cblxuKiBDaFx1MUVBMXkgdHJcdTAwRUFuIHRcdTFFQTV0IGNcdTFFQTMgY1x1MDBFMWMgcGhpXHUwMEVBbiBiXHUxRUEzbiBXaW5kb3dzOiAxMCwgOCwgNywgVmlzdGEsIDIwMDAsIFhQLCA5eC5cblxuVW5pS2V5IHJcdTFFQTV0IGdcdTFFQ0RuIG5oXHUxRUI5LCBraFx1MDBGNG5nIGNcdTFFQTduIGNcdTAwRTBpIFx1MDExMVx1MUVCN3QuXG5cbmAiLCAiXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IExpbmssIHVzZUxvYWRlckRhdGEgfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IHR5cGUgeyBMb2FkZXJGdW5jdGlvbiwgTWV0YUZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCBnZXRQYWdlRGF0YSBmcm9tIFwifi91dGlscy9nZXRQYWdlRGF0YVwiXG5pbXBvcnQgeyBsaW51eF9tZHggfSBmcm9tIFwifi9jb250ZW50L2xpbnV4Lm1kLmpzXCJcbmltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbmltcG9ydCB7IHBhZ2VNb3Rpb24gfSBmcm9tIFwifi91dGlscy9tb3Rpb25WYXJpYW50c1wiXG5cbmV4cG9ydCBjb25zdCBoYW5kbGUgPSB7XG5cdGJyZWFkY3J1bWI6ICgpID0+IDxMaW5rIHRvPVwiL2xpbnV4XCI+VW5pS2V5IFNvZnR3YXJlIGZvciBMaW51eDwvTGluaz5cbn1cblxuZXhwb3J0IGNvbnN0IG1ldGE6IE1ldGFGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIHsgdGl0bGU6IFwiVW5pS2V5IFNvZnR3YXJlIGZvciBMaW51eCB8IFVuaWtleVwiIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxvYWRlcjogTG9hZGVyRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiBnZXRQYWdlRGF0YShsaW51eF9tZHgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbnV4UGFnZSgpIHtcblx0Y29uc3QgeyBhdHRyaWJ1dGVzLCBodG1sIH0gPSB1c2VMb2FkZXJEYXRhKClcblx0cmV0dXJuIChcblx0XHQ8bW90aW9uLmRpdiB2YXJpYW50cz17cGFnZU1vdGlvbn0gaW5pdGlhbD1cImhpZGRlblwiIGFuaW1hdGU9XCJ2aXNpYmxlXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInByb3NlIG1heC13LXNjcmVlbi1sZ1wiIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fSAvPlxuXHRcdDwvbW90aW9uLmRpdj5cblx0KVxufVxuIiwgImV4cG9ydCBjb25zdCBsaW51eF9tZHggPSBgLS0tXG50aXRsZTogVW5pS2V5IFNvZnR3YXJlIGZvciBMaW51eFxuLS0tXG4jIFVuaUtleSBTb2Z0d2FyZSBmb3IgTGludXhcblxuIyMgWC1VbmlrZXlcblxuWC1VbmlrZXkgaXMgVW5pa2V5IHBvcnRlZCB0byBMaW51eCBhbmQgRnJlZUJTRC4gWC1VbmlrZXkgbGV0cyB5b3UgdHlwZSBWaWV0bmFtZXNlIGluIFggV2luZG93IGVudmlyb25tZW50LiBJdCBoYXMgYmVlbiB0ZXN0ZWQgd2l0aCBtYW55IHBvcHVsYXIgcHJvZ3JhbXMsIHN1Y2ggYXMgT3Blbk9mZmljZSwgZW1hY3MsIHZpbSwgUVQgYXBwbGljYXRpb25zLCBHVEsgYXBwbGljYXRpb25zXHUyMDI2IFgtVW5pa2V5IGhhcyBhbGwgdGhlIGZlYXR1cmVzIG9mIHRoZSBXaW5kb3dzIHZlcnNpb24sIGV4Y2VwdCB0aGF0IGl0cyBHVUkgaXMgc3RpbGwgdG9vIHNpbXBsaWZpZWQuIEFsbCBvcHRpb25zIGFyZSBzZXQgdGhyb3VnaCBjb25maWd1cmF0aW9uIGZpbGUgb3Iga2V5Ym9hcmQgc2hvcnRjdXRzLlxuXG4jIyMgRG93bmxvYWQgWC1VbmlrZXlcblxuKiBTb3VyY2UgY29kZTogW3gtdW5pa2V5IDEuMC40XSgvKVxuXG4jIyMgWC1VbmlrZXkgVXNlciBNYW51YWwgaW4gVmlldG5hbWVzZVxuXG4oVXNlciBNYW51YWwgaW4gRW5nbGlzaCBpcyBwcm92aWRlZCBpbiB0aGUgYWJvdmUgcGFja2FnZXMpXG5cbiogW1gtVW5pa2V5IE1hbnVhbCwgSFRNTF0oLyksIGVkaXRlZCBieSBQaGFtIFRoYW5oIExvbmcuXG4qIFtYLVVuaWtleSBNYW51YWwsIFBERl0oLyksIExhVGVYIHR5cGVzZXR0aW5nIGJ5IFBoYW4gVmluaCBUaGluaC5cblxuIyMgVVZDb252ZXJ0ZXJcblxuVVZDb252ZXJ0ZXIgaXMgYSB1bml2ZXJzYWwgY29tbWFuZC1saW5lIFZpZXRuYW1lc2UgZW5jb2RpbmcgY29udmVydGVyIHdoaWNoIHN1cHBvcnRzIGFsbCBwb3B1bGFyIGNoYXJzZXRzL2VuY29kaW5ncyAoVW5pY29kZSwgVVRGOCwgVENWTjMsIFZOSVx1MjAyNikuIFVWQ29udmVydGVyIGlzIGF2YWlsYWJsZSBpbiBXaW5kb3dzLCBMaW51eCwgYW5kIE1hYyBPUyBYLlxuXG4qIFtVVkNvbnZlcnRlciAxLjEuM2IgZm9yIFdpbmRvd3MgKDEyIEtCKV0oLykuXG4qIFtVVkNvbnZlcnRlciAxLjEuM2IgLSBTb3VyY2UgY29kZV0oLykuXG5cbiMjIFgtQ2hhdCBBdXRvdm4gUGx1Z2luXG5cbkF1dG92biBpcyBhIHBsdWdpbiBmb3IgWC1DaGF0IHRoYXQgYXV0b21hdGljYWxseSBjb252ZXJ0cyBhbGwgbWVzc2FnZXMgZnJvbSBWSVFSIGVuY29kaW5nIHRvIFVURi04IGVuY29kaW5nLlxuXG4qIFtBdXRvdm4gMC4yYiAoMS8zLzIwMDQpLSBzb3VyY2UgY29kZV0oLylcblxuIyMgUGluZSBWaWV0bmFtZXNlIEhPV1RPXG5cblRoaXMgSE9XVE8gc2hvd3MgaG93IFBpbmUgY2FuIGJlIHNldHVwIHRvIHJlYWQgYW5kIHdyaXRlIFZpZXRuYW1lc2UgZW1haWxzLiBPbmUgc3BlY2lhbCBmZWF0dXJlIGlzIHRoZSBhYmlsaXR5IHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIFZJUVIgYW5kIFVuaWNvZGUgY2hhcnNldHMgYXMgeW91IHJlYWQgb3Igc2VuZCBlbWFpbHMuIEVtYWlscyByZWNlaXZlZCBpbiBWSVFSIGNoYXJzZXQgY2FuIGJlIHZpZXdlZCBhcyBpZiB0aGV5IHdlcmUgd3JpdHRlbiBpbiB1bmljb2RlIVxuXG4qIFtDbGljayBoZXJlIHRvIHJlYWRdKC8pXG5cbkFsbCBzb2Z0d2FyZSBpbiB0aGlzIHBhZ2UgYXJlIHJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UuXG5gIiwgImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGluaywgT3V0bGV0IH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB0eXBlIHsgTWV0YUZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbmltcG9ydCB7IHBhZ2VNb3Rpb24gfSBmcm9tIFwifi91dGlscy9tb3Rpb25WYXJpYW50c1wiXG5cbmV4cG9ydCBjb25zdCBoYW5kbGUgPSB7XG5cdGJyZWFkY3J1bWI6ICgpID0+IDxMaW5rIHRvPVwiL2Jsb2dcIj5CbG9nPC9MaW5rPlxufVxuXG5leHBvcnQgY29uc3QgbWV0YTogTWV0YUZ1bmN0aW9uID0gKCkgPT4ge1xuXHRyZXR1cm4geyB0aXRsZTogXCJCbG9nIHwgVW5pa2V5XCIgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCbG9nUGFnZSgpIHtcblx0cmV0dXJuIChcblx0XHQ8bW90aW9uLmRpdiBjbGFzc05hbWU9XCJwcm9zZSBtYXgtdy1zY3JlZW4tbGdcIiB2YXJpYW50cz17cGFnZU1vdGlvbn0gaW5pdGlhbD1cImhpZGRlblwiIGFuaW1hdGU9XCJ2aXNpYmxlXCI+XG5cdFx0XHQ8TGluayB0bz1cIi9ibG9nXCI+PGgxIGNsYXNzTmFtZT1cIm5vLXVuZGVybGluZVwiPkJsb2c8L2gxPjwvTGluaz5cblx0XHRcdDxPdXRsZXQgLz5cblx0XHQ8L21vdGlvbi5kaXY+XG5cdClcbn1cbiIsICJpbXBvcnQgeyBtb3Rpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IExvYWRlckZ1bmN0aW9uLCB1c2VMb2FkZXJEYXRhIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCBnZXRCbG9nRGF0YSBmcm9tIFwifi91dGlscy9nZXRCbG9nRGF0YVwiXG5pbXBvcnQgeyBwYWdlTW90aW9uIH0gZnJvbSBcIn4vdXRpbHMvbW90aW9uVmFyaWFudHNcIlxuXG5leHBvcnQgY29uc3QgaGFuZGxlID0ge1xuXHRicmVhZGNydW1iOiAoKSA9PiBcIlwiXG59XG5cbmV4cG9ydCBjb25zdCBsb2FkZXI6IExvYWRlckZ1bmN0aW9uID0gYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcblx0cmV0dXJuIGdldEJsb2dEYXRhKHBhcmFtcy5zbHVnKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCbG9nRGV0YWlscygpIHtcblx0Y29uc3QgeyBhdHRyaWJ1dGVzLCBodG1sIH0gPSB1c2VMb2FkZXJEYXRhKClcblx0cmV0dXJuIChcblx0XHQ8bW90aW9uLmRpdiB2YXJpYW50cz17cGFnZU1vdGlvbn0gaW5pdGlhbD1cImhpZGRlblwiIGFuaW1hdGU9XCJ2aXNpYmxlXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInByb3NlIG1heC13LXNjcmVlbi1sZyBwcm9zZS1hOm5vLXVuZGVybGluZSBwcm9zZS1hOnRleHQtYmx1ZS02MDAgaG92ZXI6cHJvc2UtYTp1bmRlcmxpbmVcIiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGh0bWwgfX0gLz5cblx0XHQ8L21vdGlvbi5kaXY+XG5cdClcbn1cbiIsICJpbXBvcnQgeyBtYXJrZWQgfSBmcm9tIFwibWFya2VkXCJcbmltcG9ydCBwYXJzZUZyb250TWF0dGVyIGZyb20gXCJmcm9udC1tYXR0ZXJcIlxuaW1wb3J0IHsgYmxvZ0xpc3QgfSBmcm9tIFwifi9jb250ZW50L2Jsb2cvaW5kZXguanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCbG9nRGF0YShzbHVnOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcblx0Y29uc3QgYmxvZ0l0ZW0gPSBibG9nTGlzdC5maWx0ZXIoYmxvZ0l0ZW0gPT4gYmxvZ0l0ZW0uc2x1ZyA9PT0gc2x1Zylcblx0Y29uc3QgeyBhdHRyaWJ1dGVzLCBib2R5IH0gPSBwYXJzZUZyb250TWF0dGVyKGJsb2dJdGVtWzBdLmNvbnRlbnQpXG5cdC8vY29udmVydCBtYXJrZG93biB0byBodG1sXG5cdGNvbnN0IGh0bWwgPSBtYXJrZWQucGFyc2UoYm9keSlcblx0cmV0dXJuIHsgYXR0cmlidXRlcywgaHRtbCB9XG59IiwgImltcG9ydCB7IG1kXzIwMjBfMTBfMTUgfSBmcm9tIFwiLi9tZF8yMDIwXzEwXzE1XCJcbmltcG9ydCB7IG1kXzIwMThfMDdfMTQgfSBmcm9tIFwiLi9tZF8yMDE4XzA3XzE0XCJcbmltcG9ydCB7IG1kXzIwMThfMDdfMDIgfSBmcm9tIFwiLi9tZF8yMDE4XzA3XzAyXCJcbmltcG9ydCB7IG1kXzIwMThfMDZfMjMgfSBmcm9tIFwiLi9tZF8yMDE4XzA2XzIzXCJcbmltcG9ydCB7IG1kXzIwMThfMDZfMDYgfSBmcm9tIFwiLi9tZF8yMDE4XzA2XzA2XCJcbmltcG9ydCB7IG1kXzIwMThfMDVfMzAgfSBmcm9tIFwiLi9tZF8yMDE4XzA1XzMwXCJcblxuZXhwb3J0IGNvbnN0IGJsb2dMaXN0ID0gW1xuXHR7XG5cdFx0ZGF0ZTogXCIxNSBPY3QgMjAyMFwiLFxuXHRcdHRpdGxlOiBcIlVuaUtleSA0LjMgUkM1IFJlbGVhc2VcIixcblx0XHRkZXNjcmlwdGlvbjogXCJQaFx1MDBFMXQgaFx1MDBFMG5oIGJcdTFFQTNuIDQuMyBSQzUgc1x1MUVFRGEgbVx1MUVEOXQgc1x1MUVEMSBsXHUxRUQ3aSBuaFx1MUVDRlwiLFxuXHRcdHNsdWc6IFwiVW5pS2V5LTQuMy1SQzUtUmVsZWFzZVwiLFxuXHRcdGNvbnRlbnQ6IG1kXzIwMjBfMTBfMTVcblx0fSxcblx0e1xuXHRcdGRhdGU6IFwiMTQgSnVsIDIwMThcIixcblx0XHR0aXRsZTogXCJVbmlLZXkgNC4zIFJDNCBSZWxlYXNlXCIsXG5cdFx0ZGVzY3JpcHRpb246IFwiUGhcdTAwRTF0IGhcdTAwRTBuaCBiXHUxRUEzbiA0LjMgUkM0IHNcdTFFRURhIG1cdTFFRDl0IHNcdTFFRDEgbFx1MUVEN2kgbmhcdTFFQ0ZcIixcblx0XHRzbHVnOiBcIlVuaUtleS00LjMtUkM0LVJlbGVhc2VcIixcblx0XHRjb250ZW50OiBtZF8yMDE4XzA3XzE0XG5cdH0sXG5cdHtcblx0XHRkYXRlOiBcIjAyIEp1bCAyMDE4XCIsXG5cdFx0dGl0bGU6IFwiVW5pS2V5IDQuMyBSQzMgUmVsZWFzZVwiLFxuXHRcdGRlc2NyaXB0aW9uOiBcIlBoXHUwMEUxdCBoXHUwMEUwbmggYlx1MUVBM24gNC4zIFJDMyAtIHNcdTFFRURhIGNcdTAwRTFjIGxcdTFFRDdpIHZcdTFFREJpIGJyb3dzZXJzIChDaHJvbWUsIEVkZ2UsIEZpcmVmb3gpIHZcdTAwRTAgRXhjZWxcIixcblx0XHRzbHVnOiBcIlVuaUtleS00LjMtUkMzLVJlbGVhc2VcIixcblx0XHRjb250ZW50OiBtZF8yMDE4XzA3XzAyXG5cdH0sXG5cdHtcblx0XHRkYXRlOiBcIjIzIEp1biAyMDE4XCIsXG5cdFx0dGl0bGU6IFwiVW5pS2V5IDQuMyBSZWxlYXNlXCIsXG5cdFx0ZGVzY3JpcHRpb246IFwiUGhcdTAwRTF0IGhcdTAwRTBuaCBiXHUxRUEzbiA0LjMgUkMxIHZcdTFFREJpIG5oXHUxRUVGbmcgY1x1MUVBRHAgbmhcdTFFQUR0IHF1YW4gdHJcdTFFQ0RuZ1wiLFxuXHRcdHNsdWc6IFwiVW5pS2V5LTQuMy1SZWxlYXNlXCIsXG5cdFx0Y29udGVudDogbWRfMjAxOF8wNl8yM1xuXHR9LFxuXHR7XG5cdFx0ZGF0ZTogXCIwOSBKdW4gMjAxOFwiLFxuXHRcdHRpdGxlOiBcIlRcdTFFRjEgXHUwMTExXHUxRUQ5bmcgY2hcdTFFQTF5IFVuaUtleSB2XHUxRURCaSBxdXlcdTFFQzFuIGFkbWluXCIsXG5cdFx0ZGVzY3JpcHRpb246IFwiQ1x1MDBFMWMgYlx1MDFCMFx1MUVEQmMgXHUwMTExXHUxRUMzIGNoXHUxRUExeSBVbmlLZXkgdlx1MUVEQmkgcXV5XHUxRUMxbiBhZG1pbmlzdHJhdG9yIGJcdTFFQjFuZyBjXHUwMEUxY2ggZFx1MDBGOW5nIFRhc2sgU2NoZWR1bGVyXCIsXG5cdFx0c2x1ZzogXCJ0dS1kb25nLWNoYXktVW5pa2V5LXZvaS1xdXllbi1hZG1pblwiLFxuXHRcdGNvbnRlbnQ6IG1kXzIwMThfMDZfMDZcblx0fSxcblx0e1xuXHRcdGRhdGU6IFwiMzAgTWF5IDIwMThcIixcblx0XHR0aXRsZTogXCJDaFx1MUVFOW5nIHRoXHUxRUYxYyBVbmlLZXlcIixcblx0XHRkZXNjcmlwdGlvbjogXCJLXHUxRUMzIHRcdTFFRUIgcGhpXHUwMEVBbiBiXHUxRUEzbiA0LjMgUkMxLCBjXHUwMEUxYyBiXHUxRUEzbiByZWxlYXNlIGNcdTFFRTdhIFVuaUtleSBcdTAxMTFcdTAxQjBcdTFFRTNjIGdcdTFFQUZuIGNoXHUxRUU5bmcgdGhcdTFFRjFjIGNoXHUxRUVGIGtcdTAwRkQgc1x1MUVEMS5cIixcblx0XHRzbHVnOiBcImNodW5nLXRodWMtVW5pS2V5XCIsXG5cdFx0Y29udGVudDogbWRfMjAxOF8wNV8zMFxuXHR9LFxuXSIsICJleHBvcnQgY29uc3QgbWRfMjAyMF8xMF8xNSA9IGAtLS1cbnRpdGxlOiBibG9nMS1ibG9nLTFibG9nXG4tLS1cbiMjIFVuaUtleSA0LjMgUkM1IFJlbGVhc2VcblxuKiBOZ1x1MDBFMHkgMTUvMTAvMjAyMDogUGhcdTAwRTF0IGhcdTAwRTBuaCBiXHUxRUEzbiA0LjMgUkM1IHNcdTFFRURhIG1cdTFFRDl0IHNcdTFFRDEgbFx1MUVEN2kgbmhcdTFFQ0YuXG4qIFRoXHUwMEVBbSB0XHUwMEY5eSBjaFx1MUVDRG4gYlx1MUVBRHQvdFx1MUVBRnQgdGlcdTFFQkZuZyBraGkgY2h1eVx1MUVDM24gbmdcdTAwRjRuIG5nXHUxRUVGLlxuXG5UXHUwMUIwXHUwMUExbmcgdGhcdTAwRURjaCB0XHUxRUQxdCBoXHUwMUExbiB2XHUxRURCaSB0clx1MDBFQ25oIGR1eVx1MUVDN3QgRWRnZSBtXHUxRURCaSBjXHUxRUU3YSBXaW5kb3dzLlxuXG5bRG93bmxvYWQgVW5pS2V5IDQuMyBSQzVdKC8pXG5gIiwgImV4cG9ydCBjb25zdCBtZF8yMDE4XzA3XzE0ID0gYC0tLVxudGl0bGU6IGJsb2cxLWJsb2ctMWJsb2dcbi0tLVxuIyMgVW5pS2V5IDQuMyBSQzQgUmVsZWFzZVxuXG5OZ1x1MDBFMHkgMTQvNy8yMDE4OiBQaFx1MDBFMXQgaFx1MDBFMG5oIGJcdTFFQTNuIDQuMyBSQzQgc1x1MUVFRGEgbVx1MUVEOXQgc1x1MUVEMSBsXHUxRUQ3aSBuaFx1MUVDRi5cblxuKiBTXHUxRUVEYSBsXHUxRUQ3aSBraFx1MDBGNG5nIGdcdTAwRjUgXHUwMTExXHUwMUIwXHUxRUUzYyB0cm9uZyBtXHUxRUQ5dCBzXHUxRUQxIFx1MUVFOW5nIGRcdTFFRTVuZyAoY29uc29sZSwgZ2FtZXMsIFVXUCBVbml2ZXJzYWwgV2luZG93cyBQbGF0Zm9ybSkuXG4qIFNcdTFFRURhIGxcdTFFRDdpIGtoXHUwMEY0bmcgeFx1MDBGM2EvdGhheSBoXHUxRUJGdCBjaFx1MUVFRiB0cm9uZyBPcGVyYSAoXHUwMTExXHUwMEUzIHNcdTFFRURhIGxcdTFFRDdpIG5cdTAwRTB5IGNobyBFeGNlbCwgQ2hyb21lLCBGaXJlZm94LCBFZGdlLCBJRSB0XHUxRUVCIGJcdTFFQTNuIFJDMykuXG5cbltEb3dubG9hZCBVbmlLZXkgNC4zIFJDNF0oLylcbmAiLCAiZXhwb3J0IGNvbnN0IG1kXzIwMThfMDdfMDIgPSBgLS0tXG50aXRsZTogYmxvZzEtYmxvZy0xYmxvZ1xuLS0tXG4jIyBVbmlLZXkgNC4zIFJDMyBSZWxlYXNlXG5cbk5nXHUwMEUweSAyLzcvMjAxODogUGhcdTAwRTF0IGhcdTAwRTBuaCBiXHUxRUEzbiA0LjMgUkMzIC0gc1x1MUVFRGEgY1x1MDBFMWMgbFx1MUVEN2kgdlx1MUVEQmkgYnJvd3NlcnMgKENocm9tZSwgRWRnZSwgRmlyZWZveCkgdlx1MDBFMCBFeGNlbC5cblxuXHUwMTEwXHUwMEUzIHNcdTFFRURhIFx1MDExMVx1MDFCMFx1MUVFM2MgbFx1MUVEN2kga2hcdTAwRjRuZyB4XHUwMEYzYS90aGF5IGhcdTFFQkZ0IGNoXHUxRUVGIGtoaSBjXHUwMEYzIHRcdTFFRUIgZ1x1MUVFM2kgXHUwMEZEIHRyb25nIHRyb25nIGNcdTAwRTFjIGNoXHUwMUIwXHUwMUExbmcgdHJcdTAwRUNuaDpcblxuKiBbc2FuZ10gKyBbc10gPSBbc2FcdTAwRTFuZ11cbiogXHUwMTEwXHUwMEUzIHNcdTFFRURhIGhvXHUwMEUwbiB0b1x1MDBFMG4gY2hvIEV4Y2VsLCBDaHJvbWUsIEZpcmVmb3gsIEVkZ2UsIEludGVybmV0IEV4cGxvcmVyLlxuXG5DaFx1MDBGQSBcdTAwRkQ6IEJcdTFFQTNuIDQuMyBSQzIgcGhcdTAwRTF0IGhcdTAwRTBuaCBuZ1x1MDBFMHkgMS83LzIwMTggY1x1MDBGMyBsXHUxRUQ3aSBraFx1MDBGNG5nIGdcdTAwRjUgXHUwMTExXHUwMUIwXHUxRUUzYyB0cm9uZyBFZGdlLiBCXHUxRUEzbiA0LjMgUkMzIFx1MDExMVx1MDBFMyBraFx1MUVBRmMgcGhcdTFFRTVjIGxcdTFFRDdpIG5cdTAwRTB5LlxuXG5bRG93bmxvYWQgVW5pS2V5IDQuMyBSQzNdKC8pXG5gIiwgImV4cG9ydCBjb25zdCBtZF8yMDE4XzA2XzIzID0gYC0tLVxudGl0bGU6IGJsb2cxLWJsb2ctMWJsb2dcbi0tLVxuIyMgVW5pS2V5IDQuMyBSZWxlYXNlXG5cbk5nXHUwMEUweSAyMy82LzIwMTg6IFBoXHUwMEUxdCBoXHUwMEUwbmggYlx1MUVBM24gNC4zIFJDMSB2XHUxRURCaSBuaFx1MUVFRm5nIGNcdTFFQURwIG5oXHUxRUFEdCBxdWFuIHRyXHUxRUNEbmcuXG5cbkdcdTFFQUZuIGNoXHUxRUVGIGtcdTAwRkQgXHUwMTExaVx1MUVDN24gdFx1MUVFRCBjXHUwMEYzIGNoXHUxRUU5bmcgdGhcdTFFRjFjIHRyb25nIGNoXHUwMUIwXHUwMUExbmcgdHJcdTAwRUNuaCBVbmlLZXlOVC5leGUuIEtcdTFFQzMgdFx1MUVFQiBwaGlcdTAwRUFuIGJcdTFFQTNuIG5cdTAwRTB5LCBjXHUwMEUxYyBiXHUxRUExbiBsdVx1MDBGNG4gY1x1MDBGMyB0aFx1MUVDMyBraVx1MUVDM20gdHJhIFx1MDExMVx1MUVDMyBjaFx1MUVBRmMgY2hcdTFFQUZuIG1cdTAwRUNuaCBkXHUwMEY5bmcgVW5pS2V5IHNcdTFFQTFjaCwga2hcdTAwRjRuZyBiXHUxRUNCIHNcdTFFRURhIFx1MDExMVx1MUVENWkuIFhlbSBoXHUwMUIwXHUxRURCbmcgZFx1MUVBQm4gdlx1MUVDMSBjaFx1MUVFOW5nIHRoXHUxRUYxYyBVbmlLZXkgdFx1MUVBMWkgXHUwMTExXHUwMEUyeS5cblxuKiBTXHUxRUVEYSBsXHUxRUQ3aSBraFx1MDBGNG5nIGdcdTAwRjUgXHUwMTExXHUwMUIwXHUxRUUzYyB0aVx1MUVCRm5nIFZpXHUxRUM3dCB0cm9uZyBtXHUxRUQ5dCBzXHUxRUQxIHRyYW5nIHdlYiB0clx1MDBFQW4gdHJcdTAwRUNuaCBkdXlcdTFFQzd0IEVkZ2UuXG4qIFNcdTFFRURhIGxcdTFFRDdpIHhcdTAwRjNhIGJcdTFFQTNuZyBnXHUwMEY1IHRcdTFFQUZ0LlxuKiBDXHUxRUEzaSB0aVx1MUVCRm4gdFx1MDBFRG5oIG5cdTAxMDNuZyBnXHUwMEY1IHRcdTFFQUZ0OlxuXHQqIFRcdTAxMDNuZyBrXHUwMEVEY2ggdGhcdTAxQjBcdTFFREJjIHRcdTFFRDFpIFx1MDExMWEgYlx1MUVBM25nIGdcdTAwRjUgdFx1MUVBRnQgbFx1MDBFQW4gODAwMCBtXHUxRUU1Yy5cblx0KiBUaFx1MDBFQW0gdFx1MDBGOXkgY2hcdTFFQ0RuIGJcdTFFQUR0L3RcdTFFQUZ0IHRcdTAwRURuaCBuXHUwMTAzbmcgdFx1MUVGMSBcdTAxMTFcdTFFRDluZyBcdTAxMTFcdTFFRDVpIGNoXHUxRUVGIGhvYS90aFx1MDFCMFx1MUVERG5nIGtoaSBnXHUwMEY1IHRcdTFFQUZ0LlxuXG5bRG93bmxvYWQgVW5pS2V5IDQuMyBSQzFdKC8pXG5gIiwgImV4cG9ydCBjb25zdCBtZF8yMDE4XzA2XzA2ID0gYC0tLVxudGl0bGU6IGJsb2cxLWJsb2ctMWJsb2dcbi0tLVxuIyNUXHUxRUYxIFx1MDExMVx1MUVEOW5nIGNoXHUxRUExeSBVbmlLZXkgdlx1MUVEQmkgcXV5XHUxRUMxbiBhZG1pblxuXG5DXHUwMEUxYyBiXHUwMUIwXHUxRURCYyBcdTAxMTFcdTFFQzMgY2hcdTFFQTF5IFVuaUtleSB2XHUxRURCaSBxdXlcdTFFQzFuIGFkbWluaXN0cmF0b3IgYlx1MUVCMW5nIGNcdTAwRTFjaCBkXHUwMEY5bmcgVGFzayBTY2hlZHVsZXJcblxuMS4gVFx1MUVBRnQgXHUyMDFDS2hcdTFFREZpIFx1MDExMVx1MUVEOW5nIGNcdTAwRjluZyBXaW5kb3dzXHUyMDFEIHRyb25nIFVuaUtleS4gU2F1IFx1MDExMVx1MDBGMyB0XHUxRUFGdCBVbmlLZXkuXG4yLiBDaFx1MUVBMXkgVGFzayBTY2hlZHVsZXIgKGJcdTFFQTVtIG5cdTAwRkF0IFN0YXJ0LCBzYXUgXHUwMTExXHUwMEYzIGdcdTAwRjUgVGFzayBTY2hlZHVsZXIpLlxuMy4gVFx1MUVBMW8gYmFzaWMgdGFzayB2XHUxRURCaSBjXHUwMEUxYyBsXHUxRUYxYSBjaFx1MUVDRG4gc2F1OlxuXHQqIFRyaWdnZXI6IFdoZW4gSSBsb2cgb25cblx0KiBBY3Rpb246IFN0YXJ0IGEgcHJvZ3JhbS4gU2F1IFx1MDExMVx1MDBGMyBjaFx1MUVDRG4gXHUwMTExXHUwMUIwXHUxRUREbmcgZFx1MUVBQm4gXHUwMTExXHUxRUJGbiBVbmlLZXlOVC5leGVcblx0KiBGaW5pc2guIFNhdSBcdTAxMTFcdTAwRjMgY2hcdTFFQ0RuIHRpXHUxRUJGcCBQcm9wZXJ0aWVzIGNcdTFFRTdhIFRhc2sgXHUwMTExXHUxRUMzIHRoXHUwMEVBbSBjXHUwMEUxYyB0aFx1MDBGNG5nIHNcdTFFRDEgc2F1OlxuXHQqIEdlbmVyYWw6IFJ1biB3aXRoIGhpZ2hlc3QgcHJpdmlsZWdlcy5cblx0KiBUcmlnZ2VycyAtIEVkaXQ6IENoXHUxRUNEbiBcdTIwMUNEZWxheSB0YXNrIGZvcjogMzAgc2Vjb25kc1x1MjAxRCAoTlx1MUVCRnUga2hcdTAwRjRuZyBjaFx1MUVDRG4gcGhcdTFFQTduIG5cdTAwRTB5IHRoXHUwMEVDIFVuaUtleSBzXHUxRUJEIFx1MDExMVx1MDFCMFx1MUVFM2Mga2hcdTFFREZpIFx1MDExMVx1MUVEOW5nIG1cdTAwRTAga2hcdTAwRjRuZyBjXHUwMEYzIGljb24gXHUxRURGIGdcdTAwRjNjKS5cblx0KiBDb25kaXRpb246IE5cdTFFQkZ1IGxcdTAwRTAgbVx1MDBFMXkgbGFwdG9wIHRoXHUwMEVDIEJcdTFFQ0UgbFx1MUVGMWEgY2hcdTFFQ0RuIFx1MjAxQ1N0YXJ0IHRoZSB0YXNrIG9ubHkgaWYgdGhlIGNvbXB1dGVyIGlzIG9uIEFDIHBvd2VyXHUyMDFELlxuXG5Mb2dvdXQsIHNhdSBcdTAxMTFcdTAwRjMgbG9naW4sIFVuaUtleSBzXHUxRUJEIFx1MDExMVx1MDFCMFx1MUVFM2MgY2hcdTFFQTF5IHZcdTFFREJpIHF1eVx1MUVDMW4gYWRtaW4gMzAgZ2lcdTAwRTJ5IHNhdSBraGkgbG9naW4uXG5gIiwgImV4cG9ydCBjb25zdCBtZF8yMDE4XzA1XzMwID0gYC0tLVxudGl0bGU6IGJsb2cxLWJsb2ctMWJsb2dcbi0tLVxuIyMgQ2hcdTFFRTluZyB0aFx1MUVGMWMgVW5pS2V5XG5cbktcdTFFQzMgdFx1MUVFQiBwaGlcdTAwRUFuIGJcdTFFQTNuIDQuMyBSQzEsIGNcdTAwRTFjIGJcdTFFQTNuIHJlbGVhc2UgY1x1MUVFN2EgVW5pS2V5IFx1MDExMVx1MDFCMFx1MUVFM2MgZ1x1MUVBRm4gY2hcdTFFRTluZyB0aFx1MUVGMWMgY2hcdTFFRUYga1x1MDBGRCBzXHUxRUQxLlxuXG5DaFx1MUVFRiBrXHUwMEZEIHNcdTFFRDEgc1x1MUVCRCBnaVx1MDBGQXA6XG5cbiogVW5pS2V5IGtoXHUwMEY0bmcgYlx1MUVDQiBoXHUxRUM3IHRoXHUxRUQxbmcga2lcdTFFQzNtIHRyYSBXaW5kb3dzIERlZmVuZGVyIFNtYXJ0U2NyZWVuIGNcdTFFQTNuaCBiXHUwMEUxbyBuaFx1MUVBN20gbFx1MDBFMCBwaFx1MUVBN24gbVx1MUVDMW0gXHUwMTExXHUxRUQ5YyBoXHUxRUExaS5cbiogQlx1MUVBMW4gbHVcdTAwRjRuIGNcdTAwRjMgdGhcdTFFQzMga2lcdTFFQzNtIHRyYSBcdTAxMTFcdTFFQzMgY1x1MDBGMyB0aFx1MUVDMyBjaFx1MUVBRmMgY2hcdTFFQUZuIGNoXHUwMUIwXHUwMUExbmcgdHJcdTAwRUNuaCBcdTAxMTFcdTAwRkFuZyBsXHUwMEUwIGRvIHRcdTAwRTFjIGdpXHUxRUEzIFBoXHUxRUExbSBLaW0gTG9uZyBjdW5nIGNcdTFFQTVwIHZcdTAwRTAga2hcdTAwRjRuZyBiXHUxRUNCIHRoYXkgXHUwMTExXHUxRUQ1aS5cblxuIyNDXHUxRUEzbmggYlx1MDBFMW8gU21hcnRTY3JlZW4gY1x1MUVFN2EgV2luZG93cyBEZWZlbmRlclxuXG5NXHUxRUI3YyBkXHUwMEY5IFVuaUtleSBcdTAxMTFcdTAwRTMgXHUwMTExXHUwMUIwXHUxRUUzYyBnXHUxRUFGbiBjaFx1MUVFRiBrXHUwMEZEIHNcdTFFRDEsIG1cdTFFRDdpIGtoaSBtXHUxRUQ5dCBwaGlcdTAwRUFuIGJcdTFFQTNuIFVuaUtleSBtXHUxRURCaSBcdTAxMTFcdTAxQjBcdTFFRTNjIGNcdTAwRjRuZyBiXHUxRUQxIGNoXHUwMUIwYSBsXHUwMEUydSwgYlx1MUVBMW4gdlx1MUVBQm4gY1x1MDBGMyB0aFx1MUVDMyBnXHUxRUI3cCBjXHUxRUEzbmggYlx1MDBFMW8gU21hcnRTY3JlZW4ga2hpIGNoXHUxRUExeSBVbmlLZXkgbmhcdTAxQjAgc2F1OlxuXG4hW3NtYXJ0c2NyZWVuXSgvaW1nL2NlcnRpZmljYXRlL3NtYXJ0c2NyZWVuLnBuZylcblxuS2hpIGdcdTFFQjdwIG1cdTAwRTBuIGhcdTAwRUNuaCB0clx1MDBFQW4sIGJcdTFFQTFuIGJcdTFFQTVtIHZcdTAwRTBvIG5cdTAwRkF0IFx1MjAxQ01vcmUgSW5mb1x1MjAxRCBuaFx1MDFCMCBoXHUwMEVDbmggdHJcdTAwRUFuLiBLaGkgXHUwMTExXHUwMEYzIFNtYXJ0U2NyZWVuIHNcdTFFQkQgaGlcdTFFQzduIFx1MDExMVx1MUVBN3kgXHUwMTExXHUxRUU3IHRoXHUwMEY0bmcgdGluIHh1XHUxRUE1dCB4XHUxRUU5IGNcdTFFRTdhIFVuaUtleSBuaFx1MDFCMCBzYXU6XG5cbiFbc21hcnRzY3JlZW4tb2tdKC9pbWcvY2VydGlmaWNhdGUvc21hcnRzY3JlZW4tb2sucG5nKVxuXG5OXHUxRUJGdSBiXHUxRUExbiB0aFx1MUVBNXkgZFx1MDBGMm5nIGNoXHUxRUVGICoqUHVibGlzaGVyOiBQSEFNIEtJTSBMT05HKiosIHRcdTFFRTljIGxcdTAwRTAgYlx1MUVBMW4gXHUwMTExYW5nIGRcdTAwRjluZyBiXHUxRUEzbiBVbmlLZXkgc1x1MUVBMWNoLCB4dVx1MUVBNXQgcGhcdTAwRTF0IHRcdTFFRUIgdFx1MDBFMWMgZ2lcdTFFQTMuXG5cbk5cdTFFQkZ1IGJcdTFFQTFuIHRoXHUxRUE1eSBkXHUwMEYybmcgY2hcdTFFRUYgKipQdWJsaXNoZXI6IFVua25vd24gcHVibGlzaGVyKiogbmhcdTAxQjAgZFx1MDFCMFx1MUVEQmkgXHUwMTExXHUwMEUyeSB0aFx1MDBFQyBcdTAxMTFcdTFFRUJuZyBzXHUxRUVEIGRcdTFFRTVuZywgdlx1MDBFQyBcdTAxMTFcdTAwRjMgclx1MUVBNXQgY1x1MDBGMyB0aFx1MUVDMyBsXHUwMEUwIG1cdTFFRDl0IHBoaVx1MDBFQW4gYlx1MUVBM24gXHUwMTExXHUwMEUzIGJcdTFFQ0IgY1x1MDBFMGkgbVx1MDBFMyBcdTAxMTFcdTFFRDljLCBob1x1MUVCN2MgbFx1MDBFMCBtXHUxRUQ5dCBjaFx1MDFCMFx1MDFBMW5nIHRyXHUwMEVDbmgga2hcdTAwRjRuZyByXHUwMEY1IG5ndVx1MUVEM24gZ1x1MUVEMWMuXG5cbiFbc21hcnRzY3JlZW4tdW5rbm93bl0oL2ltZy9jZXJ0aWZpY2F0ZS9zbWFydHNjcmVlbi11bmtub3duLnBuZylcblxuKipMXHUwMUIwdSBcdTAwRkQqKlxuXG5WXHUxRURCaSBtXHUxRUQ3aSBiXHUxRUEzbiBVbmlLZXkgY1x1MDBGMyBnXHUxRUFGbiBjaFx1MUVFOW5nIHRoXHUxRUYxYyBjaFx1MUVFRiBrXHUwMEZEIHNcdTFFRDEsIHNhdSBraGkgY1x1MDBGMyBzXHUxRUQxIGxcdTAxQjBcdTFFRTN0IGRvd25sb2FkIFx1MDExMVx1MUVFNyBsXHUxRURCbiwgV2luZG93cyBzXHUxRUJEIGdoaSBuaFx1MUVBRG4gdlx1MDBFMCBcdTIwMUNuaFx1MUVEQlx1MjAxRCBwaGlcdTAwRUFuIGJcdTFFQTNuIHNcdTFFQTFjaCBjXHUxRUU3YSBVbmlLZXkgdlx1MDBFMCBzXHUxRUJEIGtoXHUwMEY0bmcgaGlcdTFFQzduIGNcdTFFQTNuaCBiXHUwMEUxbyBjXHUxRUU3YSBTbWFydFNjcmVlbiBuaFx1MDFCMCBcdTFFREYgdHJcdTAwRUFuIG5cdTFFRUZhICh2XHUxRURCaSBcdTAxMTFpXHUxRUMxdSBraVx1MUVDN24gYlx1MUVBM24gZG93bmxvYWQgbFx1MDBFMCBuZ3V5XHUwMEVBbiBiXHUxRUEzbiwga2hcdTAwRjRuZyBiXHUxRUNCIGFpIGtoXHUwMEUxYyB0aGF5IFx1MDExMVx1MUVENWkpLiBOXHUxRUJGdSBraFx1MDBGNG5nIGdcdTFFQjdwIGNcdTFFQTNuaCBiXHUwMEUxbywgY1x1MDBFMWMgYlx1MUVBMW4gY1x1MDBGMyB0aFx1MUVDMyB5XHUwMEVBbiB0XHUwMEUybSBzXHUxRUVEIGRcdTFFRTVuZyBVbmlLZXkuXG5cbiMjIENcdTAwRTFjaCBraVx1MUVDM20gdHJhIGNoXHUxRUU5bmcgdGhcdTFFRjFjIGNoXHUxRUVGIGtcdTAwRkQgc1x1MUVEMSBjXHUxRUU3YSBVbmlLZXlcblxuXHUwMTEwXHUxRUMzIGtpXHUxRUMzbSBjaFx1MUVFOW5nIFVuaUtleSB4dVx1MUVBNXQgcGhcdTAwRTF0IHRcdTFFRUIgdFx1MDBFMWMgZ2lcdTFFQTMsIGtoXHUwMEY0bmcgYlx1MUVDQiBzXHUxRUVEYSBcdTAxMTFcdTFFRDVpLCBjXHUwMEUxYyBiXHUxRUExbiBsXHUwMEUwbSBuaFx1MDFCMCBzYXU6XG5cbiogVHJvbmcgV2luZG93cyBFeHBsb3JlciwgYlx1MUVBNW0gY2h1XHUxRUQ5dCBwaFx1MUVBM2kgdlx1MDBFMG8gZmlsZSBVbmlLZXlOVC5leGUsIGNoXHUxRUNEbiBQcm9wZXJ0aWVzLCBzYXUgXHUwMTExXHUwMEYzIGNoXHUxRUNEbiB0YWIgRGlnaXRhbCBTaWduYXR1cmVzLlxuXG5cdCFbcHJvcGVydGllczFdKC9pbWcvY2VydGlmaWNhdGUvcHJvcGVydGllcy0xLnBuZylcblxuKiBCXHUxRUE1bSB2XHUwMEUwbyBuXHUwMEZBdCBEZXRhaWxzOlxuXG5cdCFbcHJvcGVydGllczJdKC9pbWcvY2VydGlmaWNhdGUvcHJvcGVydGllcy0yLnBuZylcblxuKiBCXHUxRUE1bSB2XHUwMEUwbyBuXHUwMEZBdCBWaWV3IENlcnRpZmljYXRlOlxuXG5cdCFbcHJvcGVydGllczNdKC9pbWcvY2VydGlmaWNhdGUvcHJvcGVydGllcy0zLnBuZylcblxuYCIsICJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IExpbmsgfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IHsgYmxvZ0xpc3QgfSBmcm9tIFwifi9jb250ZW50L2Jsb2cvaW5kZXguanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCbG9nUGFnZUluZGV4KCkge1xuXHRyZXR1cm4gKFxuXHRcdDw+XG5cdFx0XHQ8dWw+XG5cdFx0XHRcdHtibG9nTGlzdC5tYXAoYmxvZ0l0ZW0gPT4gKFxuXHRcdFx0XHRcdDxsaSBrZXk9e2Jsb2dJdGVtLnNsdWd9PlxuXHRcdFx0XHRcdFx0PExpbmsgdG89e2AvYmxvZy8ke2Jsb2dJdGVtLnNsdWd9YH0+e2Jsb2dJdGVtLnRpdGxlfTwvTGluaz5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImJsb2NrXCI+XG5cdFx0XHRcdFx0XHRcdHtibG9nSXRlbS5kZXNjcmlwdGlvbn1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQpKX1cblx0XHRcdDwvdWw+XG5cdFx0PC8+XG5cdClcbn1cbiIsICJleHBvcnQgZGVmYXVsdCB7J3ZlcnNpb24nOic2YzAyYzk5NycsJ2VudHJ5Jzp7J21vZHVsZSc6Jy9idWlsZC9lbnRyeS5jbGllbnQtVFkyNU0zRTYuanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLTZISTJJTjQ0LmpzJ119LCdyb3V0ZXMnOnsncm9vdCc6eydpZCc6J3Jvb3QnLCdwYXJlbnRJZCc6dW5kZWZpbmVkLCdwYXRoJzonJywnaW5kZXgnOnVuZGVmaW5lZCwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm9vdC1YUzdaTUJZQS5qcycsJ2ltcG9ydHMnOnVuZGVmaW5lZCwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzpmYWxzZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6dHJ1ZSwnaGFzRXJyb3JCb3VuZGFyeSc6dHJ1ZX0sJ3JvdXRlcy9hYm91dCc6eydpZCc6J3JvdXRlcy9hYm91dCcsJ3BhcmVudElkJzoncm9vdCcsJ3BhdGgnOidhYm91dCcsJ2luZGV4Jzp1bmRlZmluZWQsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9hYm91dC01U1AzVUdONS5qcycsJ2ltcG9ydHMnOlsnL2J1aWxkL19zaGFyZWQvY2h1bmstV0JJVEFNWkIuanMnXSwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzp0cnVlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvYXBwbGUnOnsnaWQnOidyb3V0ZXMvYXBwbGUnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzonYXBwbGUnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvYXBwbGUtS0RWSEtBU0MuanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLVdCSVRBTVpCLmpzJ10sJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6dHJ1ZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6ZmFsc2UsJ2hhc0Vycm9yQm91bmRhcnknOmZhbHNlfSwncm91dGVzL2Jsb2cnOnsnaWQnOidyb3V0ZXMvYmxvZycsJ3BhcmVudElkJzoncm9vdCcsJ3BhdGgnOidibG9nJywnaW5kZXgnOnVuZGVmaW5lZCwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm91dGVzL2Jsb2ctRVdQUDJUNkYuanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLVdCSVRBTVpCLmpzJ10sJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6ZmFsc2UsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX0sJ3JvdXRlcy9ibG9nLyRzbHVnJzp7J2lkJzoncm91dGVzL2Jsb2cvJHNsdWcnLCdwYXJlbnRJZCc6J3JvdXRlcy9ibG9nJywncGF0aCc6JzpzbHVnJywnaW5kZXgnOnVuZGVmaW5lZCwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm91dGVzL2Jsb2cvJHNsdWctUTZPQ0NWRkUuanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6dHJ1ZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6ZmFsc2UsJ2hhc0Vycm9yQm91bmRhcnknOmZhbHNlfSwncm91dGVzL2Jsb2cvaW5kZXgnOnsnaWQnOidyb3V0ZXMvYmxvZy9pbmRleCcsJ3BhcmVudElkJzoncm91dGVzL2Jsb2cnLCdwYXRoJzp1bmRlZmluZWQsJ2luZGV4Jzp0cnVlLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvYmxvZy9pbmRleC1LM1hQRkQ1TS5qcycsJ2ltcG9ydHMnOnVuZGVmaW5lZCwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzpmYWxzZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6ZmFsc2UsJ2hhc0Vycm9yQm91bmRhcnknOmZhbHNlfSwncm91dGVzL2Rvd25sb2FkJzp7J2lkJzoncm91dGVzL2Rvd25sb2FkJywncGFyZW50SWQnOidyb290JywncGF0aCc6J2Rvd25sb2FkJywnaW5kZXgnOnVuZGVmaW5lZCwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm91dGVzL2Rvd25sb2FkLVpJV1NKS1JOLmpzJywnaW1wb3J0cyc6WycvYnVpbGQvX3NoYXJlZC9jaHVuay1XQklUQU1aQi5qcyddLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOnRydWUsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX0sJ3JvdXRlcy9pbmRleCc6eydpZCc6J3JvdXRlcy9pbmRleCcsJ3BhcmVudElkJzoncm9vdCcsJ3BhdGgnOnVuZGVmaW5lZCwnaW5kZXgnOnRydWUsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9pbmRleC1XMk5NWVJPQS5qcycsJ2ltcG9ydHMnOlsnL2J1aWxkL19zaGFyZWQvY2h1bmstV0JJVEFNWkIuanMnXSwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzp0cnVlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvbGludXgnOnsnaWQnOidyb3V0ZXMvbGludXgnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzonbGludXgnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvbGludXgtTlNGVkZRTEwuanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLVdCSVRBTVpCLmpzJ10sJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6dHJ1ZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6ZmFsc2UsJ2hhc0Vycm9yQm91bmRhcnknOmZhbHNlfSwncm91dGVzL3NvdXJjZSc6eydpZCc6J3JvdXRlcy9zb3VyY2UnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzonc291cmNlJywnaW5kZXgnOnVuZGVmaW5lZCwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm91dGVzL3NvdXJjZS1KSlpFSVE2SS5qcycsJ2ltcG9ydHMnOlsnL2J1aWxkL19zaGFyZWQvY2h1bmstV0JJVEFNWkIuanMnXSwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzp0cnVlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvc3VwcG9ydCc6eydpZCc6J3JvdXRlcy9zdXBwb3J0JywncGFyZW50SWQnOidyb290JywncGF0aCc6J3N1cHBvcnQnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvc3VwcG9ydC1SM0tHUVRJVi5qcycsJ2ltcG9ydHMnOlsnL2J1aWxkL19zaGFyZWQvY2h1bmstV0JJVEFNWkIuanMnXSwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzp0cnVlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9fSwndXJsJzonL2J1aWxkL21hbmlmZXN0LTZDMDJDOTk3LmpzJ307Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQU1BO0FBRUEsUUFBSSx3QkFBd0IsT0FBTztBQUNuQyxRQUFJLGtC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LGFBQWE7QUFBQSxVQUNiLGdCQUFnQjtBQUFBLFVBQ2hCLFlBQVk7QUFBQSxVQUNaLGFBQWE7QUFBQSxVQUNiLFNBQVM7QUFBQSxVQUNULFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLFVBQVU7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULFdBQVc7QUFBQSxVQUNYLGNBQWM7QUFBQSxVQUNkLE1BQU07QUFBQSxVQUNOLElBQUk7QUFBQSxVQUNKLFdBQVc7QUFBQSxVQUNYLFdBQVc7QUFBQSxVQUNYLFdBQVc7QUFBQSxVQUNYLElBQUk7QUFBQSxVQUNKLFFBQVE7QUFBQSxVQUNSLFVBQVU7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULFdBQVc7QUFBQSxVQUNYLFVBQVU7QUFBQSxVQUNWLFdBQVc7QUFBQSxVQUNYLFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLEtBQUs7QUFBQSxVQUNMLFVBQVU7QUFBQSxVQUNWLGFBQWE7QUFBQSxVQUNiLGNBQWM7QUFBQSxVQUNkLEtBQUs7QUFBQSxVQUNMLFdBQVc7QUFBQSxVQUNYLE9BQU87QUFBQSxVQUNQLFlBQVk7QUFBQSxVQUNaLFFBQVE7QUFBQSxVQUNSLEtBQUs7QUFBQSxVQUNMLFdBQVc7QUFBQSxVQUNYLFVBQVU7QUFBQSxVQUNWLE9BQU87QUFBQSxVQUNQLE1BQU07QUFBQSxVQUNOLFVBQVU7QUFBQSxVQUNWLE9BQU87QUFBQSxVQUNQLFlBQVk7QUFBQSxVQUNaLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxVQUNULFNBQVM7QUFBQSxVQUNULGFBQWE7QUFBQSxVQUNiLGFBQWE7QUFBQSxVQUNiLFFBQVE7QUFBQSxVQUNSLFNBQVM7QUFBQSxVQUNULFNBQVM7QUFBQSxVQUNULFlBQVk7QUFBQSxVQUNaLFVBQVU7QUFBQSxVQUNWLGdCQUFnQjtBQUFBLFVBQ2hCLEtBQUs7QUFB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
