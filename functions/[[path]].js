var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    init_react();
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty2.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty2.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement7(type, config2, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            self2 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext3(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef3(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render.displayName == null) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare3) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare3 === void 0 ? null : compare3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type.displayName == null) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext4(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState4(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init2);
        }
        function useRef5(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback5(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement7.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            new Map([[frozenObject, null]]);
            new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext3;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef3;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback5;
        exports.useContext = useContext4;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect4;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect4;
        exports.useMemo = useMemo4;
        exports.useReducer = useReducer;
        exports.useRef = useRef5;
        exports.useState = useState4;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/@remix-run/dev/compiler/shims/react.ts
var React;
var init_react = __esm({
  "node_modules/@remix-run/dev/compiler/shims/react.ts"() {
    React = __toModule(require_react());
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    init_react();
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValue = parts.shift().split("=");
      var name = nameValue.shift();
      var value = nameValue.join("=");
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse;
    module.exports.parse = parse;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports, module) {
    init_react();
    "use strict";
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty2.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach2 = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase)
        return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString3 = object.toString;
    var isArray3 = Array.isArray;
    var isBuffer2 = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject2 = (value) => {
      return toString3.call(value) == "[object Object]";
    };
    var isString2 = (value) => {
      return typeof value == "string" || toString3.call(value) == "[object String]";
    };
    var isNumber2 = (value) => {
      return typeof value == "number" || toString3.call(value) == "[object Number]";
    };
    var isFunction2 = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString3.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString3.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc2 = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json2 = options && options.json;
      if (json2) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json2 && argument && isFunction2(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString2(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isBuffer2(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isArray3(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach2(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent) + jsesc2(value, options));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json2) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json2) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent) + jsesc2(key, options) + ":" + (compact ? "" : " ") + jsesc2(value, options));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal)
            return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json2 && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json2 || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc2.version = "3.0.2";
    module.exports = jsesc2;
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    init_react();
    "use strict";
    EventHandlers.prototype = Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance, performanceNow, startTime, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_react();
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_react();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_react();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    init_react();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_react();
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry2 = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry2;
      else
        this.head = entry2;
      this.tail = entry2;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry2 = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry2;
      this.head = entry2;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_react();
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    init_react();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    "use strict";
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry2;
    var count = 0;
    while (entry2) {
      buffer[count] = entry2;
      entry2 = entry2.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry2) {
      var chunk = entry2.chunk;
      var encoding = entry2.encoding;
      var cb = entry2.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry2 = entry2.next;
      if (state.writing) {
        break;
      }
    }
    if (entry2 === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry2;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry2 = _this.entry;
    _this.entry = null;
    while (entry2) {
      var cb = entry2.callback;
      state.pendingcb--;
      cb(err);
      entry2 = entry2.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_react();
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_react();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_react();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_react();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_react();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_react();
    var polyfill = (init_stream(), stream_exports);
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React8 = require_react();
        var _assign = require_object_assign();
        var stream = require_stream();
        var ReactVersion = "17.0.2";
        function formatProdErrorMessage(code) {
          var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;
          for (var i2 = 1; i2 < arguments.length; i2++) {
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
          }
          return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var enableSuspenseServerRenderer = false;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutInvalidateContextType = new Set();
        }
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function maskContext(type, context) {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        }
        function checkContextTypes(typeSpecs, values, location) {
          {
            checkPropTypes(typeSpecs, values, location, "Component");
          }
        }
        function validateContextBounds(context, threadID) {
          for (var i2 = context._threadCount | 0; i2 <= threadID; i2++) {
            context[i2] = context._currentValue2;
            context._threadCount = i2 + 1;
          }
        }
        function processContext(type, context, threadID, isClass) {
          if (isClass) {
            var contextType = type.contextType;
            {
              if ("contextType" in type) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
                  didWarnAboutInvalidateContextType.add(type);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              validateContextBounds(contextType, threadID);
              return contextType[threadID];
            }
            {
              var maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, maskedContext, "context");
                }
              }
              return maskedContext;
            }
          } else {
            {
              var _maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, _maskedContext, "context");
                }
              }
              return _maskedContext;
            }
          }
        }
        var nextAvailableThreadIDs = new Uint16Array(16);
        for (var i = 0; i < 15; i++) {
          nextAvailableThreadIDs[i] = i + 1;
        }
        nextAvailableThreadIDs[15] = 0;
        function growThreadCountAndReturnNextAvailable() {
          var oldArray = nextAvailableThreadIDs;
          var oldSize = oldArray.length;
          var newSize = oldSize * 2;
          if (!(newSize <= 65536)) {
            {
              throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
            }
          }
          var newArray = new Uint16Array(newSize);
          newArray.set(oldArray);
          nextAvailableThreadIDs = newArray;
          nextAvailableThreadIDs[0] = oldSize + 1;
          for (var _i = oldSize; _i < newSize - 1; _i++) {
            nextAvailableThreadIDs[_i] = _i + 1;
          }
          nextAvailableThreadIDs[newSize - 1] = 0;
          return oldSize;
        }
        function allocThreadID() {
          var nextID = nextAvailableThreadIDs[0];
          if (nextID === 0) {
            return growThreadCountAndReturnNextAvailable();
          }
          nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
          return nextID;
        }
        function freeThreadID(id) {
          nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
          nextAvailableThreadIDs[0] = id;
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        function quoteAttributeValueForBrowser(value) {
          return '"' + escapeTextForBrowser(value) + '"';
        }
        function createMarkupForRoot() {
          return ROOT_ATTRIBUTE_NAME + '=""';
        }
        function createMarkupForProperty(name, value) {
          var propertyInfo = getPropertyInfo(name);
          if (name !== "style" && shouldIgnoreAttribute(name, propertyInfo, false)) {
            return "";
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
            return "";
          }
          if (propertyInfo !== null) {
            var attributeName = propertyInfo.attributeName;
            var type = propertyInfo.type;
            if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
              return attributeName + '=""';
            } else {
              if (propertyInfo.sanitizeURL) {
                value = "" + value;
                sanitizeURL(value);
              }
              return attributeName + "=" + quoteAttributeValueForBrowser(value);
            }
          } else if (isAttributeNameSafe(name)) {
            return name + "=" + quoteAttributeValueForBrowser(value);
          }
          return "";
        }
        function createMarkupForCustomAttribute(name, value) {
          if (!isAttributeNameSafe(name) || value == null) {
            return "";
          }
          return name + "=" + quoteAttributeValueForBrowser(value);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (!(currentlyRenderingComponent !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
            if (objectIs(nextDeps[i2], prevDeps[i2])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            {
              {
                throw Error("Rendered more hooks than during the previous render");
              }
            }
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          {
            isInHookUserCodeInDev = false;
          }
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext(context, observedBits) {
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return context[threadID];
        }
        function useContext4(context, observedBits) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          return context[threadID];
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState4(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(basicStateReducer, initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init2 !== void 0 ? init2(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo4(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef5(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect4(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
            {
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback5(callback, deps) {
          return useMemo4(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function useTransition2() {
          resolveCurrentlyRenderingComponent();
          var startTransition = function(callback) {
            callback();
          };
          return [startTransition, false];
        }
        function useOpaqueIdentifier() {
          return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
        }
        function noop2() {
        }
        var currentPartialRenderer = null;
        function setCurrentPartialRenderer(renderer) {
          currentPartialRenderer = renderer;
        }
        var Dispatcher = {
          readContext,
          useContext: useContext4,
          useMemo: useMemo4,
          useReducer,
          useRef: useRef5,
          useState: useState4,
          useLayoutEffect: useLayoutEffect4,
          useCallback: useCallback5,
          useImperativeHandle: noop2,
          useEffect: noop2,
          useDebugValue: noop2,
          useDeferredValue,
          useTransition: useTransition2,
          useOpaqueIdentifier,
          useMutableSource
        };
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var ariaProperties = {
          "aria-current": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var toArray = React8.Children.toArray;
        var currentDebugStacks = [];
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1;
        var prevGetCurrentStackImpl = null;
        var getCurrentServerStackImpl = function() {
          return "";
        };
        var describeStackFrame = function(element) {
          return "";
        };
        var validatePropertiesInDevelopment = function(type, props) {
        };
        var pushCurrentDebugStack = function(stack) {
        };
        var pushElementToDebugStack = function(element) {
        };
        var popCurrentDebugStack = function() {
        };
        var hasWarnedAboutUsingContextAsConsumer = false;
        {
          ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
          };
          describeStackFrame = function(element) {
            return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
          };
          pushCurrentDebugStack = function(stack) {
            currentDebugStacks.push(stack);
            if (currentDebugStacks.length === 1) {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
            }
          };
          pushElementToDebugStack = function(element) {
            var stack = currentDebugStacks[currentDebugStacks.length - 1];
            var frame = stack[stack.length - 1];
            frame.debugElementStack.push(element);
          };
          popCurrentDebugStack = function() {
            currentDebugStacks.pop();
            if (currentDebugStacks.length === 0) {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              prevGetCurrentStackImpl = null;
            }
          };
          getCurrentServerStackImpl = function() {
            if (currentDebugStacks.length === 0) {
              return "";
            }
            var frames = currentDebugStacks[currentDebugStacks.length - 1];
            var stack = "";
            for (var i2 = frames.length - 1; i2 >= 0; i2--) {
              var frame = frames[i2];
              var debugElementStack = frame.debugElementStack;
              for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
                stack += describeStackFrame(debugElementStack[ii]);
              }
            }
            return stack;
          };
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUndefinedDerivedState = {};
        var didWarnAboutUninitializedState = {};
        var valuePropNames = ["value", "defaultValue"];
        var newlineEatingTags = {
          listing: true,
          pre: true,
          textarea: true
        };
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        function validateDangerousTag(tag) {
          if (!validatedTagCache.hasOwnProperty(tag)) {
            if (!VALID_TAG_REGEX.test(tag)) {
              {
                throw Error("Invalid tag: " + tag);
              }
            }
            validatedTagCache[tag] = true;
          }
        }
        var styleNameCache = {};
        var processStyleName = function(styleName) {
          if (styleNameCache.hasOwnProperty(styleName)) {
            return styleNameCache[styleName];
          }
          var result = hyphenateStyleName(styleName);
          styleNameCache[styleName] = result;
          return result;
        };
        function createMarkupForStyles(styles) {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            var styleValue = styles[styleName];
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styleValue);
              }
            }
            if (styleValue != null) {
              serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentName(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function getNonChildrenInnerMarkup(props) {
          var innerHTML = props.dangerouslySetInnerHTML;
          if (innerHTML != null) {
            if (innerHTML.__html != null) {
              return innerHTML.__html;
            }
          } else {
            var content = props.children;
            if (typeof content === "string" || typeof content === "number") {
              return escapeTextForBrowser(content);
            }
          }
          return null;
        }
        function flattenTopLevelChildren(children) {
          if (!React8.isValidElement(children)) {
            return toArray(children);
          }
          var element = children;
          if (element.type !== REACT_FRAGMENT_TYPE) {
            return [element];
          }
          var fragmentChildren = element.props.children;
          if (!React8.isValidElement(fragmentChildren)) {
            return toArray(fragmentChildren);
          }
          var fragmentChildElement = fragmentChildren;
          return [fragmentChildElement];
        }
        function flattenOptionChildren(children) {
          if (children === void 0 || children === null) {
            return children;
          }
          var content = "";
          React8.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Only strings and numbers are supported as <option> children.");
              }
            }
          });
          return content;
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var STYLE = "style";
        var RESERVED_PROPS = {
          children: null,
          dangerouslySetInnerHTML: null,
          suppressContentEditableWarning: null,
          suppressHydrationWarning: null
        };
        function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
          var ret = "<" + tagVerbatim;
          var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
          for (var propKey in props) {
            if (!hasOwnProperty$2.call(props, propKey)) {
              continue;
            }
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            if (propKey === STYLE) {
              propValue = createMarkupForStyles(propValue);
            }
            var markup = null;
            if (isCustomComponent$1) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += " " + markup;
            }
          }
          if (makeStaticMarkup) {
            return ret;
          }
          if (isRootElement) {
            ret += " " + createMarkupForRoot();
          }
          return ret;
        }
        function validateRenderResult(child, type) {
          if (child === void 0) {
            {
              {
                throw Error((getComponentName(type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
              }
            }
          }
        }
        function resolve(child, context, threadID) {
          while (React8.isValidElement(child)) {
            var element = child;
            var Component = element.type;
            {
              pushElementToDebugStack(element);
            }
            if (typeof Component !== "function") {
              break;
            }
            processChild(element, Component);
          }
          function processChild(element2, Component2) {
            var isClass = shouldConstruct$1(Component2);
            var publicContext = processContext(Component2, context, threadID, isClass);
            var queue2 = [];
            var replace = false;
            var updater = {
              isMounted: function(publicInstance) {
                return false;
              },
              enqueueForceUpdate: function(publicInstance) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "forceUpdate");
                  return null;
                }
              },
              enqueueReplaceState: function(publicInstance, completeState) {
                replace = true;
                queue2 = [completeState];
              },
              enqueueSetState: function(publicInstance, currentPartialState) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "setState");
                  return null;
                }
                queue2.push(currentPartialState);
              }
            };
            var inst;
            if (isClass) {
              inst = new Component2(element2.props, publicContext, updater);
              if (typeof Component2.getDerivedStateFromProps === "function") {
                {
                  if (inst.state === null || inst.state === void 0) {
                    var componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUninitializedState[componentName]) {
                      error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName);
                      didWarnAboutUninitializedState[componentName] = true;
                    }
                  }
                }
                var partialState = Component2.getDerivedStateFromProps.call(null, element2.props, inst.state);
                {
                  if (partialState === void 0) {
                    var _componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                      error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName);
                      didWarnAboutUndefinedDerivedState[_componentName] = true;
                    }
                  }
                }
                if (partialState != null) {
                  inst.state = _assign({}, inst.state, partialState);
                }
              }
            } else {
              {
                if (Component2.prototype && typeof Component2.prototype.render === "function") {
                  var _componentName2 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutBadClass[_componentName2]) {
                    error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2);
                    didWarnAboutBadClass[_componentName2] = true;
                  }
                }
              }
              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              inst = Component2(element2.props, publicContext, updater);
              inst = finishHooks(Component2, element2.props, inst, publicContext);
              {
                if (inst != null && inst.render != null) {
                  var _componentName3 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutModulePatternComponent[_componentName3]) {
                    error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3);
                    didWarnAboutModulePatternComponent[_componentName3] = true;
                  }
                }
              }
              if (inst == null || inst.render == null) {
                child = inst;
                validateRenderResult(child, Component2);
                return;
              }
            }
            inst.props = element2.props;
            inst.context = publicContext;
            inst.updater = updater;
            var initialState = inst.state;
            if (initialState === void 0) {
              inst.state = initialState = null;
            }
            if (typeof inst.UNSAFE_componentWillMount === "function" || typeof inst.componentWillMount === "function") {
              if (typeof inst.componentWillMount === "function") {
                {
                  if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                    var _componentName4 = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                      warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", _componentName4);
                      didWarnAboutDeprecatedWillMount[_componentName4] = true;
                    }
                  }
                }
                if (typeof Component2.getDerivedStateFromProps !== "function") {
                  inst.componentWillMount();
                }
              }
              if (typeof inst.UNSAFE_componentWillMount === "function" && typeof Component2.getDerivedStateFromProps !== "function") {
                inst.UNSAFE_componentWillMount();
              }
              if (queue2.length) {
                var oldQueue = queue2;
                var oldReplace = replace;
                queue2 = null;
                replace = false;
                if (oldReplace && oldQueue.length === 1) {
                  inst.state = oldQueue[0];
                } else {
                  var nextState = oldReplace ? oldQueue[0] : inst.state;
                  var dontMutate = true;
                  for (var i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2];
                    var _partialState = typeof partial === "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                    if (_partialState != null) {
                      if (dontMutate) {
                        dontMutate = false;
                        nextState = _assign({}, nextState, _partialState);
                      } else {
                        _assign(nextState, _partialState);
                      }
                    }
                  }
                  inst.state = nextState;
                }
              } else {
                queue2 = null;
              }
            }
            child = inst.render();
            {
              if (child === void 0 && inst.render._isMockFunction) {
                child = null;
              }
            }
            validateRenderResult(child, Component2);
            var childContext;
            {
              if (typeof inst.getChildContext === "function") {
                var _childContextTypes = Component2.childContextTypes;
                if (typeof _childContextTypes === "object") {
                  childContext = inst.getChildContext();
                  for (var contextKey in childContext) {
                    if (!(contextKey in _childContextTypes)) {
                      {
                        throw Error((getComponentName(Component2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                      }
                    }
                  }
                } else {
                  {
                    error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component2) || "Unknown");
                  }
                }
              }
              if (childContext) {
                context = _assign({}, context, childContext);
              }
            }
          }
          return {
            child,
            context
          };
        }
        var ReactDOMServerRenderer = /* @__PURE__ */ function() {
          function ReactDOMServerRenderer2(children, makeStaticMarkup, options) {
            var flatChildren = flattenTopLevelChildren(children);
            var topFrame = {
              type: null,
              domNamespace: Namespaces.html,
              children: flatChildren,
              childIndex: 0,
              context: emptyObject,
              footer: ""
            };
            {
              topFrame.debugElementStack = [];
            }
            this.threadID = allocThreadID();
            this.stack = [topFrame];
            this.exhausted = false;
            this.currentSelectValue = null;
            this.previousWasTextNode = false;
            this.makeStaticMarkup = makeStaticMarkup;
            this.suspenseDepth = 0;
            this.contextIndex = -1;
            this.contextStack = [];
            this.contextValueStack = [];
            this.uniqueID = 0;
            this.identifierPrefix = options && options.identifierPrefix || "";
            {
              this.contextProviderStack = [];
            }
          }
          var _proto = ReactDOMServerRenderer2.prototype;
          _proto.destroy = function destroy() {
            if (!this.exhausted) {
              this.exhausted = true;
              this.clearProviders();
              freeThreadID(this.threadID);
            }
          };
          _proto.pushProvider = function pushProvider(provider) {
            var index = ++this.contextIndex;
            var context = provider.type._context;
            var threadID = this.threadID;
            validateContextBounds(context, threadID);
            var previousValue = context[threadID];
            this.contextStack[index] = context;
            this.contextValueStack[index] = previousValue;
            {
              this.contextProviderStack[index] = provider;
            }
            context[threadID] = provider.props.value;
          };
          _proto.popProvider = function popProvider(provider) {
            var index = this.contextIndex;
            {
              if (index < 0 || provider !== this.contextProviderStack[index]) {
                error("Unexpected pop.");
              }
            }
            var context = this.contextStack[index];
            var previousValue = this.contextValueStack[index];
            this.contextStack[index] = null;
            this.contextValueStack[index] = null;
            {
              this.contextProviderStack[index] = null;
            }
            this.contextIndex--;
            context[this.threadID] = previousValue;
          };
          _proto.clearProviders = function clearProviders() {
            for (var index = this.contextIndex; index >= 0; index--) {
              var context = this.contextStack[index];
              var previousValue = this.contextValueStack[index];
              context[this.threadID] = previousValue;
            }
          };
          _proto.read = function read2(bytes) {
            if (this.exhausted) {
              return null;
            }
            var prevPartialRenderer = currentPartialRenderer;
            setCurrentPartialRenderer(this);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            try {
              var out = [""];
              var suspended = false;
              while (out[0].length < bytes) {
                if (this.stack.length === 0) {
                  this.exhausted = true;
                  freeThreadID(this.threadID);
                  break;
                }
                var frame = this.stack[this.stack.length - 1];
                if (suspended || frame.childIndex >= frame.children.length) {
                  var footer = frame.footer;
                  if (footer !== "") {
                    this.previousWasTextNode = false;
                  }
                  this.stack.pop();
                  if (frame.type === "select") {
                    this.currentSelectValue = null;
                  } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                    var provider = frame.type;
                    this.popProvider(provider);
                  } else if (frame.type === REACT_SUSPENSE_TYPE) {
                    this.suspenseDepth--;
                    var buffered = out.pop();
                    if (suspended) {
                      suspended = false;
                      var fallbackFrame = frame.fallbackFrame;
                      if (!fallbackFrame) {
                        {
                          throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                        }
                      }
                      this.stack.push(fallbackFrame);
                      out[this.suspenseDepth] += "<!--$!-->";
                      continue;
                    } else {
                      out[this.suspenseDepth] += buffered;
                    }
                  }
                  out[this.suspenseDepth] += footer;
                  continue;
                }
                var child = frame.children[frame.childIndex++];
                var outBuffer = "";
                if (true) {
                  pushCurrentDebugStack(this.stack);
                  frame.debugElementStack.length = 0;
                }
                try {
                  outBuffer += this.render(child, frame.context, frame.domNamespace);
                } catch (err) {
                  if (err != null && typeof err.then === "function") {
                    if (enableSuspenseServerRenderer) {
                      if (!(this.suspenseDepth > 0)) {
                        {
                          throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                        }
                      }
                      suspended = true;
                    } else {
                      if (true) {
                        {
                          throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                        }
                      }
                    }
                  } else {
                    throw err;
                  }
                } finally {
                  if (true) {
                    popCurrentDebugStack();
                  }
                }
                if (out.length <= this.suspenseDepth) {
                  out.push("");
                }
                out[this.suspenseDepth] += outBuffer;
              }
              return out[0];
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
              setCurrentPartialRenderer(prevPartialRenderer);
              resetHooksState();
            }
          };
          _proto.render = function render(child, context, parentNamespace) {
            if (typeof child === "string" || typeof child === "number") {
              var text = "" + child;
              if (text === "") {
                return "";
              }
              if (this.makeStaticMarkup) {
                return escapeTextForBrowser(text);
              }
              if (this.previousWasTextNode) {
                return "<!-- -->" + escapeTextForBrowser(text);
              }
              this.previousWasTextNode = true;
              return escapeTextForBrowser(text);
            } else {
              var nextChild;
              var _resolve = resolve(child, context, this.threadID);
              nextChild = _resolve.child;
              context = _resolve.context;
              if (nextChild === null || nextChild === false) {
                return "";
              } else if (!React8.isValidElement(nextChild)) {
                if (nextChild != null && nextChild.$$typeof != null) {
                  var $$typeof = nextChild.$$typeof;
                  if (!($$typeof !== REACT_PORTAL_TYPE)) {
                    {
                      throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                    }
                  }
                  {
                    {
                      throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                    }
                  }
                }
                var nextChildren = toArray(nextChild);
                var frame = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                {
                  frame.debugElementStack = [];
                }
                this.stack.push(frame);
                return "";
              }
              var nextElement = nextChild;
              var elementType = nextElement.type;
              if (typeof elementType === "string") {
                return this.renderDOM(nextElement, context, parentNamespace);
              }
              switch (elementType) {
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_FRAGMENT_TYPE: {
                  var _nextChildren = toArray(nextChild.props.children);
                  var _frame = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  {
                    _frame.debugElementStack = [];
                  }
                  this.stack.push(_frame);
                  return "";
                }
                case REACT_SUSPENSE_TYPE: {
                  {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support Suspense.");
                      }
                    }
                  }
                }
                case REACT_SCOPE_TYPE: {
                  {
                    {
                      throw Error("ReactDOMServer does not yet support scope components.");
                    }
                  }
                }
              }
              if (typeof elementType === "object" && elementType !== null) {
                switch (elementType.$$typeof) {
                  case REACT_FORWARD_REF_TYPE: {
                    var element = nextChild;
                    var _nextChildren5;
                    var componentIdentity = {};
                    prepareToUseHooks(componentIdentity);
                    _nextChildren5 = elementType.render(element.props, element.ref);
                    _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                    _nextChildren5 = toArray(_nextChildren5);
                    var _frame5 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren5,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame5.debugElementStack = [];
                    }
                    this.stack.push(_frame5);
                    return "";
                  }
                  case REACT_MEMO_TYPE: {
                    var _element = nextChild;
                    var _nextChildren6 = [React8.createElement(elementType.type, _assign({
                      ref: _element.ref
                    }, _element.props))];
                    var _frame6 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren6,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame6.debugElementStack = [];
                    }
                    this.stack.push(_frame6);
                    return "";
                  }
                  case REACT_PROVIDER_TYPE: {
                    var provider = nextChild;
                    var nextProps = provider.props;
                    var _nextChildren7 = toArray(nextProps.children);
                    var _frame7 = {
                      type: provider,
                      domNamespace: parentNamespace,
                      children: _nextChildren7,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame7.debugElementStack = [];
                    }
                    this.pushProvider(provider);
                    this.stack.push(_frame7);
                    return "";
                  }
                  case REACT_CONTEXT_TYPE: {
                    var reactContext = nextChild.type;
                    {
                      if (reactContext._context === void 0) {
                        if (reactContext !== reactContext.Consumer) {
                          if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                          }
                        }
                      } else {
                        reactContext = reactContext._context;
                      }
                    }
                    var _nextProps = nextChild.props;
                    var threadID = this.threadID;
                    validateContextBounds(reactContext, threadID);
                    var nextValue = reactContext[threadID];
                    var _nextChildren8 = toArray(_nextProps.children(nextValue));
                    var _frame8 = {
                      type: nextChild,
                      domNamespace: parentNamespace,
                      children: _nextChildren8,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame8.debugElementStack = [];
                    }
                    this.stack.push(_frame8);
                    return "";
                  }
                  case REACT_FUNDAMENTAL_TYPE: {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support the fundamental API.");
                      }
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var _element2 = nextChild;
                    var lazyComponent = nextChild.type;
                    var payload = lazyComponent._payload;
                    var init2 = lazyComponent._init;
                    var result = init2(payload);
                    var _nextChildren10 = [React8.createElement(result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame10 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren10,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame10.debugElementStack = [];
                    }
                    this.stack.push(_frame10);
                    return "";
                  }
                }
              }
              var info = "";
              {
                var owner = nextElement._owner;
                if (elementType === void 0 || typeof elementType === "object" && elementType !== null && Object.keys(elementType).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentName(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              {
                {
                  throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                }
              }
            }
          };
          _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
            var tag = element.type.toLowerCase();
            var namespace = parentNamespace;
            if (parentNamespace === Namespaces.html) {
              namespace = getIntrinsicNamespace(tag);
            }
            {
              if (namespace === Namespaces.html) {
                if (tag !== element.type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type);
                }
              }
            }
            validateDangerousTag(tag);
            var props = element.props;
            if (tag === "input") {
              {
                checkControlledValueProps("input", props);
                if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                  error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultChecked = true;
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                  error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultInputValue = true;
                }
              }
              props = _assign({
                type: void 0
              }, props, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: props.value != null ? props.value : props.defaultValue,
                checked: props.checked != null ? props.checked : props.defaultChecked
              });
            } else if (tag === "textarea") {
              {
                checkControlledValueProps("textarea", props);
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                  error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultTextareaValue = true;
                }
              }
              var initialValue = props.value;
              if (initialValue == null) {
                var defaultValue = props.defaultValue;
                var textareaChildren = props.children;
                if (textareaChildren != null) {
                  {
                    error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                  }
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(textareaChildren)) {
                    if (!(textareaChildren.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    textareaChildren = textareaChildren[0];
                  }
                  defaultValue = "" + textareaChildren;
                }
                if (defaultValue == null) {
                  defaultValue = "";
                }
                initialValue = defaultValue;
              }
              props = _assign({}, props, {
                value: void 0,
                children: "" + initialValue
              });
            } else if (tag === "select") {
              {
                checkControlledValueProps("select", props);
                for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                  var propName = valuePropNames[i2];
                  if (props[propName] == null) {
                    continue;
                  }
                  var isArray3 = Array.isArray(props[propName]);
                  if (props.multiple && !isArray3) {
                    error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                  } else if (!props.multiple && isArray3) {
                    error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                  }
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                  error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultSelectValue = true;
                }
              }
              this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
              props = _assign({}, props, {
                value: void 0
              });
            } else if (tag === "option") {
              var selected = null;
              var selectValue = this.currentSelectValue;
              var optionChildren = flattenOptionChildren(props.children);
              if (selectValue != null) {
                var value;
                if (props.value != null) {
                  value = props.value + "";
                } else {
                  value = optionChildren;
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                  for (var j = 0; j < selectValue.length; j++) {
                    if ("" + selectValue[j] === value) {
                      selected = true;
                      break;
                    }
                  }
                } else {
                  selected = "" + selectValue === value;
                }
                props = _assign({
                  selected: void 0,
                  children: void 0
                }, props, {
                  selected,
                  children: optionChildren
                });
              }
            }
            {
              validatePropertiesInDevelopment(tag, props);
            }
            assertValidProps(tag, props);
            var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
            var footer = "";
            if (omittedCloseTags.hasOwnProperty(tag)) {
              out += "/>";
            } else {
              out += ">";
              footer = "</" + element.type + ">";
            }
            var children;
            var innerMarkup = getNonChildrenInnerMarkup(props);
            if (innerMarkup != null) {
              children = [];
              if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === "\n") {
                out += "\n";
              }
              out += innerMarkup;
            } else {
              children = toArray(props.children);
            }
            var frame = {
              domNamespace: getChildNamespace(parentNamespace, element.type),
              type: tag,
              children,
              childIndex: 0,
              context,
              footer
            };
            {
              frame.debugElementStack = [];
            }
            this.stack.push(frame);
            this.previousWasTextNode = false;
            return out;
          };
          return ReactDOMServerRenderer2;
        }();
        function renderToString2(element, options) {
          var renderer = new ReactDOMServerRenderer(element, false, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToStaticMarkup(element, options) {
          var renderer = new ReactDOMServerRenderer(element, true, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
          _inheritsLoose(ReactMarkupReadableStream2, _Readable);
          function ReactMarkupReadableStream2(element, makeStaticMarkup, options) {
            var _this;
            _this = _Readable.call(this, {}) || this;
            _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup, options);
            return _this;
          }
          var _proto = ReactMarkupReadableStream2.prototype;
          _proto._destroy = function _destroy(err, callback) {
            this.partialRenderer.destroy();
            callback(err);
          };
          _proto._read = function _read(size) {
            try {
              this.push(this.partialRenderer.read(size));
            } catch (err) {
              this.destroy(err);
            }
          };
          return ReactMarkupReadableStream2;
        }(stream.Readable);
        function renderToNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, false, options);
        }
        function renderToStaticNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, true, options);
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString2;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_dom_server_node_development();
    }
  }
});

// node_modules/react-dom/server.js
var require_server = __commonJS({
  "node_modules/react-dom/server.js"(exports, module) {
    init_react();
    "use strict";
    module.exports = require_server_node();
  }
});

// node_modules/nprogress/nprogress.js
var require_nprogress = __commonJS({
  "node_modules/nprogress/nprogress.js"(exports, module) {
    init_react();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.NProgress = factory();
      }
    })(exports, function() {
      var NProgress2 = {};
      NProgress2.version = "0.2.0";
      var Settings = NProgress2.settings = {
        minimum: 0.08,
        easing: "ease",
        positionUsing: "",
        speed: 200,
        trickle: true,
        trickleRate: 0.02,
        trickleSpeed: 800,
        showSpinner: true,
        barSelector: '[role="bar"]',
        spinnerSelector: '[role="spinner"]',
        parent: "body",
        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
      };
      NProgress2.configure = function(options) {
        var key, value;
        for (key in options) {
          value = options[key];
          if (value !== void 0 && options.hasOwnProperty(key))
            Settings[key] = value;
        }
        return this;
      };
      NProgress2.status = null;
      NProgress2.set = function(n) {
        var started = NProgress2.isStarted();
        n = clamp(n, Settings.minimum, 1);
        NProgress2.status = n === 1 ? null : n;
        var progress = NProgress2.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
        progress.offsetWidth;
        queue2(function(next) {
          if (Settings.positionUsing === "")
            Settings.positionUsing = NProgress2.getPositioningCSS();
          css(bar, barPositionCSS(n, speed, ease));
          if (n === 1) {
            css(progress, {
              transition: "none",
              opacity: 1
            });
            progress.offsetWidth;
            setTimeout(function() {
              css(progress, {
                transition: "all " + speed + "ms linear",
                opacity: 0
              });
              setTimeout(function() {
                NProgress2.remove();
                next();
              }, speed);
            }, speed);
          } else {
            setTimeout(next, speed);
          }
        });
        return this;
      };
      NProgress2.isStarted = function() {
        return typeof NProgress2.status === "number";
      };
      NProgress2.start = function() {
        if (!NProgress2.status)
          NProgress2.set(0);
        var work = function() {
          setTimeout(function() {
            if (!NProgress2.status)
              return;
            NProgress2.trickle();
            work();
          }, Settings.trickleSpeed);
        };
        if (Settings.trickle)
          work();
        return this;
      };
      NProgress2.done = function(force) {
        if (!force && !NProgress2.status)
          return this;
        return NProgress2.inc(0.3 + 0.5 * Math.random()).set(1);
      };
      NProgress2.inc = function(amount) {
        var n = NProgress2.status;
        if (!n) {
          return NProgress2.start();
        } else {
          if (typeof amount !== "number") {
            amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
          }
          n = clamp(n + amount, 0, 0.994);
          return NProgress2.set(n);
        }
      };
      NProgress2.trickle = function() {
        return NProgress2.inc(Math.random() * Settings.trickleRate);
      };
      (function() {
        var initial = 0, current = 0;
        NProgress2.promise = function($promise) {
          if (!$promise || $promise.state() === "resolved") {
            return this;
          }
          if (current === 0) {
            NProgress2.start();
          }
          initial++;
          current++;
          $promise.always(function() {
            current--;
            if (current === 0) {
              initial = 0;
              NProgress2.done();
            } else {
              NProgress2.set((initial - current) / initial);
            }
          });
          return this;
        };
      })();
      NProgress2.render = function(fromStart) {
        if (NProgress2.isRendered())
          return document.getElementById("nprogress");
        addClass(document.documentElement, "nprogress-busy");
        var progress = document.createElement("div");
        progress.id = "nprogress";
        progress.innerHTML = Settings.template;
        var bar = progress.querySelector(Settings.barSelector), perc = fromStart ? "-100" : toBarPerc(NProgress2.status || 0), parent = document.querySelector(Settings.parent), spinner;
        css(bar, {
          transition: "all 0 linear",
          transform: "translate3d(" + perc + "%,0,0)"
        });
        if (!Settings.showSpinner) {
          spinner = progress.querySelector(Settings.spinnerSelector);
          spinner && removeElement(spinner);
        }
        if (parent != document.body) {
          addClass(parent, "nprogress-custom-parent");
        }
        parent.appendChild(progress);
        return progress;
      };
      NProgress2.remove = function() {
        removeClass(document.documentElement, "nprogress-busy");
        removeClass(document.querySelector(Settings.parent), "nprogress-custom-parent");
        var progress = document.getElementById("nprogress");
        progress && removeElement(progress);
      };
      NProgress2.isRendered = function() {
        return !!document.getElementById("nprogress");
      };
      NProgress2.getPositioningCSS = function() {
        var bodyStyle = document.body.style;
        var vendorPrefix = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
        if (vendorPrefix + "Perspective" in bodyStyle) {
          return "translate3d";
        } else if (vendorPrefix + "Transform" in bodyStyle) {
          return "translate";
        } else {
          return "margin";
        }
      };
      function clamp(n, min, max) {
        if (n < min)
          return min;
        if (n > max)
          return max;
        return n;
      }
      function toBarPerc(n) {
        return (-1 + n) * 100;
      }
      function barPositionCSS(n, speed, ease) {
        var barCSS;
        if (Settings.positionUsing === "translate3d") {
          barCSS = { transform: "translate3d(" + toBarPerc(n) + "%,0,0)" };
        } else if (Settings.positionUsing === "translate") {
          barCSS = { transform: "translate(" + toBarPerc(n) + "%,0)" };
        } else {
          barCSS = { "margin-left": toBarPerc(n) + "%" };
        }
        barCSS.transition = "all " + speed + "ms " + ease;
        return barCSS;
      }
      var queue2 = function() {
        var pending = [];
        function next() {
          var fn = pending.shift();
          if (fn) {
            fn(next);
          }
        }
        return function(fn) {
          pending.push(fn);
          if (pending.length == 1)
            next();
        };
      }();
      var css = function() {
        var cssPrefixes = ["Webkit", "O", "Moz", "ms"], cssProps = {};
        function camelCase(string) {
          return string.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match, letter) {
            return letter.toUpperCase();
          });
        }
        function getVendorProp(name) {
          var style = document.body.style;
          if (name in style)
            return name;
          var i = cssPrefixes.length, capName = name.charAt(0).toUpperCase() + name.slice(1), vendorName;
          while (i--) {
            vendorName = cssPrefixes[i] + capName;
            if (vendorName in style)
              return vendorName;
          }
          return name;
        }
        function getStyleProp(name) {
          name = camelCase(name);
          return cssProps[name] || (cssProps[name] = getVendorProp(name));
        }
        function applyCss(element, prop, value) {
          prop = getStyleProp(prop);
          element.style[prop] = value;
        }
        return function(element, properties) {
          var args = arguments, prop, value;
          if (args.length == 2) {
            for (prop in properties) {
              value = properties[prop];
              if (value !== void 0 && properties.hasOwnProperty(prop))
                applyCss(element, prop, value);
            }
          } else {
            applyCss(element, args[1], args[2]);
          }
        };
      }();
      function hasClass(element, name) {
        var list = typeof element == "string" ? element : classList(element);
        return list.indexOf(" " + name + " ") >= 0;
      }
      function addClass(element, name) {
        var oldList = classList(element), newList = oldList + name;
        if (hasClass(oldList, name))
          return;
        element.className = newList.substring(1);
      }
      function removeClass(element, name) {
        var oldList = classList(element), newList;
        if (!hasClass(element, name))
          return;
        newList = oldList.replace(" " + name + " ", " ");
        element.className = newList.substring(1, newList.length - 1);
      }
      function classList(element) {
        return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
      }
      function removeElement(element) {
        element && element.parentNode && element.parentNode.removeChild(element);
      }
      return NProgress2;
    });
  }
});

// server.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/index.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/cookieSigning.js
init_react();
var encoder = new TextEncoder();
async function sign(value, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["sign"]);
  let data = encoder.encode(value);
  let signature = await crypto.subtle.sign("HMAC", key, data);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
  return value + "." + hash;
}
async function unsign(cookie, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["verify"]);
  let value = cookie.slice(0, cookie.lastIndexOf("."));
  let hash = cookie.slice(cookie.lastIndexOf(".") + 1);
  let data = encoder.encode(value);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data);
  return valid ? value : false;
}
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
function installGlobals() {
  self.sign = sign;
  self.unsign = unsign;
}

// node_modules/@remix-run/cloudflare-pages/esm/sessions/cloudflareKVSessionStorage.js
init_react();

// node_modules/@remix-run/server-runtime/esm/index.js
init_react();

// node_modules/@remix-run/server-runtime/esm/responses.js
init_react();
function json(data, init2 = {}) {
  let responseInit = init2;
  if (typeof init2 === "number") {
    responseInit = {
      status: init2
    };
  }
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), __spreadProps(__spreadValues({}, responseInit), {
    headers
  }));
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
var redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response) {
  return redirectStatusCodes.has(response.status);
}
function isCatchResponse(response) {
  return response.headers.get("X-Remix-Catch") != null;
}

// node_modules/@remix-run/server-runtime/esm/server.js
init_react();

// node_modules/@remix-run/server-runtime/esm/data.js
init_react();
async function callRouteAction({
  loadContext,
  match,
  request
}) {
  let action = match.route.module.action;
  if (!action) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide an \`action\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await action({
      request: stripDataParam(stripIndexParam(request)),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
async function callRouteLoader({
  loadContext,
  match,
  request
}) {
  let loader = match.route.module.loader;
  if (!loader) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await loader({
      request: stripDataParam(stripIndexParam(request.clone())),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
function stripIndexParam(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_data");
  return new Request(url.href, request);
}
function extractData(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}

// node_modules/@remix-run/server-runtime/esm/entry.js
init_react();
function createEntryMatches(matches, routes2) {
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: routes2[match.route.id]
  }));
}
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo, routeId) => {
    memo[routeId] = manifest[routeId].module;
    return memo;
  }, {});
}

// node_modules/@remix-run/server-runtime/esm/errors.js
init_react();
async function serializeError(error) {
  return {
    message: error.message,
    stack: error.stack
  };
}

// node_modules/@remix-run/server-runtime/esm/headers.js
init_react();
var import_set_cookie_parser = __toModule(require_set_cookie());
function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
  return matches.reduce((parentHeaders, match, index) => {
    let routeModule = build.routes[match.route.id].module;
    let routeLoaderResponse = routeLoaderResponses[match.route.id];
    let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();
    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);
    cookies.forEach((cookie) => {
      childHeaders.append("Set-Cookie", cookie);
    });
  }
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
init_react();

// node_modules/react-router-dom/index.js
init_react();
var import_react2 = __toModule(require_react());

// node_modules/history/index.js
init_react();

// node_modules/@babel/runtime/helpers/esm/extends.js
init_react();

// node_modules/history/index.js
var r;
var B = r || (r = {});
B.Pop = "POP";
B.Push = "PUSH";
B.Replace = "REPLACE";
function I(b) {
  var h = b.pathname;
  h = h === void 0 ? "/" : h;
  var e = b.search;
  e = e === void 0 ? "" : e;
  b = b.hash;
  b = b === void 0 ? "" : b;
  e && e !== "?" && (h += e.charAt(0) === "?" ? e : "?" + e);
  b && b !== "#" && (h += b.charAt(0) === "#" ? b : "#" + b);
  return h;
}
function J(b) {
  var h = {};
  if (b) {
    var e = b.indexOf("#");
    0 <= e && (h.hash = b.substr(e), b = b.substr(0, e));
    e = b.indexOf("?");
    0 <= e && (h.search = b.substr(e), b = b.substr(0, e));
    b && (h.pathname = b);
  }
  return h;
}

// node_modules/react-router/index.js
init_react();
var import_react = __toModule(require_react());
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning(false, message) : void 0;
  }
}
var NavigationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = /* @__PURE__ */ (0, import_react.createContext)({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = r.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0, import_react.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = J(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = (0, import_react.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  true ? warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ (0, import_react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react.createElement)(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
function useHref(to) {
  !useInRouterContext() ? true ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0, import_react.useContext)(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  return (0, import_react.useContext)(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0, import_react.useCallback)(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = /* @__PURE__ */ (0, import_react.createContext)(null);
function useOutlet(context) {
  let outlet = (0, import_react.useContext)(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ (0, import_react.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to) {
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0, import_react.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes2, locationArg) {
  !useInRouterContext() ? true ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    matches: parentMatches
  } = (0, import_react.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? J(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : void 0;
    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function matchRoutes(routes2, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? J(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes2.forEach((route, index) => {
    let meta2 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta2.relativePath.startsWith("/")) {
      !meta2.relativePath.startsWith(parentPath) ? true ? invariant(false, 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : invariant(false) : void 0;
      meta2.relativePath = meta2.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta2.relativePath]);
    let routesMeta = parentsMeta.concat(meta2);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ? true ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index) => {
    return /* @__PURE__ */ (0, import_react.createElement)(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : /* @__PURE__ */ (0, import_react.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')) : void 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    true ? warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")) : void 0;
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? J(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? J(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? J(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

// node_modules/react-router-dom/index.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0, import_react2.useState)({
    action: history.action,
    location: history.location
  });
  (0, import_react2.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0, import_react2.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var Link = /* @__PURE__ */ (0, import_react2.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ (0, import_react2.createElement)("a", _extends2({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = /* @__PURE__ */ (0, import_react2.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let location = useLocation();
  let path = useResolvedPath(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ (0, import_react2.createElement)(Link, _extends2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to);
  return (0, import_react2.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || I(location) === I(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/server-runtime/esm/mode.js
init_react();
var ServerMode;
(function(ServerMode2) {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
})(ServerMode || (ServerMode = {}));
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}

// node_modules/@remix-run/server-runtime/esm/routes.js
init_react();
function createRoutes(manifest, parentId) {
  return Object.keys(manifest).filter((key) => manifest[key].parentId === parentId).map((id) => __spreadProps(__spreadValues({}, manifest[id]), {
    children: createRoutes(manifest, id)
  }));
}

// node_modules/@remix-run/server-runtime/esm/serverHandoff.js
init_react();
var import_jsesc = __toModule(require_jsesc());
function createServerHandoffString(serverHandoff) {
  return (0, import_jsesc.default)(serverHandoff, {
    isScriptContext: true
  });
}

// node_modules/@remix-run/server-runtime/esm/server.js
function createRequestHandler(build, platform2, mode) {
  let routes2 = createRoutes(build.routes);
  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;
  return async function requestHandler(request, loadContext) {
    let url = new URL(request.url);
    let matches = matchServerRoutes(routes2, url.pathname);
    let requestType = getRequestType(url, matches);
    let response;
    switch (requestType) {
      case "data":
        response = await handleDataRequest({
          request,
          loadContext,
          matches,
          handleDataRequest: build.entry.module.handleDataRequest,
          serverMode
        });
        break;
      case "document":
        response = await renderDocumentRequest({
          build,
          loadContext,
          matches,
          request,
          routes: routes2,
          serverMode
        });
        break;
      case "resource":
        response = await handleResourceRequest({
          request,
          loadContext,
          matches,
          serverMode
        });
        break;
    }
    if (request.method.toLowerCase() === "head") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
}
async function handleDataRequest({
  handleDataRequest: handleDataRequest2,
  loadContext,
  matches,
  request,
  serverMode
}) {
  if (!isValidRequestMethod(request)) {
    return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
  }
  let url = new URL(request.url);
  if (!matches) {
    return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
  }
  let response;
  let match;
  try {
    if (isActionRequest(request)) {
      match = getActionRequestMatch(url, matches);
      response = await callRouteAction({
        loadContext,
        match,
        request
      });
    } else {
      let routeId = url.searchParams.get("_data");
      if (!routeId) {
        return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
      }
      let tempMatch = matches.find((match2) => match2.route.id === routeId);
      if (!tempMatch) {
        return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
      }
      match = tempMatch;
      response = await callRouteLoader({
        loadContext,
        match,
        request
      });
    }
    if (isRedirectResponse(response)) {
      let headers = new Headers(response.headers);
      headers.set("X-Remix-Redirect", headers.get("Location"));
      headers.delete("Location");
      return new Response(null, {
        status: 204,
        headers
      });
    }
    if (handleDataRequest2) {
      response = await handleDataRequest2(response.clone(), {
        context: loadContext,
        params: match.params,
        request: request.clone()
      });
    }
    return response;
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    if (serverMode === ServerMode.Development) {
      return errorBoundaryError(error, 500);
    }
    return errorBoundaryError(new Error("Unexpected Server Error"), 500);
  }
}
async function renderDocumentRequest({
  build,
  loadContext,
  matches,
  request,
  routes: routes2,
  serverMode
}) {
  let url = new URL(request.url);
  let appState = {
    trackBoundaries: true,
    trackCatchBoundaries: true,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: void 0,
    catch: void 0
  };
  if (!isValidRequestMethod(request)) {
    matches = null;
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 405,
      statusText: "Method Not Allowed"
    };
  } else if (!matches) {
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 404,
      statusText: "Not Found"
    };
  }
  let actionStatus;
  let actionData;
  let actionMatch;
  let actionResponse;
  if (matches && isActionRequest(request)) {
    actionMatch = getActionRequestMatch(url, matches);
    try {
      actionResponse = await callRouteAction({
        loadContext,
        match: actionMatch,
        request
      });
      if (isRedirectResponse(actionResponse)) {
        return actionResponse;
      }
      actionStatus = {
        status: actionResponse.status,
        statusText: actionResponse.statusText
      };
      if (isCatchResponse(actionResponse)) {
        appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
        appState.trackCatchBoundaries = false;
        appState.catch = __spreadProps(__spreadValues({}, actionStatus), {
          data: await extractData(actionResponse)
        });
      } else {
        actionData = {
          [actionMatch.route.id]: await extractData(actionResponse)
        };
      }
    } catch (error) {
      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the action for route ${actionMatch.route.id}`);
      }
    }
  }
  let routeModules = createEntryRouteModules(build.routes);
  let matchesToLoad = matches || [];
  if (appState.catch) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "CatchBoundary");
  } else if (appState.error) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "ErrorBoundary");
  }
  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? callRouteLoader({
    loadContext,
    match,
    request
  }) : Promise.resolve(void 0)));
  let actionCatch = appState.catch;
  let actionError = appState.error;
  let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
  let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
  appState.catch = void 0;
  appState.error = void 0;
  let routeLoaderResponses = {};
  let loaderStatusCodes = [];
  let routeData = {};
  for (let index = 0; index < matchesToLoad.length; index++) {
    let match = matchesToLoad[index];
    let result = routeLoaderResults[index];
    let error = result.status === "rejected" ? result.reason : void 0;
    let response = result.status === "fulfilled" ? result.value : void 0;
    let isRedirect = response ? isRedirectResponse(response) : false;
    let isCatch = response ? isCatchResponse(response) : false;
    if (appState.catch || appState.error) {
      break;
    }
    if (!actionCatch && !actionError && response && isRedirect) {
      return response;
    }
    if (match.route.module.CatchBoundary) {
      appState.catchBoundaryRouteId = match.route.id;
    }
    if (match.route.module.ErrorBoundary) {
      appState.loaderBoundaryRouteId = match.route.id;
    }
    if (error) {
      loaderStatusCodes.push(500);
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the data loader for route ${match.route.id}`);
      }
      break;
    } else if (response) {
      routeLoaderResponses[match.route.id] = response;
      loaderStatusCodes.push(response.status);
      if (isCatch) {
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: await extractData(response),
          status: response.status,
          statusText: response.statusText
        };
        break;
      } else {
        routeData[match.route.id] = await extractData(response);
      }
    }
  }
  if (!appState.catch) {
    appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
  }
  if (!appState.error) {
    appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
  }
  appState.catch = actionCatch || appState.catch;
  appState.error = actionError || appState.error;
  let renderableMatches = getRenderableMatches(matches, appState);
  if (!renderableMatches) {
    renderableMatches = [];
    let root = routes2[0];
    if (root !== null && root !== void 0 && root.module.CatchBoundary) {
      appState.catchBoundaryRouteId = "root";
      renderableMatches.push({
        params: {},
        pathname: "",
        route: routes2[0]
      });
    }
  }
  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
  let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
  let responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);
  let serverHandoff = {
    actionData,
    appState,
    matches: entryMatches,
    routeData
  };
  let entryContext = __spreadProps(__spreadValues({}, serverHandoff), {
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff)
  });
  let handleDocumentRequest = build.entry.module.default;
  try {
    return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
  } catch (error) {
    responseStatusCode = 500;
    appState.trackBoundaries = false;
    appState.error = await serializeError(error);
    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
    try {
      return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
    } catch (error2) {
      if (serverMode !== ServerMode.Test) {
        console.error(error2);
      }
      let message = "Unexpected Server Error";
      if (serverMode === ServerMode.Development) {
        message += `

${String(error2)}`;
      }
      return new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
  }
}
async function handleResourceRequest({
  loadContext,
  matches,
  request,
  serverMode
}) {
  let match = matches.slice(-1)[0];
  try {
    if (isActionRequest(request)) {
      return await callRouteAction({
        match,
        loadContext,
        request
      });
    } else {
      return await callRouteLoader({
        match,
        loadContext,
        request
      });
    }
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    let message = "Unexpected Server Error";
    if (serverMode === ServerMode.Development) {
      message += `

${String(error)}`;
    }
    return new Response(message, {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
}
function getRequestType(url, matches) {
  if (url.searchParams.has("_data")) {
    return "data";
  }
  if (!matches) {
    return "document";
  }
  let match = matches.slice(-1)[0];
  if (!match.route.module.default) {
    return "resource";
  }
  return "document";
}
function isActionRequest(request) {
  let method = request.method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function isHeadRequest(request) {
  return request.method.toLowerCase() === "head";
}
function isValidRequestMethod(request) {
  return request.method.toLowerCase() === "get" || isHeadRequest(request) || isActionRequest(request);
}
async function errorBoundaryError(error, status) {
  return json(await serializeError(error), {
    status,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function isIndexRequestUrl(url) {
  let indexRequest = false;
  for (let param of url.searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
function getActionRequestMatch(url, matches) {
  let match = matches.slice(-1)[0];
  if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
    return matches.slice(-2)[0];
  }
  return match;
}
function getDeepestRouteIdWithBoundary(matches, key) {
  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
  return matched ? matched.route.id : null;
}
function getMatchesUpToDeepestBoundary(matches, key) {
  let deepestBoundaryIndex = -1;
  matches.forEach((match, index) => {
    if (match.route.module[key]) {
      deepestBoundaryIndex = index;
    }
  });
  if (deepestBoundaryIndex === -1) {
    return [];
  }
  return matches.slice(0, deepestBoundaryIndex + 1);
}
function getRenderableMatches(matches, appState) {
  if (!matches) {
    return null;
  }
  if (!appState.catch && !appState.error) {
    return matches;
  }
  let lastRenderableIndex = -1;
  matches.forEach((match, index) => {
    let id = match.route.id;
    if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {
      lastRenderableIndex = index;
    }
  });
  return matches.slice(0, lastRenderableIndex + 1);
}

// node_modules/@remix-run/cloudflare-pages/esm/worker.js
init_react();
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let platform2 = {};
  let handleRequest3 = createRequestHandler(build, platform2, mode);
  return (context) => {
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(context) : void 0;
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  const handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  });
  const handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone());
      response = response && response.status >= 200 && response.status < 400 ? new Response(response.body, response) : void 0;
    } catch {
    }
    if (!response) {
      response = await handleRequest3(context);
    }
    return response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (e) {
      if (e instanceof Error) {
        console.error(e);
        return new Response(e.message || e.toString(), {
          status: 500
        });
      }
      return new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// node_modules/@remix-run/cloudflare-pages/esm/index.js
installGlobals();

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  entry: () => entry,
  routes: () => routes
});
init_react();

// app/entry.server.jsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
init_react();
var import_server3 = __toModule(require_server());

// node_modules/remix/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/components.js
init_react();

// node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js
init_react();
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// node_modules/@remix-run/react/esm/components.js
var React3 = __toModule(require_react());

// node_modules/@remix-run/react/esm/errorBoundaries.js
init_react();
var import_react3 = __toModule(require_react());
var RemixErrorBoundary = class extends import_react3.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ import_react3.default.createElement(this.props.component, {
        error: this.state.error
      });
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error
}) {
  console.error(error);
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react3.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
var RemixCatchContext = /* @__PURE__ */ import_react3.default.createContext(void 0);
function useCatch() {
  return (0, import_react3.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component,
  children
}) {
  if (catchVal) {
    return /* @__PURE__ */ import_react3.default.createElement(RemixCatchContext.Provider, {
      value: catchVal
    }, /* @__PURE__ */ import_react3.default.createElement(Component, null));
  }
  return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}

// node_modules/@remix-run/react/esm/invariant.js
init_react();
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// node_modules/@remix-run/react/esm/links.js
init_react();

// node_modules/@remix-run/react/esm/routeModules.js
init_react();
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push(__spreadProps(__spreadValues({}, descriptor), {
        rel: "preload",
        as: "style"
      }));
    }
  }
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  return object != null && typeof object.rel === "string" && typeof object.href === "string";
}
async function getStylesheetPrefetchLinks(matches, routeModules) {
  let links2 = await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(match.route, routeModules);
    return mod.links ? mod.links() : [];
  }));
  return links2.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((_a) => {
    var _b = _a, {
      rel
    } = _b, attrs = __objRest(_b, [
      "rel"
    ]);
    return rel === "preload" ? __spreadValues({
      rel: "prefetch"
    }, attrs) : __spreadValues({
      rel: "prefetch",
      as: "style"
    }, attrs);
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {
  let path = parsePathPatch(page);
  let isNew = (match, index) => {
    if (!currentMatches[index])
      return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _currentMatches$index;
    return currentMatches[index].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"];
  };
  let newMatches = mode === "data" && location.search !== path.search ? nextMatches.filter((match, index) => {
    if (!match.route.hasLoader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      return match.route.shouldReload({
        params: match.params,
        prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),
        url: new URL(page, window.origin)
      });
    }
    return true;
  }) : nextMatches.filter((match, index) => {
    return match.route.hasLoader && (isNew(match, index) || matchPathChanged(match, index));
  });
  return newMatches;
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path;
    let searchParams = new URLSearchParams(search);
    searchParams.set("_data", match.route.id);
    return `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let str = JSON.stringify(descriptor);
    if (!set.has(str)) {
      set.add(str);
      deduped.push(descriptor);
    }
    return deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = J(href);
  if (path.search === void 0)
    path.search = "";
  return path;
}

// node_modules/@remix-run/react/esm/markup.js
init_react();
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/esm/routes.js
init_react();
var React2 = __toModule(require_react());

// node_modules/@remix-run/react/esm/data.js
init_react();
function isCatchResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
async function fetchData(url, routeId, signal, submission) {
  url.searchParams.set("_data", routeId);
  let init2 = submission ? getActionInit(submission, signal) : {
    credentials: "same-origin",
    signal
  };
  let response = await fetch(url.href, init2);
  if (isErrorResponse(response)) {
    let data = await response.json();
    let error = new Error(data.message);
    error.stack = data.stack;
    return error;
  }
  return response;
}
async function extractData2(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission;
  let headers = void 0;
  let body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData) {
      invariant2(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
      body.append(key, value);
    }
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}

// node_modules/@remix-run/react/esm/transition.js
init_react();

// node_modules/@remix-run/react/esm/routeMatching.js
init_react();
function matchClientRoutes(routes2, location) {
  let matches = matchRoutes(routes2, location);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/react/esm/transition.js
var CatchValue = class {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText;
    this.data = data;
  }
};
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location) {
  return Boolean(location.state) && location.state.isRedirect;
}
function isLoaderRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loader";
}
function isActionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "action";
}
function isFetchActionRedirect(location) {
  return isRedirectLocation(location) && location.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loaderSubmission";
}
var TransitionRedirect = class {
  constructor(location) {
    this.location = typeof location === "string" ? location : location.pathname + location.search;
  }
};
var IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
};
var IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init2) {
  let {
    routes: routes2
  } = init2;
  let pendingNavigationController;
  let fetchControllers = new Map();
  let incrementingLoadId = 0;
  let navigationLoadId = -1;
  let fetchReloadIds = new Map();
  let matches = matchClientRoutes(routes2, init2.location);
  if (!matches) {
    matches = [{
      params: {},
      pathname: "",
      route: routes2[0]
    }];
  }
  let state = {
    location: init2.location,
    loaderData: init2.loaderData || {},
    actionData: init2.actionData,
    catch: init2.catch,
    error: init2.error,
    catchBoundaryId: init2.catchBoundaryId || null,
    errorBoundaryId: init2.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: new Map()
  };
  function update(updates) {
    state = Object.assign({}, state, updates);
    init2.onChange(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchReloadIds.delete(key);
    state.fetchers.delete(key);
  }
  async function send(event) {
    switch (event.type) {
      case "navigation": {
        let {
          action,
          location,
          submission
        } = event;
        let matches2 = matchClientRoutes(routes2, location);
        if (!matches2) {
          matches2 = [{
            params: {},
            pathname: "",
            route: routes2[0]
          }];
          await handleNotFoundNavigation(location, matches2);
        } else if (!submission && isHashChangeOnly(location)) {
          await handleHashChange(location, matches2);
        } else if (action === r.Pop) {
          await handleLoad(location, matches2);
        } else if (submission && isActionSubmission(submission)) {
          await handleActionSubmissionNavigation(location, submission, matches2);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderSubmissionNavigation(location, submission, matches2);
        } else if (isActionRedirectLocation(location)) {
          await handleActionRedirect(location, matches2);
        } else if (isLoaderSubmissionRedirectLocation(location)) {
          await handleLoaderSubmissionRedirect(location, matches2);
        } else if (isLoaderRedirectLocation(location)) {
          await handleLoaderRedirect(location, matches2);
        } else if (isFetchActionRedirect(location)) {
          await handleFetchActionRedirect(location, matches2);
        } else {
          await handleLoad(location, matches2);
        }
        navigationLoadId = -1;
        break;
      }
      case "fetcher": {
        let {
          key,
          submission,
          href
        } = event;
        let matches2 = matchClientRoutes(routes2, href);
        invariant2(matches2, "No matches found");
        let match = matches2.slice(-1)[0];
        if (fetchControllers.has(key))
          abortFetcher(key);
        if (submission && isActionSubmission(submission)) {
          await handleActionFetchSubmission(key, submission, match);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderFetchSubmission(href, key, submission, match);
        } else {
          await handleLoaderFetch(href, key, match);
        }
        break;
      }
      default: {
        throw new Error(`Unknown data event type: ${event.type}`);
      }
    }
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers) {
      controller.abort();
    }
  }
  async function handleActionFetchSubmission(key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callAction(submission, match, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "fetchAction"
      };
      init2.onRedirect(result.value.location, locationState);
      let doneFetcher2 = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher2);
      update({
        fetchers: new Map(state.fetchers)
      });
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let loadFetcher = {
      state: "loading",
      type: "actionReload",
      data: result.value,
      submission
    };
    state.fetchers.set(key, loadFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
    let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let matchesToLoad = state.nextMatches || state.matches;
    let hrefToLoad = createHref(state.transition.location || state.location);
    let results = await callLoaders(state, createUrl(hrefToLoad), matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
    if (controller.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    let redirect = findRedirect(results);
    if (redirect) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(redirect.location, locationState);
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult);
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    let abortedKeys = abortStaleFetchLoads(loadId);
    if (abortedKeys) {
      markFetchersDone(abortedKeys);
    }
    let yeetedNavigation = yeetStaleNavigationLoad(loadId);
    if (yeetedNavigation) {
      let {
        transition
      } = state;
      invariant2(transition.state === "loading", "Expected loading transition");
      update({
        location: transition.location,
        matches: state.nextMatches,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad),
        actionData: transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers)
      });
    } else {
      update({
        fetchers: new Map(state.fetchers),
        error,
        errorBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad)
      });
    }
  }
  function yeetStaleNavigationLoad(landedId) {
    let isLoadingNavigation = state.transition.state === "loading";
    if (isLoadingNavigation && navigationLoadId < landedId) {
      abortNormalNavigation();
      return true;
    }
    return false;
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant2(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    return yeetedKeys.length ? yeetedKeys : false;
  }
  async function handleLoaderFetchSubmission(href, key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    fetchControllers.delete(key);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function handleLoaderFetch(href, key, match) {
    if (typeof AbortController === "undefined") {
      throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
    }
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (controller.signal.aborted)
      return;
    fetchControllers.delete(key);
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function maybeBailOnCatch(match, key, result) {
    if (isCatchResult(result)) {
      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers),
        catch: {
          data: result.value.data,
          status: result.value.status,
          statusText: result.value.statusText
        },
        catchBoundaryId
      });
      return true;
    }
    return false;
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      });
      return true;
    }
    return false;
  }
  async function handleNotFoundNavigation(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
    update({
      location,
      matches: matches2,
      catch: {
        data: null,
        status: 404,
        statusText: "Not Found"
      },
      catchBoundaryId,
      transition: IDLE_TRANSITION
    });
  }
  async function handleActionSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    let controller = new AbortController();
    pendingNavigationController = controller;
    if (!isIndexRequestAction(submission.action) && matches2[matches2.length - 1].route.id.endsWith("/index")) {
      matches2 = matches2.slice(0, -1);
    }
    let leafMatch = matches2.slice(-1)[0];
    let result = await callAction(submission, leafMatch, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "action"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (isCatchResult(result)) {
      let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], matches2, result);
      update({
        transition: IDLE_TRANSITION,
        catch: catchVal,
        catchBoundaryId
      });
      return;
    }
    let loadTransition = {
      state: "loading",
      type: "actionReload",
      submission,
      location
    };
    update({
      transition: loadTransition,
      actionData: {
        [leafMatch.route.id]: result.value
      }
    });
    await loadPageData(location, matches2, submission, leafMatch.route.id, result);
  }
  async function handleLoaderSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleHashChange(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    update({
      location,
      matches: matches2,
      transition: IDLE_TRANSITION
    });
  }
  async function handleLoad(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderSubmissionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "loaderSubmissionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleFetchActionRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "fetchActionRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleActionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "actionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  function isHashChangeOnly(location) {
    return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;
  }
  async function loadPageData(location, matches2, submission, submissionRouteId, actionResult) {
    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
    let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
    let controller = new AbortController();
    pendingNavigationController = controller;
    navigationLoadId = ++incrementingLoadId;
    let results = await callLoaders(state, createUrl(createHref(location)), matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId);
    if (controller.signal.aborted) {
      return;
    }
    let redirect = findRedirect(results);
    if (redirect) {
      if (state.transition.type === "actionReload") {
        let locationState = {
          isRedirect: true,
          type: "action"
        };
        init2.onRedirect(redirect.location, locationState);
      } else if (state.transition.type === "loaderSubmission") {
        let locationState = {
          isRedirect: true,
          type: "loaderSubmission"
        };
        init2.onRedirect(redirect.location, locationState);
      } else {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init2.onRedirect(redirect.location, locationState);
      }
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult);
    let abortedIds = abortStaleFetchLoads(navigationLoadId);
    if (abortedIds) {
      markFetchersDone(abortedIds);
    }
    update({
      location,
      matches: matches2,
      error,
      errorBoundaryId,
      catch: catchVal,
      catchBoundaryId,
      loaderData: makeLoaderData(state, results, matches2),
      actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
      transition: IDLE_TRANSITION,
      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
    });
  }
  function abortNormalNavigation() {
    var _pendingNavigationCon;
    (_pendingNavigationCon = pendingNavigationController) === null || _pendingNavigationCon === void 0 ? void 0 : _pendingNavigationCon.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant2(controller, `Expected fetch controller: ${key}`);
    controller.abort();
    fetchControllers.delete(key);
  }
  return {
    send,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
function isIndexRequestAction(action) {
  let indexRequest = false;
  let searchParams = new URLSearchParams(action.split("?", 2)[1] || "");
  for (let param of searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
async function callLoaders(state, url, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  let matchesToLoad = filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher);
  return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
}
async function callLoader(match, url, signal) {
  invariant2(match.route.loader, `Expected loader for ${match.route.id}`);
  try {
    let {
      params
    } = match;
    let value = await match.route.loader({
      params,
      url,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
async function callAction(submission, match, signal) {
  if (!match.route.action) {
    throw new Error(`Route "${match.route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
  }
  try {
    let value = await match.route.action({
      url: createUrl(submission.action),
      params: match.params,
      submission,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
function filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  if (submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = false;
    matches = matches.filter((match) => {
      if (foundProblematicRoute) {
        return false;
      }
      if (match.route.id === submissionRouteId) {
        foundProblematicRoute = true;
        return false;
      }
      return true;
    });
  }
  let isNew = (match, index) => {
    if (!state.matches[index])
      return true;
    return match.route.id !== state.matches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _state$matches$index$;
    return state.matches[index].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index].params["*"] !== match.params["*"];
  };
  let filterByRouteProps = (match, index) => {
    if (!match.route.loader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return true;
  };
  let isInRootCatchBoundary = state.matches.length === 1;
  if (isInRootCatchBoundary) {
    return matches.filter((match) => !!match.route.loader);
  }
  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
    return matches.filter(filterByRouteProps);
  } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search) {
    return matches.filter(filterByRouteProps);
  }
  return matches.filter((match, index, arr) => {
    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index) {
      return false;
    }
    return match.route.loader && (isNew(match, index) || matchPathChanged(match, index));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location) {
  return location.pathname + location.search;
}
function findRedirect(results) {
  for (let result of results) {
    if (isRedirectResult(result)) {
      return result.value;
    }
  }
  return null;
}
async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  let loaderCatchResult;
  for (let result of results) {
    if (isCatchResult(result)) {
      loaderCatchResult = result;
      break;
    }
  }
  let extractCatchData = async (res) => ({
    status: res.status,
    statusText: res.statusText,
    data: res.data
  });
  if (actionCatchResult && loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(actionCatchResult.value), boundaryId];
  }
  if (loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(loaderCatchResult.value), boundaryId];
  }
  return [void 0, void 0];
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results) {
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.CatchBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.ErrorBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results) {
    newData[match.route.id] = value;
  }
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    if (value !== void 0) {
      loaderData[route.id] = value;
    }
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}

// node_modules/@remix-run/react/esm/routes.js
function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ React2.createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    if (children.length > 0)
      route.children = children;
    return route;
  });
}
function createShouldReload(route, routeModules) {
  let shouldReload = (arg) => {
    let module = routeModules[route.id];
    invariant2(module, `Expected route module to be loaded for ${route.id}`);
    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }
    return true;
  };
  return shouldReload;
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  await prefetchStyleLinks(routeModule);
  return routeModule;
}
function createLoader(route, routeModules) {
  let loader = async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect = await checkRedirect(result);
      if (redirect)
        return redirect;
      if (isCatchResponse2(result)) {
        throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
      }
      return extractData2(result);
    } else {
      await loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  };
  return loader;
}
function createAction(route) {
  if (!route.hasAction)
    return void 0;
  let action = async ({
    url,
    signal,
    submission
  }) => {
    let result = await fetchData(url, route.id, signal, submission);
    if (result instanceof Error) {
      throw result;
    }
    let redirect = await checkRedirect(result);
    if (redirect)
      return redirect;
    if (isCatchResponse2(result)) {
      throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
    }
    return extractData2(result);
  };
  return action;
}
async function checkRedirect(response) {
  if (isRedirectResponse2(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
    if (url.origin !== window.location.origin) {
      await new Promise(() => {
        window.location.replace(url.href);
      });
    } else {
      return new TransitionRedirect(url.pathname + url.search);
    }
  }
  return null;
}

// node_modules/@remix-run/react/esm/components.js
var RemixEntryContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixEntryContext() {
  let context = React3.useContext(RemixEntryContext);
  invariant2(context, "You must render this element inside a <Remix> element");
  return context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = false
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext;
  let clientRoutes = React3.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
  let [clientState, setClientState] = React3.useState(entryComponentDidCatchEmulator);
  let [transitionManager] = React3.useState(() => {
    return createTransitionManager({
      routes: clientRoutes,
      actionData: documentActionData,
      loaderData: documentLoaderData,
      location: historyLocation,
      catch: entryComponentDidCatchEmulator.catch,
      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
      onRedirect: _navigator.replace,
      onChange: (state) => {
        setClientState({
          catch: state.catch,
          error: state.error,
          catchBoundaryRouteId: state.catchBoundaryId,
          loaderBoundaryRouteId: state.errorBoundaryId,
          renderBoundaryRouteId: null,
          trackBoundaries: false,
          trackCatchBoundaries: false
        });
      }
    });
  });
  let navigator = React3.useMemo(() => {
    let push = (to, state) => {
      return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
    };
    return __spreadProps(__spreadValues({}, _navigator), {
      push
    });
  }, [_navigator, transitionManager]);
  let {
    location,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  React3.useEffect(() => {
    let {
      location: location2
    } = transitionManager.getState();
    if (historyLocation === location2)
      return;
    transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ React3.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
    location,
    component: RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
    location,
    component: RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(Router, {
    navigationType: action,
    location,
    navigator,
    static: staticProp
  }, /* @__PURE__ */ React3.createElement(Routes2, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  error.stack = data.stack;
  return error;
}
function Routes2() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  let element = useRoutes(clientRoutes) || clientRoutes[0].element;
  return element;
}
var RemixRouteContext = /* @__PURE__ */ React3.createContext(void 0);
function DefaultRouteComponent({
  id
}) {
  throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id
}) {
  let location = useLocation();
  let {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  let data = routeData[id];
  let {
    default: Component,
    CatchBoundary,
    ErrorBoundary
  } = routeModules[id];
  let element = Component ? /* @__PURE__ */ React3.createElement(Component, null) : /* @__PURE__ */ React3.createElement(DefaultRouteComponent, {
    id
  });
  let context = {
    data,
    id
  };
  if (CatchBoundary) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
    if (appState.trackCatchBoundaries) {
      appState.catchBoundaryRouteId = id;
    }
    context = maybeServerCaught ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
      location,
      component: CatchBoundary,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
    if (appState.trackBoundaries) {
      appState.renderBoundaryRouteId = id;
    }
    context = maybeServerRenderError ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
      location,
      component: ErrorBoundary,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ React3.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext();
  let links2 = React3.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, links2.map((link) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, _extends3({
    key: link.page
  }, link)) : /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.rel + link.href
  }, link))));
}
function PrefetchPageLinks(_a) {
  var _b = _a, {
    page
  } = _b, dataLinkProps = __objRest(_b, [
    "page"
  ]);
  let {
    clientRoutes
  } = useRemixEntryContext();
  let matches = React3.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
  if (!matches) {
    console.warn(`Tried to prefetch ${page} but no routes matched.`);
    return null;
  }
  return /* @__PURE__ */ React3.createElement(PrefetchPageLinksImpl, _extends3({
    page,
    matches
  }, dataLinkProps));
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext();
  let [styleLinks, setStyleLinks] = React3.useState([]);
  React3.useEffect(() => {
    let interrupted = false;
    getStylesheetPrefetchLinks(matches, routeModules).then((links2) => {
      if (!interrupted)
        setStyleLinks(links2);
    });
    return () => {
      interrupted = true;
    };
  }, [matches, routeModules]);
  return styleLinks;
}
function PrefetchPageLinksImpl(_a) {
  var _b = _a, {
    page,
    matches: nextMatches
  } = _b, linkProps = __objRest(_b, [
    "page",
    "matches"
  ]);
  let location = useLocation();
  let {
    matches,
    manifest
  } = useRemixEntryContext();
  let newMatchesForData = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "data"), [page, nextMatches, matches, location]);
  let newMatchesForAssets = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "assets"), [page, nextMatches, matches, location]);
  let dataHrefs = React3.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
  let moduleHrefs = React3.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  let location = useLocation();
  let meta2 = {};
  let parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id;
    let data = routeData[routeId];
    let params = match.params;
    let routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location
      }) : routeModule.meta;
      Object.assign(meta2, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, Object.entries(meta2).map(([name, value]) => {
    let isOpenGraphTag = name.startsWith("og:");
    return name === "title" ? /* @__PURE__ */ React3.createElement("title", {
      key: "title"
    }, value) : Array.isArray(value) ? value.map((content) => isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      property: name,
      content
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      name,
      content
    })) : isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      property: name,
      content: value
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      name,
      content: value
    });
  }));
}
var isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  React3.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = React3.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
    let routeModulesScript = `${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};`;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(contextScript)
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.url
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module"
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.entry.module,
      type: "module"
    })));
  }, []);
  let nextMatches = React3.useMemo(() => {
    if (pendingLocation) {
      let matches2 = matchClientRoutes(clientRoutes, pendingLocation);
      invariant2(matches2, `No routes match path "${pendingLocation.pathname}"`);
      return matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]);
  let routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1);
  let preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dedupe2(preloads).map((path) => /* @__PURE__ */ React3.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe2(array) {
  return [...new Set(array)];
}
var nextNavigationSubmission;
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  nextNavigationSubmission = void 0;
  return submission;
}
function useBeforeUnload(callback) {
  React3.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
var LiveReload = false ? () => null : function LiveReload2({
  port = Number(8002)
}) {
  return /* @__PURE__ */ React3.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
let protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
let host = location.hostname;
let socketPath = protocol + '//' + host + ':${port}/socket';

let ws = new WebSocket(socketPath);
ws.onmessage = message => {
  let event = JSON.parse(message.data);
  if (event.type === "LOG") {
    console.log(event.message);
  }
  if (event.type === "RELOAD") {
    console.log("\u{1F4BF} Reloading window ...");
    window.location.reload();
  }
};
ws.onerror = error => {
  console.log("Remix dev asset server web socket error:");
  console.error(error);
};
              `.trim()
    }
  });
};

// node_modules/@remix-run/react/esm/scroll-restoration.js
init_react();
var React4 = __toModule(require_react());
var STORAGE_KEY = "positions";
var positions = {};
if (typeof document !== "undefined") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  if (sessionPositions) {
    positions = JSON.parse(sessionPositions);
  }
}
function ScrollRestoration() {
  useScrollRestoration();
  React4.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []);
  useBeforeUnload(React4.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  return /* @__PURE__ */ React4.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
          let STORAGE_KEY = ${JSON.stringify(STORAGE_KEY)};
          if (!window.history.state || !window.history.state.key) {
            window.history.replaceState({ key: Math.random().toString(32).slice(2) }, null);
          }
          try {
            let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || '{}')
            let storedY = positions[window.history.state.key];
            if (typeof storedY === 'number') {
              window.scrollTo(0, storedY)
            }
          } catch(error) {
            console.error(error)
            sessionStorage.removeItem(STORAGE_KEY)
          }
        `
    }
  });
}
var hydrated = false;
function useScrollRestoration() {
  let location = useLocation();
  let transition = useTransition();
  let wasSubmissionRef = React4.useRef(false);
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
  React4.useEffect(() => {
    if (transition.location) {
      positions[location.key] = window.scrollY;
    }
  }, [transition, location]);
  useBeforeUnload(React4.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, []));
  if (typeof document !== "undefined") {
    React4.useLayoutEffect(() => {
      if (!hydrated) {
        hydrated = true;
        return;
      }
      let y = positions[location.key];
      if (y) {
        window.scrollTo(0, y);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (wasSubmissionRef.current === true) {
        wasSubmissionRef.current = false;
        return;
      }
      window.scrollTo(0, 0);
    }, [location]);
  }
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
}

// node_modules/@remix-run/react/esm/server.js
init_react();
var React5 = __toModule(require_react());
function RemixServer({
  context,
  url
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let location = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  };
  let staticNavigator = {
    createHref(to) {
      return typeof to === "string" ? to : I(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    },
    block() {
      throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
    }
  };
  return /* @__PURE__ */ React5.createElement(RemixEntry, {
    context,
    action: r.Pop,
    location,
    navigator: staticNavigator,
    static: true
  });
}

// app/entry.server.jsx
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  const markup = (0, import_server3.renderToString)(/* @__PURE__ */ React.createElement(RemixServer, {
    context: remixContext,
    url: request.url
  }));
  responseHeaders.set("Content-Type", "text/html");
  return new Response("<!DOCTYPE html>" + markup, {
    status: responseStatusCode,
    headers: responseHeaders
  });
}

// route:D:\projects\unikey.org\app\root.jsx
var root_exports = {};
__export(root_exports, {
  default: () => App,
  links: () => links,
  meta: () => meta
});
init_react();
var import_nprogress = __toModule(require_nprogress());

// node_modules/nprogress/nprogress.css
var nprogress_default = "/build/_assets/nprogress-JFUSETFZ.css";

// route:D:\projects\unikey.org\app\root.jsx
var import_react5 = __toModule(require_react());
var links = () => {
  return [
    { rel: "stylesheet", href: nprogress_default }
  ];
};
function meta() {
  return { title: "Unikey - B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t" };
}
function App() {
  const transition = useTransition();
  import_react5.default.useEffect(() => {
    if (transition.state === "idle")
      import_nprogress.default.done();
    else
      import_nprogress.default.start();
  }, [transition.state]);
  return /* @__PURE__ */ import_react5.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react5.default.createElement("head", null, /* @__PURE__ */ import_react5.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react5.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1"
  }), /* @__PURE__ */ import_react5.default.createElement(Meta, null), /* @__PURE__ */ import_react5.default.createElement(Links, null)), /* @__PURE__ */ import_react5.default.createElement("body", null, /* @__PURE__ */ import_react5.default.createElement(Outlet, null), /* @__PURE__ */ import_react5.default.createElement(ScrollRestoration, null), /* @__PURE__ */ import_react5.default.createElement(Scripts, null), /* @__PURE__ */ import_react5.default.createElement(LiveReload, null)));
}

// route:D:\projects\unikey.org\app\routes\index.jsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index
});
init_react();
var import_react6 = __toModule(require_react());
function Index() {
  return /* @__PURE__ */ import_react6.default.createElement("nav", null, /* @__PURE__ */ import_react6.default.createElement("ul", null, /* @__PURE__ */ import_react6.default.createElement("li", null, /* @__PURE__ */ import_react6.default.createElement("strong", null, "UniKey"))), /* @__PURE__ */ import_react6.default.createElement("ul", null, /* @__PURE__ */ import_react6.default.createElement("li", null, /* @__PURE__ */ import_react6.default.createElement("a", {
    href: "#"
  }, "Link")), /* @__PURE__ */ import_react6.default.createElement("li", null, /* @__PURE__ */ import_react6.default.createElement("a", {
    href: "#"
  }, "Link")), /* @__PURE__ */ import_react6.default.createElement("li", null, /* @__PURE__ */ import_react6.default.createElement("a", {
    href: "#"
  }, "Link"))));
}

// server-assets-manifest:@remix-run/dev/assets-manifest
init_react();
var assets_manifest_default = { "version": "80b48ca3", "entry": { "module": "/build/entry.client-IGZ25QHQ.js", "imports": ["/build/_shared/chunk-ZOXDBZZ5.js", "/build/_shared/chunk-E7VMOUYL.js"] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "module": "/build/root-AKURGHBX.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/index": { "id": "routes/index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/index-OHDIJKVC.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false } }, "url": "/build/manifest-80B48CA3.js" };

// server-entry-module:@remix-run/dev/server-build
var entry = { module: entry_server_exports };
var routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: routes_exports
  }
};

// server.js
var handleRequest2 = createPagesFunctionHandler({
  build: server_build_exports,
  mode: "development",
  getLoadContext: (context) => context.env
});
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/**
 * @remix-run/cloudflare-pages v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/** @license React v17.0.2
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vZGV2L2NvbXBpbGVyL3NoaW1zL3JlYWN0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvanNlc2MvanNlc2MuanMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpldmVudHMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpwcm9jZXNzIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9pbmhlcml0cy5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnV0aWwiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpidWZmZXIiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9idWZmZXItbGlzdC5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnN0cmluZ19kZWNvZGVyIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6c3RyZWFtIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6c3RyZWFtIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzIiwgIi4uL3NlcnZlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9nbG9iYWxzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL2Nvb2tpZVNpZ25pbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vc2Vzc2lvbnMvY2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yZXNwb25zZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3NlcnZlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZGF0YS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZW50cnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2Vycm9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vaGVhZGVycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vcm91dGVNYXRjaGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsICIuLi8uLi9wYWNrYWdlcy9yZWFjdC1yb3V0ZXIvaW5kZXgudHN4IiwgIi4uLy4uL3BhY2thZ2VzL3JlYWN0LXJvdXRlci1kb20vaW5kZXgudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9tb2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yb3V0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3NlcnZlckhhbmRvZmYuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vd29ya2VyLmpzIiwgInNlcnZlci1lbnRyeS1tb2R1bGU6QHJlbWl4LXJ1bi9kZXYvc2VydmVyLWJ1aWxkIiwgIi4uL2FwcC9lbnRyeS5zZXJ2ZXIuanN4IiwgIi4uL25vZGVfbW9kdWxlcy9yZW1peC9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9jb21wb25lbnRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9lcnJvckJvdW5kYXJpZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2ludmFyaWFudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbGlua3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTW9kdWxlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbWFya3VwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9yb3V0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2RhdGEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3RyYW5zaXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTWF0Y2hpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3Njcm9sbC1yZXN0b3JhdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vc2VydmVyLmpzIiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb290LmpzeCIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxpbmRleC5qc3giLCAic2VydmVyLWFzc2V0cy1tYW5pZmVzdDpAcmVtaXgtcnVuL2Rldi9hc3NldHMtbWFuaWZlc3QiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCAiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjInO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZXhwb3J0IHsgUmVhY3QgfTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGRlZmF1bHRQYXJzZU9wdGlvbnMgPSB7XG4gIGRlY29kZVZhbHVlczogdHJ1ZSxcbiAgbWFwOiBmYWxzZSxcbiAgc2lsZW50OiBmYWxzZSxcbn07XG5cbmZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiICYmICEhc3RyLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc2V0Q29va2llVmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gc2V0Q29va2llVmFsdWUuc3BsaXQoXCI7XCIpLmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKTtcbiAgdmFyIG5hbWVWYWx1ZSA9IHBhcnRzLnNoaWZ0KCkuc3BsaXQoXCI9XCIpO1xuICB2YXIgbmFtZSA9IG5hbWVWYWx1ZS5zaGlmdCgpO1xuICB2YXIgdmFsdWUgPSBuYW1lVmFsdWUuam9pbihcIj1cIik7IC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0ID0sIGpvaW5lZCBieSBhIFwiPVwiIGlmIHRoZXJlIHdhcyBtb3JlIHRoYW4gb25lIHBhcnRcblxuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucylcbiAgICA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IG9wdGlvbnMuZGVjb2RlVmFsdWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlOyAvLyBkZWNvZGUgY29va2llIHZhbHVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJzZXQtY29va2llLXBhcnNlciBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBkZWNvZGluZyBhIGNvb2tpZSB3aXRoIHZhbHVlICdcIiArXG4gICAgICAgIHZhbHVlICtcbiAgICAgICAgXCInLiBTZXQgb3B0aW9ucy5kZWNvZGVWYWx1ZXMgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXCIsXG4gICAgICBlXG4gICAgKTtcbiAgfVxuXG4gIHZhciBjb29raWUgPSB7XG4gICAgbmFtZTogbmFtZSwgLy8gZ3JhYiBldmVyeXRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgPVxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgfTtcblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdmFyIHNpZGVzID0gcGFydC5zcGxpdChcIj1cIik7XG4gICAgdmFyIGtleSA9IHNpZGVzLnNoaWZ0KCkudHJpbUxlZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IHNpZGVzLmpvaW4oXCI9XCIpO1xuICAgIGlmIChrZXkgPT09IFwiZXhwaXJlc1wiKSB7XG4gICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJtYXgtYWdlXCIpIHtcbiAgICAgIGNvb2tpZS5tYXhBZ2UgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNlY3VyZVwiKSB7XG4gICAgICBjb29raWUuc2VjdXJlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJodHRwb25seVwiKSB7XG4gICAgICBjb29raWUuaHR0cE9ubHkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNhbWVzaXRlXCIpIHtcbiAgICAgIGNvb2tpZS5zYW1lU2l0ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29raWVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvb2tpZTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIGlmICghaW5wdXQpIHtcbiAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5wdXQuaGVhZGVycyAmJiBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXSkge1xuICAgIC8vIGZhc3QtcGF0aCBmb3Igbm9kZS5qcyAod2hpY2ggYXV0b21hdGljYWxseSBub3JtYWxpemVzIGhlYWRlciBuYW1lcyB0byBsb3dlci1jYXNlXG4gICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgfSBlbHNlIGlmIChpbnB1dC5oZWFkZXJzKSB7XG4gICAgLy8gc2xvdy1wYXRoIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBzZWUgIzI1XG4gICAgdmFyIHNjaCA9XG4gICAgICBpbnB1dC5oZWFkZXJzW1xuICAgICAgICBPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwic2V0LWNvb2tpZVwiO1xuICAgICAgICB9KVxuICAgICAgXTtcbiAgICAvLyB3YXJuIGlmIGNhbGxlZCBvbiBhIHJlcXVlc3QtbGlrZSBvYmplY3Qgd2l0aCBhIGNvb2tpZSBoZWFkZXIgcmF0aGVyIHRoYW4gYSBzZXQtY29va2llIGhlYWRlciAtIHNlZSAjMzQsIDM2XG4gICAgaWYgKCFzY2ggJiYgaW5wdXQuaGVhZGVycy5jb29raWUgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiV2FybmluZzogc2V0LWNvb2tpZS1wYXJzZXIgYXBwZWFycyB0byBoYXZlIGJlZW4gY2FsbGVkIG9uIGEgcmVxdWVzdCBvYmplY3QuIEl0IGlzIGRlc2lnbmVkIHRvIHBhcnNlIFNldC1Db29raWUgaGVhZGVycyBmcm9tIHJlc3BvbnNlcywgbm90IENvb2tpZSBoZWFkZXJzIGZyb20gcmVxdWVzdHMuIFNldCB0aGUgb3B0aW9uIHtzaWxlbnQ6IHRydWV9IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaW5wdXQgPSBzY2g7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlucHV0ID0gW2lucHV0XTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvb2tpZXMgPSB7fTtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLnJlZHVjZShmdW5jdGlvbiAoY29va2llcywgc3RyKSB7XG4gICAgICB2YXIgY29va2llID0gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgIGNvb2tpZXNbY29va2llLm5hbWVdID0gY29va2llO1xuICAgICAgcmV0dXJuIGNvb2tpZXM7XG4gICAgfSwgY29va2llcyk7XG4gIH1cbn1cblxuLypcbiAgU2V0LUNvb2tpZSBoZWFkZXIgZmllbGQtdmFsdWVzIGFyZSBzb21ldGltZXMgY29tbWEgam9pbmVkIGluIG9uZSBzdHJpbmcuIFRoaXMgc3BsaXRzIHRoZW0gd2l0aG91dCBjaG9raW5nIG9uIGNvbW1hc1xuICB0aGF0IGFyZSB3aXRoaW4gYSBzaW5nbGUgc2V0LWNvb2tpZSBmaWVsZC12YWx1ZSwgc3VjaCBhcyBpbiB0aGUgRXhwaXJlcyBwb3J0aW9uLlxuXG4gIFRoaXMgaXMgdW5jb21tb24sIGJ1dCBleHBsaWNpdGx5IGFsbG93ZWQgLSBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTYjc2VjdGlvbi00LjJcbiAgTm9kZS5qcyBkb2VzIHRoaXMgZm9yIGV2ZXJ5IGhlYWRlciAqZXhjZXB0KiBzZXQtY29va2llIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2Q1ZTM2M2I3N2ViYWYxY2FmNjdjZDc1MjgyMjRiNjUxYzg2ODE1YzEvbGliL19odHRwX2luY29taW5nLmpzI0wxMjhcbiAgUmVhY3QgTmF0aXZlJ3MgZmV0Y2ggZG9lcyB0aGlzIGZvciAqZXZlcnkqIGhlYWRlciwgaW5jbHVkaW5nIHNldC1jb29raWUuXG5cbiAgQmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvajJvYmpjL2NvbW1pdC8xNjgyMGZkYmM4Zjc2Y2EwYzMzNDcyODEwY2UwY2IwM2QyMGVmZTI1XG4gIENyZWRpdHMgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS90b21iYWxsIGZvciBvcmlnaW5hbCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2NocnVzYXJ0IGZvciBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uXG4qL1xuZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nKGNvb2tpZXNTdHJpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29va2llc1N0cmluZykpIHtcbiAgICByZXR1cm4gY29va2llc1N0cmluZztcbiAgfVxuICBpZiAodHlwZW9mIGNvb2tpZXNTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgY29va2llc1N0cmluZ3MgPSBbXTtcbiAgdmFyIHBvcyA9IDA7XG4gIHZhciBzdGFydDtcbiAgdmFyIGNoO1xuICB2YXIgbGFzdENvbW1hO1xuICB2YXIgbmV4dFN0YXJ0O1xuICB2YXIgY29va2llc1NlcGFyYXRvckZvdW5kO1xuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICBwb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuXG4gICAgcmV0dXJuIGNoICE9PSBcIj1cIiAmJiBjaCAhPT0gXCI7XCIgJiYgY2ggIT09IFwiLFwiO1xuICB9XG5cbiAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBwb3M7XG4gICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoc2tpcFdoaXRlc3BhY2UoKSkge1xuICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICAvLyAnLCcgaXMgYSBjb29raWUgc2VwYXJhdG9yIGlmIHdlIGhhdmUgbGF0ZXIgZmlyc3QgJz0nLCBub3QgJzsnIG9yICcsJ1xuICAgICAgICBsYXN0Q29tbWEgPSBwb3M7XG4gICAgICAgIHBvcyArPSAxO1xuXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIG5leHRTdGFydCA9IHBvcztcblxuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VycmVudGx5IHNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgIC8vIHdlIGZvdW5kIGNvb2tpZXMgc2VwYXJhdG9yXG4gICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAvLyBwb3MgaXMgaW5zaWRlIHRoZSBuZXh0IGNvb2tpZSwgc28gYmFjayB1cCBhbmQgcmV0dXJuIGl0LlxuICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBwYXJhbSAnLCcgb3IgcGFyYW0gc2VwYXJhdG9yICc7JyxcbiAgICAgICAgICAvLyB3ZSBjb250aW51ZSBmcm9tIHRoYXQgY29tbWFcbiAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5zcGxpdENvb2tpZXNTdHJpbmcgPSBzcGxpdENvb2tpZXNTdHJpbmc7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvYmplY3QgPSB7fTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuY29uc3QgZm9yT3duID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG5cdFx0XHRjYWxsYmFjayhrZXksIG9iamVjdFtrZXldKTtcblx0XHR9XG5cdH1cbn07XG5cbmNvbnN0IGV4dGVuZCA9IChkZXN0aW5hdGlvbiwgc291cmNlKSA9PiB7XG5cdGlmICghc291cmNlKSB7XG5cdFx0cmV0dXJuIGRlc3RpbmF0aW9uO1xuXHR9XG5cdGZvck93bihzb3VyY2UsIChrZXksIHZhbHVlKSA9PiB7XG5cdFx0ZGVzdGluYXRpb25ba2V5XSA9IHZhbHVlO1xuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuY29uc3QgZm9yRWFjaCA9IChhcnJheSwgY2FsbGJhY2spID0+IHtcblx0Y29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRsZXQgaW5kZXggPSAtMTtcblx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRjYWxsYmFjayhhcnJheVtpbmRleF0pO1xuXHR9XG59O1xuXG5jb25zdCBmb3VySGV4RXNjYXBlID0gKGhleCkgPT4ge1xuXHRyZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBoZXgpLnNsaWNlKC00KTtcbn1cblxuY29uc3QgaGV4YWRlY2ltYWwgPSAoY29kZSwgbG93ZXJjYXNlKSA9PiB7XG5cdGxldCBoZXhhZGVjaW1hbCA9IGNvZGUudG9TdHJpbmcoMTYpO1xuXHRpZiAobG93ZXJjYXNlKSByZXR1cm4gaGV4YWRlY2ltYWw7XG5cdHJldHVybiBoZXhhZGVjaW1hbC50b1VwcGVyQ2FzZSgpO1xufTtcblxuY29uc3QgdG9TdHJpbmcgPSBvYmplY3QudG9TdHJpbmc7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzQnVmZmVyID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSk7XG59O1xuY29uc3QgaXNPYmplY3QgPSAodmFsdWUpID0+IHtcblx0Ly8gVGhpcyBpcyBhIHZlcnkgc2ltcGxlIGNoZWNrLCBidXQgaXRcdTIwMTlzIGdvb2QgZW5vdWdoIGZvciB3aGF0IHdlIG5lZWQuXG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBPYmplY3RdJztcbn07XG5jb25zdCBpc1N0cmluZyA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG5cdFx0dG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuY29uc3QgaXNOdW1iZXIgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuXHRcdHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xufTtcbmNvbnN0IGlzTWFwID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBNYXBdJztcbn07XG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgU2V0XSc7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZXNjYXBlcyNzaW5nbGVcbmNvbnN0IHNpbmdsZUVzY2FwZXMgPSB7XG5cdCdcXFxcJzogJ1xcXFxcXFxcJyxcblx0J1xcYic6ICdcXFxcYicsXG5cdCdcXGYnOiAnXFxcXGYnLFxuXHQnXFxuJzogJ1xcXFxuJyxcblx0J1xccic6ICdcXFxccicsXG5cdCdcXHQnOiAnXFxcXHQnXG5cdC8vIGBcXHZgIGlzIG9taXR0ZWQgaW50ZW50aW9uYWxseSwgYmVjYXVzZSBpbiBJRSA8IDksICdcXHYnID09ICd2Jy5cblx0Ly8gJ1xcdic6ICdcXFxceDBCJ1xufTtcbmNvbnN0IHJlZ2V4U2luZ2xlRXNjYXBlID0gL1tcXFxcXFxiXFxmXFxuXFxyXFx0XS87XG5cbmNvbnN0IHJlZ2V4RGlnaXQgPSAvWzAtOV0vO1xuY29uc3QgcmVnZXhXaGl0ZXNwYWNlID0gL1tcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vO1xuXG5jb25zdCBlc2NhcGVFdmVyeXRoaW5nUmVnZXggPSAvKFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0pfChbXFx1RDgwMC1cXHVERkZGXSl8KFsnXCJgXSl8W15dL2c7XG5jb25zdCBlc2NhcGVOb25Bc2NpaVJlZ2V4ID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKXwoW1xcdUQ4MDAtXFx1REZGRl0pfChbJ1wiYF0pfFteICEjLSZcXCgtXFxbXFxdLV9hLX5dL2c7XG5cbmNvbnN0IGpzZXNjID0gKGFyZ3VtZW50LCBvcHRpb25zKSA9PiB7XG5cdGNvbnN0IGluY3JlYXNlSW5kZW50YXRpb24gPSAoKSA9PiB7XG5cdFx0b2xkSW5kZW50ID0gaW5kZW50O1xuXHRcdCsrb3B0aW9ucy5pbmRlbnRMZXZlbDtcblx0XHRpbmRlbnQgPSBvcHRpb25zLmluZGVudC5yZXBlYXQob3B0aW9ucy5pbmRlbnRMZXZlbClcblx0fTtcblx0Ly8gSGFuZGxlIG9wdGlvbnNcblx0Y29uc3QgZGVmYXVsdHMgPSB7XG5cdFx0J2VzY2FwZUV2ZXJ5dGhpbmcnOiBmYWxzZSxcblx0XHQnbWluaW1hbCc6IGZhbHNlLFxuXHRcdCdpc1NjcmlwdENvbnRleHQnOiBmYWxzZSxcblx0XHQncXVvdGVzJzogJ3NpbmdsZScsXG5cdFx0J3dyYXAnOiBmYWxzZSxcblx0XHQnZXM2JzogZmFsc2UsXG5cdFx0J2pzb24nOiBmYWxzZSxcblx0XHQnY29tcGFjdCc6IHRydWUsXG5cdFx0J2xvd2VyY2FzZUhleCc6IGZhbHNlLFxuXHRcdCdudW1iZXJzJzogJ2RlY2ltYWwnLFxuXHRcdCdpbmRlbnQnOiAnXFx0Jyxcblx0XHQnaW5kZW50TGV2ZWwnOiAwLFxuXHRcdCdfX2lubGluZTFfXyc6IGZhbHNlLFxuXHRcdCdfX2lubGluZTJfXyc6IGZhbHNlXG5cdH07XG5cdGNvbnN0IGpzb24gPSBvcHRpb25zICYmIG9wdGlvbnMuanNvbjtcblx0aWYgKGpzb24pIHtcblx0XHRkZWZhdWx0cy5xdW90ZXMgPSAnZG91YmxlJztcblx0XHRkZWZhdWx0cy53cmFwID0gdHJ1ZTtcblx0fVxuXHRvcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblx0aWYgKFxuXHRcdG9wdGlvbnMucXVvdGVzICE9ICdzaW5nbGUnICYmXG5cdFx0b3B0aW9ucy5xdW90ZXMgIT0gJ2RvdWJsZScgJiZcblx0XHRvcHRpb25zLnF1b3RlcyAhPSAnYmFja3RpY2snXG5cdCkge1xuXHRcdG9wdGlvbnMucXVvdGVzID0gJ3NpbmdsZSc7XG5cdH1cblx0Y29uc3QgcXVvdGUgPSBvcHRpb25zLnF1b3RlcyA9PSAnZG91YmxlJyA/XG5cdFx0J1wiJyA6XG5cdFx0KG9wdGlvbnMucXVvdGVzID09ICdiYWNrdGljaycgP1xuXHRcdFx0J2AnIDpcblx0XHRcdCdcXCcnXG5cdFx0KTtcblx0Y29uc3QgY29tcGFjdCA9IG9wdGlvbnMuY29tcGFjdDtcblx0Y29uc3QgbG93ZXJjYXNlSGV4ID0gb3B0aW9ucy5sb3dlcmNhc2VIZXg7XG5cdGxldCBpbmRlbnQgPSBvcHRpb25zLmluZGVudC5yZXBlYXQob3B0aW9ucy5pbmRlbnRMZXZlbCk7XG5cdGxldCBvbGRJbmRlbnQgPSAnJztcblx0Y29uc3QgaW5saW5lMSA9IG9wdGlvbnMuX19pbmxpbmUxX187XG5cdGNvbnN0IGlubGluZTIgPSBvcHRpb25zLl9faW5saW5lMl9fO1xuXHRjb25zdCBuZXdMaW5lID0gY29tcGFjdCA/ICcnIDogJ1xcbic7XG5cdGxldCByZXN1bHQ7XG5cdGxldCBpc0VtcHR5ID0gdHJ1ZTtcblx0Y29uc3QgdXNlQmluTnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnYmluYXJ5Jztcblx0Y29uc3QgdXNlT2N0TnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnb2N0YWwnO1xuXHRjb25zdCB1c2VEZWNOdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdkZWNpbWFsJztcblx0Y29uc3QgdXNlSGV4TnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnaGV4YWRlY2ltYWwnO1xuXG5cdGlmIChqc29uICYmIGFyZ3VtZW50ICYmIGlzRnVuY3Rpb24oYXJndW1lbnQudG9KU09OKSkge1xuXHRcdGFyZ3VtZW50ID0gYXJndW1lbnQudG9KU09OKCk7XG5cdH1cblxuXHRpZiAoIWlzU3RyaW5nKGFyZ3VtZW50KSkge1xuXHRcdGlmIChpc01hcChhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5zaXplID09IDApIHtcblx0XHRcdFx0cmV0dXJuICduZXcgTWFwKCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFjb21wYWN0KSB7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUxX18gPSB0cnVlO1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ25ldyBNYXAoJyArIGpzZXNjKEFycmF5LmZyb20oYXJndW1lbnQpLCBvcHRpb25zKSArICcpJztcblx0XHR9XG5cdFx0aWYgKGlzU2V0KGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGFyZ3VtZW50LnNpemUgPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ25ldyBTZXQoKSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ25ldyBTZXQoJyArIGpzZXNjKEFycmF5LmZyb20oYXJndW1lbnQpLCBvcHRpb25zKSArICcpJztcblx0XHR9XG5cdFx0aWYgKGlzQnVmZmVyKGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGFyZ3VtZW50Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnQnVmZmVyLmZyb20oW10pJztcblx0XHRcdH1cblx0XHRcdHJldHVybiAnQnVmZmVyLmZyb20oJyArIGpzZXNjKEFycmF5LmZyb20oYXJndW1lbnQpLCBvcHRpb25zKSArICcpJztcblx0XHR9XG5cdFx0aWYgKGlzQXJyYXkoYXJndW1lbnQpKSB7XG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdG9wdGlvbnMud3JhcCA9IHRydWU7XG5cdFx0XHRpZiAoaW5saW5lMSkge1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMV9fID0gZmFsc2U7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpbmxpbmUyKSB7XG5cdFx0XHRcdGluY3JlYXNlSW5kZW50YXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGZvckVhY2goYXJndW1lbnQsICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpc0VtcHR5ID0gZmFsc2U7XG5cdFx0XHRcdGlmIChpbmxpbmUyKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTJfXyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdChjb21wYWN0IHx8IGlubGluZTIgPyAnJyA6IGluZGVudCkgK1xuXHRcdFx0XHRcdGpzZXNjKHZhbHVlLCBvcHRpb25zKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoaXNFbXB0eSkge1xuXHRcdFx0XHRyZXR1cm4gJ1tdJztcblx0XHRcdH1cblx0XHRcdGlmIChpbmxpbmUyKSB7XG5cdFx0XHRcdHJldHVybiAnWycgKyByZXN1bHQuam9pbignLCAnKSArICddJztcblx0XHRcdH1cblx0XHRcdHJldHVybiAnWycgKyBuZXdMaW5lICsgcmVzdWx0LmpvaW4oJywnICsgbmV3TGluZSkgKyBuZXdMaW5lICtcblx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IG9sZEluZGVudCkgKyAnXSc7XG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihhcmd1bWVudCkpIHtcblx0XHRcdGlmIChqc29uKSB7XG5cdFx0XHRcdC8vIFNvbWUgbnVtYmVyIHZhbHVlcyAoZS5nLiBgSW5maW5pdHlgKSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTi5cblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50KTtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VEZWNOdW1iZXJzKSB7XG5cdFx0XHRcdHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUhleE51bWJlcnMpIHtcblx0XHRcdFx0bGV0IGhleGFkZWNpbWFsID0gYXJndW1lbnQudG9TdHJpbmcoMTYpO1xuXHRcdFx0XHRpZiAoIWxvd2VyY2FzZUhleCkge1xuXHRcdFx0XHRcdGhleGFkZWNpbWFsID0gaGV4YWRlY2ltYWwudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJzB4JyArIGhleGFkZWNpbWFsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUJpbk51bWJlcnMpIHtcblx0XHRcdFx0cmV0dXJuICcwYicgKyBhcmd1bWVudC50b1N0cmluZygyKTtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VPY3ROdW1iZXJzKSB7XG5cdFx0XHRcdHJldHVybiAnMG8nICsgYXJndW1lbnQudG9TdHJpbmcoOCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaXNPYmplY3QoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoanNvbikge1xuXHRcdFx0XHQvLyBGb3Igc29tZSB2YWx1ZXMgKGUuZy4gYHVuZGVmaW5lZGAsIGBmdW5jdGlvbmAgb2JqZWN0cyksXG5cdFx0XHRcdC8vIGBKU09OLnN0cmluZ2lmeSh2YWx1ZSlgIHJldHVybnMgYHVuZGVmaW5lZGAgKHdoaWNoIGlzblx1MjAxOXQgdmFsaWRcblx0XHRcdFx0Ly8gSlNPTikgaW5zdGVhZCBvZiBgJ251bGwnYC5cblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50KSB8fCAnbnVsbCc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcblx0XHR9IGVsc2UgeyAvLyBpdFx1MjAxOXMgYW4gb2JqZWN0XG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdG9wdGlvbnMud3JhcCA9IHRydWU7XG5cdFx0XHRpbmNyZWFzZUluZGVudGF0aW9uKCk7XG5cdFx0XHRmb3JPd24oYXJndW1lbnQsIChrZXksIHZhbHVlKSA9PiB7XG5cdFx0XHRcdGlzRW1wdHkgPSBmYWxzZTtcblx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IGluZGVudCkgK1xuXHRcdFx0XHRcdGpzZXNjKGtleSwgb3B0aW9ucykgKyAnOicgK1xuXHRcdFx0XHRcdChjb21wYWN0ID8gJycgOiAnICcpICtcblx0XHRcdFx0XHRqc2VzYyh2YWx1ZSwgb3B0aW9ucylcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzRW1wdHkpIHtcblx0XHRcdFx0cmV0dXJuICd7fSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ3snICsgbmV3TGluZSArIHJlc3VsdC5qb2luKCcsJyArIG5ld0xpbmUpICsgbmV3TGluZSArXG5cdFx0XHRcdChjb21wYWN0ID8gJycgOiBvbGRJbmRlbnQpICsgJ30nO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHJlZ2V4ID0gb3B0aW9ucy5lc2NhcGVFdmVyeXRoaW5nID8gZXNjYXBlRXZlcnl0aGluZ1JlZ2V4IDogZXNjYXBlTm9uQXNjaWlSZWdleDtcblx0cmVzdWx0ID0gYXJndW1lbnQucmVwbGFjZShyZWdleCwgKGNoYXIsIHBhaXIsIGxvbmUsIHF1b3RlQ2hhciwgaW5kZXgsIHN0cmluZykgPT4ge1xuXHRcdGlmIChwYWlyKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5taW5pbWFsKSByZXR1cm4gcGFpcjtcblx0XHRcdGNvbnN0IGZpcnN0ID0gcGFpci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0Y29uc3Qgc2Vjb25kID0gcGFpci5jaGFyQ29kZUF0KDEpO1xuXHRcdFx0aWYgKG9wdGlvbnMuZXM2KSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHRjb25zdCBjb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuXHRcdFx0XHRjb25zdCBoZXggPSBoZXhhZGVjaW1hbChjb2RlUG9pbnQsIGxvd2VyY2FzZUhleCk7XG5cdFx0XHRcdHJldHVybiAnXFxcXHV7JyArIGhleCArICd9Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKGZpcnN0LCBsb3dlcmNhc2VIZXgpKSArIGZvdXJIZXhFc2NhcGUoaGV4YWRlY2ltYWwoc2Vjb25kLCBsb3dlcmNhc2VIZXgpKTtcblx0XHR9XG5cblx0XHRpZiAobG9uZSkge1xuXHRcdFx0cmV0dXJuIGZvdXJIZXhFc2NhcGUoaGV4YWRlY2ltYWwobG9uZS5jaGFyQ29kZUF0KDApLCBsb3dlcmNhc2VIZXgpKTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRjaGFyID09ICdcXDAnICYmXG5cdFx0XHQhanNvbiAmJlxuXHRcdFx0IXJlZ2V4RGlnaXQudGVzdChzdHJpbmcuY2hhckF0KGluZGV4ICsgMSkpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gJ1xcXFwwJztcblx0XHR9XG5cblx0XHRpZiAocXVvdGVDaGFyKSB7XG5cdFx0XHRpZiAocXVvdGVDaGFyID09IHF1b3RlIHx8IG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZykge1xuXHRcdFx0XHRyZXR1cm4gJ1xcXFwnICsgcXVvdGVDaGFyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1b3RlQ2hhcjtcblx0XHR9XG5cblx0XHRpZiAocmVnZXhTaW5nbGVFc2NhcGUudGVzdChjaGFyKSkge1xuXHRcdFx0Ly8gbm8gbmVlZCBmb3IgYSBgaGFzT3duUHJvcGVydHlgIGNoZWNrIGhlcmVcblx0XHRcdHJldHVybiBzaW5nbGVFc2NhcGVzW2NoYXJdO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLm1pbmltYWwgJiYgIXJlZ2V4V2hpdGVzcGFjZS50ZXN0KGNoYXIpKSB7XG5cdFx0XHRyZXR1cm4gY2hhcjtcblx0XHR9XG5cblx0XHRjb25zdCBoZXggPSBoZXhhZGVjaW1hbChjaGFyLmNoYXJDb2RlQXQoMCksIGxvd2VyY2FzZUhleCk7XG5cdFx0aWYgKGpzb24gfHwgaGV4Lmxlbmd0aCA+IDIpIHtcblx0XHRcdHJldHVybiBmb3VySGV4RXNjYXBlKGhleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdcXFxceCcgKyAoJzAwJyArIGhleCkuc2xpY2UoLTIpO1xuXHR9KTtcblxuXHRpZiAocXVvdGUgPT0gJ2AnKSB7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcJFxcey9nLCAnXFxcXCR7Jyk7XG5cdH1cblx0aWYgKG9wdGlvbnMuaXNTY3JpcHRDb250ZXh0KSB7XG5cdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2V0YWdvXG5cdFx0cmVzdWx0ID0gcmVzdWx0XG5cdFx0XHQucmVwbGFjZSgvPFxcLyhzY3JpcHR8c3R5bGUpL2dpLCAnPFxcXFwvJDEnKVxuXHRcdFx0LnJlcGxhY2UoLzwhLS0vZywganNvbiA/ICdcXFxcdTAwM0MhLS0nIDogJ1xcXFx4M0MhLS0nKTtcblx0fVxuXHRpZiAob3B0aW9ucy53cmFwKSB7XG5cdFx0cmVzdWx0ID0gcXVvdGUgKyByZXN1bHQgKyBxdW90ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuanNlc2MudmVyc2lvbiA9ICczLjAuMic7XG5cbm1vZHVsZS5leHBvcnRzID0ganNlc2M7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tYWluO1xuXG4vLyBUaGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgdG8gc3RvcmUgZXZlbnQgaGFuZGxlcnMuIEluc3RhbnRpYXRpbmcgdGhpcyBpc1xuLy8gZmFzdGVyIHRoYW4gZXhwbGljaXRseSBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCB0byBnZXQgYSBcImNsZWFuXCIgZW1wdHlcbi8vIG9iamVjdCAodGVzdGVkIHdpdGggdjggdjQuOSkuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXJzKCkge31cbkV2ZW50SGFuZGxlcnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuZXhwb3J0IHtFdmVudEVtaXR0ZXJ9O1xuXG4vLyBub2RlanMgb2RkaXR5XG4vLyByZXF1aXJlKCdldmVudHMnKSA9PT0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyXG5cbkV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMgPSBmYWxzZTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5kb21haW4gPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZG9tYWluID0gbnVsbDtcbiAgaWYgKEV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgZG9tYWluLCB0aGVuIGF0dGFjaCB0byBpdC5cbiAgICBpZiAoZG9tYWluLmFjdGl2ZSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBkb21haW4uRG9tYWluKSkge1xuICAgICAgdGhpcy5kb21haW4gPSBkb21haW4uYWN0aXZlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHMsIGRvbWFpbjtcbiAgdmFyIG5lZWREb21haW5FeGl0ID0gZmFsc2U7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZG9tYWluID0gdGhpcy5kb21haW47XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkb21haW4pIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIGVyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50Jyk7XG4gICAgICBlci5kb21haW5FbWl0dGVyID0gdGhpcztcbiAgICAgIGVyLmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgIGVyLmRvbWFpblRocm93biA9IGZhbHNlO1xuICAgICAgZG9tYWluLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIGlmIChuZWVkRG9tYWluRXhpdClcbiAgICBkb21haW4uZXhpdCgpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIHR5cGUgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Jyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGVtaXRXYXJuaW5nKHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBlbWl0V2FybmluZyhlKSB7XG4gIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgPyBjb25zb2xlLndhcm4oZSkgOiBjb25zb2xlLmxvZyhlKTtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGZpcmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICByZXR1cm4gZztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBsaXN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHM7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXk7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH0gd2hpbGUgKGxpc3RlbmVyc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgdmFyIGV2bGlzdGVuZXI7XG4gIHZhciByZXQ7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0ID0gW107XG4gIGVsc2Uge1xuICAgIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKCFldmxpc3RlbmVyKVxuICAgICAgcmV0ID0gW107XG4gICAgZWxzZSBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICByZXQgPSBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXTtcbiAgICBlbHNlXG4gICAgICByZXQgPSB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgaSkge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsICIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbi8vIGJhc2VkIG9mZiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXByb2Nlc3MvYmxvYi9tYXN0ZXIvYnJvd3Nlci5qc1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbnZhciBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuaWYgKHR5cGVvZiBnbG9iYWwuc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xufVxuaWYgKHR5cGVvZiBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xufVxuXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5mdW5jdGlvbiBuZXh0VGljayhmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufVxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnZhciB0aXRsZSA9ICdicm93c2VyJztcbnZhciBwbGF0Zm9ybSA9ICdicm93c2VyJztcbnZhciBicm93c2VyID0gdHJ1ZTtcbnZhciBlbnYgPSB7fTtcbnZhciBhcmd2ID0gW107XG52YXIgdmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xudmFyIHZlcnNpb25zID0ge307XG52YXIgcmVsZWFzZSA9IHt9O1xudmFyIGNvbmZpZyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIG9uID0gbm9vcDtcbnZhciBhZGRMaXN0ZW5lciA9IG5vb3A7XG52YXIgb25jZSA9IG5vb3A7XG52YXIgb2ZmID0gbm9vcDtcbnZhciByZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG52YXIgcmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnZhciBlbWl0ID0gbm9vcDtcblxuZnVuY3Rpb24gYmluZGluZyhuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG5mdW5jdGlvbiBjd2QgKCkgeyByZXR1cm4gJy8nIH1cbmZ1bmN0aW9uIGNoZGlyIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufWZ1bmN0aW9uIHVtYXNrKCkgeyByZXR1cm4gMDsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rdW1hdmlzL2Jyb3dzZXItcHJvY2Vzcy1ocnRpbWUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbnZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCB7fTtcbnZhciBwZXJmb3JtYW5jZU5vdyA9XG4gIHBlcmZvcm1hbmNlLm5vdyAgICAgICAgfHxcbiAgcGVyZm9ybWFuY2UubW96Tm93ICAgICB8fFxuICBwZXJmb3JtYW5jZS5tc05vdyAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm9Ob3cgICAgICAgfHxcbiAgcGVyZm9ybWFuY2Uud2Via2l0Tm93ICB8fFxuICBmdW5jdGlvbigpeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9O1xuXG4vLyBnZW5lcmF0ZSB0aW1lc3RhbXAgb3IgZGVsdGFcbi8vIHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19ocnRpbWVcbmZ1bmN0aW9uIGhydGltZShwcmV2aW91c1RpbWVzdGFtcCl7XG4gIHZhciBjbG9ja3RpbWUgPSBwZXJmb3JtYW5jZU5vdy5jYWxsKHBlcmZvcm1hbmNlKSoxZS0zO1xuICB2YXIgc2Vjb25kcyA9IE1hdGguZmxvb3IoY2xvY2t0aW1lKTtcbiAgdmFyIG5hbm9zZWNvbmRzID0gTWF0aC5mbG9vcigoY2xvY2t0aW1lJTEpKjFlOSk7XG4gIGlmIChwcmV2aW91c1RpbWVzdGFtcCkge1xuICAgIHNlY29uZHMgPSBzZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMF07XG4gICAgbmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcyAtIHByZXZpb3VzVGltZXN0YW1wWzFdO1xuICAgIGlmIChuYW5vc2Vjb25kczwwKSB7XG4gICAgICBzZWNvbmRzLS07XG4gICAgICBuYW5vc2Vjb25kcyArPSAxZTk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbc2Vjb25kcyxuYW5vc2Vjb25kc11cbn1cblxudmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5mdW5jdGlvbiB1cHRpbWUoKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XG4gIHZhciBkaWYgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgcmV0dXJuIGRpZiAvIDEwMDA7XG59XG5cbnZhciBicm93c2VyJDEgPSB7XG4gIG5leHRUaWNrOiBuZXh0VGljayxcbiAgdGl0bGU6IHRpdGxlLFxuICBicm93c2VyOiBicm93c2VyLFxuICBlbnY6IGVudixcbiAgYXJndjogYXJndixcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgdmVyc2lvbnM6IHZlcnNpb25zLFxuICBvbjogb24sXG4gIGFkZExpc3RlbmVyOiBhZGRMaXN0ZW5lcixcbiAgb25jZTogb25jZSxcbiAgb2ZmOiBvZmYsXG4gIHJlbW92ZUxpc3RlbmVyOiByZW1vdmVMaXN0ZW5lcixcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiByZW1vdmVBbGxMaXN0ZW5lcnMsXG4gIGVtaXQ6IGVtaXQsXG4gIGJpbmRpbmc6IGJpbmRpbmcsXG4gIGN3ZDogY3dkLFxuICBjaGRpcjogY2hkaXIsXG4gIHVtYXNrOiB1bWFzayxcbiAgaHJ0aW1lOiBocnRpbWUsXG4gIHBsYXRmb3JtOiBwbGF0Zm9ybSxcbiAgcmVsZWFzZTogcmVsZWFzZSxcbiAgY29uZmlnOiBjb25maWcsXG4gIHVwdGltZTogdXB0aW1lXG59O1xuXG5leHBvcnQgZGVmYXVsdCBicm93c2VyJDE7XG5leHBvcnQgeyBhZGRMaXN0ZW5lciwgYXJndiwgYmluZGluZywgYnJvd3NlciwgY2hkaXIsIGNvbmZpZywgY3dkLCBlbWl0LCBlbnYsIGhydGltZSwgbmV4dFRpY2ssIG9mZiwgb24sIG9uY2UsIHBsYXRmb3JtLCByZWxlYXNlLCByZW1vdmVBbGxMaXN0ZW5lcnMsIHJlbW92ZUxpc3RlbmVyLCB0aXRsZSwgdW1hc2ssIHVwdGltZSwgdmVyc2lvbiwgdmVyc2lvbnMgfTtcbiIsICJcbnZhciBpbmhlcml0cztcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGluaGVyaXRzO1xuIiwgIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnQgZnVuY3Rpb24gZGVidWdsb2coc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gMDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBfZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnVmZmVyKG1heWJlQnVmKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIobWF5YmVCdWYpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnQgZnVuY3Rpb24gbG9nKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG59XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmltcG9ydCBpbmhlcml0cyBmcm9tICcuL2luaGVyaXRzJztcbmV4cG9ydCB7aW5oZXJpdHN9XG5cbmV4cG9ydCBmdW5jdGlvbiBfZXh0ZW5kKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgX2V4dGVuZDogX2V4dGVuZCxcbiAgbG9nOiBsb2csXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc0Vycm9yOiBpc0Vycm9yLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNTeW1ib2w6IGlzU3ltYm9sLFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuICBpc051bGw6IGlzTnVsbCxcbiAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGluc3BlY3Q6IGluc3BlY3QsXG4gIGRlcHJlY2F0ZTogZGVwcmVjYXRlLFxuICBmb3JtYXQ6IGZvcm1hdCxcbiAgZGVidWdsb2c6IGRlYnVnbG9nXG59XG4iLCAidmFyIGxvb2t1cCA9IFtdO1xudmFyIHJldkxvb2t1cCA9IFtdO1xudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbnZhciBpbml0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXQgKCkge1xuICBpbml0ZWQgPSB0cnVlO1xuICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMDtcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG5cbiAgdmFyIEwgPSAwO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKTtcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz09JztcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9JztcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KTtcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IC03O1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwO1xuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7XG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmZ1bmN0aW9uIHdyaXRlIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYztcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCk7XG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSk7XG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufVxuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0cnVlO1xuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG52YXIgX2tNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKCk7XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICByZXR1cm4gYXJyXG59O1xuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn07XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59O1xuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpO1xuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKTtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aDsgLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7XG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cbmV4cG9ydCB7IEJ1ZmZlciwgSU5TUEVDVF9NQVhfQllURVMsIFNsb3dCdWZmZXIsIGlzQnVmZmVyLCBfa01heExlbmd0aCBhcyBrTWF4TGVuZ3RoIH07XG4iLCAiaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAocCkge1xuICAgIHAuZGF0YS5jb3B5KHJldCwgaSk7XG4gICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbmV4cG9ydCBmdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtpbmhlcml0cywgZGVidWdsb2d9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IEJ1ZmZlckxpc3QgZnJvbSAnLi9idWZmZXItbGlzdCc7XG5pbXBvcnQge1N0cmluZ0RlY29kZXJ9IGZyb20gJ3N0cmluZ19kZWNvZGVyJztcbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL2R1cGxleCc7XG5pbXBvcnQge25leHRUaWNrfSBmcm9tICdwcm9jZXNzJztcblxudmFyIGRlYnVnID0gZGVidWdsb2coJ3N0cmVhbScpO1xuaW5oZXJpdHMoUmVhZGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSlcbiAgICAgIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtcbiAgICBlbHNlXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbiAgfVxufVxuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBSZWFkYWJsZTtcbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgbmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIG5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSk7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBuZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAobGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBzcmMubGlzdGVuZXJzKCdkYXRhJykubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcbiAgICAgIGRlc3RzW19pXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIG5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgbmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCAiLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5cbmltcG9ydCB7aW5oZXJpdHMsIGRlcHJlY2F0ZX0gZnJvbSAndXRpbCc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5pbmhlcml0cyhXcml0YWJsZSwgRXZlbnRFbWl0dGVyKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcicsIHtcbiAgICBnZXQ6IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicpXG4gIH0pO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBXcml0YWJsZTtcbmV4cG9ydCBmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgbmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIG5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgbmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgICBuZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIG5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZW50cnkgPSBfdGhpcy5lbnRyeTtcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXJyKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBfdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XG4gICAgfVxuICB9O1xufVxuIiwgIlxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbXBvcnQge25leHRUaWNrfSBmcm9tICdwcm9jZXNzJztcbmltcG9ydCB7UmVhZGFibGV9IGZyb20gJy4vcmVhZGFibGUnO1xuaW1wb3J0IHtXcml0YWJsZX0gZnJvbSAnLi93cml0YWJsZSc7XG5cblxuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuZXhwb3J0IGRlZmF1bHQgRHVwbGV4O1xuZXhwb3J0IGZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIG5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cbiIsICIvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cblxuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vZHVwbGV4JztcblxuXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3JtO1xuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwgIlxuaW1wb3J0IHtUcmFuc2Zvcm19IGZyb20gJy4vdHJhbnNmb3JtJztcblxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcbmV4cG9ydCBkZWZhdWx0IFBhc3NUaHJvdWdoO1xuZXhwb3J0IGZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwgImltcG9ydCBFRSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnO1xuaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnO1xuaW1wb3J0IHtXcml0YWJsZX0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnO1xuaW1wb3J0IHtUcmFuc2Zvcm19IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge1Bhc3NUaHJvdWdofSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyc7XG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IFJlYWRhYmxlO1xuU3RyZWFtLldyaXRhYmxlID0gV3JpdGFibGU7XG5TdHJlYW0uRHVwbGV4ID0gRHVwbGV4O1xuU3RyZWFtLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IFBhc3NUaHJvdWdoO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuZXhwb3J0IGRlZmF1bHQgU3RyZWFtO1xuZXhwb3J0IHtSZWFkYWJsZSxXcml0YWJsZSxEdXBsZXgsVHJhbnNmb3JtLFBhc3NUaHJvdWdoLFN0cmVhbX1cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsICJcbmNvbnN0IHBvbHlmaWxsID0gcmVxdWlyZSgnc3RyZWFtJylcblxuaWYgKHBvbHlmaWxsICYmIHBvbHlmaWxsLmRlZmF1bHQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsLmRlZmF1bHRcbiAgICBmb3IgKGxldCBrIGluIHBvbHlmaWxsKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzW2tdID0gcG9seWZpbGxba11cbiAgICB9XG59IGVsc2UgaWYgKHBvbHlmaWxsKSAge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWZpbGxcbn1cblxuXG4iLCAiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzIHdpdGhcbi8vIHRlbXBsYXRlIGxpdGVyYWwgc3RyaW5ncy4gVGhlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuLy8gZHVyaW5nIGJ1aWxkLlxuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHZhciB1cmwgPSAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB1cmwgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiICsgY29kZSArIFwiOyB2aXNpdCBcIiArIHVybCArIFwiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIFwiICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgJyArICdoZWxwZnVsIHdhcm5pbmdzLic7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyID0gZmFsc2U7XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KSB7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcblxuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG5cbiAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgfVxuXG4gIHJldHVybiBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAge1xuICAgIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgJ0NvbXBvbmVudCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCkge1xuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzbG90cyBpbiB0aGlzIGNvbnRleHQgdG8gc3RvcmUgdGhpcyB0aHJlYWRJRCxcbiAgLy8gZmlsbCBpdCBpbiB3aXRob3V0IGxlYXZpbmcgYW55IGhvbGVzIHRvIGVuc3VyZSB0aGF0IHRoZSBWTSBvcHRpbWl6ZXNcbiAgLy8gdGhpcyBhcyBub24taG9sZXkgaW5kZXggcHJvcGVydGllcy5cbiAgLy8gKE5vdGU6IElmIGByZWFjdGAgcGFja2FnZSBpcyA8IDE2LjYsIF90aHJlYWRDb3VudCBpcyB1bmRlZmluZWQuKVxuICBmb3IgKHZhciBpID0gY29udGV4dC5fdGhyZWFkQ291bnQgfCAwOyBpIDw9IHRocmVhZElEOyBpKyspIHtcbiAgICAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0VmFsdWUgd2hpY2ggbWlnaHQgbm90IGJlXG4gICAgLy8gdHJ1ZSBpZiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIGEgc2Vjb25kYXJ5IHJlbmRlcmVyIGJ1dCB0aGV5IGFyZVxuICAgIC8vIHNlY29uZGFyeSBiZWNhdXNlIHRoZXNlIHVzZSBjYXNlcyBhcmUgdmVyeSByYXJlLlxuICAgIGNvbnRleHRbaV0gPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gaSArIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDb250ZXh0KHR5cGUsIGNvbnRleHQsIHRocmVhZElELCBpc0NsYXNzKSB7XG4gIGlmIChpc0NsYXNzKSB7XG4gICAgdmFyIGNvbnRleHRUeXBlID0gdHlwZS5jb250ZXh0VHlwZTtcblxuICAgIHtcbiAgICAgIGlmICgnY29udGV4dFR5cGUnIGluIHR5cGUpIHtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZCh0eXBlKTtcbiAgICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnLCBhZGRlbmR1bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHRUeXBlLCB0aHJlYWRJRCk7XG4gICAgICByZXR1cm4gY29udGV4dFR5cGVbdGhyZWFkSURdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tDb250ZXh0VHlwZXModHlwZS5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHZhciBfbWFza2VkQ29udGV4dCA9IG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIGNoZWNrQ29udGV4dFR5cGVzKHR5cGUuY29udGV4dFR5cGVzLCBfbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21hc2tlZENvbnRleHQ7XG4gICAgfVxuICB9XG59XG5cbnZhciBuZXh0QXZhaWxhYmxlVGhyZWFkSURzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbaV0gPSBpICsgMTtcbn1cblxubmV4dEF2YWlsYWJsZVRocmVhZElEc1sxNV0gPSAwO1xuXG5mdW5jdGlvbiBncm93VGhyZWFkQ291bnRBbmRSZXR1cm5OZXh0QXZhaWxhYmxlKCkge1xuICB2YXIgb2xkQXJyYXkgPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzO1xuICB2YXIgb2xkU2l6ZSA9IG9sZEFycmF5Lmxlbmd0aDtcbiAgdmFyIG5ld1NpemUgPSBvbGRTaXplICogMjtcblxuICBpZiAoIShuZXdTaXplIDw9IDB4MTAwMDApKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiTWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBSZWFjdCByZW5kZXJlcnMgZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5vdCBwcm9wZXJseSBkZXN0cm95aW5nIHRoZSBSZWFkYWJsZSBwcm92aWRlZCBieSBSZWFjdC4gRW5zdXJlIHRoYXQgeW91IGNhbGwgLmRlc3Ryb3koKSBvbiBpdCBpZiB5b3Ugbm8gbG9uZ2VyIHdhbnQgdG8gcmVhZCBmcm9tIGl0LCBhbmQgZGlkIG5vdCByZWFkIHRvIHRoZSBlbmQuIElmIHlvdSB1c2UgLnBpcGUoKSB0aGlzIHNob3VsZCBiZSBhdXRvbWF0aWMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDE2QXJyYXkobmV3U2l6ZSk7XG4gIG5ld0FycmF5LnNldChvbGRBcnJheSk7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHMgPSBuZXdBcnJheTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IG9sZFNpemUgKyAxO1xuXG4gIGZvciAodmFyIF9pID0gb2xkU2l6ZTsgX2kgPCBuZXdTaXplIC0gMTsgX2krKykge1xuICAgIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbX2ldID0gX2kgKyAxO1xuICB9XG5cbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tuZXdTaXplIC0gMV0gPSAwO1xuICByZXR1cm4gb2xkU2l6ZTtcbn1cblxuZnVuY3Rpb24gYWxsb2NUaHJlYWRJRCgpIHtcbiAgdmFyIG5leHRJRCA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF07XG5cbiAgaWYgKG5leHRJRCA9PT0gMCkge1xuICAgIHJldHVybiBncm93VGhyZWFkQ291bnRBbmRSZXR1cm5OZXh0QXZhaWxhYmxlKCk7XG4gIH1cblxuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1tuZXh0SURdO1xuICByZXR1cm4gbmV4dElEO1xufVxuZnVuY3Rpb24gZnJlZVRocmVhZElEKGlkKSB7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbaWRdID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IGlkO1xufVxuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuLyoqXG4gKiBFc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgSFRNTCBlbnRpdGllcyBpbiBhIGdpdmVuIGh0bWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIEhUTUwgc3RyaW5nIHRvIGVzY2FwZSBmb3IgbGF0ZXIgaW5zZXJ0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufSAvLyBlbmQgY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICBpZiAodHlwZW9mIHRleHQgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyB0aGlzIHNob3J0Y2lyY3VpdCBoZWxwcyBwZXJmIGZvciB0eXBlcyB0aGF0IHdlIGtub3cgd2lsbCBuZXZlciBoYXZlXG4gICAgLy8gc3BlY2lhbCBjaGFyYWN0ZXJzLCBlc3BlY2lhbGx5IGdpdmVuIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIG9mdGVuXG4gICAgLy8gZm9yIG51bWVyaWMgZG9tIGlkcy5cbiAgICByZXR1cm4gJycgKyB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGVzY2FwZUh0bWwodGV4dCk7XG59XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JSb290KCkge1xuICByZXR1cm4gUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG59XG4vKipcbiAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgdmFyIHR5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcblxuICAgIGlmICh0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTiAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgc2FuaXRpemVVUkwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlclwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gY29tcG9uZW50SWRlbnRpdHk7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIC8vIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbn1cbmZ1bmN0aW9uIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuLCByZWZPckNvbnRleHQpIHtcbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBldmVyeSBmdW5jdGlvbiBjb21wb25lbnQgdG8gcHJldmVudCBob29rcyBmcm9tXG4gIC8vIGJlaW5nIHVzZWQgaW4gY2xhc3Nlcy5cbiAgd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBVcGRhdGVzIHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGV5IGFyZSBzdG9yZWQgaW5cbiAgICAvLyB0aGUgYHJlbmRlclBoYXNlVXBkYXRlc2AgbWFwLiBDYWxsIHRoZSBjb21wb25lbnQgYWdhaW4sIHJldXNpbmcgdGhlXG4gICAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rcyBhbmQgYXBwbHlpbmcgdGhlIGFkZGl0aW9uYWwgdXBkYXRlcyBvbiB0b3AuIEtlZXBcbiAgICAvLyByZXN0YXJ0aW5nIHVudGlsIG5vIG1vcmUgdXBkYXRlcyBhcmUgc2NoZWR1bGVkLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxOyAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgfVxuXG4gIHJlc2V0SG9va3NTdGF0ZSgpO1xuICByZXR1cm4gY2hpbGRyZW47XG59IC8vIFJlc2V0IHRoZSBpbnRlcm5hbCBob29rcyBzdGF0ZSBpZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgcmVuZGVyaW5nIGEgY29tcG9uZW50XG5cbmZ1bmN0aW9uIHJlc2V0SG9va3NTdGF0ZSgpIHtcbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciB0aHJlYWRJRCA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIudGhyZWFkSUQ7XG4gIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG5cbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGV4dFt0aHJlYWRJRF07XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgfVxuXG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgdmFyIHRocmVhZElEID0gY3VycmVudFBhcnRpYWxSZW5kZXJlci50aHJlYWRJRDtcbiAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcbiAgcmV0dXJuIGNvbnRleHRbdGhyZWFkSURdO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gIH1cblxuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgLy8gdXNlUmVkdWNlciBoYXMgYSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBsYXp5IHVzZVN0YXRlIGluaXRpYWxpemVyc1xuICBpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHtcbiAgICBpZiAocmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIGN1cnJlbnQgaG9vay5cbiAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYHVzZVN0YXRlYC5cbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbiAgICB2YXIgX3F1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0ge1xuICAgICAgbGFzdDogbnVsbCxcbiAgICAgIGRpc3BhdGNoOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBfZGlzcGF0Y2ggPSBfcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCwgX3F1ZXVlKTtcblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIF9kaXNwYXRjaF07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZpb3VzUmVmID09PSBudWxsKSB7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICAgIH07XG5cbiAgICB7XG4gICAgICBPYmplY3Quc2VhbChyZWYpO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICAgIHJldHVybiByZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZpb3VzUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGlucHV0cykge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcblxuICAgIGVycm9yKCd1c2VMYXlvdXRFZmZlY3QgZG9lcyBub3RoaW5nIG9uIHRoZSBzZXJ2ZXIsIGJlY2F1c2UgaXRzIGVmZmVjdCBjYW5ub3QgJyArIFwiYmUgZW5jb2RlZCBpbnRvIHRoZSBzZXJ2ZXIgcmVuZGVyZXIncyBvdXRwdXQgZm9ybWF0LiBUaGlzIHdpbGwgbGVhZCBcIiArICd0byBhIG1pc21hdGNoIGJldHdlZW4gdGhlIGluaXRpYWwsIG5vbi1oeWRyYXRlZCBVSSBhbmQgdGhlIGludGVuZGVkICcgKyAnVUkuIFRvIGF2b2lkIHRoaXMsIHVzZUxheW91dEVmZmVjdCBzaG91bGQgb25seSBiZSB1c2VkIGluICcgKyAnY29tcG9uZW50cyB0aGF0IHJlbmRlciBleGNsdXNpdmVseSBvbiB0aGUgY2xpZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdXNlbGF5b3V0ZWZmZWN0LXNzciBmb3IgY29tbW9uIGZpeGVzLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGNvbXBvbmVudElkZW50aXR5LCBxdWV1ZSwgYWN0aW9uKSB7XG4gIGlmICghKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSwgZGVwcyk7XG59IC8vIFRPRE8gRGVjaWRlIG9uIGhvdyB0byBpbXBsZW1lbnQgdGhpcyBob29rIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuLy8gSWYgYSBtdXRhdGlvbiBvY2N1cnMgZHVyaW5nIHJlbmRlciwgY29uc2lkZXIgdHJpZ2dlcmluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4vLyBhbmQgZmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuXG4gIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIHJldHVybiBbc3RhcnRUcmFuc2l0aW9uLCBmYWxzZV07XG59XG5cbmZ1bmN0aW9uIHVzZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHJldHVybiAoY3VycmVudFBhcnRpYWxSZW5kZXJlci5pZGVudGlmaWVyUHJlZml4IHx8ICcnKSArICdSOicgKyAoY3VycmVudFBhcnRpYWxSZW5kZXJlci51bmlxdWVJRCsrKS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgY3VycmVudFBhcnRpYWxSZW5kZXJlciA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gIGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIgPSByZW5kZXJlcjtcbn1cbnZhciBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUxheW91dEVmZmVjdDogdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIC8vIHVzZUltcGVyYXRpdmVIYW5kbGUgaXMgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AsXG4gIC8vIEVmZmVjdHMgYXJlIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlRWZmZWN0OiBub29wLFxuICAvLyBEZWJ1Z2dpbmcgZWZmZWN0XG4gIHVzZURlYnVnVmFsdWU6IG5vb3AsXG4gIHVzZURlZmVycmVkVmFsdWU6IHVzZURlZmVycmVkVmFsdWUsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb24sXG4gIHVzZU9wYXF1ZUlkZW50aWZpZXI6IHVzZU9wYXF1ZUlkZW50aWZpZXIsXG4gIC8vIFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzZXR1cCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlTXV0YWJsZVNvdXJjZTogdXNlTXV0YWJsZVNvdXJjZVxufTtcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07IC8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cblxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfSAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cblxuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICBidXR0b246IHRydWUsXG4gIGNoZWNrYm94OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgaGlkZGVuOiB0cnVlLFxuICByYWRpbzogdHJ1ZSxcbiAgcmVzZXQ6IHRydWUsXG4gIHN1Ym1pdDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICghKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMub25JbnB1dCB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy52YWx1ZSA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuXG4gICAgaWYgKCEocHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuY2hlY2tlZCA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuXG5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggdGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKCFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiYgcHJvcHMuY29udGVudEVkaXRhYmxlICYmIHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIiApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIGVycm9yKCdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cblxuXG4gICAgaWYgKGV2ZW50UmVnaXN0cnkgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSBldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG4gICAgICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcblxuXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgZXJyb3IoJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2FyaWEnKSB7XG4gICAgICBlcnJvcignVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgKyAnUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgdHlwZW9mIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIG5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgICB2YXIgaXNSZXNlcnZlZCA9IHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQ7IC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBlcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLCBuYW1lLCBsb3dlckNhc2VkTmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG5cblxuICAgIGlmIChpc1Jlc2VydmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG5cblxuICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG5cblxuICAgIGlmICgodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykgJiYgcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJyArICclcyAnICsgJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS4nIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIHZhciB1bmtub3duUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KTtcbn1cblxudmFyIHRvQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5OyAvLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBERVYuXG4vLyBFYWNoIGVudHJ5IGlzIGB0aGlzLnN0YWNrYCBmcm9tIGEgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXJlciBpbnN0YW5jZS5cbi8vIChUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBiZWNhdXNlIFJlYWN0RE9NU2VydmVyIGlzIHJlZW50cmFudCkuXG4vLyBFYWNoIHN0YWNrIGlzIGFuIGFycmF5IG9mIGZyYW1lcyB3aGljaCBtYXkgY29udGFpbiBuZXN0ZWQgc3RhY2tzIG9mIGVsZW1lbnRzLlxuXG52YXIgY3VycmVudERlYnVnU3RhY2tzID0gW107XG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDE7XG52YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuXG52YXIgZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIGRlc2NyaWJlU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiAnJztcbn07XG5cbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7fTtcblxudmFyIHB1c2hDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge307XG5cbnZhciBwdXNoRWxlbWVudFRvRGVidWdTdGFjayA9IGZ1bmN0aW9uIChlbGVtZW50KSB7fTtcblxudmFyIHBvcEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgbnVsbCk7XG4gIH07XG5cbiAgZGVzY3JpYmVTdGFja0ZyYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBudWxsKTtcbiAgfTtcblxuICBwdXNoQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucHVzaChzdGFjayk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gV2UgYXJlIGVudGVyaW5nIGEgc2VydmVyIHJlbmRlcmVyLlxuICAgICAgLy8gUmVtZW1iZXIgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGw7XG4gICAgfVxuICB9O1xuXG4gIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBGb3IgdGhlIGlubmVybW9zdCBleGVjdXRpbmcgUmVhY3RET01TZXJ2ZXIgY2FsbCxcbiAgICB2YXIgc3RhY2sgPSBjdXJyZW50RGVidWdTdGFja3NbY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCAtIDFdOyAvLyBUYWtlIHRoZSBpbm5lcm1vc3QgZXhlY3V0aW5nIGZyYW1lIChlLmcuIDxGb28+KSxcblxuICAgIHZhciBmcmFtZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdOyAvLyBhbmQgcmVjb3JkIHRoYXQgaXQgaGFzIG9uZSBtb3JlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG4gICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTsgLy8gV2Ugb25seSBuZWVkIHRoaXMgYmVjYXVzZSB3ZSB0YWlsLW9wdGltaXplIHNpbmdsZS1lbGVtZW50XG4gICAgLy8gY2hpbGRyZW4gYW5kIGRpcmVjdGx5IGhhbmRsZSB0aGVtIGluIGFuIGlubmVyIGxvb3AgaW5zdGVhZCBvZlxuICAgIC8vIGNyZWF0aW5nIHNlcGFyYXRlIGZyYW1lcyBmb3IgdGhlbS5cbiAgfTtcblxuICBwb3BDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucG9wKCk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gV2UgYXJlIGV4aXRpbmcgdGhlIHNlcnZlciByZW5kZXJlci5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsO1xuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBSZWFjdERPTVNlcnZlciBpcyByZWVudHJhbnQgc28gdGhlcmUgbWF5IGJlIG11bHRpcGxlIGNhbGxzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gVGFrZSB0aGUgZnJhbWVzIGZyb20gdGhlIGlubmVybW9zdCBjYWxsIHdoaWNoIGlzIHRoZSBsYXN0IGluIHRoZSBhcnJheS5cblxuXG4gICAgdmFyIGZyYW1lcyA9IGN1cnJlbnREZWJ1Z1N0YWNrc1tjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoIC0gMV07XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEdvIHRocm91Z2ggZXZlcnkgZnJhbWUgaW4gdGhlIHN0YWNrIGZyb20gdGhlIGlubmVybW9zdCBvbmUuXG5cbiAgICBmb3IgKHZhciBpID0gZnJhbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaV07IC8vIEV2ZXJ5IGZyYW1lIG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBkZWJ1ZyBlbGVtZW50IHN0YWNrIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBzaW5nbGUtY2hpbGQgbmVzdGluZyBkb2Vzbid0IGNyZWF0ZSBtYXRlcmlhbGl6ZWQgZnJhbWVzLlxuICAgICAgLy8gSW5zdGVhZCBpdCB3b3VsZCBwdXNoIHRoZW0gdGhyb3VnaCBgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soKWAuXG5cbiAgICAgIHZhciBkZWJ1Z0VsZW1lbnRTdGFjayA9IGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrO1xuXG4gICAgICBmb3IgKHZhciBpaSA9IGRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgc3RhY2sgKz0gZGVzY3JpYmVTdGFja0ZyYW1lKGRlYnVnRWxlbWVudFN0YWNrW2lpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG52YXIgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IHt9O1xudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgbGlzdGluZzogdHJ1ZSxcbiAgcHJlOiB0cnVlLFxuICB0ZXh0YXJlYTogdHJ1ZVxufTsgLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcblxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIXZhbGlkYXRlZFRhZ0NhY2hlLmhhc093blByb3BlcnR5KHRhZykpIHtcbiAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB0YWc6IFwiICsgdGFnICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxudmFyIHN0eWxlTmFtZUNhY2hlID0ge307XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICBpZiAoc3R5bGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgIHJldHVybiBzdHlsZU5hbWVDYWNoZVtzdHlsZU5hbWVdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xuICBzdHlsZU5hbWVDYWNoZVtzdHlsZU5hbWVdID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHN0eWxlcykge1xuICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICB2YXIgZGVsaW1pdGVyID0gJyc7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyAoaXNDdXN0b21Qcm9wZXJ0eSA/IHN0eWxlTmFtZSA6IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSkgKyAnOic7XG4gICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgIGRlbGltaXRlciA9ICc7JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIGdldENvbXBvbmVudE5hbWUoX2NvbnN0cnVjdG9yKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uQ2hpbGRyZW5Jbm5lck1hcmt1cChwcm9wcykge1xuICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlubmVySFRNTC5fX2h0bWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuVG9wTGV2ZWxDaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGNoaWxkcmVuKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY2hpbGRyZW47XG5cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHJldHVybiBbZWxlbWVudF07XG4gIH1cblxuICB2YXIgZnJhZ21lbnRDaGlsZHJlbiA9IGVsZW1lbnQucHJvcHMuY2hpbGRyZW47XG5cbiAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChmcmFnbWVudENoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGZyYWdtZW50Q2hpbGRyZW4pO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50Q2hpbGRFbGVtZW50ID0gZnJhZ21lbnRDaGlsZHJlbjtcbiAgcmV0dXJuIFtmcmFnbWVudENoaWxkRWxlbWVudF07XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiAmJiB0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBjaGlsZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbCxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiBudWxsXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVPcGVuVGFnTWFya3VwKHRhZ1ZlcmJhdGltLCB0YWdMb3dlcmNhc2UsIHByb3BzLCBuYW1lc3BhY2UsIG1ha2VTdGF0aWNNYXJrdXAsIGlzUm9vdEVsZW1lbnQpIHtcbiAgdmFyIHJldCA9ICc8JyArIHRhZ1ZlcmJhdGltO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnQkMSA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZ0xvd2VyY2FzZSwgcHJvcHMpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDIuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBwcm9wVmFsdWUgPSBjcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgbWFya3VwID0gbnVsbDtcblxuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudCQxKSB7XG4gICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIG1hcmt1cCA9IGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChtYXJrdXApIHtcbiAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgfVxuICB9IC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAvLyBieXRlcy5cblxuXG4gIGlmIChtYWtlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChpc1Jvb3RFbGVtZW50KSB7XG4gICAgcmV0ICs9ICcgJyArIGNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVuZGVyUmVzdWx0KGNoaWxkLCB0eXBlKSB7XG4gIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggKGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCcpICsgXCIoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKGNoaWxkLCBjb250ZXh0LCB0aHJlYWRJRCkge1xuICB3aGlsZSAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgLy8gU2FmZSBiZWNhdXNlIHdlIGp1c3QgY2hlY2tlZCBpdCdzIGFuIGVsZW1lbnQuXG4gICAgdmFyIGVsZW1lbnQgPSBjaGlsZDtcbiAgICB2YXIgQ29tcG9uZW50ID0gZWxlbWVudC50eXBlO1xuXG4gICAge1xuICAgICAgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByb2Nlc3NDaGlsZChlbGVtZW50LCBDb21wb25lbnQpO1xuICB9IC8vIEV4dHJhIGNsb3N1cmUgc28gcXVldWUgYW5kIHJlcGxhY2UgY2FuIGJlIGNhcHR1cmVkIHByb3Blcmx5XG5cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGQoZWxlbWVudCwgQ29tcG9uZW50KSB7XG4gICAgdmFyIGlzQ2xhc3MgPSBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gcHJvY2Vzc0NvbnRleHQoQ29tcG9uZW50LCBjb250ZXh0LCB0aHJlYWRJRCwgaXNDbGFzcyk7XG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHJlcGxhY2UgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRlciA9IHtcbiAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICAgICAgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIHF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgICAgfSxcbiAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjdXJyZW50UGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnB1c2goY3VycmVudFBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW5zdDtcblxuICAgIGlmIChpc0NsYXNzKSB7XG4gICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcblxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaW5zdC5zdGF0ZSA9PT0gbnVsbCB8fCBpbnN0LnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0LnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuY2FsbChudWxsLCBlbGVtZW50LnByb3BzLCBpbnN0LnN0YXRlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBfYXNzaWduKHt9LCBpbnN0LnN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgICAgIGVycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyKTtcblxuICAgICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICAgICAgcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgaW5zdCA9IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcbiAgICAgIGluc3QgPSBmaW5pc2hIb29rcyhDb21wb25lbnQsIGVsZW1lbnQucHJvcHMsIGluc3QsIHB1YmxpY0NvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG4gICAgICAgIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5yZW5kZXIgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMywgX2NvbXBvbmVudE5hbWUzLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB0aGUgZmxhZyBpcyBvbiwgZXZlcnl0aGluZyBpcyBhc3N1bWVkIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50LlxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhbHNvIGRvIHRoZSB1bmZvcnR1bmF0ZSBkeW5hbWljIGNoZWNrcy5cblxuXG4gICAgICBpZiAoIGluc3QgPT0gbnVsbCB8fCBpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gaW5zdDtcbiAgICAgICAgdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0LnByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG5cbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBpbnN0LmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWU0ID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgICAgICAgd2FybiggLy8ga2VlcCB0aGlzIHdhcm5pbmcgaW4gc3luYyB3aXRoIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmcuanNcbiAgICAgICAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBhbnkgY29tcG9uZW50IHdpdGggdGhlIG5ldyBnRFNGUC5cblxuXG4gICAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgYW55IGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgZ0RTRlAuXG4gICAgICAgIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvbGRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB2YXIgb2xkUmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgICAgcmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvbGRSZXBsYWNlICYmIG9sZFF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gb2xkUmVwbGFjZSA/IG9sZFF1ZXVlWzBdIDogaW5zdC5zdGF0ZTtcbiAgICAgICAgICB2YXIgZG9udE11dGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gb2xkUXVldWVbaV07XG5cbiAgICAgICAgICAgIHZhciBfcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0KSA6IHBhcnRpYWw7XG5cbiAgICAgICAgICAgIGlmIChfcGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGRvbnRNdXRhdGUpIHtcbiAgICAgICAgICAgICAgICBkb250TXV0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gX2Fzc2lnbih7fSwgbmV4dFN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfYXNzaWduKG5leHRTdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBpbnN0LnJlbmRlcigpO1xuXG4gICAge1xuICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIGNoaWxkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgQ29tcG9uZW50KTtcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0LmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX2NoaWxkQ29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX2NoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBfY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggKGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IF9hc3NpZ24oe30sIGNvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZDogY2hpbGQsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xufVxuXG52YXIgUmVhY3RET01TZXJ2ZXJSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IHR5cGUgdGhpcyBtb3JlIHN0cmljdGx5OlxuICAvLyBERVYtb25seVxuICBmdW5jdGlvbiBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGNoaWxkcmVuLCBtYWtlU3RhdGljTWFya3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGZsYXRDaGlsZHJlbiA9IGZsYXR0ZW5Ub3BMZXZlbENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB2YXIgdG9wRnJhbWUgPSB7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgLy8gQXNzdW1lIGFsbCB0cmVlcyBzdGFydCBpbiB0aGUgSFRNTCBuYW1lc3BhY2UgKG5vdCB0b3RhbGx5IHRydWUsIGJ1dFxuICAgICAgLy8gdGhpcyBpcyB3aGF0IHdlIGRpZCBoaXN0b3JpY2FsbHkpXG4gICAgICBkb21OYW1lc3BhY2U6IE5hbWVzcGFjZXMuaHRtbCxcbiAgICAgIGNoaWxkcmVuOiBmbGF0Q2hpbGRyZW4sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgY29udGV4dDogZW1wdHlPYmplY3QsXG4gICAgICBmb290ZXI6ICcnXG4gICAgfTtcblxuICAgIHtcbiAgICAgIHRvcEZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgfVxuXG4gICAgdGhpcy50aHJlYWRJRCA9IGFsbG9jVGhyZWFkSUQoKTtcbiAgICB0aGlzLnN0YWNrID0gW3RvcEZyYW1lXTtcbiAgICB0aGlzLmV4aGF1c3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1ha2VTdGF0aWNNYXJrdXAgPSBtYWtlU3RhdGljTWFya3VwO1xuICAgIHRoaXMuc3VzcGVuc2VEZXB0aCA9IDA7IC8vIENvbnRleHQgKG5ldyBBUEkpXG5cbiAgICB0aGlzLmNvbnRleHRJbmRleCA9IC0xO1xuICAgIHRoaXMuY29udGV4dFN0YWNrID0gW107XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFjayA9IFtdOyAvLyB1c2VPcGFxdWVJZGVudGlmaWVyIElEXG5cbiAgICB0aGlzLnVuaXF1ZUlEID0gMDtcbiAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zICYmIG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCB8fCAnJztcblxuICAgIHtcbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2sgPSBbXTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3RET01TZXJ2ZXJSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5leGhhdXN0ZWQpIHtcbiAgICAgIHRoaXMuZXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2xlYXJQcm92aWRlcnMoKTtcbiAgICAgIGZyZWVUaHJlYWRJRCh0aGlzLnRocmVhZElEKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5vdGU6IFdlIHVzZSBqdXN0IHR3byBzdGFja3MgcmVnYXJkbGVzcyBvZiBob3cgbWFueSBjb250ZXh0IHByb3ZpZGVycyB5b3UgaGF2ZS5cbiAgICogUHJvdmlkZXJzIGFyZSBhbHdheXMgcG9wcGVkIGluIHRoZSByZXZlcnNlIG9yZGVyIHRvIGhvdyB0aGV5IHdlcmUgcHVzaGVkXG4gICAqIHNvIHdlIGFsd2F5cyBrbm93IG9uIHRoZSB3YXkgZG93biB3aGljaCBwcm92aWRlciB5b3UnbGwgZW5jb3VudGVyIG5leHQgb24gdGhlIHdheSB1cC5cbiAgICogT24gdGhlIHdheSBkb3duLCB3ZSBwdXNoIHRoZSBjdXJyZW50IHByb3ZpZGVyLCBhbmQgaXRzIGNvbnRleHQgdmFsdWUgKmJlZm9yZSpcbiAgICogd2UgbXV0YXRlZCBpdCwgb250byB0aGUgc3RhY2tzLiBUaGVyZWZvcmUsIG9uIHRoZSB3YXkgdXAsIHdlIGFsd2F5cyBrbm93IHdoaWNoXG4gICAqIHByb3ZpZGVyIG5lZWRzIHRvIGJlIFwicmVzdG9yZWRcIiB0byB3aGljaCB2YWx1ZS5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTI5ODUjaXNzdWVjb21tZW50LTM5NjMwMTI0OFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wdXNoUHJvdmlkZXIgPSBmdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB2YXIgaW5kZXggPSArK3RoaXMuY29udGV4dEluZGV4O1xuICAgIHZhciBjb250ZXh0ID0gcHJvdmlkZXIudHlwZS5fY29udGV4dDtcbiAgICB2YXIgdGhyZWFkSUQgPSB0aGlzLnRocmVhZElEO1xuICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBjb250ZXh0W3RocmVhZElEXTsgLy8gUmVtZW1iZXIgd2hpY2ggdmFsdWUgdG8gcmVzdG9yZSB0aGlzIGNvbnRleHQgdG8gb24gb3VyIHdheSB1cC5cblxuICAgIHRoaXMuY29udGV4dFN0YWNrW2luZGV4XSA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF0gPSBwcmV2aW91c1ZhbHVlO1xuXG4gICAge1xuICAgICAgLy8gT25seSB1c2VkIGZvciBwdXNoL3BvcCBtaXNtYXRjaCB3YXJuaW5ncy5cbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdID0gcHJvdmlkZXI7XG4gICAgfSAvLyBNdXRhdGUgdGhlIGN1cnJlbnQgdmFsdWUuXG5cblxuICAgIGNvbnRleHRbdGhyZWFkSURdID0gcHJvdmlkZXIucHJvcHMudmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLnBvcFByb3ZpZGVyID0gZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHRJbmRleDtcblxuICAgIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgcHJvdmlkZXIgIT09IHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdOyAvLyBcIkhpZGVcIiB0aGVzZSBudWxsIGFzc2lnbm1lbnRzIGZyb20gRmxvdyBieSB1c2luZyBgYW55YFxuICAgIC8vIGJlY2F1c2UgY29uY2VwdHVhbGx5IHRoZXkgYXJlIGRlbGV0aW9ucy0tYXMgbG9uZyBhcyB3ZVxuICAgIC8vIHByb21pc2UgdG8gbmV2ZXIgYWNjZXNzIHZhbHVlcyBiZXlvbmQgYHRoaXMuY29udGV4dEluZGV4YC5cblxuICAgIHRoaXMuY29udGV4dFN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dEluZGV4LS07IC8vIFJlc3RvcmUgdG8gdGhlIHByZXZpb3VzIHZhbHVlIHdlIHN0b3JlZCBhcyB3ZSB3ZXJlIHdhbGtpbmcgZG93bi5cbiAgICAvLyBXZSd2ZSBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgdGhpcyBjb250ZXh0IGhhcyBiZWVuIGV4cGFuZGVkIHRvIGFjY29tbW9kYXRlXG4gICAgLy8gdGhpcyB0aHJlYWQgaWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gaXQgYWdhaW4uXG5cbiAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJQcm92aWRlcnMgPSBmdW5jdGlvbiBjbGVhclByb3ZpZGVycygpIHtcbiAgICAvLyBSZXN0b3JlIGFueSByZW1haW5pbmcgcHJvdmlkZXJzIG9uIHRoZSBzdGFjayB0byBwcmV2aW91cyB2YWx1ZXNcbiAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuY29udGV4dEluZGV4OyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF07XG4gICAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlYWQgPSBmdW5jdGlvbiByZWFkKGJ5dGVzKSB7XG4gICAgaWYgKHRoaXMuZXhoYXVzdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcHJldlBhcnRpYWxSZW5kZXJlciA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXI7XG4gICAgc2V0Q3VycmVudFBhcnRpYWxSZW5kZXJlcih0aGlzKTtcbiAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IERpc3BhdGNoZXI7XG5cbiAgICB0cnkge1xuICAgICAgLy8gTWFya3VwIGdlbmVyYXRlZCB3aXRoaW4gPFN1c3BlbnNlPiBlbmRzIHVwIGJ1ZmZlcmVkIHVudGlsIHdlIGtub3dcbiAgICAgIC8vIG5vdGhpbmcgaW4gdGhhdCBib3VuZGFyeSBzdXNwZW5kZWRcbiAgICAgIHZhciBvdXQgPSBbJyddO1xuICAgICAgdmFyIHN1c3BlbmRlZCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAob3V0WzBdLmxlbmd0aCA8IGJ5dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICBmcmVlVGhyZWFkSUQodGhpcy50aHJlYWRJRCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHN1c3BlbmRlZCB8fCBmcmFtZS5jaGlsZEluZGV4ID49IGZyYW1lLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBmb290ZXIgPSBmcmFtZS5mb290ZXI7XG5cbiAgICAgICAgICBpZiAoZm9vdGVyICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcblxuICAgICAgICAgIGlmIChmcmFtZS50eXBlID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZSAhPSBudWxsICYmIGZyYW1lLnR5cGUudHlwZSAhPSBudWxsICYmIGZyYW1lLnR5cGUudHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZnJhbWUudHlwZTtcbiAgICAgICAgICAgIHRoaXMucG9wUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSkge1xuICAgICAgICAgICAgdGhpcy5zdXNwZW5zZURlcHRoLS07XG4gICAgICAgICAgICB2YXIgYnVmZmVyZWQgPSBvdXQucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChzdXNwZW5kZWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuZGVkID0gZmFsc2U7IC8vIElmIHJlbmRlcmluZyB3YXMgc3VzcGVuZGVkIGF0IHRoaXMgYm91bmRhcnksIHJlbmRlciB0aGUgZmFsbGJhY2tGcmFtZVxuXG4gICAgICAgICAgICAgIHZhciBmYWxsYmFja0ZyYW1lID0gZnJhbWUuZmFsbGJhY2tGcmFtZTtcblxuICAgICAgICAgICAgICBpZiAoIWZhbGxiYWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJSZWFjdERPTVNlcnZlciBkaWQgbm90IGZpbmQgYW4gaW50ZXJuYWwgZmFsbGJhY2sgZnJhbWUgZm9yIFN1c3BlbnNlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiA6IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzAzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZhbGxiYWNrRnJhbWUpO1xuICAgICAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSAnPCEtLSQhLS0+JzsgLy8gU2tpcCBmbHVzaGluZyBvdXRwdXQgc2luY2Ugd2UncmUgc3dpdGNoaW5nIHRvIHRoZSBmYWxsYmFja1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gYnVmZmVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBGbHVzaCBvdXRwdXRcblxuXG4gICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gZm9vdGVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZnJhbWUuY2hpbGRyZW5bZnJhbWUuY2hpbGRJbmRleCsrXTtcbiAgICAgICAgdmFyIG91dEJ1ZmZlciA9ICcnO1xuXG4gICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrKHRoaXMuc3RhY2spOyAvLyBXZSdyZSBzdGFydGluZyB3b3JrIG9uIHRoaXMgZnJhbWUsIHNvIHJlc2V0IGl0cyBpbm5lciBzdGFjay5cblxuICAgICAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dEJ1ZmZlciArPSB0aGlzLnJlbmRlcihjaGlsZCwgZnJhbWUuY29udGV4dCwgZnJhbWUuZG9tTmFtZXNwYWNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsICYmIHR5cGVvZiBlcnIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5zdXNwZW5zZURlcHRoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJBIFJlYWN0IGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVuZGVyaW5nLCBidXQgbm8gZmFsbGJhY2sgVUkgd2FzIHNwZWNpZmllZC5cXG5cXG5BZGQgYSA8U3VzcGVuc2UgZmFsbGJhY2s9Li4uPiBjb21wb25lbnQgaGlnaGVyIGluIHRoZSB0cmVlIHRvIHByb3ZpZGUgYSBsb2FkaW5nIGluZGljYXRvciBvciBwbGFjZWhvbGRlciB0byBkaXNwbGF5LlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFmYWxzZSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRydWUgPyBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IFN1c3BlbnNlLlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOTQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgcG9wQ3VycmVudERlYnVnU3RhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA8PSB0aGlzLnN1c3BlbnNlRGVwdGgpIHtcbiAgICAgICAgICBvdXQucHVzaCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBvdXRCdWZmZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRbMF07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHByZXZQYXJ0aWFsUmVuZGVyZXIpO1xuICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2hpbGQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB0ZXh0ID0gJycgKyBjaGlsZDtcblxuICAgICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWFrZVN0YXRpY01hcmt1cCkge1xuICAgICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUpIHtcbiAgICAgICAgcmV0dXJuICc8IS0tIC0tPicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRDaGlsZDtcblxuICAgICAgdmFyIF9yZXNvbHZlID0gcmVzb2x2ZShjaGlsZCwgY29udGV4dCwgdGhpcy50aHJlYWRJRCk7XG5cbiAgICAgIG5leHRDaGlsZCA9IF9yZXNvbHZlLmNoaWxkO1xuICAgICAgY29udGV4dCA9IF9yZXNvbHZlLmNvbnRleHQ7XG5cbiAgICAgIGlmIChuZXh0Q2hpbGQgPT09IG51bGwgfHwgbmV4dENoaWxkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2UgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXh0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBuZXh0Q2hpbGQuJCR0eXBlb2YgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENhdGNoIHVuZXhwZWN0ZWQgc3BlY2lhbCB0eXBlcyBlYXJseS5cbiAgICAgICAgICB2YXIgJCR0eXBlb2YgPSBuZXh0Q2hpbGQuJCR0eXBlb2Y7XG5cbiAgICAgICAgICBpZiAoISgkJHR5cGVvZiAhPT0gUkVBQ1RfUE9SVEFMX1RZUEUpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlBvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuIFJlbmRlciB0aGVtIGNvbmRpdGlvbmFsbHkgc28gdGhhdCB0aGV5IG9ubHkgYXBwZWFyIG9uIHRoZSBjbGllbnQgcmVuZGVyLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDYXRjaC1hbGwgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIGlmIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoKSBzdXBwb3J0cyBzb21lIG5ldyB0eXBlLlxuXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gZWxlbWVudC1saWtlIG9iamVjdCB0eXBlOiBcIiArICQkdHlwZW9mLnRvU3RyaW5nKCkgKyBcIi4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRvQXJyYXkobmV4dENoaWxkKTtcbiAgICAgICAgdmFyIGZyYW1lID0ge1xuICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgY2hpbGRyZW46IG5leHRDaGlsZHJlbixcbiAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZyYW1lKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSAvLyBTYWZlIGJlY2F1c2Ugd2UganVzdCBjaGVja2VkIGl0J3MgYW4gZWxlbWVudC5cblxuXG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGQ7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSBuZXh0RWxlbWVudC50eXBlO1xuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJET00obmV4dEVsZW1lbnQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZWxlbWVudFR5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogTGVnYWN5SGlkZGVuIGFjdHMgdGhlIHNhbWUgYXMgYSBmcmFnbWVudC4gVGhpcyBvbmx5IHdvcmtzXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpc1xuICAgICAgICAvLyBhY2NvbXBhbmllZCBieSBhIGhvc3QgY29tcG9uZW50IHdyYXBwZXIuIEluIHRoZSBoaWRkZW4gbW9kZSwgdGhlIGhvc3RcbiAgICAgICAgLy8gY29tcG9uZW50IGlzIGdpdmVuIGEgYGhpZGRlbmAgYXR0cmlidXRlLCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgSFRNTCBpcyBub3QgdmlzaWJsZS4gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhXG4gICAgICAgIC8vIHRydWUgZnJhZ21lbnQsIHdpdGhvdXQgYW4gZXh0cmEgRE9NIG5vZGUsIHdlIHdvdWxkIGhhdmUgdG8gaGlkZSB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBIVE1MIGluIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4gPSB0b0FycmF5KG5leHRDaGlsZC5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIHZhciBfZnJhbWUgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBTdXNwZW5zZS5cIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAgICAgIHtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnRUeXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IG5leHRDaGlsZDtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjU7XG5cbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gICAgICAgICAgICAgIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSBlbGVtZW50VHlwZS5yZW5kZXIoZWxlbWVudC5wcm9wcywgZWxlbWVudC5yZWYpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNSA9IGZpbmlzaEhvb2tzKGVsZW1lbnRUeXBlLnJlbmRlciwgZWxlbWVudC5wcm9wcywgX25leHRDaGlsZHJlbjUsIGVsZW1lbnQucmVmKTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSB0b0FycmF5KF9uZXh0Q2hpbGRyZW41KTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjUsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTUpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGVtZW50ID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjYgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZS50eXBlLCBfYXNzaWduKHtcbiAgICAgICAgICAgICAgICByZWY6IF9lbGVtZW50LnJlZlxuICAgICAgICAgICAgICB9LCBfZWxlbWVudC5wcm9wcykpXTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTYgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjYsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNi5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTYpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3ZpZGVyLnByb3BzO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNyA9IHRvQXJyYXkobmV4dFByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm92aWRlcixcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjcsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNy5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5wdXNoUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNyk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcmVhY3RDb250ZXh0ID0gbmV4dENoaWxkLnR5cGU7IC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAgICAgICAgICAgICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAgICAgICAgICAgICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgICAgICAgICAgICAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgICAgICAgICAgICAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gICAgICAgICAgICAgIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWN0Q29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgICAgICAgICAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgICAgICAgICAgICAgIGlmIChyZWFjdENvbnRleHQgIT09IHJlYWN0Q29udGV4dC5Db25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlYWN0Q29udGV4dCA9IHJlYWN0Q29udGV4dC5fY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX25leHRQcm9wcyA9IG5leHRDaGlsZC5wcm9wcztcbiAgICAgICAgICAgICAgdmFyIHRocmVhZElEID0gdGhpcy50aHJlYWRJRDtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKHJlYWN0Q29udGV4dCwgdGhyZWFkSUQpO1xuICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gcmVhY3RDb250ZXh0W3RocmVhZElEXTtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjggPSB0b0FycmF5KF9uZXh0UHJvcHMuY2hpbGRyZW4obmV4dFZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTggPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbmV4dENoaWxkLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuOCxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU4LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lOCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRTpcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIGZ1bmRhbWVudGFsIEFQSS5cIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZWxlbWVudDIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gbmV4dENoaWxkLnR5cGU7IC8vIEF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBsYXp5IGNvbXBvbmVudCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlXG4gICAgICAgICAgICAgIC8vIHN1c3BlbnNlIHNlcnZlci1zaWRlIHJlbmRlcmVyIGlzIGVuYWJsZWQgc28gc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAvLyByZXNvbHZlZCBjb25zdHJ1Y3RvcnMgYXJlIHN1cHBvcnRlZC5cblxuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuMTAgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChyZXN1bHQsIF9hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHJlZjogX2VsZW1lbnQyLnJlZlxuICAgICAgICAgICAgICB9LCBfZWxlbWVudDIucHJvcHMpKV07XG4gICAgICAgICAgICAgIHZhciBfZnJhbWUxMCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuMTAsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lMTAuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUxMCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICB7XG4gICAgICAgIHZhciBvd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGVsZW1lbnRUeXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICsgKGVsZW1lbnRUeXBlID09IG51bGwgPyBlbGVtZW50VHlwZSA6IHR5cGVvZiBlbGVtZW50VHlwZSkgKyBcIi5cIiArIGluZm8gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyRE9NID0gZnVuY3Rpb24gcmVuZGVyRE9NKGVsZW1lbnQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIHZhciB0YWcgPSBlbGVtZW50LnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuXG4gICAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICBuYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBOYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICAgIGlmICh0YWcgIT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgZWxlbWVudC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gICAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcblxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gX2Fzc2lnbih7XG4gICAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygndGV4dGFyZWEnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gICAgICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICAgICAgICB2YXIgdGV4dGFyZWFDaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmICh0ZXh0YXJlYUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEoZGVmYXVsdFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHRhcmVhQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBpZiAoISh0ZXh0YXJlYUNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dGFyZWFDaGlsZHJlbiA9IHRleHRhcmVhQ2hpbGRyZW5bMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyB0ZXh0YXJlYUNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46ICcnICsgaW5pdGlhbFZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcblxuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJywgcHJvcE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdvcHRpb24nKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgdmFyIHNlbGVjdFZhbHVlID0gdGhpcy5jdXJyZW50U2VsZWN0VmFsdWU7XG4gICAgICB2YXIgb3B0aW9uQ2hpbGRyZW4gPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlICsgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25DaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtqXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzID0gX2Fzc2lnbih7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gICAgICAgIH0sIHByb3BzLCB7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICAgIGNoaWxkcmVuOiBvcHRpb25DaGlsZHJlblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcHJvcHMpO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gICAgdmFyIG91dCA9IGNyZWF0ZU9wZW5UYWdNYXJrdXAoZWxlbWVudC50eXBlLCB0YWcsIHByb3BzLCBuYW1lc3BhY2UsIHRoaXMubWFrZVN0YXRpY01hcmt1cCwgdGhpcy5zdGFjay5sZW5ndGggPT09IDEpO1xuICAgIHZhciBmb290ZXIgPSAnJztcblxuICAgIGlmIChvbWl0dGVkQ2xvc2VUYWdzLmhhc093blByb3BlcnR5KHRhZykpIHtcbiAgICAgIG91dCArPSAnLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJz4nO1xuICAgICAgZm9vdGVyID0gJzwvJyArIGVsZW1lbnQudHlwZSArICc+JztcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW47XG4gICAgdmFyIGlubmVyTWFya3VwID0gZ2V0Tm9uQ2hpbGRyZW5Jbm5lck1hcmt1cChwcm9wcyk7XG5cbiAgICBpZiAoaW5uZXJNYXJrdXAgIT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzLmhhc093blByb3BlcnR5KHRhZykgJiYgaW5uZXJNYXJrdXAuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgICBvdXQgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSBpbm5lck1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4gPSB0b0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWUgPSB7XG4gICAgICBkb21OYW1lc3BhY2U6IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgZWxlbWVudC50eXBlKSxcbiAgICAgIHR5cGU6IHRhZyxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgZm9vdGVyOiBmb290ZXJcbiAgICB9O1xuXG4gICAge1xuICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2goZnJhbWUpO1xuICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0RE9NU2VydmVyUmVuZGVyZXI7XG59KCk7XG5cbi8qKlxuICogUmVuZGVyIGEgUmVhY3RFbGVtZW50IHRvIGl0cyBpbml0aWFsIEhUTUwuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiB0aGVcbiAqIHNlcnZlci5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCBmYWxzZSwgb3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbWFya3VwID0gcmVuZGVyZXIucmVhZChJbmZpbml0eSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSBmaW5hbGx5IHtcbiAgICByZW5kZXJlci5kZXN0cm95KCk7XG4gIH1cbn1cbi8qKlxuICogU2ltaWxhciB0byByZW5kZXJUb1N0cmluZywgZXhjZXB0IHRoaXMgZG9lc24ndCBjcmVhdGUgZXh0cmEgRE9NIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgZGF0YS1yZWFjdC1pZCB0aGF0IFJlYWN0IHVzZXMgaW50ZXJuYWxseS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RhdGljbWFya3VwXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCB0cnVlLCBvcHRpb25zKTtcblxuICB0cnkge1xuICAgIHZhciBtYXJrdXAgPSByZW5kZXJlci5yZWFkKEluZmluaXR5KTtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhZGFibGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSwgX1JlYWRhYmxlKTtcblxuICBmdW5jdGlvbiBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIG1ha2VTdGF0aWNNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAvLyBDYWxscyB0aGUgc3RyZWFtLlJlYWRhYmxlKG9wdGlvbnMpIGNvbnN0cnVjdG9yLiBDb25zaWRlciBleHBvc2luZyBidWlsdC1pblxuICAgIC8vIGZlYXR1cmVzIGxpa2UgaGlnaFdhdGVyTWFyayBpbiB0aGUgZnV0dXJlLlxuICAgIF90aGlzID0gX1JlYWRhYmxlLmNhbGwodGhpcywge30pIHx8IHRoaXM7XG4gICAgX3RoaXMucGFydGlhbFJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgbWFrZVN0YXRpY01hcmt1cCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5fZGVzdHJveSA9IGZ1bmN0aW9uIF9kZXN0cm95KGVyciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnBhcnRpYWxSZW5kZXJlci5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlYWQgPSBmdW5jdGlvbiBfcmVhZChzaXplKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLnBhcnRpYWxSZW5kZXJlci5yZWFkKHNpemUpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbTtcbn0oc3RyZWFtLlJlYWRhYmxlKTtcbi8qKlxuICogUmVuZGVyIGEgUmVhY3RFbGVtZW50IHRvIGl0cyBpbml0aWFsIEhUTUwuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiB0aGVcbiAqIHNlcnZlci5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvbm9kZXN0cmVhbVxuICovXG5cblxuZnVuY3Rpb24gcmVuZGVyVG9Ob2RlU3RyZWFtKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIGZhbHNlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogU2ltaWxhciB0byByZW5kZXJUb05vZGVTdHJlYW0sIGV4Y2VwdCB0aGlzIGRvZXNuJ3QgY3JlYXRlIGV4dHJhIERPTSBhdHRyaWJ1dGVzXG4gKiBzdWNoIGFzIGRhdGEtcmVhY3QtaWQgdGhhdCBSZWFjdCB1c2VzIGludGVybmFsbHkuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0YXRpY25vZGVzdHJlYW1cbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0oZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgdHJ1ZSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydHMucmVuZGVyVG9Ob2RlU3RyZWFtID0gcmVuZGVyVG9Ob2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0gPSByZW5kZXJUb1N0YXRpY05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvU3RyaW5nID0gcmVuZGVyVG9TdHJpbmc7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zZXJ2ZXIubm9kZScpO1xuIiwgIi8qIE5Qcm9ncmVzcywgKGMpIDIwMTMsIDIwMTQgUmljbyBTdGEuIENydXogLSBodHRwOi8vcmljb3N0YWNydXouY29tL25wcm9ncmVzc1xuICogQGxpY2Vuc2UgTUlUICovXG5cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5OUHJvZ3Jlc3MgPSBmYWN0b3J5KCk7XG4gIH1cblxufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gIHZhciBOUHJvZ3Jlc3MgPSB7fTtcblxuICBOUHJvZ3Jlc3MudmVyc2lvbiA9ICcwLjIuMCc7XG5cbiAgdmFyIFNldHRpbmdzID0gTlByb2dyZXNzLnNldHRpbmdzID0ge1xuICAgIG1pbmltdW06IDAuMDgsXG4gICAgZWFzaW5nOiAnZWFzZScsXG4gICAgcG9zaXRpb25Vc2luZzogJycsXG4gICAgc3BlZWQ6IDIwMCxcbiAgICB0cmlja2xlOiB0cnVlLFxuICAgIHRyaWNrbGVSYXRlOiAwLjAyLFxuICAgIHRyaWNrbGVTcGVlZDogODAwLFxuICAgIHNob3dTcGlubmVyOiB0cnVlLFxuICAgIGJhclNlbGVjdG9yOiAnW3JvbGU9XCJiYXJcIl0nLFxuICAgIHNwaW5uZXJTZWxlY3RvcjogJ1tyb2xlPVwic3Bpbm5lclwiXScsXG4gICAgcGFyZW50OiAnYm9keScsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiYmFyXCIgcm9sZT1cImJhclwiPjxkaXYgY2xhc3M9XCJwZWdcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwic3Bpbm5lclwiIHJvbGU9XCJzcGlubmVyXCI+PGRpdiBjbGFzcz1cInNwaW5uZXItaWNvblwiPjwvZGl2PjwvZGl2PidcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiAgICAgTlByb2dyZXNzLmNvbmZpZ3VyZSh7XG4gICAqICAgICAgIG1pbmltdW06IDAuMVxuICAgKiAgICAgfSk7XG4gICAqL1xuICBOUHJvZ3Jlc3MuY29uZmlndXJlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBTZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIExhc3QgbnVtYmVyLlxuICAgKi9cblxuICBOUHJvZ3Jlc3Muc3RhdHVzID0gbnVsbDtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJvZ3Jlc3MgYmFyIHN0YXR1cywgd2hlcmUgYG5gIGlzIGEgbnVtYmVyIGZyb20gYDAuMGAgdG8gYDEuMGAuXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3Muc2V0KDAuNCk7XG4gICAqICAgICBOUHJvZ3Jlc3Muc2V0KDEuMCk7XG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zZXQgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHN0YXJ0ZWQgPSBOUHJvZ3Jlc3MuaXNTdGFydGVkKCk7XG5cbiAgICBuID0gY2xhbXAobiwgU2V0dGluZ3MubWluaW11bSwgMSk7XG4gICAgTlByb2dyZXNzLnN0YXR1cyA9IChuID09PSAxID8gbnVsbCA6IG4pO1xuXG4gICAgdmFyIHByb2dyZXNzID0gTlByb2dyZXNzLnJlbmRlcighc3RhcnRlZCksXG4gICAgICAgIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHNwZWVkICAgID0gU2V0dGluZ3Muc3BlZWQsXG4gICAgICAgIGVhc2UgICAgID0gU2V0dGluZ3MuZWFzaW5nO1xuXG4gICAgcHJvZ3Jlc3Mub2Zmc2V0V2lkdGg7IC8qIFJlcGFpbnQgKi9cblxuICAgIHF1ZXVlKGZ1bmN0aW9uKG5leHQpIHtcbiAgICAgIC8vIFNldCBwb3NpdGlvblVzaW5nIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc2V0XG4gICAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJycpIFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPSBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MoKTtcblxuICAgICAgLy8gQWRkIHRyYW5zaXRpb25cbiAgICAgIGNzcyhiYXIsIGJhclBvc2l0aW9uQ1NTKG4sIHNwZWVkLCBlYXNlKSk7XG5cbiAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgIC8vIEZhZGUgb3V0XG4gICAgICAgIGNzcyhwcm9ncmVzcywgeyBcbiAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZScsIFxuICAgICAgICAgIG9wYWNpdHk6IDEgXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2FsbCAnICsgc3BlZWQgKyAnbXMgbGluZWFyJywgXG4gICAgICAgICAgICBvcGFjaXR5OiAwIFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBOUHJvZ3Jlc3MucmVtb3ZlKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfSwgc3BlZWQpO1xuICAgICAgICB9LCBzcGVlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KG5leHQsIHNwZWVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE5Qcm9ncmVzcy5pc1N0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIE5Qcm9ncmVzcy5zdGF0dXMgPT09ICdudW1iZXInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93cyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHNldHRpbmcgdGhlIHN0YXR1cyB0byAwJSwgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBnbyBiYWNrd2FyZHMuXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICpcbiAgICovXG4gIE5Qcm9ncmVzcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgTlByb2dyZXNzLnNldCgwKTtcblxuICAgIHZhciB3b3JrID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIU5Qcm9ncmVzcy5zdGF0dXMpIHJldHVybjtcbiAgICAgICAgTlByb2dyZXNzLnRyaWNrbGUoKTtcbiAgICAgICAgd29yaygpO1xuICAgICAgfSwgU2V0dGluZ3MudHJpY2tsZVNwZWVkKTtcbiAgICB9O1xuXG4gICAgaWYgKFNldHRpbmdzLnRyaWNrbGUpIHdvcmsoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGlzIGlzIHRoZSAqc29ydCBvZiogdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDEwMCUsIHdpdGggdGhlXG4gICAqIGRpZmZlcmVuY2UgYmVpbmcgYGRvbmUoKWAgbWFrZXMgc29tZSBwbGFjZWJvIGVmZmVjdCBvZiBzb21lIHJlYWxpc3RpYyBtb3Rpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuZG9uZSgpO1xuICAgKlxuICAgKiBJZiBgdHJ1ZWAgaXMgcGFzc2VkLCBpdCB3aWxsIHNob3cgdGhlIHByb2dyZXNzIGJhciBldmVuIGlmIGl0cyBoaWRkZW4uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuZG9uZSh0cnVlKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLmRvbmUgPSBmdW5jdGlvbihmb3JjZSkge1xuICAgIGlmICghZm9yY2UgJiYgIU5Qcm9ncmVzcy5zdGF0dXMpIHJldHVybiB0aGlzO1xuXG4gICAgcmV0dXJuIE5Qcm9ncmVzcy5pbmMoMC4zICsgMC41ICogTWF0aC5yYW5kb20oKSkuc2V0KDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIGJ5IGEgcmFuZG9tIGFtb3VudC5cbiAgICovXG5cbiAgTlByb2dyZXNzLmluYyA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIHZhciBuID0gTlByb2dyZXNzLnN0YXR1cztcblxuICAgIGlmICghbikge1xuICAgICAgcmV0dXJuIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgYW1vdW50ID0gKDEgLSBuKSAqIGNsYW1wKE1hdGgucmFuZG9tKCkgKiBuLCAwLjEsIDAuOTUpO1xuICAgICAgfVxuXG4gICAgICBuID0gY2xhbXAobiArIGFtb3VudCwgMCwgMC45OTQpO1xuICAgICAgcmV0dXJuIE5Qcm9ncmVzcy5zZXQobik7XG4gICAgfVxuICB9O1xuXG4gIE5Qcm9ncmVzcy50cmlja2xlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE5Qcm9ncmVzcy5pbmMoTWF0aC5yYW5kb20oKSAqIFNldHRpbmdzLnRyaWNrbGVSYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIGFsbCBzdXBwbGllZCBqUXVlcnkgcHJvbWlzZXMgYW5kXG4gICAqIGluY3JlYXNlcyB0aGUgcHJvZ3Jlc3MgYXMgdGhlIHByb21pc2VzIHJlc29sdmUuXG4gICAqXG4gICAqIEBwYXJhbSAkcHJvbWlzZSBqUVVlcnkgUHJvbWlzZVxuICAgKi9cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbml0aWFsID0gMCwgY3VycmVudCA9IDA7XG5cbiAgICBOUHJvZ3Jlc3MucHJvbWlzZSA9IGZ1bmN0aW9uKCRwcm9taXNlKSB7XG4gICAgICBpZiAoISRwcm9taXNlIHx8ICRwcm9taXNlLnN0YXRlKCkgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWwrKztcbiAgICAgIGN1cnJlbnQrKztcblxuICAgICAgJHByb21pc2UuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJyZW50LS07XG4gICAgICAgIGlmIChjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgICBpbml0aWFsID0gMDtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBOUHJvZ3Jlc3Muc2V0KChpbml0aWFsIC0gY3VycmVudCkgLyBpbml0aWFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSByZW5kZXJzIHRoZSBwcm9ncmVzcyBiYXIgbWFya3VwIGJhc2VkIG9uIHRoZSBgdGVtcGxhdGVgXG4gICAqIHNldHRpbmcuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5yZW5kZXIgPSBmdW5jdGlvbihmcm9tU3RhcnQpIHtcbiAgICBpZiAoTlByb2dyZXNzLmlzUmVuZGVyZWQoKSkgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcblxuICAgIGFkZENsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ25wcm9ncmVzcy1idXN5Jyk7XG4gICAgXG4gICAgdmFyIHByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJvZ3Jlc3MuaWQgPSAnbnByb2dyZXNzJztcbiAgICBwcm9ncmVzcy5pbm5lckhUTUwgPSBTZXR0aW5ncy50ZW1wbGF0ZTtcblxuICAgIHZhciBiYXIgICAgICA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MuYmFyU2VsZWN0b3IpLFxuICAgICAgICBwZXJjICAgICA9IGZyb21TdGFydCA/ICctMTAwJyA6IHRvQmFyUGVyYyhOUHJvZ3Jlc3Muc3RhdHVzIHx8IDApLFxuICAgICAgICBwYXJlbnQgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MucGFyZW50KSxcbiAgICAgICAgc3Bpbm5lcjtcbiAgICBcbiAgICBjc3MoYmFyLCB7XG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAgbGluZWFyJyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBwZXJjICsgJyUsMCwwKSdcbiAgICB9KTtcblxuICAgIGlmICghU2V0dGluZ3Muc2hvd1NwaW5uZXIpIHtcbiAgICAgIHNwaW5uZXIgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnNwaW5uZXJTZWxlY3Rvcik7XG4gICAgICBzcGlubmVyICYmIHJlbW92ZUVsZW1lbnQoc3Bpbm5lcik7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudCAhPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBhZGRDbGFzcyhwYXJlbnQsICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIH1cblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwcm9ncmVzcyk7XG4gICAgcmV0dXJuIHByb2dyZXNzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50LiBPcHBvc2l0ZSBvZiByZW5kZXIoKS5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ25wcm9ncmVzcy1idXN5Jyk7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLCAnbnByb2dyZXNzLWN1c3RvbS1wYXJlbnQnKTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbnByb2dyZXNzJyk7XG4gICAgcHJvZ3Jlc3MgJiYgcmVtb3ZlRWxlbWVudChwcm9ncmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHJlbmRlcmVkLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaXNSZW5kZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoaWNoIHBvc2l0aW9uaW5nIENTUyBydWxlIHRvIHVzZS5cbiAgICovXG5cbiAgTlByb2dyZXNzLmdldFBvc2l0aW9uaW5nQ1NTID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gU25pZmYgb24gZG9jdW1lbnQuYm9keS5zdHlsZVxuICAgIHZhciBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG4gICAgLy8gU25pZmYgcHJlZml4ZXNcbiAgICB2YXIgdmVuZG9yUHJlZml4ID0gKCdXZWJraXRUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnV2Via2l0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnTW96VHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ01veicgOlxuICAgICAgICAgICAgICAgICAgICAgICAoJ21zVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ21zJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnT1RyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdPJyA6ICcnO1xuXG4gICAgaWYgKHZlbmRvclByZWZpeCArICdQZXJzcGVjdGl2ZScgaW4gYm9keVN0eWxlKSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgd2l0aCAzRCBzdXBwb3J0LCBlLmcuIFdlYmtpdCwgSUUxMFxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUzZCc7XG4gICAgfSBlbHNlIGlmICh2ZW5kb3JQcmVmaXggKyAnVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIEJyb3dzZXJzIHdpdGhvdXQgM0Qgc3VwcG9ydCwgZS5nLiBJRTlcbiAgICAgIHJldHVybiAndHJhbnNsYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCB0cmFuc2xhdGUoKSBzdXBwb3J0LCBlLmcuIElFNy04XG4gICAgICByZXR1cm4gJ21hcmdpbic7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsYW1wKG4sIG1pbiwgbWF4KSB7XG4gICAgaWYgKG4gPCBtaW4pIHJldHVybiBtaW47XG4gICAgaWYgKG4gPiBtYXgpIHJldHVybiBtYXg7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBjb252ZXJ0cyBhIHBlcmNlbnRhZ2UgKGAwLi4xYCkgdG8gYSBiYXIgdHJhbnNsYXRlWFxuICAgKiBwZXJjZW50YWdlIChgLTEwMCUuLjAlYCkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvQmFyUGVyYyhuKSB7XG4gICAgcmV0dXJuICgtMSArIG4pICogMTAwO1xuICB9XG5cblxuICAvKipcbiAgICogKEludGVybmFsKSByZXR1cm5zIHRoZSBjb3JyZWN0IENTUyBmb3IgY2hhbmdpbmcgdGhlIGJhcidzXG4gICAqIHBvc2l0aW9uIGdpdmVuIGFuIG4gcGVyY2VudGFnZSwgYW5kIHNwZWVkIGFuZCBlYXNlIGZyb20gU2V0dGluZ3NcbiAgICovXG5cbiAgZnVuY3Rpb24gYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpIHtcbiAgICB2YXIgYmFyQ1NTO1xuXG4gICAgaWYgKFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09ICd0cmFuc2xhdGUzZCcpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyt0b0JhclBlcmMobikrJyUsMCwwKScgfTtcbiAgICB9IGVsc2UgaWYgKFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09ICd0cmFuc2xhdGUnKSB7XG4gICAgICBiYXJDU1MgPSB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnK3RvQmFyUGVyYyhuKSsnJSwwKScgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyQ1NTID0geyAnbWFyZ2luLWxlZnQnOiB0b0JhclBlcmMobikrJyUnIH07XG4gICAgfVxuXG4gICAgYmFyQ1NTLnRyYW5zaXRpb24gPSAnYWxsICcrc3BlZWQrJ21zICcrZWFzZTtcblxuICAgIHJldHVybiBiYXJDU1M7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBRdWV1ZXMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICovXG5cbiAgdmFyIHF1ZXVlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nID0gW107XG4gICAgXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBmbiA9IHBlbmRpbmcuc2hpZnQoKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHBlbmRpbmcucHVzaChmbik7XG4gICAgICBpZiAocGVuZGluZy5sZW5ndGggPT0gMSkgbmV4dCgpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgQXBwbGllcyBjc3MgcHJvcGVydGllcyB0byBhbiBlbGVtZW50LCBzaW1pbGFyIHRvIHRoZSBqUXVlcnkgXG4gICAqIGNzcyBtZXRob2QuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgaGVscGVyIGRvZXMgYXNzaXN0IHdpdGggdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5IG5hbWVzLCBpdCBcbiAgICogZG9lcyBub3QgcGVyZm9ybSBhbnkgbWFuaXB1bGF0aW9uIG9mIHZhbHVlcyBwcmlvciB0byBzZXR0aW5nIHN0eWxlcy5cbiAgICovXG5cbiAgdmFyIGNzcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY3NzUHJlZml4ZXMgPSBbICdXZWJraXQnLCAnTycsICdNb3onLCAnbXMnIF0sXG4gICAgICAgIGNzc1Byb3BzICAgID0ge307XG5cbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL14tbXMtLywgJ21zLScpLnJlcGxhY2UoLy0oW1xcZGEtel0pL2dpLCBmdW5jdGlvbihtYXRjaCwgbGV0dGVyKSB7XG4gICAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlbmRvclByb3AobmFtZSkge1xuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgIGlmIChuYW1lIGluIHN0eWxlKSByZXR1cm4gbmFtZTtcblxuICAgICAgdmFyIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGgsXG4gICAgICAgICAgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuICAgICAgICAgIHZlbmRvck5hbWU7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZlbmRvck5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XG4gICAgICAgIGlmICh2ZW5kb3JOYW1lIGluIHN0eWxlKSByZXR1cm4gdmVuZG9yTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3R5bGVQcm9wKG5hbWUpIHtcbiAgICAgIG5hbWUgPSBjYW1lbENhc2UobmFtZSk7XG4gICAgICByZXR1cm4gY3NzUHJvcHNbbmFtZV0gfHwgKGNzc1Byb3BzW25hbWVdID0gZ2V0VmVuZG9yUHJvcChuYW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3AgPSBnZXRTdHlsZVByb3AocHJvcCk7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHByb3AsIFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMikge1xuICAgICAgICBmb3IgKHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3ApKSBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5Q3NzKGVsZW1lbnQsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgfVxuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBEZXRlcm1pbmVzIGlmIGFuIGVsZW1lbnQgb3Igc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3MgbmFtZXMgY29udGFpbnMgYSBjbGFzcyBuYW1lLlxuICAgKi9cblxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIGxpc3QgPSB0eXBlb2YgZWxlbWVudCA9PSAnc3RyaW5nJyA/IGVsZW1lbnQgOiBjbGFzc0xpc3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIGxpc3QuaW5kZXhPZignICcgKyBuYW1lICsgJyAnKSA+PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgQWRkcyBhIGNsYXNzIHRvIGFuIGVsZW1lbnQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgb2xkTGlzdCA9IGNsYXNzTGlzdChlbGVtZW50KSxcbiAgICAgICAgbmV3TGlzdCA9IG9sZExpc3QgKyBuYW1lO1xuXG4gICAgaWYgKGhhc0NsYXNzKG9sZExpc3QsIG5hbWUpKSByZXR1cm47IFxuXG4gICAgLy8gVHJpbSB0aGUgb3BlbmluZyBzcGFjZS5cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUmVtb3ZlcyBhIGNsYXNzIGZyb20gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0O1xuXG4gICAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBuYW1lKSkgcmV0dXJuO1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgY2xhc3MgbmFtZS5cbiAgICBuZXdMaXN0ID0gb2xkTGlzdC5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHNwYWNlcy5cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEsIG5ld0xpc3QubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBHZXRzIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGNsYXNzIG5hbWVzIG9uIHRoZSBlbGVtZW50LiBcbiAgICogVGhlIGxpc3QgaXMgd3JhcHBlZCB3aXRoIGEgc2luZ2xlIHNwYWNlIG9uIGVhY2ggZW5kIHRvIGZhY2lsaXRhdGUgZmluZGluZyBcbiAgICogbWF0Y2hlcyB3aXRoaW4gdGhlIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsYXNzTGlzdChlbGVtZW50KSB7XG4gICAgcmV0dXJuICgnICcgKyAoZWxlbWVudC5jbGFzc05hbWUgfHwgJycpICsgJyAnKS5yZXBsYWNlKC9cXHMrL2dpLCAnICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIE5Qcm9ncmVzcztcbn0pO1xuXG4iLCAiaW1wb3J0IHsgY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIgfSBmcm9tIFwiQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzXCI7XG5pbXBvcnQgKiBhcyBidWlsZCBmcm9tIFwiQHJlbWl4LXJ1bi9kZXYvc2VydmVyLWJ1aWxkXCI7XG5cbmNvbnN0IGhhbmRsZVJlcXVlc3QgPSBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlcih7XG4gIGJ1aWxkLFxuICBtb2RlOiBwcm9jZXNzLmVudi5OT0RFX0VOVixcbiAgZ2V0TG9hZENvbnRleHQ6IGNvbnRleHQgPT4gY29udGV4dC5lbnZcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gb25SZXF1ZXN0KGNvbnRleHQpIHtcbiAgcmV0dXJuIGhhbmRsZVJlcXVlc3QoY29udGV4dCk7XG59XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGluc3RhbGxHbG9iYWxzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmV4cG9ydCB7IGNyZWF0ZUNsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlIH0gZnJvbSAnLi9zZXNzaW9ucy9jbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZS5qcyc7XG5leHBvcnQgeyBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlciwgY3JlYXRlUmVxdWVzdEhhbmRsZXIgfSBmcm9tICcuL3dvcmtlci5qcyc7XG5cbmluc3RhbGxHbG9iYWxzKCk7XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IHNpZ24sIHVuc2lnbiB9IGZyb20gJy4vY29va2llU2lnbmluZy5qcyc7XG5cbmZ1bmN0aW9uIGluc3RhbGxHbG9iYWxzKCkge1xuICBzZWxmLnNpZ24gPSBzaWduO1xuICBzZWxmLnVuc2lnbiA9IHVuc2lnbjtcbn1cblxuZXhwb3J0IHsgaW5zdGFsbEdsb2JhbHMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuYXN5bmMgZnVuY3Rpb24gc2lnbih2YWx1ZSwgc2VjcmV0KSB7XG4gIGxldCBrZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBlbmNvZGVyLmVuY29kZShzZWNyZXQpLCB7XG4gICAgbmFtZTogXCJITUFDXCIsXG4gICAgaGFzaDogXCJTSEEtMjU2XCJcbiAgfSwgZmFsc2UsIFtcInNpZ25cIl0pO1xuICBsZXQgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IHNpZ25hdHVyZSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihcIkhNQUNcIiwga2V5LCBkYXRhKTtcbiAgbGV0IGhhc2ggPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSkpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xuICByZXR1cm4gdmFsdWUgKyBcIi5cIiArIGhhc2g7XG59XG5hc3luYyBmdW5jdGlvbiB1bnNpZ24oY29va2llLCBzZWNyZXQpIHtcbiAgbGV0IGtleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGVuY29kZXIuZW5jb2RlKHNlY3JldCksIHtcbiAgICBuYW1lOiBcIkhNQUNcIixcbiAgICBoYXNoOiBcIlNIQS0yNTZcIlxuICB9LCBmYWxzZSwgW1widmVyaWZ5XCJdKTtcbiAgbGV0IHZhbHVlID0gY29va2llLnNsaWNlKDAsIGNvb2tpZS5sYXN0SW5kZXhPZihcIi5cIikpO1xuICBsZXQgaGFzaCA9IGNvb2tpZS5zbGljZShjb29raWUubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gIGxldCBkYXRhID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQgc2lnbmF0dXJlID0gYnl0ZVN0cmluZ1RvVWludDhBcnJheShhdG9iKGhhc2gpKTtcbiAgbGV0IHZhbGlkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoXCJITUFDXCIsIGtleSwgc2lnbmF0dXJlLCBkYXRhKTtcbiAgcmV0dXJuIHZhbGlkID8gdmFsdWUgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYnl0ZVN0cmluZ1RvVWludDhBcnJheShieXRlU3RyaW5nKSB7XG4gIGxldCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVTdHJpbmcubGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IHsgc2lnbiwgdW5zaWduIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGNyZWF0ZVNlc3Npb25TdG9yYWdlIH0gZnJvbSAnQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNlc3Npb25TdG9yYWdlIHRoYXQgc3RvcmVzIHNlc3Npb24gZGF0YSBpbiB0aGUgQ2xvdWxkZmxhcmUgS1YgU3RvcmUuXG4gKlxuICogVGhlIGFkdmFudGFnZSBvZiB1c2luZyB0aGlzIGluc3RlYWQgb2YgY29va2llIHNlc3Npb24gc3RvcmFnZSBpcyB0aGF0XG4gKiBLViBTdG9yZSBtYXkgY29udGFpbiBtdWNoIG1vcmUgZGF0YSB0aGFuIGNvb2tpZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjY3JlYXRlY2xvdWRmbGFyZWt2c2Vzc2lvbnN0b3JhZ2UtY2xvdWRmbGFyZS13b3JrZXJzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlKHtcbiAgY29va2llLFxuICBrdlxufSkge1xuICByZXR1cm4gY3JlYXRlU2Vzc2lvblN0b3JhZ2Uoe1xuICAgIGNvb2tpZSxcblxuICAgIGFzeW5jIGNyZWF0ZURhdGEoZGF0YSwgZXhwaXJlcykge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHJhbmRvbUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnl0ZXMpOyAvLyBUaGlzIHN0b3JhZ2UgbWFuYWdlcyBhbiBpZCBzcGFjZSBvZiAyXjY0IGlkcywgd2hpY2ggaXMgZmFyIGdyZWF0ZXJcbiAgICAgICAgLy8gdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZmlsZXMgYWxsb3dlZCBvbiBhbiBOVEZTIG9yIGV4dDQgdm9sdW1lXG4gICAgICAgIC8vICgyXjMyKS4gSG93ZXZlciwgdGhlIGxhcmdlciBpZCBzcGFjZSBzaG91bGQgaGVscCB0byBhdm9pZCBjb2xsaXNpb25zXG4gICAgICAgIC8vIHdpdGggZXhpc3RpbmcgaWRzIHdoZW4gY3JlYXRpbmcgbmV3IHNlc3Npb25zLCB3aGljaCBzcGVlZHMgdGhpbmdzIHVwLlxuXG4gICAgICAgIGxldCBpZCA9IFsuLi5yYW5kb21CeXRlc10ubWFwKHggPT4geC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuXG4gICAgICAgIGlmIChhd2FpdCBrdi5nZXQoaWQsIFwianNvblwiKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQga3YucHV0KGlkLCBKU09OLnN0cmluZ2lmeShkYXRhKSwge1xuICAgICAgICAgIGV4cGlyYXRpb246IGV4cGlyZXMgPyBNYXRoLnJvdW5kKGV4cGlyZXMuZ2V0VGltZSgpIC8gMTAwMCkgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgcmVhZERhdGEoaWQpIHtcbiAgICAgIGxldCBzZXNzaW9uID0gYXdhaXQga3YuZ2V0KGlkKTtcblxuICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShzZXNzaW9uKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgdXBkYXRlRGF0YShpZCwgZGF0YSwgZXhwaXJlcykge1xuICAgICAgYXdhaXQga3YucHV0KGlkLCBKU09OLnN0cmluZ2lmeShkYXRhKSwge1xuICAgICAgICBleHBpcmF0aW9uOiBleHBpcmVzID8gTWF0aC5yb3VuZChleHBpcmVzLmdldFRpbWUoKSAvIDEwMDApIDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZGVsZXRlRGF0YShpZCkge1xuICAgICAgYXdhaXQga3YuZGVsZXRlKGlkKTtcbiAgICB9XG5cbiAgfSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5leHBvcnQgeyBjcmVhdGVDb29raWUsIGlzQ29va2llIH0gZnJvbSAnLi9jb29raWVzLmpzJztcbmV4cG9ydCB7IGpzb24sIHJlZGlyZWN0IH0gZnJvbSAnLi9yZXNwb25zZXMuanMnO1xuZXhwb3J0IHsgY3JlYXRlUmVxdWVzdEhhbmRsZXIgfSBmcm9tICcuL3NlcnZlci5qcyc7XG5leHBvcnQgeyBjcmVhdGVTZXNzaW9uLCBjcmVhdGVTZXNzaW9uU3RvcmFnZSwgaXNTZXNzaW9uIH0gZnJvbSAnLi9zZXNzaW9ucy5qcyc7XG5leHBvcnQgeyBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSB9IGZyb20gJy4vc2Vzc2lvbnMvY29va2llU3RvcmFnZS5qcyc7XG5leHBvcnQgeyBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSB9IGZyb20gJy4vc2Vzc2lvbnMvbWVtb3J5U3RvcmFnZS5qcyc7XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKipcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgY3JlYXRpbmcgYGFwcGxpY2F0aW9uL2pzb25gIHJlc3BvbnNlcy4gQ29udmVydHMgYGRhdGFgXG4gKiB0byBKU09OIGFuZCBzZXRzIHRoZSBgQ29udGVudC1UeXBlYCBoZWFkZXIuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjanNvblxuICovXG5mdW5jdGlvbiBqc29uKGRhdGEsIGluaXQgPSB7fSkge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcblxuICBpZiAodHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7XG4gICAgICBzdGF0dXM6IGluaXRcbiAgICB9O1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG5cbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIHsgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UuIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3JlZGlyZWN0XG4gKi9cblxuZnVuY3Rpb24gcmVkaXJlY3QodXJsLCBpbml0ID0gMzAyKSB7XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuXG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgc3RhdHVzOiByZXNwb25zZUluaXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzUmVzcG9uc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUuaGVhZGVycyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUuYm9keSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhyZXNwb25zZS5zdGF0dXMpO1xufVxuZnVuY3Rpb24gaXNDYXRjaFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldChcIlgtUmVtaXgtQ2F0Y2hcIikgIT0gbnVsbDtcbn1cblxuZXhwb3J0IHsgaXNDYXRjaFJlc3BvbnNlLCBpc1JlZGlyZWN0UmVzcG9uc2UsIGlzUmVzcG9uc2UsIGpzb24sIHJlZGlyZWN0IH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBjYWxsUm91dGVBY3Rpb24sIGNhbGxSb3V0ZUxvYWRlciwgZXh0cmFjdERhdGEgfSBmcm9tICcuL2RhdGEuanMnO1xuaW1wb3J0IHsgY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMsIGNyZWF0ZUVudHJ5TWF0Y2hlcyB9IGZyb20gJy4vZW50cnkuanMnO1xuaW1wb3J0IHsgc2VyaWFsaXplRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBnZXREb2N1bWVudEhlYWRlcnMgfSBmcm9tICcuL2hlYWRlcnMuanMnO1xuaW1wb3J0IHsgbWF0Y2hTZXJ2ZXJSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IHsgaXNTZXJ2ZXJNb2RlLCBTZXJ2ZXJNb2RlIH0gZnJvbSAnLi9tb2RlLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJvdXRlcyB9IGZyb20gJy4vcm91dGVzLmpzJztcbmltcG9ydCB7IGlzUmVkaXJlY3RSZXNwb25zZSwgaXNDYXRjaFJlc3BvbnNlLCBqc29uIH0gZnJvbSAnLi9yZXNwb25zZXMuanMnO1xuaW1wb3J0IHsgY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyB9IGZyb20gJy4vc2VydmVySGFuZG9mZi5qcyc7XG5cbi8qKlxuICogVGhlIG1haW4gcmVxdWVzdCBoYW5kbGVyIGZvciBhIFJlbWl4IHNlcnZlci4gVGhpcyBoYW5kbGVyIHJ1bnMgaW4gdGhlIGNvbnRleHRcbiAqIG9mIGEgY2xvdWQgcHJvdmlkZXIncyBzZXJ2ZXIgKGUuZy4gRXhwcmVzcyBvbiBGaXJlYmFzZSkgb3IgbG9jYWxseSB2aWEgdGhlaXJcbiAqIGRldiB0b29scy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHNlcnZlcyBIVFRQIHJlcXVlc3RzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SGFuZGxlcihidWlsZCwgcGxhdGZvcm0sIG1vZGUpIHtcbiAgbGV0IHJvdXRlcyA9IGNyZWF0ZVJvdXRlcyhidWlsZC5yb3V0ZXMpO1xuICBsZXQgc2VydmVyTW9kZSA9IGlzU2VydmVyTW9kZShtb2RlKSA/IG1vZGUgOiBTZXJ2ZXJNb2RlLlByb2R1Y3Rpb247XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0LCBsb2FkQ29udGV4dCkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgdXJsLnBhdGhuYW1lKTtcbiAgICBsZXQgcmVxdWVzdFR5cGUgPSBnZXRSZXF1ZXN0VHlwZSh1cmwsIG1hdGNoZXMpO1xuICAgIGxldCByZXNwb25zZTtcblxuICAgIHN3aXRjaCAocmVxdWVzdFR5cGUpIHtcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlRGF0YVJlcXVlc3Qoe1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgICBoYW5kbGVEYXRhUmVxdWVzdDogYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZURhdGFSZXF1ZXN0LFxuICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiZG9jdW1lbnRcIjpcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCByZW5kZXJEb2N1bWVudFJlcXVlc3Qoe1xuICAgICAgICAgIGJ1aWxkLFxuICAgICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICByb3V0ZXMsXG4gICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJyZXNvdXJjZVwiOlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZVJlc291cmNlUmVxdWVzdCh7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImhlYWRcIikge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZURhdGFSZXF1ZXN0KHtcbiAgaGFuZGxlRGF0YVJlcXVlc3QsXG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaGVzLFxuICByZXF1ZXN0LFxuICBzZXJ2ZXJNb2RlXG59KSB7XG4gIGlmICghaXNWYWxpZFJlcXVlc3RNZXRob2QocmVxdWVzdCkpIHtcbiAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihgSW52YWxpZCByZXF1ZXN0IG1ldGhvZCBcIiR7cmVxdWVzdC5tZXRob2R9XCJgKSwgNDA1KTtcbiAgfVxuXG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihgTm8gcm91dGUgbWF0Y2hlcyBVUkwgXCIke3VybC5wYXRobmFtZX1cImApLCA0MDQpO1xuICB9XG5cbiAgbGV0IHJlc3BvbnNlO1xuICBsZXQgbWF0Y2g7XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICBtYXRjaCA9IGdldEFjdGlvblJlcXVlc3RNYXRjaCh1cmwsIG1hdGNoZXMpO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjYWxsUm91dGVBY3Rpb24oe1xuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcm91dGVJZCA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwiX2RhdGFcIik7XG5cbiAgICAgIGlmICghcm91dGVJZCkge1xuICAgICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihgTWlzc2luZyByb3V0ZSBpZCBpbiA/X2RhdGFgKSwgNDAzKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRlbXBNYXRjaCA9IG1hdGNoZXMuZmluZChtYXRjaCA9PiBtYXRjaC5yb3V0ZS5pZCA9PT0gcm91dGVJZCk7XG5cbiAgICAgIGlmICghdGVtcE1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBtYXRjaCBVUkwgXCIke3VybC5wYXRobmFtZX1cImApLCA0MDMpO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbFJvdXRlTG9hZGVyKHtcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIHByZXZlbnQgYSBmZXRjaCByZXF1ZXN0IGZyb20gZm9sbG93aW5nXG4gICAgICAvLyByZWRpcmVjdHMuIFNvIHdlIHVzZSB0aGUgYFgtUmVtaXgtUmVkaXJlY3RgIGhlYWRlciB0byBpbmRpY2F0ZSB0aGVcbiAgICAgIC8vIG5leHQgVVJMLCBhbmQgdGhlbiBcImZvbGxvd1wiIHRoZSByZWRpcmVjdCBtYW51YWxseSBvbiB0aGUgY2xpZW50LlxuICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgIGhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiLCBoZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpKTtcbiAgICAgIGhlYWRlcnMuZGVsZXRlKFwiTG9jYXRpb25cIik7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVEYXRhUmVxdWVzdCkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVEYXRhUmVxdWVzdChyZXNwb25zZS5jbG9uZSgpLCB7XG4gICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdC5jbG9uZSgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlck1vZGUgPT09IFNlcnZlck1vZGUuRGV2ZWxvcG1lbnQpIHtcbiAgICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IoZXJyb3IsIDUwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiKSwgNTAwKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJEb2N1bWVudFJlcXVlc3Qoe1xuICBidWlsZCxcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoZXMsXG4gIHJlcXVlc3QsXG4gIHJvdXRlcyxcbiAgc2VydmVyTW9kZVxufSkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIGxldCBhcHBTdGF0ZSA9IHtcbiAgICB0cmFja0JvdW5kYXJpZXM6IHRydWUsXG4gICAgdHJhY2tDYXRjaEJvdW5kYXJpZXM6IHRydWUsXG4gICAgY2F0Y2hCb3VuZGFyeVJvdXRlSWQ6IG51bGwsXG4gICAgcmVuZGVyQm91bmRhcnlSb3V0ZUlkOiBudWxsLFxuICAgIGxvYWRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgIGNhdGNoOiB1bmRlZmluZWRcbiAgfTtcblxuICBpZiAoIWlzVmFsaWRSZXF1ZXN0TWV0aG9kKHJlcXVlc3QpKSB7XG4gICAgbWF0Y2hlcyA9IG51bGw7XG4gICAgYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICBhcHBTdGF0ZS5jYXRjaCA9IHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBzdGF0dXM6IDQwNSxcbiAgICAgIHN0YXR1c1RleHQ6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCJcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICBhcHBTdGF0ZS5jYXRjaCA9IHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBzdGF0dXM6IDQwNCxcbiAgICAgIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCJcbiAgICB9O1xuICB9XG5cbiAgbGV0IGFjdGlvblN0YXR1cztcbiAgbGV0IGFjdGlvbkRhdGE7XG4gIGxldCBhY3Rpb25NYXRjaDtcbiAgbGV0IGFjdGlvblJlc3BvbnNlO1xuXG4gIGlmIChtYXRjaGVzICYmIGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgIGFjdGlvbk1hdGNoID0gZ2V0QWN0aW9uUmVxdWVzdE1hdGNoKHVybCwgbWF0Y2hlcyk7XG5cbiAgICB0cnkge1xuICAgICAgYWN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsUm91dGVBY3Rpb24oe1xuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgbWF0Y2g6IGFjdGlvbk1hdGNoLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShhY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvblJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICBhY3Rpb25TdGF0dXMgPSB7XG4gICAgICAgIHN0YXR1czogYWN0aW9uUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiBhY3Rpb25SZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9O1xuXG4gICAgICBpZiAoaXNDYXRjaFJlc3BvbnNlKGFjdGlvblJlc3BvbnNlKSkge1xuICAgICAgICBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZCA9IGdldERlZXBlc3RSb3V0ZUlkV2l0aEJvdW5kYXJ5KG1hdGNoZXMsIFwiQ2F0Y2hCb3VuZGFyeVwiKTtcbiAgICAgICAgYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgICAgYXBwU3RhdGUuY2F0Y2ggPSB7IC4uLmFjdGlvblN0YXR1cyxcbiAgICAgICAgICBkYXRhOiBhd2FpdCBleHRyYWN0RGF0YShhY3Rpb25SZXNwb25zZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSB7XG4gICAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogYXdhaXQgZXh0cmFjdERhdGEoYWN0aW9uUmVzcG9uc2UpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9IGdldERlZXBlc3RSb3V0ZUlkV2l0aEJvdW5kYXJ5KG1hdGNoZXMsIFwiRXJyb3JCb3VuZGFyeVwiKTtcbiAgICAgIGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcyA9IGZhbHNlO1xuICAgICAgYXBwU3RhdGUuZXJyb3IgPSBhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvcik7XG5cbiAgICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIHJ1bm5pbmcgdGhlIGFjdGlvbiBmb3Igcm91dGUgJHthY3Rpb25NYXRjaC5yb3V0ZS5pZH1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcm91dGVNb2R1bGVzID0gY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IG1hdGNoZXNUb0xvYWQgPSBtYXRjaGVzIHx8IFtdO1xuXG4gIGlmIChhcHBTdGF0ZS5jYXRjaCkge1xuICAgIG1hdGNoZXNUb0xvYWQgPSBnZXRNYXRjaGVzVXBUb0RlZXBlc3RCb3VuZGFyeSggLy8gZ2V0IHJpZCBvZiB0aGUgYWN0aW9uLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgaXQncyBsb2FkZXIgZWl0aGVyXG4gICAgLy8gYmVjYXVzZSB3ZSdsbCBiZSByZW5kZXJpbmcgdGhlIGNhdGNoIGJvdW5kYXJ5LCBpZiB5b3UgY2FuIGdldCBhY2Nlc3NcbiAgICAvLyB0byB0aGUgbG9hZGVyIGRhdGEgaW4gdGhlIGNhdGNoIGJvdW5kYXJ5IHRoZW4gaG93IHRoZSBoZWNrIGlzIGl0XG4gICAgLy8gc3VwcG9zZWQgdG8gZGVhbCB3aXRoIHRocm93biByZXNwb25zZXM/XG4gICAgbWF0Y2hlc1RvTG9hZC5zbGljZSgwLCAtMSksIFwiQ2F0Y2hCb3VuZGFyeVwiKTtcbiAgfSBlbHNlIGlmIChhcHBTdGF0ZS5lcnJvcikge1xuICAgIG1hdGNoZXNUb0xvYWQgPSBnZXRNYXRjaGVzVXBUb0RlZXBlc3RCb3VuZGFyeSggLy8gZ2V0IHJpZCBvZiB0aGUgYWN0aW9uLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgaXQncyBsb2FkZXIgZWl0aGVyXG4gICAgLy8gYmVjYXVzZSB3ZSdsbCBiZSByZW5kZXJpbmcgdGhlIGVycm9yIGJvdW5kYXJ5LCBpZiB5b3UgY2FuIGdldCBhY2Nlc3NcbiAgICAvLyB0byB0aGUgbG9hZGVyIGRhdGEgaW4gdGhlIGVycm9yIGJvdW5kYXJ5IHRoZW4gaG93IHRoZSBoZWNrIGlzIGl0XG4gICAgLy8gc3VwcG9zZWQgdG8gZGVhbCB3aXRoIGVycm9ycyBpbiB0aGUgbG9hZGVyLCB0b28/XG4gICAgbWF0Y2hlc1RvTG9hZC5zbGljZSgwLCAtMSksIFwiRXJyb3JCb3VuZGFyeVwiKTtcbiAgfVxuXG4gIGxldCByb3V0ZUxvYWRlclJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQobWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gbWF0Y2gucm91dGUubW9kdWxlLmxvYWRlciA/IGNhbGxSb3V0ZUxvYWRlcih7XG4gICAgbG9hZENvbnRleHQsXG4gICAgbWF0Y2gsXG4gICAgcmVxdWVzdFxuICB9KSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKSk7IC8vIFN0b3JlIHRoZSBzdGF0ZSBvZiB0aGUgYWN0aW9uLiBXZSB3aWxsIHVzZSB0aGlzIHRvIGRldGVybWluZSBsYXRlclxuICAvLyB3aGF0IGNhdGNoIG9yIGVycm9yIGJvdW5kYXJ5IHNob3VsZCBiZSByZW5kZXJlZCB1bmRlciBjYXNlcyB3aGVyZVxuICAvLyBhY3Rpb25zIGRvbid0IHRocm93IGJ1dCBsb2FkZXJzIGRvLCBhY3Rpb25zIHRocm93IGFuZCBwYXJlbnQgbG9hZGVyc1xuICAvLyBhbHNvIHRocm93LCBldGMuXG5cbiAgbGV0IGFjdGlvbkNhdGNoID0gYXBwU3RhdGUuY2F0Y2g7XG4gIGxldCBhY3Rpb25FcnJvciA9IGFwcFN0YXRlLmVycm9yO1xuICBsZXQgYWN0aW9uQ2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZDtcbiAgbGV0IGFjdGlvbkxvYWRlckJvdW5kYXJ5Um91dGVJZCA9IGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZDsgLy8gUmVzZXQgdGhlIGFwcCBlcnJvciBhbmQgY2F0Y2ggc3RhdGUgdG8gcHJvcG9nYXRlIHRoZSBsb2FkZXIgc3RhdGVzXG4gIC8vIGZyb20gdGhlIHJlc3VsdHMgaW50byB0aGUgYXBwIHN0YXRlLlxuXG4gIGFwcFN0YXRlLmNhdGNoID0gdW5kZWZpbmVkO1xuICBhcHBTdGF0ZS5lcnJvciA9IHVuZGVmaW5lZDtcbiAgbGV0IHJvdXRlTG9hZGVyUmVzcG9uc2VzID0ge307XG4gIGxldCBsb2FkZXJTdGF0dXNDb2RlcyA9IFtdO1xuICBsZXQgcm91dGVEYXRhID0ge307XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1hdGNoZXNUb0xvYWQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hlc1RvTG9hZFtpbmRleF07XG4gICAgbGV0IHJlc3VsdCA9IHJvdXRlTG9hZGVyUmVzdWx0c1tpbmRleF07XG4gICAgbGV0IGVycm9yID0gcmVzdWx0LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiID8gcmVzdWx0LnJlYXNvbiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiID8gcmVzdWx0LnZhbHVlIDogdW5kZWZpbmVkO1xuICAgIGxldCBpc1JlZGlyZWN0ID0gcmVzcG9uc2UgPyBpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpIDogZmFsc2U7XG4gICAgbGV0IGlzQ2F0Y2ggPSByZXNwb25zZSA/IGlzQ2F0Y2hSZXNwb25zZShyZXNwb25zZSkgOiBmYWxzZTsgLy8gSWYgYSBwYXJlbnQgbG9hZGVyIGhhcyBhbHJlYWR5IGNhdWdodCBvciBlcnJvcidkLCBiYWlsIGJlY2F1c2VcbiAgICAvLyB3ZSBkb24ndCBuZWVkIGFueSBtb3JlIGNoaWxkIGRhdGEuXG5cbiAgICBpZiAoYXBwU3RhdGUuY2F0Y2ggfHwgYXBwU3RhdGUuZXJyb3IpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgdGhlcmUgaXMgYSByZXNwb25zZSBhbmQgaXQncyBhIHJlZGlyZWN0LCBkbyBpdCB1bmxlc3MgdGhlcmVcbiAgICAvLyBpcyBhbiBhY3Rpb24gZXJyb3Igb3IgY2F0Y2ggc3RhdGUsIHRob3NlIGFjdGlvbiBib3VuZGFyeSBzdGF0ZXNcbiAgICAvLyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXIgc2F0ZXMsIHRoaXMgbWVhbnMgaWYgYSBsb2FkZXIgcmVkaXJlY3RzXG4gICAgLy8gYWZ0ZXIgYW4gYWN0aW9uIGNhdGNoZXMgb3IgZXJyb3JzIHdlIHdvbid0IGZvbGxvdyBpdCwgYW5kIGluc3RlYWRcbiAgICAvLyByZW5kZXIgdGhlIGJvdW5kYXJ5IGNhdXNlZCBieSB0aGUgYWN0aW9uLlxuXG5cbiAgICBpZiAoIWFjdGlvbkNhdGNoICYmICFhY3Rpb25FcnJvciAmJiByZXNwb25zZSAmJiBpc1JlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSAvLyBUcmFjayB0aGUgYm91bmRhcnkgSUQncyBmb3IgdGhlIGxvYWRlcnNcblxuXG4gICAgaWYgKG1hdGNoLnJvdXRlLm1vZHVsZS5DYXRjaEJvdW5kYXJ5KSB7XG4gICAgICBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5tb2R1bGUuRXJyb3JCb3VuZGFyeSkge1xuICAgICAgYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBsb2FkZXJTdGF0dXNDb2Rlcy5wdXNoKDUwMCk7XG4gICAgICBhcHBTdGF0ZS50cmFja0JvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgIGFwcFN0YXRlLmVycm9yID0gYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuXG4gICAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZXJlIHdhcyBhbiBlcnJvciBydW5uaW5nIHRoZSBkYXRhIGxvYWRlciBmb3Igcm91dGUgJHttYXRjaC5yb3V0ZS5pZH1gKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZSkge1xuICAgICAgcm91dGVMb2FkZXJSZXNwb25zZXNbbWF0Y2gucm91dGUuaWRdID0gcmVzcG9uc2U7XG4gICAgICBsb2FkZXJTdGF0dXNDb2Rlcy5wdXNoKHJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICAgIGlmIChpc0NhdGNoKSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSBjYXRjaCByZXNwb25zZSwgc3RvcmUgaXQgaW4gYXBwIHN0YXRlLCBhbmQgYmFpbFxuICAgICAgICBhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcyA9IGZhbHNlO1xuICAgICAgICBhcHBTdGF0ZS5jYXRjaCA9IHtcbiAgICAgICAgICBkYXRhOiBhd2FpdCBleHRyYWN0RGF0YShyZXNwb25zZSksXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4dHJhY3QgYW5kIHN0b3JlIHRoZSBsb2FkZXIgZGF0YVxuICAgICAgICByb3V0ZURhdGFbbWF0Y2gucm91dGUuaWRdID0gYXdhaXQgZXh0cmFjdERhdGEocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZiB0aGVyZSB3YXMgbm90IGEgbG9hZGVyIGNhdGNoIG9yIGVycm9yIHN0YXRlIHRyaWdnZXJlZCByZXNldCB0aGVcbiAgLy8gYm91bmRhcmllcyBhcyB0aGV5IGFyZSBwcm9iYWJseSBkZWVwZXIgaW4gdGhlIHRyZWUgaWYgdGhlIGFjdGlvblxuICAvLyBpbml0aWFsbHkgdHJpZ2dlcmVkIGEgYm91bmRhcnkgYXMgdGhhdCBtYXRjaCB3b3VsZCBub3QgZXhpc3QgaW4gdGhlXG4gIC8vIG1hdGNoZXMgdG8gbG9hZC5cblxuXG4gIGlmICghYXBwU3RhdGUuY2F0Y2gpIHtcbiAgICBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZCA9IGFjdGlvbkNhdGNoQm91bmRhcnlSb3V0ZUlkO1xuICB9XG5cbiAgaWYgKCFhcHBTdGF0ZS5lcnJvcikge1xuICAgIGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9IGFjdGlvbkxvYWRlckJvdW5kYXJ5Um91dGVJZDtcbiAgfSAvLyBJZiB0aGVyZSB3YXMgYW4gYWN0aW9uIGVycm9yIG9yIGNhdGNoLCB3ZSB3aWxsIHJlc2V0IHRoZSBzdGF0ZSB0byB0aGVcbiAgLy8gaW5pdGlhbCB2YWx1ZXMsIG90aGVyd2lzZSB3ZSB3aWxsIHVzZSB3aGF0ZXZlciBjYW1lIG91dCBvZiB0aGUgbG9hZGVycy5cblxuXG4gIGFwcFN0YXRlLmNhdGNoID0gYWN0aW9uQ2F0Y2ggfHwgYXBwU3RhdGUuY2F0Y2g7XG4gIGFwcFN0YXRlLmVycm9yID0gYWN0aW9uRXJyb3IgfHwgYXBwU3RhdGUuZXJyb3I7XG4gIGxldCByZW5kZXJhYmxlTWF0Y2hlcyA9IGdldFJlbmRlcmFibGVNYXRjaGVzKG1hdGNoZXMsIGFwcFN0YXRlKTtcblxuICBpZiAoIXJlbmRlcmFibGVNYXRjaGVzKSB7XG4gICAgcmVuZGVyYWJsZU1hdGNoZXMgPSBbXTtcbiAgICBsZXQgcm9vdCA9IHJvdXRlc1swXTtcblxuICAgIGlmIChyb290ICE9PSBudWxsICYmIHJvb3QgIT09IHZvaWQgMCAmJiByb290Lm1vZHVsZS5DYXRjaEJvdW5kYXJ5KSB7XG4gICAgICBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZCA9IFwicm9vdFwiO1xuICAgICAgcmVuZGVyYWJsZU1hdGNoZXMucHVzaCh7XG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICByb3V0ZTogcm91dGVzWzBdXG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gSGFuZGxlIHJlc3BvbnNlcyB3aXRoIGEgbm9uLTIwMCBzdGF0dXMgY29kZS4gVGhlIGZpcnN0IGxvYWRlciB3aXRoIGFcbiAgLy8gbm9uLTIwMCBzdGF0dXMgY29kZSBkZXRlcm1pbmVzIHRoZSBzdGF0dXMgY29kZSBmb3IgdGhlIHdob2xlIHJlc3BvbnNlLlxuXG5cbiAgbGV0IG5vdE9rUmVzcG9uc2UgPSBhY3Rpb25TdGF0dXMgJiYgYWN0aW9uU3RhdHVzLnN0YXR1cyAhPT0gMjAwID8gYWN0aW9uU3RhdHVzLnN0YXR1cyA6IGxvYWRlclN0YXR1c0NvZGVzLmZpbmQoc3RhdHVzID0+IHN0YXR1cyAhPT0gMjAwKTtcbiAgbGV0IHJlc3BvbnNlU3RhdHVzQ29kZSA9IGFwcFN0YXRlLmVycm9yID8gNTAwIDogdHlwZW9mIG5vdE9rUmVzcG9uc2UgPT09IFwibnVtYmVyXCIgPyBub3RPa1Jlc3BvbnNlIDogYXBwU3RhdGUuY2F0Y2ggPyBhcHBTdGF0ZS5jYXRjaC5zdGF0dXMgOiAyMDA7XG4gIGxldCByZXNwb25zZUhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIHJlbmRlcmFibGVNYXRjaGVzLCByb3V0ZUxvYWRlclJlc3BvbnNlcywgYWN0aW9uUmVzcG9uc2UpO1xuICBsZXQgZW50cnlNYXRjaGVzID0gY3JlYXRlRW50cnlNYXRjaGVzKHJlbmRlcmFibGVNYXRjaGVzLCBidWlsZC5hc3NldHMucm91dGVzKTtcbiAgbGV0IHNlcnZlckhhbmRvZmYgPSB7XG4gICAgYWN0aW9uRGF0YSxcbiAgICBhcHBTdGF0ZTogYXBwU3RhdGUsXG4gICAgbWF0Y2hlczogZW50cnlNYXRjaGVzLFxuICAgIHJvdXRlRGF0YVxuICB9O1xuICBsZXQgZW50cnlDb250ZXh0ID0geyAuLi5zZXJ2ZXJIYW5kb2ZmLFxuICAgIG1hbmlmZXN0OiBidWlsZC5hc3NldHMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIHNlcnZlckhhbmRvZmZTdHJpbmc6IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZilcbiAgfTtcbiAgbGV0IGhhbmRsZURvY3VtZW50UmVxdWVzdCA9IGJ1aWxkLmVudHJ5Lm1vZHVsZS5kZWZhdWx0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdChyZXF1ZXN0LmNsb25lKCksIHJlc3BvbnNlU3RhdHVzQ29kZSwgcmVzcG9uc2VIZWFkZXJzLCBlbnRyeUNvbnRleHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlc3BvbnNlU3RhdHVzQ29kZSA9IDUwMDsgLy8gR28gYWdhaW4sIHRoaXMgdGltZSB3aXRoIHRoZSBjb21wb25lbnREaWRDYXRjaCBlbXVsYXRpb24uIEFzIGl0IHJlbmRlcmVkXG4gICAgLy8gbGFzdCB0aW1lIHdlIG11dGF0ZWQgYGNvbXBvbmVudERpZENhdGNoLnJvdXRlSWRgIGZvciB0aGUgbGFzdCByZW5kZXJlZFxuICAgIC8vIHJvdXRlLCBub3cgd2Uga25vdyB3aGVyZSB0byByZW5kZXIgdGhlIGVycm9yIGJvdW5kYXJ5IChmZWVscyBhIGxpdHRsZVxuICAgIC8vIGhhY2t5IGJ1dCB0aGF0J3MgaG93IGhvb2tzIHdvcmspLiBUaGlzIHRlbGxzIHRoZSBlbXVsYXRvciB0byBzdG9wXG4gICAgLy8gdHJhY2tpbmcgdGhlIGByb3V0ZUlkYCBhcyB3ZSByZW5kZXIgYmVjYXVzZSB3ZSBhbHJlYWR5IGhhdmUgYW4gZXJyb3IgdG9cbiAgICAvLyByZW5kZXIuXG5cbiAgICBhcHBTdGF0ZS50cmFja0JvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICBhcHBTdGF0ZS5lcnJvciA9IGF3YWl0IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcbiAgICBlbnRyeUNvbnRleHQuc2VydmVySGFuZG9mZlN0cmluZyA9IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZik7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdChyZXF1ZXN0LmNsb25lKCksIHJlc3BvbnNlU3RhdHVzQ29kZSwgcmVzcG9uc2VIZWFkZXJzLCBlbnRyeUNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBsZXQgbWVzc2FnZSA9IFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIjtcblxuICAgICAgaWYgKHNlcnZlck1vZGUgPT09IFNlcnZlck1vZGUuRGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgXFxuXFxuJHtTdHJpbmcoZXJyb3IpfWA7XG4gICAgICB9IC8vIEdvb2QgZ3JpZWYgZm9sa3MsIGdldCB5b3VyIGFjdCB0b2dldGhlciBcdUQ4M0RcdURFMDIhXG5cblxuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShtZXNzYWdlLCB7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc291cmNlUmVxdWVzdCh7XG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaGVzLFxuICByZXF1ZXN0LFxuICBzZXJ2ZXJNb2RlXG59KSB7XG4gIGxldCBtYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuXG4gIHRyeSB7XG4gICAgaWYgKGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgcmV0dXJuIGF3YWl0IGNhbGxSb3V0ZUFjdGlvbih7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsUm91dGVMb2FkZXIoe1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBsZXQgbWVzc2FnZSA9IFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIjtcblxuICAgIGlmIChzZXJ2ZXJNb2RlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50KSB7XG4gICAgICBtZXNzYWdlICs9IGBcXG5cXG4ke1N0cmluZyhlcnJvcil9YDtcbiAgICB9IC8vIEdvb2QgZ3JpZWYgZm9sa3MsIGdldCB5b3VyIGFjdCB0b2dldGhlciBcdUQ4M0RcdURFMDIhXG5cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobWVzc2FnZSwge1xuICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdFR5cGUodXJsLCBtYXRjaGVzKSB7XG4gIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcyhcIl9kYXRhXCIpKSB7XG4gICAgcmV0dXJuIFwiZGF0YVwiO1xuICB9XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFwiZG9jdW1lbnRcIjtcbiAgfVxuXG4gIGxldCBtYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuXG4gIGlmICghbWF0Y2gucm91dGUubW9kdWxlLmRlZmF1bHQpIHtcbiAgICByZXR1cm4gXCJyZXNvdXJjZVwiO1xuICB9XG5cbiAgcmV0dXJuIFwiZG9jdW1lbnRcIjtcbn1cblxuZnVuY3Rpb24gaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpIHtcbiAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBtZXRob2QgPT09IFwicG9zdFwiIHx8IG1ldGhvZCA9PT0gXCJwdXRcIiB8fCBtZXRob2QgPT09IFwicGF0Y2hcIiB8fCBtZXRob2QgPT09IFwiZGVsZXRlXCI7XG59XG5cbmZ1bmN0aW9uIGlzSGVhZFJlcXVlc3QocmVxdWVzdCkge1xuICByZXR1cm4gcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJoZWFkXCI7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRSZXF1ZXN0TWV0aG9kKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgfHwgaXNIZWFkUmVxdWVzdChyZXF1ZXN0KSB8fCBpc0FjdGlvblJlcXVlc3QocmVxdWVzdCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVycm9yQm91bmRhcnlFcnJvcihlcnJvciwgc3RhdHVzKSB7XG4gIHJldHVybiBqc29uKGF3YWl0IHNlcmlhbGl6ZUVycm9yKGVycm9yKSwge1xuICAgIHN0YXR1cyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIlgtUmVtaXgtRXJyb3JcIjogXCJ5ZXNcIlxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzSW5kZXhSZXF1ZXN0VXJsKHVybCkge1xuICBsZXQgaW5kZXhSZXF1ZXN0ID0gZmFsc2U7XG5cbiAgZm9yIChsZXQgcGFyYW0gb2YgdXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKSkge1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIGluZGV4UmVxdWVzdCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4UmVxdWVzdDtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uUmVxdWVzdE1hdGNoKHVybCwgbWF0Y2hlcykge1xuICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcblxuICBpZiAoIWlzSW5kZXhSZXF1ZXN0VXJsKHVybCkgJiYgbWF0Y2gucm91dGUuaWQuZW5kc1dpdGgoXCIvaW5kZXhcIikpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgtMilbMF07XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbmZ1bmN0aW9uIGdldERlZXBlc3RSb3V0ZUlkV2l0aEJvdW5kYXJ5KG1hdGNoZXMsIGtleSkge1xuICBsZXQgbWF0Y2hlZCA9IGdldE1hdGNoZXNVcFRvRGVlcGVzdEJvdW5kYXJ5KG1hdGNoZXMsIGtleSkuc2xpY2UoLTEpWzBdO1xuICByZXR1cm4gbWF0Y2hlZCA/IG1hdGNoZWQucm91dGUuaWQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNYXRjaGVzVXBUb0RlZXBlc3RCb3VuZGFyeShtYXRjaGVzLCBrZXkpIHtcbiAgbGV0IGRlZXBlc3RCb3VuZGFyeUluZGV4ID0gLTE7XG4gIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLm1vZHVsZVtrZXldKSB7XG4gICAgICBkZWVwZXN0Qm91bmRhcnlJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRlZXBlc3RCb3VuZGFyeUluZGV4ID09PSAtMSkge1xuICAgIC8vIG5vIHJvdXRlIGVycm9yIGJvdW5kYXJpZXMsIGRvbid0IG5lZWQgdG8gY2FsbCBhbnkgbG9hZGVyc1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIGRlZXBlc3RCb3VuZGFyeUluZGV4ICsgMSk7XG59IC8vIFRoaXMgcHJldmVudHMgYDxPdXRsZXQvPmAgZnJvbSByZW5kZXJpbmcgYW55dGhpbmcgYmVsb3cgd2hlcmUgdGhlIGVycm9yIHRocmV3XG4vLyBUT0RPOiBtYXliZSBkbyB0aGlzIGluIDxSZW1peEVycm9yQm91bmRhcnkgKyBjb250ZXh0PlxuXG5cbmZ1bmN0aW9uIGdldFJlbmRlcmFibGVNYXRjaGVzKG1hdGNoZXMsIGFwcFN0YXRlKSB7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIG5vIGVycm9yLCBubyB3b3JyaWVzXG5cblxuICBpZiAoIWFwcFN0YXRlLmNhdGNoICYmICFhcHBTdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgbGV0IGxhc3RSZW5kZXJhYmxlSW5kZXggPSAtMTtcbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcblxuICAgIGlmIChhcHBTdGF0ZS5yZW5kZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkIHx8IGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9PT0gaWQgfHwgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPT09IGlkKSB7XG4gICAgICBsYXN0UmVuZGVyYWJsZUluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgbGFzdFJlbmRlcmFibGVJbmRleCArIDEpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgaXNSZXNwb25zZSwgaXNSZWRpcmVjdFJlc3BvbnNlLCBqc29uIH0gZnJvbSAnLi9yZXNwb25zZXMuanMnO1xuXG4vKipcbiAqIEFuIG9iamVjdCBvZiBhcmJpdHJhcnkgZm9yIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgcHJvdmlkZWQgYnkgdGhlXG4gKiBzZXJ2ZXIncyBgZ2V0TG9hZENvbnRleHQoKWAgZnVuY3Rpb24uXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gY2FsbFJvdXRlQWN0aW9uKHtcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoLFxuICByZXF1ZXN0XG59KSB7XG4gIGxldCBhY3Rpb24gPSBtYXRjaC5yb3V0ZS5tb2R1bGUuYWN0aW9uO1xuXG4gIGlmICghYWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbWFkZSBhICR7cmVxdWVzdC5tZXRob2R9IHJlcXVlc3QgdG8gJHtyZXF1ZXN0LnVybH0gYnV0IGRpZCBub3QgcHJvdmlkZSBgICsgYGFuIFxcYGFjdGlvblxcYCBmb3Igcm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiLCBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSBgICsgYHJlcXVlc3QuYCk7XG4gIH1cblxuICBsZXQgcmVzdWx0O1xuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKHtcbiAgICAgIHJlcXVlc3Q6IHN0cmlwRGF0YVBhcmFtKHN0cmlwSW5kZXhQYXJhbShyZXF1ZXN0KSksXG4gICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1JlZGlyZWN0UmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBlcnJvci5oZWFkZXJzLnNldChcIlgtUmVtaXgtQ2F0Y2hcIiwgXCJ5ZXNcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gZXJyb3I7XG4gIH1cblxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBkZWZpbmVkIGFuIGFjdGlvbiBmb3Igcm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGAgKyBgYW55dGhpbmcgZnJvbSB5b3VyIFxcYGFjdGlvblxcYCBmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYCk7XG4gIH1cblxuICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0IDoganNvbihyZXN1bHQpO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbFJvdXRlTG9hZGVyKHtcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoLFxuICByZXF1ZXN0XG59KSB7XG4gIGxldCBsb2FkZXIgPSBtYXRjaC5yb3V0ZS5tb2R1bGUubG9hZGVyO1xuXG4gIGlmICghbG9hZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbWFkZSBhICR7cmVxdWVzdC5tZXRob2R9IHJlcXVlc3QgdG8gJHtyZXF1ZXN0LnVybH0gYnV0IGRpZCBub3QgcHJvdmlkZSBgICsgYGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIGAgKyBgcmVxdWVzdC5gKTtcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBsb2FkZXIoe1xuICAgICAgcmVxdWVzdDogc3RyaXBEYXRhUGFyYW0oc3RyaXBJbmRleFBhcmFtKHJlcXVlc3QuY2xvbmUoKSkpLFxuICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtc1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmICghaXNSZWRpcmVjdFJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgZXJyb3IuaGVhZGVycy5zZXQoXCJYLVJlbWl4LUNhdGNoXCIsIFwieWVzXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGVycm9yO1xuICB9XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgZGVmaW5lZCBhIGxvYWRlciBmb3Igcm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGAgKyBgYW55dGhpbmcgZnJvbSB5b3VyIFxcYGxvYWRlclxcYCBmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYCk7XG4gIH1cblxuICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0IDoganNvbihyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBzdHJpcEluZGV4UGFyYW0ocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIGxldCBpbmRleFZhbHVlcyA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gIGxldCBpbmRleFZhbHVlc1RvS2VlcCA9IFtdO1xuXG4gIGZvciAobGV0IGluZGV4VmFsdWUgb2YgaW5kZXhWYWx1ZXMpIHtcbiAgICBpZiAoaW5kZXhWYWx1ZSkge1xuICAgICAgaW5kZXhWYWx1ZXNUb0tlZXAucHVzaChpbmRleFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLmhyZWYsIHJlcXVlc3QpO1xufVxuXG5mdW5jdGlvbiBzdHJpcERhdGFQYXJhbShyZXF1ZXN0KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJfZGF0YVwiKTtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCByZXF1ZXN0KTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcG9uc2UpIHtcbiAgbGV0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG5cbiAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSAvLyBXaGF0IG90aGVyIGRhdGEgdHlwZXMgZG8gd2UgbmVlZCB0byBoYW5kbGUgaGVyZT8gV2hhdCBvdGhlciBraW5kcyBvZlxuICAvLyByZXNwb25zZXMgYXJlIHBlb3BsZSBnb2luZyB0byBiZSByZXR1cm5pbmcgZnJvbSB0aGVpciBsb2FkZXJzP1xuICAvLyAtIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCA/XG4gIC8vIC0gbXVsdGlwYXJ0L2Zvcm0tZGF0YSA/XG4gIC8vIC0gYmluYXJ5IChhdWRpby92aWRlbykgP1xuXG5cbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZXhwb3J0IHsgY2FsbFJvdXRlQWN0aW9uLCBjYWxsUm91dGVMb2FkZXIsIGV4dHJhY3REYXRhIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbnRyeU1hdGNoZXMobWF0Y2hlcywgcm91dGVzKSB7XG4gIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogcm91dGVzW21hdGNoLnJvdXRlLmlkXVxuICB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcyhtYW5pZmVzdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWFuaWZlc3QpLnJlZHVjZSgobWVtbywgcm91dGVJZCkgPT4ge1xuICAgIG1lbW9bcm91dGVJZF0gPSBtYW5pZmVzdFtyb3V0ZUlkXS5tb2R1bGU7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW50cnlNYXRjaGVzLCBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLyoqXG4gKiBUaGlzIHRoaW5nIHByb2JhYmx5IHdhcnJhbnRzIHNvbWUgZXhwbGFuYXRpb24uXG4gKlxuICogVGhlIHdob2xlIHBvaW50IGhlcmUgaXMgdG8gZW11bGF0ZSBjb21wb25lbnREaWRDYXRjaCBmb3Igc2VydmVyIHJlbmRlcmluZyBhbmRcbiAqIGRhdGEgbG9hZGluZy4gSXQgY2FuIGdldCB0cmlja3kuIFJlYWN0IGNhbiBkbyB0aGlzIG9uIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gKiBidXQgZG9lc24ndCBzdXBwb3J0IGl0IGZvciBzZXJ2ZXIgcmVuZGVyaW5nIG9yIGRhdGEgbG9hZGluZy4gV2Uga25vdyBlbm91Z2hcbiAqIHdpdGggbmVzdGVkIHJvdXRlcyB0byBiZSBhYmxlIHRvIGVtdWxhdGUgdGhlIGJlaGF2aW9yIChiZWNhdXNlIHdlIGtub3cgdGhlbVxuICogc3RhdGljYWxseSBiZWZvcmUgcmVuZGVyaW5nLilcbiAqXG4gKiBFYWNoIHJvdXRlIGNhbiBleHBvcnQgYW4gYEVycm9yQm91bmRhcnlgLlxuICpcbiAqIC0gV2hlbiByZW5kZXJpbmcgdGhyb3dzIGFuIGVycm9yLCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSB3aWxsIHJlbmRlclxuICogICAobm9ybWFsIHJlYWN0IGNvbXBvbmVudERpZENhdGNoKS4gVGhpcyB3aWxsIGJlIHRoZSByb3V0ZSdzIG93biBib3VuZGFyeSwgYnV0XG4gKiAgIGlmIG5vbmUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYnViYmxlIHVwIHRvIHRoZSBwYXJlbnRzLlxuICogLSBXaGVuIGRhdGEgbG9hZGluZyB0aHJvd3MgYW4gZXJyb3IsIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IHdpbGwgcmVuZGVyXG4gKiAtIFdoZW4gcGVyZm9ybWluZyBhbiBhY3Rpb24sIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IGZvciB0aGUgYWN0aW9uJ3NcbiAqICAgcm91dGUgdHJlZSB3aWxsIHJlbmRlciAobm8gcmVkaXJlY3QgaGFwcGVucylcbiAqXG4gKiBEdXJpbmcgbm9ybWFsIHJlYWN0IHJlbmRlcmluZywgd2UgZG8gbm90aGluZyBzcGVjaWFsLCBqdXN0IG5vcm1hbFxuICogY29tcG9uZW50RGlkQ2F0Y2guXG4gKlxuICogRm9yIHNlcnZlciByZW5kZXJpbmcsIHdlIG11dGF0ZSBgcmVuZGVyQm91bmRhcnlSb3V0ZUlkYCB0byBrbm93IHRoZSBsYXN0XG4gKiBsYXlvdXQgdGhhdCBoYXMgYW4gZXJyb3IgYm91bmRhcnkgdGhhdCB0cmllZCB0byByZW5kZXIuIFRoaXMgZW11bGF0ZXMgd2hpY2hcbiAqIGxheW91dCB3b3VsZCBjYXRjaCBhIHRocm93biBlcnJvci4gSWYgdGhlIHJlbmRlcmluZyBmYWlscywgd2UgY2F0Y2ggdGhlIGVycm9yXG4gKiBvbiB0aGUgc2VydmVyLCBhbmQgZ28gYWdhaW4gYSBzZWNvbmQgdGltZSB3aXRoIHRoZSBlbXVsYXRvciBob2xkaW5nIG9uIHRvIHRoZVxuICogaW5mb3JtYXRpb24gaXQgbmVlZHMgdG8gcmVuZGVyIHRoZSBzYW1lIGVycm9yIGJvdW5kYXJ5IGFzIGEgZHluYW1pY2FsbHlcbiAqIHRocm93biByZW5kZXIgZXJyb3IuXG4gKlxuICogV2hlbiBkYXRhIGxvYWRpbmcsIHNlcnZlciBvciBjbGllbnQgc2lkZSwgd2UgdXNlIHRoZSBlbXVsYXRvciB0byBsaWtld2lzZVxuICogaGFuZyBvbiB0byB0aGUgZXJyb3IgYW5kIHJlLXJlbmRlciBhdCB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0ICh3aGVyZSBhIHRocm93blxuICogZXJyb3Igd291bGQgaGF2ZSBiZWVuIGNhdWdodCBieSBjREMpLlxuICpcbiAqIFdoZW4gYWN0aW9ucyB0aHJvdywgaXQgYWxsIHdvcmtzIHRoZSBzYW1lLiBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB0byBiZSBhd2FyZVxuICogb2YgdGhvdWdoLiBBY3Rpb25zIG5vcm1hbGx5IGFyZSByZXF1aXJlZCB0byByZWRpcmVjdCwgYnV0IGluIHRoZSBjYXNlIG9mXG4gKiBlcnJvcnMsIHdlIHJlbmRlciB0aGUgYWN0aW9uJ3Mgcm91dGUgd2l0aCB0aGUgZW11bGF0b3IgaG9sZGluZyBvbiB0byB0aGVcbiAqIGVycm9yLiBJZiBkdXJpbmcgdGhpcyByZW5kZXIgYSBwYXJlbnQgcm91dGUvbG9hZGVyIHRocm93cyB3ZSBpZ25vcmUgdGhhdCBuZXdcbiAqIGVycm9yIGFuZCByZW5kZXIgdGhlIGFjdGlvbidzIG9yaWdpbmFsIGVycm9yIGFzIGRlZXBseSBhcyBwb3NzaWJsZS4gSW4gb3RoZXJcbiAqIHdvcmRzLCB3ZSBzaW1wbHkgaWdub3JlIHRoZSBuZXcgZXJyb3IgYW5kIHVzZSB0aGUgYWN0aW9uJ3MgZXJyb3IgaW4gcGxhY2VcbiAqIGJlY2F1c2UgaXQgY2FtZSBmaXJzdCwgYW5kIHRoYXQganVzdCB3b3VsZG4ndCBiZSBmYWlyIHRvIGxldCBlcnJvcnMgY3V0IGluXG4gKiBsaW5lLlxuICovXG5hc3luYyBmdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gIH07XG59XG5cbmV4cG9ydCB7IHNlcmlhbGl6ZUVycm9yIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBzcGxpdENvb2tpZXNTdHJpbmcgfSBmcm9tICdzZXQtY29va2llLXBhcnNlcic7XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgbWF0Y2hlcywgcm91dGVMb2FkZXJSZXNwb25zZXMsIGFjdGlvblJlc3BvbnNlKSB7XG4gIHJldHVybiBtYXRjaGVzLnJlZHVjZSgocGFyZW50SGVhZGVycywgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gYnVpbGQucm91dGVzW21hdGNoLnJvdXRlLmlkXS5tb2R1bGU7XG4gICAgbGV0IHJvdXRlTG9hZGVyUmVzcG9uc2UgPSByb3V0ZUxvYWRlclJlc3BvbnNlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IGxvYWRlckhlYWRlcnMgPSByb3V0ZUxvYWRlclJlc3BvbnNlID8gcm91dGVMb2FkZXJSZXNwb25zZS5oZWFkZXJzIDogbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgYWN0aW9uSGVhZGVycyA9IGFjdGlvblJlc3BvbnNlID8gYWN0aW9uUmVzcG9uc2UuaGVhZGVycyA6IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyb3V0ZU1vZHVsZS5oZWFkZXJzID8gdHlwZW9mIHJvdXRlTW9kdWxlLmhlYWRlcnMgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLmhlYWRlcnMoe1xuICAgICAgbG9hZGVySGVhZGVycyxcbiAgICAgIHBhcmVudEhlYWRlcnMsXG4gICAgICBhY3Rpb25IZWFkZXJzXG4gICAgfSkgOiByb3V0ZU1vZHVsZS5oZWFkZXJzIDogdW5kZWZpbmVkKTsgLy8gQXV0b21hdGljYWxseSBwcmVzZXJ2ZSBTZXQtQ29va2llIGhlYWRlcnMgdGhhdCB3ZXJlIHNldCBlaXRoZXIgYnkgdGhlXG4gICAgLy8gbG9hZGVyIG9yIGJ5IGEgcGFyZW50IHJvdXRlLlxuXG4gICAgcHJlcGVuZENvb2tpZXMoYWN0aW9uSGVhZGVycywgaGVhZGVycyk7XG4gICAgcHJlcGVuZENvb2tpZXMobG9hZGVySGVhZGVycywgaGVhZGVycyk7XG4gICAgcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgaGVhZGVycyk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sIG5ldyBIZWFkZXJzKCkpO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBjaGlsZEhlYWRlcnMpIHtcbiAgbGV0IHBhcmVudFNldENvb2tpZVN0cmluZyA9IHBhcmVudEhlYWRlcnMuZ2V0KFwiU2V0LUNvb2tpZVwiKTtcblxuICBpZiAocGFyZW50U2V0Q29va2llU3RyaW5nKSB7XG4gICAgbGV0IGNvb2tpZXMgPSBzcGxpdENvb2tpZXNTdHJpbmcocGFyZW50U2V0Q29va2llU3RyaW5nKTtcbiAgICBjb29raWVzLmZvckVhY2goY29va2llID0+IHtcbiAgICAgIGNoaWxkSGVhZGVycy5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0RG9jdW1lbnRIZWFkZXJzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBtYXRjaFJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG4vLyBUT0RPOiBleHBvcnQvaW1wb3J0IGZyb20gcmVhY3Qtcm91dGVyLWRvbVxuZnVuY3Rpb24gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCBwYXRobmFtZSkge1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgbWF0Y2hTZXJ2ZXJSb3V0ZXMgfTtcbiIsICJpbXBvcnQgX2V4dGVuZHMgZnJvbSdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJzt2YXIgcixCPXJ8fChyPXt9KTtCLlBvcD1cIlBPUFwiO0IuUHVzaD1cIlBVU0hcIjtCLlJlcGxhY2U9XCJSRVBMQUNFXCI7dmFyIEM9XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9mdW5jdGlvbihiKXtyZXR1cm4gT2JqZWN0LmZyZWV6ZShiKX06ZnVuY3Rpb24oYil7cmV0dXJuIGJ9O2Z1bmN0aW9uIEQoYixoKXtpZighYil7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlJiZjb25zb2xlLndhcm4oaCk7dHJ5e3Rocm93IEVycm9yKGgpO31jYXRjaChlKXt9fX1mdW5jdGlvbiBFKGIpe2IucHJldmVudERlZmF1bHQoKTtiLnJldHVyblZhbHVlPVwiXCJ9XG5mdW5jdGlvbiBGKCl7dmFyIGI9W107cmV0dXJue2dldCBsZW5ndGgoKXtyZXR1cm4gYi5sZW5ndGh9LHB1c2g6ZnVuY3Rpb24oaCl7Yi5wdXNoKGgpO3JldHVybiBmdW5jdGlvbigpe2I9Yi5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT1ofSl9fSxjYWxsOmZ1bmN0aW9uKGgpe2IuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZSYmZShoKX0pfX19ZnVuY3Rpb24gSCgpe3JldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiw4KX1mdW5jdGlvbiBJKGIpe3ZhciBoPWIucGF0aG5hbWU7aD12b2lkIDA9PT1oP1wiL1wiOmg7dmFyIGU9Yi5zZWFyY2g7ZT12b2lkIDA9PT1lP1wiXCI6ZTtiPWIuaGFzaDtiPXZvaWQgMD09PWI/XCJcIjpiO2UmJlwiP1wiIT09ZSYmKGgrPVwiP1wiPT09ZS5jaGFyQXQoMCk/ZTpcIj9cIitlKTtiJiZcIiNcIiE9PWImJihoKz1cIiNcIj09PWIuY2hhckF0KDApP2I6XCIjXCIrYik7cmV0dXJuIGh9XG5mdW5jdGlvbiBKKGIpe3ZhciBoPXt9O2lmKGIpe3ZhciBlPWIuaW5kZXhPZihcIiNcIik7MDw9ZSYmKGguaGFzaD1iLnN1YnN0cihlKSxiPWIuc3Vic3RyKDAsZSkpO2U9Yi5pbmRleE9mKFwiP1wiKTswPD1lJiYoaC5zZWFyY2g9Yi5zdWJzdHIoZSksYj1iLnN1YnN0cigwLGUpKTtiJiYoaC5wYXRobmFtZT1iKX1yZXR1cm4gaH1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KGIpe2Z1bmN0aW9uIGgoKXt2YXIgYz1wLmxvY2F0aW9uLGE9bS5zdGF0ZXx8e307cmV0dXJuW2EuaWR4LEMoe3BhdGhuYW1lOmMucGF0aG5hbWUsc2VhcmNoOmMuc2VhcmNoLGhhc2g6Yy5oYXNoLHN0YXRlOmEudXNyfHxudWxsLGtleTphLmtleXx8XCJkZWZhdWx0XCJ9KV19ZnVuY3Rpb24gZShjKXtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGM/YzpJKGMpfWZ1bmN0aW9uIHgoYyxhKXt2b2lkIDA9PT1hJiYoYT1udWxsKTtyZXR1cm4gQyhfZXh0ZW5kcyh7cGF0aG5hbWU6cS5wYXRobmFtZSxoYXNoOlwiXCIsc2VhcmNoOlwiXCJ9LFwic3RyaW5nXCI9PT10eXBlb2YgYz9KKGMpOmMse3N0YXRlOmEsa2V5OkgoKX0pKX1mdW5jdGlvbiB6KGMpe3Q9YztjPWgoKTt2PWNbMF07cT1jWzFdO2QuY2FsbCh7YWN0aW9uOnQsbG9jYXRpb246cX0pfWZ1bmN0aW9uIEEoYyxhKXtmdW5jdGlvbiBmKCl7QShjLGEpfXZhciBsPXIuUHVzaCxrPXgoYyxcbmEpO2lmKCFnLmxlbmd0aHx8KGcuY2FsbCh7YWN0aW9uOmwsbG9jYXRpb246ayxyZXRyeTpmfSksITEpKXt2YXIgbj1be3VzcjprLnN0YXRlLGtleTprLmtleSxpZHg6disxfSxlKGspXTtrPW5bMF07bj1uWzFdO3RyeXttLnB1c2hTdGF0ZShrLFwiXCIsbil9Y2F0Y2goRyl7cC5sb2NhdGlvbi5hc3NpZ24obil9eihsKX19ZnVuY3Rpb24geShjLGEpe2Z1bmN0aW9uIGYoKXt5KGMsYSl9dmFyIGw9ci5SZXBsYWNlLGs9eChjLGEpO2cubGVuZ3RoJiYoZy5jYWxsKHthY3Rpb246bCxsb2NhdGlvbjprLHJldHJ5OmZ9KSwxKXx8KGs9W3t1c3I6ay5zdGF0ZSxrZXk6ay5rZXksaWR4OnZ9LGUoayldLG0ucmVwbGFjZVN0YXRlKGtbMF0sXCJcIixrWzFdKSx6KGwpKX1mdW5jdGlvbiB3KGMpe20uZ28oYyl9dm9pZCAwPT09YiYmKGI9e30pO2I9Yi53aW5kb3c7dmFyIHA9dm9pZCAwPT09Yj9kb2N1bWVudC5kZWZhdWx0VmlldzpiLG09cC5oaXN0b3J5LHU9bnVsbDtwLmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLFxuZnVuY3Rpb24oKXtpZih1KWcuY2FsbCh1KSx1PW51bGw7ZWxzZXt2YXIgYz1yLlBvcCxhPWgoKSxmPWFbMF07YT1hWzFdO2lmKGcubGVuZ3RoKWlmKG51bGwhPWYpe3ZhciBsPXYtZjtsJiYodT17YWN0aW9uOmMsbG9jYXRpb246YSxyZXRyeTpmdW5jdGlvbigpe3coLTEqbCl9fSx3KGwpKX1lbHNlXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKCExLFwiWW91IGFyZSB0cnlpbmcgdG8gYmxvY2sgYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoZSBoaXN0b3J5IGxpYnJhcnkuIFRoZSBibG9jayB3aWxsIGZhaWwgc2lsZW50bHkgaW4gcHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBoaXN0b3J5IGxpYnJhcnkgKGluc3RlYWQgb2YgdXNpbmcgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlIGRpcmVjdGx5KSB0byBhdm9pZCB0aGlzIHNpdHVhdGlvbi5cIik6XG52b2lkIDA7ZWxzZSB6KGMpfX0pO3ZhciB0PXIuUG9wO2I9aCgpO3ZhciB2PWJbMF0scT1iWzFdLGQ9RigpLGc9RigpO251bGw9PXYmJih2PTAsbS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sbS5zdGF0ZSx7aWR4OnZ9KSxcIlwiKSk7cmV0dXJue2dldCBhY3Rpb24oKXtyZXR1cm4gdH0sZ2V0IGxvY2F0aW9uKCl7cmV0dXJuIHF9LGNyZWF0ZUhyZWY6ZSxwdXNoOkEscmVwbGFjZTp5LGdvOncsYmFjazpmdW5jdGlvbigpe3coLTEpfSxmb3J3YXJkOmZ1bmN0aW9uKCl7dygxKX0sbGlzdGVuOmZ1bmN0aW9uKGMpe3JldHVybiBkLnB1c2goYyl9LGJsb2NrOmZ1bmN0aW9uKGMpe3ZhciBhPWcucHVzaChjKTsxPT09Zy5sZW5ndGgmJnAuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLEUpO3JldHVybiBmdW5jdGlvbigpe2EoKTtnLmxlbmd0aHx8cC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsRSl9fX19O1xuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoYil7ZnVuY3Rpb24gaCgpe3ZhciBhPUoobS5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSksZj1hLnBhdGhuYW1lLGw9YS5zZWFyY2g7YT1hLmhhc2g7dmFyIGs9dS5zdGF0ZXx8e307cmV0dXJuW2suaWR4LEMoe3BhdGhuYW1lOnZvaWQgMD09PWY/XCIvXCI6ZixzZWFyY2g6dm9pZCAwPT09bD9cIlwiOmwsaGFzaDp2b2lkIDA9PT1hP1wiXCI6YSxzdGF0ZTprLnVzcnx8bnVsbCxrZXk6ay5rZXl8fFwiZGVmYXVsdFwifSldfWZ1bmN0aW9uIGUoKXtpZih0KWMuY2FsbCh0KSx0PW51bGw7ZWxzZXt2YXIgYT1yLlBvcCxmPWgoKSxsPWZbMF07Zj1mWzFdO2lmKGMubGVuZ3RoKWlmKG51bGwhPWwpe3ZhciBrPXEtbDtrJiYodD17YWN0aW9uOmEsbG9jYXRpb246ZixyZXRyeTpmdW5jdGlvbigpe3AoLTEqayl9fSxwKGspKX1lbHNlXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKCExLFwiWW91IGFyZSB0cnlpbmcgdG8gYmxvY2sgYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoZSBoaXN0b3J5IGxpYnJhcnkuIFRoZSBibG9jayB3aWxsIGZhaWwgc2lsZW50bHkgaW4gcHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBoaXN0b3J5IGxpYnJhcnkgKGluc3RlYWQgb2YgdXNpbmcgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlIGRpcmVjdGx5KSB0byBhdm9pZCB0aGlzIHNpdHVhdGlvbi5cIik6XG52b2lkIDA7ZWxzZSBBKGEpfX1mdW5jdGlvbiB4KGEpe3ZhciBmPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpLGw9XCJcIjtmJiZmLmdldEF0dHJpYnV0ZShcImhyZWZcIikmJihmPW0ubG9jYXRpb24uaHJlZixsPWYuaW5kZXhPZihcIiNcIiksbD0tMT09PWw/ZjpmLnNsaWNlKDAsbCkpO3JldHVybiBsK1wiI1wiKyhcInN0cmluZ1wiPT09dHlwZW9mIGE/YTpJKGEpKX1mdW5jdGlvbiB6KGEsZil7dm9pZCAwPT09ZiYmKGY9bnVsbCk7cmV0dXJuIEMoX2V4dGVuZHMoe3BhdGhuYW1lOmQucGF0aG5hbWUsaGFzaDpcIlwiLHNlYXJjaDpcIlwifSxcInN0cmluZ1wiPT09dHlwZW9mIGE/SihhKTphLHtzdGF0ZTpmLGtleTpIKCl9KSl9ZnVuY3Rpb24gQShhKXt2PWE7YT1oKCk7cT1hWzBdO2Q9YVsxXTtnLmNhbGwoe2FjdGlvbjp2LGxvY2F0aW9uOmR9KX1mdW5jdGlvbiB5KGEsZil7ZnVuY3Rpb24gbCgpe3koYSxmKX12YXIgaz1yLlB1c2gsbj16KGEsZik7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9cbkQoXCIvXCI9PT1uLnBhdGhuYW1lLmNoYXJBdCgwKSxcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaChcIitKU09OLnN0cmluZ2lmeShhKStcIilcIik6dm9pZCAwO2lmKCFjLmxlbmd0aHx8KGMuY2FsbCh7YWN0aW9uOmssbG9jYXRpb246bixyZXRyeTpsfSksITEpKXt2YXIgRz1be3VzcjpuLnN0YXRlLGtleTpuLmtleSxpZHg6cSsxfSx4KG4pXTtuPUdbMF07Rz1HWzFdO3RyeXt1LnB1c2hTdGF0ZShuLFwiXCIsRyl9Y2F0Y2goSyl7bS5sb2NhdGlvbi5hc3NpZ24oRyl9QShrKX19ZnVuY3Rpb24gdyhhLGYpe2Z1bmN0aW9uIGwoKXt3KGEsZil9dmFyIGs9ci5SZXBsYWNlLG49eihhLGYpO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/RChcIi9cIj09PW4ucGF0aG5hbWUuY2hhckF0KDApLFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5yZXBsYWNlKFwiK0pTT04uc3RyaW5naWZ5KGEpK1xuXCIpXCIpOnZvaWQgMDtjLmxlbmd0aCYmKGMuY2FsbCh7YWN0aW9uOmssbG9jYXRpb246bixyZXRyeTpsfSksMSl8fChuPVt7dXNyOm4uc3RhdGUsa2V5Om4ua2V5LGlkeDpxfSx4KG4pXSx1LnJlcGxhY2VTdGF0ZShuWzBdLFwiXCIsblsxXSksQShrKSl9ZnVuY3Rpb24gcChhKXt1LmdvKGEpfXZvaWQgMD09PWImJihiPXt9KTtiPWIud2luZG93O3ZhciBtPXZvaWQgMD09PWI/ZG9jdW1lbnQuZGVmYXVsdFZpZXc6Yix1PW0uaGlzdG9yeSx0PW51bGw7bS5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIixlKTttLmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsZnVuY3Rpb24oKXt2YXIgYT1oKClbMV07SShhKSE9PUkoZCkmJmUoKX0pO3ZhciB2PXIuUG9wO2I9aCgpO3ZhciBxPWJbMF0sZD1iWzFdLGc9RigpLGM9RigpO251bGw9PXEmJihxPTAsdS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sdS5zdGF0ZSx7aWR4OnF9KSxcIlwiKSk7cmV0dXJue2dldCBhY3Rpb24oKXtyZXR1cm4gdn0sZ2V0IGxvY2F0aW9uKCl7cmV0dXJuIGR9LFxuY3JlYXRlSHJlZjp4LHB1c2g6eSxyZXBsYWNlOncsZ286cCxiYWNrOmZ1bmN0aW9uKCl7cCgtMSl9LGZvcndhcmQ6ZnVuY3Rpb24oKXtwKDEpfSxsaXN0ZW46ZnVuY3Rpb24oYSl7cmV0dXJuIGcucHVzaChhKX0sYmxvY2s6ZnVuY3Rpb24oYSl7dmFyIGY9Yy5wdXNoKGEpOzE9PT1jLmxlbmd0aCYmbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsRSk7cmV0dXJuIGZ1bmN0aW9uKCl7ZigpO2MubGVuZ3RofHxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIixFKX19fX07XG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KGIpe2Z1bmN0aW9uIGgoZCxnKXt2b2lkIDA9PT1nJiYoZz1udWxsKTtyZXR1cm4gQyhfZXh0ZW5kcyh7cGF0aG5hbWU6dC5wYXRobmFtZSxzZWFyY2g6XCJcIixoYXNoOlwiXCJ9LFwic3RyaW5nXCI9PT10eXBlb2YgZD9KKGQpOmQse3N0YXRlOmcsa2V5OkgoKX0pKX1mdW5jdGlvbiBlKGQsZyxjKXtyZXR1cm4hcS5sZW5ndGh8fChxLmNhbGwoe2FjdGlvbjpkLGxvY2F0aW9uOmcscmV0cnk6Y30pLCExKX1mdW5jdGlvbiB4KGQsZyl7dT1kO3Q9Zzt2LmNhbGwoe2FjdGlvbjp1LGxvY2F0aW9uOnR9KX1mdW5jdGlvbiB6KGQsZyl7dmFyIGM9ci5QdXNoLGE9aChkLGcpO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/RChcIi9cIj09PXQucGF0aG5hbWUuY2hhckF0KDApLFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5LnB1c2goXCIrSlNPTi5zdHJpbmdpZnkoZCkrXCIpXCIpOlxudm9pZCAwO2UoYyxhLGZ1bmN0aW9uKCl7eihkLGcpfSkmJihtKz0xLHAuc3BsaWNlKG0scC5sZW5ndGgsYSkseChjLGEpKX1mdW5jdGlvbiBBKGQsZyl7dmFyIGM9ci5SZXBsYWNlLGE9aChkLGcpO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/RChcIi9cIj09PXQucGF0aG5hbWUuY2hhckF0KDApLFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5LnJlcGxhY2UoXCIrSlNPTi5zdHJpbmdpZnkoZCkrXCIpXCIpOnZvaWQgMDtlKGMsYSxmdW5jdGlvbigpe0EoZCxnKX0pJiYocFttXT1hLHgoYyxhKSl9ZnVuY3Rpb24geShkKXt2YXIgZz1NYXRoLm1pbihNYXRoLm1heChtK2QsMCkscC5sZW5ndGgtMSksYz1yLlBvcCxhPXBbZ107ZShjLGEsZnVuY3Rpb24oKXt5KGQpfSkmJihtPWcseChjLGEpKX12b2lkIDA9PT1iJiYoYj17fSk7dmFyIHc9YjtiPXcuaW5pdGlhbEVudHJpZXM7dz13LmluaXRpYWxJbmRleDt2YXIgcD0odm9pZCAwPT09XG5iP1tcIi9cIl06YikubWFwKGZ1bmN0aW9uKGQpe3ZhciBnPUMoX2V4dGVuZHMoe3BhdGhuYW1lOlwiL1wiLHNlYXJjaDpcIlwiLGhhc2g6XCJcIixzdGF0ZTpudWxsLGtleTpIKCl9LFwic3RyaW5nXCI9PT10eXBlb2YgZD9KKGQpOmQpKTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoXCIvXCI9PT1nLnBhdGhuYW1lLmNoYXJBdCgwKSxcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjcmVhdGVNZW1vcnlIaXN0b3J5KHsgaW5pdGlhbEVudHJpZXMgfSkgKGludmFsaWQgZW50cnk6IFwiK0pTT04uc3RyaW5naWZ5KGQpK1wiKVwiKTp2b2lkIDA7cmV0dXJuIGd9KSxtPU1hdGgubWluKE1hdGgubWF4KG51bGw9PXc/cC5sZW5ndGgtMTp3LDApLHAubGVuZ3RoLTEpLHU9ci5Qb3AsdD1wW21dLHY9RigpLHE9RigpO3JldHVybntnZXQgaW5kZXgoKXtyZXR1cm4gbX0sZ2V0IGFjdGlvbigpe3JldHVybiB1fSxnZXQgbG9jYXRpb24oKXtyZXR1cm4gdH0sY3JlYXRlSHJlZjpmdW5jdGlvbihkKXtyZXR1cm5cInN0cmluZ1wiPT09XG50eXBlb2YgZD9kOkkoZCl9LHB1c2g6eixyZXBsYWNlOkEsZ286eSxiYWNrOmZ1bmN0aW9uKCl7eSgtMSl9LGZvcndhcmQ6ZnVuY3Rpb24oKXt5KDEpfSxsaXN0ZW46ZnVuY3Rpb24oZCl7cmV0dXJuIHYucHVzaChkKX0sYmxvY2s6ZnVuY3Rpb24oZCl7cmV0dXJuIHEucHVzaChkKX19fTtleHBvcnR7ciBhcyBBY3Rpb24sY3JlYXRlQnJvd3Nlckhpc3RvcnksY3JlYXRlSGFzaEhpc3RvcnksY3JlYXRlTWVtb3J5SGlzdG9yeSxJIGFzIGNyZWF0ZVBhdGgsSiBhcyBwYXJzZVBhdGh9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgSGlzdG9yeSxcbiAgSW5pdGlhbEVudHJ5LFxuICBMb2NhdGlvbixcbiAgTWVtb3J5SGlzdG9yeSxcbiAgUGF0aCxcbiAgVG9cbn0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7XG4gIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSxcbiAgY3JlYXRlTWVtb3J5SGlzdG9yeSxcbiAgcGFyc2VQYXRoXG59IGZyb20gXCJoaXN0b3J5XCI7XG5cbmV4cG9ydCB0eXBlIHsgTG9jYXRpb24sIFBhdGgsIFRvLCBOYXZpZ2F0aW9uVHlwZSB9O1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpOiBhc3NlcnRzIGNvbmQge1xuICBpZiAoIWNvbmQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2FybmluZyhjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IFJvdXRlciFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG5jb25zdCBhbHJlYWR5V2FybmVkOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5OiBzdHJpbmcsIGNvbmQ6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZykge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09OVEVYVFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgTmF2aWdhdG9yIGlzIGEgXCJsb2NhdGlvbiBjaGFuZ2VyXCI7IGl0J3MgaG93IHlvdSBnZXQgdG8gZGlmZmVyZW50IGxvY2F0aW9ucy5cbiAqXG4gKiBFdmVyeSBoaXN0b3J5IGluc3RhbmNlIGNvbmZvcm1zIHRvIHRoZSBOYXZpZ2F0b3IgaW50ZXJmYWNlLCBidXQgdGhlXG4gKiBkaXN0aW5jdGlvbiBpcyB1c2VmdWwgcHJpbWFyaWx5IHdoZW4gaXQgY29tZXMgdG8gdGhlIGxvdy1sZXZlbCA8Um91dGVyPiBBUElcbiAqIHdoZXJlIGJvdGggdGhlIGxvY2F0aW9uIGFuZCBhIG5hdmlnYXRvciBtdXN0IGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgaW4gb3JkZXJcbiAqIHRvIGF2b2lkIFwidGVhcmluZ1wiIHRoYXQgbWF5IG9jY3VyIGluIGEgc3VzcGVuc2UtZW5hYmxlZCBhcHAgaWYgdGhlIGFjdGlvblxuICogYW5kL29yIGxvY2F0aW9uIHdlcmUgdG8gYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBoaXN0b3J5IGluc3RhbmNlLlxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0b3IgPSBQaWNrPEhpc3RvcnksIFwiZ29cIiB8IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgfCBcImNyZWF0ZUhyZWZcIj47XG5cbmludGVyZmFjZSBOYXZpZ2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGJhc2VuYW1lOiBzdHJpbmc7XG4gIG5hdmlnYXRvcjogTmF2aWdhdG9yO1xuICBzdGF0aWM6IGJvb2xlYW47XG59XG5cbmNvbnN0IE5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOYXZpZ2F0aW9uQ29udGV4dE9iamVjdD4obnVsbCEpO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuXG5pbnRlcmZhY2UgTG9jYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xuICBuYXZpZ2F0aW9uVHlwZTogTmF2aWdhdGlvblR5cGU7XG59XG5cbmNvbnN0IExvY2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TG9jYXRpb25Db250ZXh0T2JqZWN0PihudWxsISk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQ29udGV4dE9iamVjdCB7XG4gIG91dGxldDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbDtcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdO1xufVxuXG5jb25zdCBSb3V0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFJvdXRlQ29udGV4dE9iamVjdD4oe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdXG59KTtcblxuaWYgKF9fREVWX18pIHtcbiAgUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDT01QT05FTlRTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb3J5Um91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gIGluaXRpYWxJbmRleD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGFsbCBlbnRyaWVzIGluIG1lbW9yeS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI21lbW9yeXJvdXRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gTWVtb3J5Um91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBpbml0aWFsRW50cmllcyxcbiAgaW5pdGlhbEluZGV4XG59OiBNZW1vcnlSb3V0ZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPE1lbW9yeUhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3RvcnkoeyBpbml0aWFsRW50cmllcywgaW5pdGlhbEluZGV4IH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVQcm9wcyB7XG4gIHRvOiBUbztcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNuYXZpZ2F0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTmF2aWdhdGUoeyB0bywgcmVwbGFjZSwgc3RhdGUgfTogTmF2aWdhdGVQcm9wcyk6IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGA8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHdhcm5pbmcoXG4gICAgIVJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYyxcbiAgICBgPE5hdmlnYXRlPiBtdXN0IG5vdCBiZSB1c2VkIG9uIHRoZSBpbml0aWFsIHJlbmRlciBpbiBhIDxTdGF0aWNSb3V0ZXI+LiBgICtcbiAgICAgIGBUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgYCArXG4gICAgICBgb25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuYFxuICApO1xuXG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbmF2aWdhdGUodG8sIHsgcmVwbGFjZSwgc3RhdGUgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dGxldFByb3BzIHtcbiAgY29udGV4dD86IHVua25vd247XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNvdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE91dGxldChwcm9wczogT3V0bGV0UHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVByb3BzIHtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgaW5kZXg/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhSb3V0ZVByb3BzIHtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgaW5kZXg/OiBmYWxzZTtcbiAgcGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExheW91dFJvdXRlUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhSb3V0ZVByb3BzIHtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4OiB0cnVlO1xufVxuXG4vKipcbiAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlKFxuICBfcHJvcHM6IFBhdGhSb3V0ZVByb3BzIHwgTGF5b3V0Um91dGVQcm9wcyB8IEluZGV4Um91dGVQcm9wc1xuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICBgQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBgICtcbiAgICAgIGBuZXZlciByZW5kZXJlZCBkaXJlY3RseS4gUGxlYXNlIHdyYXAgeW91ciA8Um91dGU+IGluIGEgPFJvdXRlcz4uYFxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBsb2NhdGlvbjogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmc7XG4gIG5hdmlnYXRpb25UeXBlPzogTmF2aWdhdGlvblR5cGU7XG4gIG5hdmlnYXRvcjogTmF2aWdhdG9yO1xuICBzdGF0aWM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGxvY2F0aW9uIGNvbnRleHQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcHAuXG4gKlxuICogTm90ZTogWW91IHVzdWFsbHkgd29uJ3QgcmVuZGVyIGEgPFJvdXRlcj4gZGlyZWN0bHkuIEluc3RlYWQsIHlvdSdsbCByZW5kZXIgYVxuICogcm91dGVyIHRoYXQgaXMgbW9yZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50IHN1Y2ggYXMgYSA8QnJvd3NlclJvdXRlcj5cbiAqIGluIHdlYiBicm93c2VycyBvciBhIDxTdGF0aWNSb3V0ZXI+IGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXIoe1xuICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgbmF2aWdhdGlvblR5cGUgPSBOYXZpZ2F0aW9uVHlwZS5Qb3AsXG4gIG5hdmlnYXRvcixcbiAgc3RhdGljOiBzdGF0aWNQcm9wID0gZmFsc2Vcbn06IFJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgYFlvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uYCArXG4gICAgICBgIFlvdSBzaG91bGQgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGluIHlvdXIgYXBwLmBcbiAgKTtcblxuICBsZXQgYmFzZW5hbWUgPSBub3JtYWxpemVQYXRobmFtZShiYXNlbmFtZVByb3ApO1xuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7IGJhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpYzogc3RhdGljUHJvcCB9KSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF1cbiAgKTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG5cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiXG4gIH0gPSBsb2NhdGlvblByb3A7XG5cbiAgbGV0IGxvY2F0aW9uID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICBzZWFyY2gsXG4gICAgICBoYXNoLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXldKTtcblxuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uICE9IG51bGwsXG4gICAgYDxSb3V0ZXIgYmFzZW5hbWU9XCIke2Jhc2VuYW1lfVwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIGAgK1xuICAgICAgYFwiJHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9XCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBgICtcbiAgICAgIGBiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5gXG4gICk7XG5cbiAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtuYXZpZ2F0aW9uQ29udGV4dH0+XG4gICAgICA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyXG4gICAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgICAgdmFsdWU9e3sgbG9jYXRpb24sIG5hdmlnYXRpb25UeXBlIH19XG4gICAgICAvPlxuICAgIDwvTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVzUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb24/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiA8Um91dGU+IGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXG4gKiB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVzKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2F0aW9uXG59OiBSb3V0ZXNQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSE9PS1Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VocmVmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VIcmVmKHRvOiBUbyk6IHN0cmluZyB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUhyZWYoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgaGFzaCwgcGF0aG5hbWUsIHNlYXJjaCB9ID0gdXNlUmVzb2x2ZWRQYXRoKHRvKTtcblxuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIGxldCB0b1BhdGhuYW1lID0gZ2V0VG9QYXRobmFtZSh0byk7XG4gICAgbGV0IGVuZHNXaXRoU2xhc2ggPSB0b1BhdGhuYW1lICE9IG51bGwgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gICAgam9pbmVkUGF0aG5hbWUgPVxuICAgICAgcGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gYmFzZW5hbWUgKyAoZW5kc1dpdGhTbGFzaCA/IFwiL1wiIDogXCJcIilcbiAgICAgICAgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHsgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhIDxSb3V0ZXI+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlaW5yb3V0ZXJjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBVUkwgaW4gd2ViXG4gKiBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBJZiB5b3UncmUgdXNpbmcgdGhpcyBpdCBtYXkgbWVhbiB5b3UncmUgZG9pbmcgc29tZSBvZiB5b3VyIG93blxuICogXCJyb3V0aW5nXCIgaW4geW91ciBhcHAsIGFuZCB3ZSdkIGxpa2UgdG8ga25vdyB3aGF0IHlvdXIgdXNlIGNhc2UgaXMuIFdlIG1heVxuICogYmUgYWJsZSB0byBwcm92aWRlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdG8gYmV0dGVyIHN1aXQgeW91ciBuZWVkcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZWxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhdGlvbigpOiBMb2NhdGlvbiB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5sb2NhdGlvbjtcbn1cblxudHlwZSBQYXJhbVBhcnNlRmFpbGVkID0geyBmYWlsZWQ6IHRydWUgfTtcblxudHlwZSBQYXJhbVBhcnNlU2VnbWVudDxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIENoZWNrIGhlcmUgaWYgdGhlcmUgZXhpc3RzIGEgZm9yd2FyZCBzbGFzaCBpbiB0aGUgc3RyaW5nLlxuICBTZWdtZW50IGV4dGVuZHMgYCR7aW5mZXIgTGVmdFNlZ21lbnR9LyR7aW5mZXIgUmlnaHRTZWdtZW50fWBcbiAgICA/IC8vIElmIHRoZXJlIGlzIGEgZm9yd2FyZCBzbGFzaCwgdGhlbiBhdHRlbXB0IHRvIHBhcnNlIGVhY2ggc2lkZSBvZiB0aGVcbiAgICAgIC8vIGZvcndhcmQgc2xhc2guXG4gICAgICBQYXJhbVBhcnNlU2VnbWVudDxMZWZ0U2VnbWVudD4gZXh0ZW5kcyBpbmZlciBMZWZ0UmVzdWx0XG4gICAgICA/IFBhcmFtUGFyc2VTZWdtZW50PFJpZ2h0U2VnbWVudD4gZXh0ZW5kcyBpbmZlciBSaWdodFJlc3VsdFxuICAgICAgICA/IExlZnRSZXN1bHQgZXh0ZW5kcyBzdHJpbmdcbiAgICAgICAgICA/IC8vIElmIHRoZSBsZWZ0IHNpZGUgaXMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBhcyBhIHBhcmFtLCB0aGVuIGNoZWNrIGlmXG4gICAgICAgICAgICAvLyB0aGUgcmlnaHQgc2lkZSBjYW4gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBhcyB3ZWxsLiBJZiBib3RoIHNpZGVzXG4gICAgICAgICAgICAvLyBjYW4gYmUgcGFyc2VkLCB0aGVuIHRoZSByZXN1bHQgaXMgYSB1bmlvbiBvZiB0aGUgdHdvIHNpZGVzXG4gICAgICAgICAgICAvLyAocmVhZDogXCJmb29cIiB8IFwiYmFyXCIpLlxuICAgICAgICAgICAgUmlnaHRSZXN1bHQgZXh0ZW5kcyBzdHJpbmdcbiAgICAgICAgICAgID8gTGVmdFJlc3VsdCB8IFJpZ2h0UmVzdWx0XG4gICAgICAgICAgICA6IExlZnRSZXN1bHRcbiAgICAgICAgICA6IC8vIElmIHRoZSBsZWZ0IHNpZGUgaXMgbm90IHN1Y2Nlc3NmdWxseSBwYXJzZWQgYXMgYSBwYXJhbSwgdGhlbiBjaGVja1xuICAgICAgICAgIC8vIGlmIG9ubHkgdGhlIHJpZ2h0IHNpZGUgY2FuIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZSBhcyBhIHBhcmFtLiBJZiBpdFxuICAgICAgICAgIC8vIGNhbiwgdGhlbiB0aGUgcmVzdWx0IGlzIGp1c3QgcmlnaHQsIGVsc2UgaXQncyBhIGZhaWx1cmUuXG4gICAgICAgICAgUmlnaHRSZXN1bHQgZXh0ZW5kcyBzdHJpbmdcbiAgICAgICAgICA/IFJpZ2h0UmVzdWx0XG4gICAgICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgICAgOiAvLyBJZiB0aGUgbGVmdCBzaWRlIGRpZG4ndCBwYXJzZSBpbnRvIGEgcGFyYW0sIHRoZW4ganVzdCBjaGVjayB0aGUgcmlnaHRcbiAgICAgIC8vIHNpZGUuXG4gICAgICBQYXJhbVBhcnNlU2VnbWVudDxSaWdodFNlZ21lbnQ+IGV4dGVuZHMgaW5mZXIgUmlnaHRSZXN1bHRcbiAgICAgID8gUmlnaHRSZXN1bHQgZXh0ZW5kcyBzdHJpbmdcbiAgICAgICAgPyBSaWdodFJlc3VsdFxuICAgICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgIDogLy8gSWYgdGhlcmUncyBubyBmb3J3YXJkIHNsYXNoLCB0aGVuIGNoZWNrIGlmIHRoaXMgc2VnbWVudCBzdGFydHMgd2l0aCBhXG4gICAgLy8gY29sb24uIElmIGl0IGRvZXMsIHRoZW4gdGhpcyBpcyBhIGR5bmFtaWMgc2VnbWVudCwgc28gdGhlIHJlc3VsdCBpc1xuICAgIC8vIGp1c3QgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3RyaW5nLiBPdGhlcndpc2UsIGl0J3MgYSBmYWlsdXJlLlxuICAgIFNlZ21lbnQgZXh0ZW5kcyBgOiR7aW5mZXIgUmVtYWluaW5nfWBcbiAgICA/IFJlbWFpbmluZ1xuICAgIDogUGFyYW1QYXJzZUZhaWxlZDtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIHNlZ21lbnQuIElmIGl0IGZhaWxzLCB0aGVuIGp1c3QgcmV0dXJuIHRoZVxuLy8gcGxhaW4gc3RyaW5nIHR5cGUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLiBPdGhlcndpc2UgcmV0dXJuIHRoZSB1bmlvbiBvZiB0aGVcbi8vIHBhcnNlZCBzdHJpbmcgbGl0ZXJhbHMgdGhhdCB3ZXJlIHJlZmVyZW5jZWQgYXMgZHluYW1pYyBzZWdtZW50cyBpbiB0aGUgcm91dGUuXG50eXBlIFBhcmFtUGFyc2VLZXk8U2VnbWVudCBleHRlbmRzIHN0cmluZz4gPVxuICBQYXJhbVBhcnNlU2VnbWVudDxTZWdtZW50PiBleHRlbmRzIHN0cmluZ1xuICAgID8gUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudD5cbiAgICA6IHN0cmluZztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gYWN0aW9uIHdoaWNoIGRlc2NyaWJlcyBob3cgdGhlIHJvdXRlciBjYW1lIHRvXG4gKiB0aGUgY3VycmVudCBsb2NhdGlvbiwgZWl0aGVyIGJ5IGEgcG9wLCBwdXNoLCBvciByZXBsYWNlIG9uIHRoZSBoaXN0b3J5IHN0YWNrLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlbmF2aWdhdGlvbnR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCk6IE5hdmlnYXRpb25UeXBlIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIFVSTCBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZSBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIDxOYXZMaW5rPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW1hdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KHBhdHRlcm46IFBhdGhQYXR0ZXJuPFBhdGg+IHwgUGF0aCk6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBwYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hQYXRoPFBhcmFtS2V5LCBQYXRoPihwYXR0ZXJuLCBwYXRobmFtZSksXG4gICAgW3BhdGhuYW1lLCBwYXR0ZXJuXVxuICApO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBuYXZpZ2F0ZSgpIGZ1bmN0aW9uIHJldHVybmVkIGZyb20gdXNlTmF2aWdhdGUoKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgKHRvOiBUbywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucyk6IHZvaWQ7XG4gIChkZWx0YTogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZU9wdGlvbnMge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBpbXBlcmF0aXZlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGxvY2F0aW9uLiBVc2VkIGJ5IDxMaW5rPnMsIGJ1dFxuICogbWF5IGFsc28gYmUgdXNlZCBieSBvdGhlciBlbGVtZW50cyB0byBjaGFuZ2UgdGhlIGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRlKCk6IE5hdmlnYXRlRnVuY3Rpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShcbiAgICBtYXRjaGVzLm1hcChtYXRjaCA9PiBtYXRjaC5wYXRobmFtZUJhc2UpXG4gICk7XG5cbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgbmF2aWdhdGU6IE5hdmlnYXRlRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodG86IFRvIHwgbnVtYmVyLCBvcHRpb25zOiBOYXZpZ2F0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQsXG4gICAgICAgIGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBgICtcbiAgICAgICAgICBgeW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuYFxuICAgICAgKTtcblxuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWVcbiAgICAgICk7XG5cbiAgICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aC5wYXRobmFtZSA9IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGVcbiAgICAgICk7XG4gICAgfSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lXVxuICApO1xuXG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cblxuY29uc3QgT3V0bGV0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5rbm93bj4obnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlb3V0bGV0Y29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dDxDb250ZXh0ID0gdW5rbm93bj4oKTogQ29udGV4dCB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KE91dGxldENvbnRleHQpIGFzIENvbnRleHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSA8T3V0bGV0PiB0byByZW5kZXIgY2hpbGQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dD86IHVua25vd24pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPE91dGxldENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHR9PntvdXRsZXR9PC9PdXRsZXRDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnRcbiAqIFVSTCB0aGF0IHdlcmUgbWF0Y2hlZCBieSB0aGUgcm91dGUgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFyYW1zPFxuICBQYXJhbXNPcktleSBleHRlbmRzIHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSBzdHJpbmdcbj4oKTogUmVhZG9ubHk8XG4gIFtQYXJhbXNPcktleV0gZXh0ZW5kcyBbc3RyaW5nXSA/IFBhcmFtczxQYXJhbXNPcktleT4gOiBQYXJ0aWFsPFBhcmFtc09yS2V5PlxuPiB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gKHJvdXRlTWF0Y2gucGFyYW1zIGFzIGFueSkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXJlc29sdmVkcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvOiBUbyk6IFBhdGgge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShcbiAgICBtYXRjaGVzLm1hcChtYXRjaCA9PiBtYXRjaC5wYXRobmFtZUJhc2UpXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gcmVzb2x2ZVRvKHRvLCBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksIGxvY2F0aW9uUGF0aG5hbWUpLFxuICAgIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lXVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIHJvdXRlIHRoYXQgbWF0Y2hlZCB0aGUgY3VycmVudCBsb2NhdGlvbiwgcHJlcGFyZWRcbiAqIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dCB0byByZW5kZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgdHJlZS4gUm91dGVcbiAqIGVsZW1lbnRzIGluIHRoZSB0cmVlIG11c3QgcmVuZGVyIGFuIDxPdXRsZXQ+IHRvIHJlbmRlciB0aGVpciBjaGlsZCByb3V0ZSdzXG4gKiBlbGVtZW50LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgbG9jYXRpb25Bcmc/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZ1xuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IG1hdGNoZXM6IHBhcmVudE1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGxldCBwYXJlbnRQYXJhbXMgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbiAgbGV0IHBhcmVudFBhdGhuYW1lID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWUgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50Um91dGUgPSByb3V0ZU1hdGNoICYmIHJvdXRlTWF0Y2gucm91dGU7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgIC8vIGNhbm5vdCBldmVuIGdpdmUgdGhlIHdhcm5pbmcgdW5sZXNzIHRoZXkgbGFuZCBhdCB0aGUgcGFyZW50IHJvdXRlLlxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIDxSb3V0ZXM+XG4gICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyAgICAgICBpdCB3aWxsIG5ldmVyIG1hdGNoIC9ibG9nL3Bvc3QvMTIzICovfVxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAvLyA8L1JvdXRlcz5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgLy8gICByZXR1cm4gKFxuICAgIC8vICAgICA8Um91dGVzPlxuICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAvLyAgICAgPC9Sb3V0ZXM+XG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBsZXQgcGFyZW50UGF0aCA9IChwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoKSB8fCBcIlwiO1xuICAgIHdhcm5pbmdPbmNlKFxuICAgICAgcGFyZW50UGF0aG5hbWUsXG4gICAgICAhcGFyZW50Um91dGUgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIipcIiksXG4gICAgICBgWW91IHJlbmRlcmVkIGRlc2NlbmRhbnQgPFJvdXRlcz4gKG9yIGNhbGxlZCBcXGB1c2VSb3V0ZXMoKVxcYCkgYXQgYCArXG4gICAgICAgIGBcIiR7cGFyZW50UGF0aG5hbWV9XCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPikgYnV0IHRoZSBgICtcbiAgICAgICAgYHBhcmVudCByb3V0ZSBwYXRoIGhhcyBubyB0cmFpbGluZyBcIipcIi4gVGhpcyBtZWFucyBpZiB5b3UgbmF2aWdhdGUgYCArXG4gICAgICAgIGBkZWVwZXIsIHRoZSBwYXJlbnQgd29uJ3QgbWF0Y2ggYW55bW9yZSBhbmQgdGhlcmVmb3JlIHRoZSBjaGlsZCBgICtcbiAgICAgICAgYHJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5gICtcbiAgICAgICAgYFBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4gdG8gPFJvdXRlIGAgK1xuICAgICAgICBgcGF0aD1cIiR7cGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IGAke3BhcmVudFBhdGh9LypgfVwiPi5gXG4gICAgKTtcbiAgfVxuXG4gIGxldCBsb2NhdGlvbkZyb21Db250ZXh0ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgbG9jYXRpb247XG4gIGlmIChsb2NhdGlvbkFyZykge1xuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9XG4gICAgICB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiIHx8XG4gICAgICAgIHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lPy5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSksXG4gICAgICBgV2hlbiBvdmVycmlkaW5nIHRoZSBsb2NhdGlvbiB1c2luZyBcXGA8Um91dGVzIGxvY2F0aW9uPlxcYCBvciBcXGB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbilcXGAsIGAgK1xuICAgICAgICBgdGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIGAgK1xuICAgICAgICBgbWF0Y2hlZCBieSBhbGwgcGFyZW50IHJvdXRlcy4gVGhlIGN1cnJlbnQgcGF0aG5hbWUgYmFzZSBpcyBcIiR7cGFyZW50UGF0aG5hbWVCYXNlfVwiIGAgK1xuICAgICAgICBgYnV0IHBhdGhuYW1lIFwiJHtwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZX1cIiB3YXMgZ2l2ZW4gaW4gdGhlIFxcYGxvY2F0aW9uXFxgIHByb3AuYFxuICAgICk7XG5cbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuXG4gIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPVxuICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCJcbiAgICAgID8gcGF0aG5hbWVcbiAgICAgIDogcGF0aG5hbWUuc2xpY2UocGFyZW50UGF0aG5hbWVCYXNlLmxlbmd0aCkgfHwgXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7IHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSB9KTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5pbmcoXG4gICAgICBwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsXG4gICAgICBgTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBgXG4gICAgKTtcblxuICAgIHdhcm5pbmcoXG4gICAgICBtYXRjaGVzID09IG51bGwgfHxcbiAgICAgICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCxcbiAgICAgIGBNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQuIGAgK1xuICAgICAgICBgVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFwiZW1wdHlcIiBwYWdlLmBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKFxuICAgIG1hdGNoZXMgJiZcbiAgICAgIG1hdGNoZXMubWFwKG1hdGNoID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgICAgIHBhdGhuYW1lQmFzZTpcbiAgICAgICAgICAgIG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCJcbiAgICAgICAgICAgICAgPyBwYXJlbnRQYXRobmFtZUJhc2VcbiAgICAgICAgICAgICAgOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgcGFyZW50TWF0Y2hlc1xuICApO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNjcmVhdGVyb3V0ZXNmcm9tY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuKTogUm91dGVPYmplY3RbXSB7XG4gIGxldCByb3V0ZXM6IFJvdXRlT2JqZWN0W10gPSBbXTtcblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBlbGVtZW50ID0+IHtcbiAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBJZ25vcmUgbm9uLWVsZW1lbnRzLiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gbW9yZSBlYXNpbHkgaW5saW5lXG4gICAgICAvLyBjb25kaXRpb25hbHMgaW4gdGhlaXIgcm91dGUgY29uZmlnLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICBlbGVtZW50LnR5cGUgPT09IFJvdXRlLFxuICAgICAgYFske1xuICAgICAgICB0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWVcbiAgICAgIH1dIGlzIG5vdCBhIDxSb3V0ZT4gY29tcG9uZW50LiBBbGwgY29tcG9uZW50IGNoaWxkcmVuIG9mIDxSb3V0ZXM+IG11c3QgYmUgYSA8Um91dGU+IG9yIDxSZWFjdC5GcmFnbWVudD5gXG4gICAgKTtcblxuICAgIGxldCByb3V0ZTogUm91dGVPYmplY3QgPSB7XG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aFxuICAgIH07XG5cbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXJzZWQgZnJvbSB0aGUgVVJMIHBhdGguXG4gKi9cbmV4cG9ydCB0eXBlIFBhcmFtczxLZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0ge1xuICByZWFkb25seSBba2V5IGluIEtleV06IHN0cmluZyB8IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQSByb3V0ZSBvYmplY3QgcmVwcmVzZW50cyBhIGxvZ2ljYWwgcm91dGUsIHdpdGggKG9wdGlvbmFsbHkpIGl0cyBjaGlsZFxuICogcm91dGVzIG9yZ2FuaXplZCBpbiBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVPYmplY3Qge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2hpbGRyZW4/OiBSb3V0ZU9iamVjdFtdO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICBpbmRleD86IGJvb2xlYW47XG4gIHBhdGg/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGggd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjZ2VuZXJhdGVwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhdGgocGF0aDogc3RyaW5nLCBwYXJhbXM6IFBhcmFtcyA9IHt9KTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGhcbiAgICAucmVwbGFjZSgvOihcXHcrKS9nLCAoXywga2V5KSA9PiB7XG4gICAgICBpbnZhcmlhbnQocGFyYW1zW2tleV0gIT0gbnVsbCwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgIHJldHVybiBwYXJhbXNba2V5XSE7XG4gICAgfSlcbiAgICAucmVwbGFjZSgvXFwvKlxcKiQvLCBfID0+XG4gICAgICBwYXJhbXNbXCIqXCJdID09IG51bGwgPyBcIlwiIDogcGFyYW1zW1wiKlwiXS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKVxuICAgICk7XG59XG5cbi8qKlxuICogQSBSb3V0ZU1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgcm91dGUgbWF0Y2hlZCBhIFVSTC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZU1hdGNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJvdXRlIG9iamVjdCB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcm91dGU6IFJvdXRlT2JqZWN0O1xufVxuXG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWF0Y2hyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUm91dGVzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGxvY2F0aW9uQXJnOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZyxcbiAgYmFzZW5hbWUgPSBcIi9cIlxuKTogUm91dGVNYXRjaFtdIHwgbnVsbCB7XG4gIGxldCBsb2NhdGlvbiA9XG4gICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcblxuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG5cbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaGVzW2ldLCBwYXRobmFtZSk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuaW50ZXJmYWNlIFJvdXRlTWV0YSB7XG4gIHJlbGF0aXZlUGF0aDogc3RyaW5nO1xuICBjYXNlU2Vuc2l0aXZlOiBib29sZWFuO1xuICBjaGlsZHJlbkluZGV4OiBudW1iZXI7XG4gIHJvdXRlOiBSb3V0ZU9iamVjdDtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQnJhbmNoIHtcbiAgcGF0aDogc3RyaW5nO1xuICBzY29yZTogbnVtYmVyO1xuICByb3V0ZXNNZXRhOiBSb3V0ZU1ldGFbXTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBicmFuY2hlczogUm91dGVCcmFuY2hbXSA9IFtdLFxuICBwYXJlbnRzTWV0YTogUm91dGVNZXRhW10gPSBbXSxcbiAgcGFyZW50UGF0aCA9IFwiXCJcbik6IFJvdXRlQnJhbmNoW10ge1xuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IG1ldGE6IFJvdXRlTWV0YSA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcm91dGUucGF0aCB8fCBcIlwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGVcbiAgICB9O1xuXG4gICAgaWYgKG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCksXG4gICAgICAgIGBBYnNvbHV0ZSByb3V0ZSBwYXRoIFwiJHttZXRhLnJlbGF0aXZlUGF0aH1cIiBuZXN0ZWQgdW5kZXIgcGF0aCBgICtcbiAgICAgICAgICBgXCIke3BhcmVudFBhdGh9XCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIGAgK1xuICAgICAgICAgIGBtdXN0IHN0YXJ0IHdpdGggdGhlIGNvbWJpbmVkIHBhdGggb2YgYWxsIGl0cyBwYXJlbnQgcm91dGVzLmBcbiAgICAgICk7XG5cbiAgICAgIG1ldGEucmVsYXRpdmVQYXRoID0gbWV0YS5yZWxhdGl2ZVBhdGguc2xpY2UocGFyZW50UGF0aC5sZW5ndGgpO1xuICAgIH1cblxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuXG4gICAgLy8gQWRkIHRoZSBjaGlsZHJlbiBiZWZvcmUgYWRkaW5nIHRoaXMgcm91dGUgdG8gdGhlIGFycmF5IHNvIHdlIHRyYXZlcnNlIHRoZVxuICAgIC8vIHJvdXRlIHRyZWUgZGVwdGgtZmlyc3QgYW5kIGNoaWxkIHJvdXRlcyBhcHBlYXIgYmVmb3JlIHRoZWlyIHBhcmVudHMgaW5cbiAgICAvLyB0aGUgXCJmbGF0dGVuZWRcIiB2ZXJzaW9uLlxuICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLFxuICAgICAgICBgSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIGAgK1xuICAgICAgICAgIGBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuXG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyYW5jaGVzLnB1c2goeyBwYXRoLCBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSwgcm91dGVzTWV0YSB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuXG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlczogUm91dGVCcmFuY2hbXSk6IHZvaWQge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PlxuICAgIGEuc2NvcmUgIT09IGIuc2NvcmVcbiAgICAgID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gICAgICA6IGNvbXBhcmVJbmRleGVzKFxuICAgICAgICAgIGEucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgICAgIGIucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgICAgIClcbiAgKTtcbn1cblxuY29uc3QgcGFyYW1SZSA9IC9eOlxcdyskLztcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xuY29uc3QgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbmNvbnN0IGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xuY29uc3Qgc3BsYXRQZW5hbHR5ID0gLTI7XG5jb25zdCBpc1NwbGF0ID0gKHM6IHN0cmluZykgPT4gcyA9PT0gXCIqXCI7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoOiBzdHJpbmcsIGluZGV4OiBib29sZWFuIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuXG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNcbiAgICAuZmlsdGVyKHMgPT4gIWlzU3BsYXQocykpXG4gICAgLnJlZHVjZShcbiAgICAgIChzY29yZSwgc2VnbWVudCkgPT5cbiAgICAgICAgc2NvcmUgK1xuICAgICAgICAocGFyYW1SZS50ZXN0KHNlZ21lbnQpXG4gICAgICAgICAgPyBkeW5hbWljU2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzZWdtZW50ID09PSBcIlwiXG4gICAgICAgICAgPyBlbXB0eVNlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc3RhdGljU2VnbWVudFZhbHVlKSxcbiAgICAgIGluaXRpYWxTY29yZVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGxldCBzaWJsaW5ncyA9XG4gICAgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcblxuICByZXR1cm4gc2libGluZ3NcbiAgICA/IC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgICAgIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAgICAgLy8gYmVoYXZpb3IgYnkgc2ltcGx5IHB1dHRpbmcgcm91dGVzIHdpdGggaWRlbnRpY2FsIHBhdGhzIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gICAgICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV1cbiAgICA6IC8vIE90aGVyd2lzZSwgaXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSB0byByYW5rIG5vbi1zaWJsaW5ncyBieSBpbmRleCxcbiAgICAgIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAgICAgMDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4oXG4gIGJyYW5jaDogUm91dGVCcmFuY2gsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFJvdXRlTWF0Y2g8UGFyYW1LZXk+W10gfCBudWxsIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuXG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlc01ldGEubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWV0YSA9IHJvdXRlc01ldGFbaV07XG4gICAgbGV0IGVuZCA9IGkgPT09IHJvdXRlc01ldGEubGVuZ3RoIC0gMTtcbiAgICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPVxuICAgICAgbWF0Y2hlZFBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICA/IHBhdGhuYW1lXG4gICAgICAgIDogcGF0aG5hbWUuc2xpY2UobWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKFxuICAgICAgeyBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCwgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLCBlbmQgfSxcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgKTtcblxuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuXG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcblxuICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMsXG4gICAgICBwYXRobmFtZTogam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICBwYXRobmFtZUJhc2U6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG5cbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHJlc3VsdCBvZiBgbWF0Y2hSb3V0ZXMoKWAgaW50byBhIFJlYWN0IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xufVxuXG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbCxcbiAgcGFyZW50TWF0Y2hlczogUm91dGVNYXRjaFtdID0gW11cbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPFJvdXRlQ29udGV4dC5Qcm92aWRlclxuICAgICAgICBjaGlsZHJlbj17XG4gICAgICAgICAgbWF0Y2gucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkID8gbWF0Y2gucm91dGUuZWxlbWVudCA6IDxPdXRsZXQgLz5cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZT17e1xuICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzLmNvbmNhdChtYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgICk7XG4gIH0sIG51bGwgYXMgUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCk7XG59XG5cbi8qKlxuICogQSBQYXRoUGF0dGVybiBpcyB1c2VkIHRvIG1hdGNoIG9uIHNvbWUgcG9ydGlvbiBvZiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoUGF0dGVybjxQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0IGEgVVJMIHBhdGhuYW1lLiBNYXkgY29udGFpbiBgOmlkYC1zdHlsZSBzZWdtZW50c1xuICAgKiB0byBpbmRpY2F0ZSBwbGFjZWhvbGRlcnMgZm9yIGR5bmFtaWMgcGFyYW1ldGVycy4gTWF5IGFsc28gZW5kIHdpdGggYC8qYCB0b1xuICAgKiBpbmRpY2F0ZSBtYXRjaGluZyB0aGUgcmVzdCBvZiB0aGUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgcGF0aDogUGF0aDtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhlIHN0YXRpYyBwb3J0aW9ucyBvZiB0aGUgYHBhdGhgIHNob3VsZCBiZSBtYXRjaGVkIGluXG4gICAqIHRoZSBzYW1lIGNhc2UuXG4gICAqL1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhpcyBwYXR0ZXJuIHNob3VsZCBtYXRjaCB0aGUgZW50aXJlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIGVuZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSBQYXRoTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSBQYXRoUGF0dGVybiBtYXRjaGVkIG9uIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhNYXRjaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwYXR0ZXJuIHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjtcbn1cblxudHlwZSBNdXRhYmxlPFQ+ID0ge1xuICAtcmVhZG9ubHkgW1AgaW4ga2V5b2YgVF06IFRbUF07XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHBhdHRlcm4gbWF0Y2hpbmcgb24gYSBVUkwgcGF0aG5hbWUgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHRoZSBtYXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI21hdGNocGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hQYXRoPFxuICBQYXJhbUtleSBleHRlbmRzIFBhcmFtUGFyc2VLZXk8UGF0aD4sXG4gIFBhdGggZXh0ZW5kcyBzdHJpbmdcbj4oXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuPFBhdGg+IHwgUGF0aCxcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogUGF0aE1hdGNoPFBhcmFtS2V5PiB8IG51bGwge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0geyBwYXRoOiBwYXR0ZXJuLCBjYXNlU2Vuc2l0aXZlOiBmYWxzZSwgZW5kOiB0cnVlIH07XG4gIH1cblxuICBsZXQgW21hdGNoZXIsIHBhcmFtTmFtZXNdID0gY29tcGlsZVBhdGgoXG4gICAgcGF0dGVybi5wYXRoLFxuICAgIHBhdHRlcm4uY2FzZVNlbnNpdGl2ZSxcbiAgICBwYXR0ZXJuLmVuZFxuICApO1xuXG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zOiBQYXJhbXMgPSBwYXJhbU5hbWVzLnJlZHVjZTxNdXRhYmxlPFBhcmFtcz4+KFxuICAgIChtZW1vLCBwYXJhbU5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIHBhdGhuYW1lQmFzZSBoZXJlIHVzaW5nIHRoZSByYXcgc3BsYXQgdmFsdWVcbiAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgICBpZiAocGFyYW1OYW1lID09PSBcIipcIikge1xuICAgICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZVxuICAgICAgICAgIC5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICAgIH1cblxuICAgICAgbWVtb1twYXJhbU5hbWVdID0gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiLFxuICAgICAgICBwYXJhbU5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LFxuICAgIHt9XG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVyblxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21waWxlUGF0aChcbiAgcGF0aDogc3RyaW5nLFxuICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gIGVuZCA9IHRydWVcbik6IFtSZWdFeHAsIHN0cmluZ1tdXSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgIGBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGAgK1xuICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG5cbiAgbGV0IHBhcmFtTmFtZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPVxuICAgIFwiXlwiICtcbiAgICBwYXRoXG4gICAgICAucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcbiAgICAgIC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKSAvLyBNYWtlIHN1cmUgaXQgaGFzIGEgbGVhZGluZyAvXG4gICAgICAucmVwbGFjZSgvW1xcXFwuKiteJD97fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gICAgICAucmVwbGFjZSgvOihcXHcrKS9nLCAoXzogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgcmV0dXJuIFwiKFteXFxcXC9dKylcIjtcbiAgICAgIH0pO1xuXG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtTmFtZXMucHVzaChcIipcIik7XG4gICAgcmVnZXhwU291cmNlICs9XG4gICAgICBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCJcbiAgICAgICAgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcbiAgICAgICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIHtcbiAgICByZWdleHBTb3VyY2UgKz0gZW5kXG4gICAgICA/IFwiXFxcXC8qJFwiIC8vIFdoZW4gbWF0Y2hpbmcgdG8gdGhlIGVuZCwgaWdub3JlIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgIDogLy8gT3RoZXJ3aXNlLCBtYXRjaCBhIHdvcmQgYm91bmRhcnkgb3IgYSBwcm9jZWVkaW5nIC8uIFRoZSB3b3JkIGJvdW5kYXJ5IHJlc3RyaWN0c1xuICAgICAgICAvLyBwYXJlbnQgcm91dGVzIHRvIG1hdGNoaW5nIG9ubHkgdGhlaXIgb3duIHdvcmRzIGFuZCBub3RoaW5nIG1vcmUsIGUuZy4gcGFyZW50XG4gICAgICAgIC8vIHJvdXRlIFwiL2hvbWVcIiBzaG91bGQgbm90IG1hdGNoIFwiL2hvbWUyXCIuXG4gICAgICAgIFwiKD86XFxcXGJ8XFxcXC98JClcIjtcbiAgfVxuXG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiBcImlcIik7XG5cbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbU5hbWVzXTtcbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcIiR7cGFyYW1OYW1lfVwiIHdpbGwgbm90IGJlIGRlY29kZWQgYmVjYXVzZWAgK1xuICAgICAgICBgIHRoZSBzdHJpbmcgXCIke3ZhbHVlfVwiIGlzIGEgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5YCArXG4gICAgICAgIGAgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSByZXNvbHZlZCBwYXRoIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyZXNvbHZlcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG86IFRvLCBmcm9tUGF0aG5hbWUgPSBcIi9cIik6IFBhdGgge1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcblxuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lXG4gICAgPyB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpXG4gICAgICA/IHRvUGF0aG5hbWVcbiAgICAgIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSlcbiAgICA6IGZyb21QYXRobmFtZTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaDogbm9ybWFsaXplU2VhcmNoKHNlYXJjaCksXG4gICAgaGFzaDogbm9ybWFsaXplSGFzaChoYXNoKVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZyb21QYXRobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG5cbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID4gMSA/IHNlZ21lbnRzLmpvaW4oXCIvXCIpIDogXCIvXCI7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUbyhcbiAgdG9Bcmc6IFRvLFxuICByb3V0ZVBhdGhuYW1lczogc3RyaW5nW10sXG4gIGxvY2F0aW9uUGF0aG5hbWU6IHN0cmluZ1xuKTogUGF0aCB7XG4gIGxldCB0byA9IHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0b0FyZykgOiB0b0FyZztcbiAgbGV0IHRvUGF0aG5hbWUgPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIiA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG5cbiAgLy8gSWYgYSBwYXRobmFtZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIGB0b2AsIGl0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGVcbiAgLy8gcm91dGUgY29udGV4dC4gVGhpcyBpcyBleHBsYWluZWQgaW4gYE5vdGUgb24gYDxMaW5rIHRvPmAgdmFsdWVzYCBpbiBvdXJcbiAgLy8gbWlncmF0aW9uIGd1aWRlIGZyb20gdjUgYXMgYSBtZWFucyBvZiBkaXNhbWJpZ3VhdGlvbiBiZXR3ZWVuIGB0b2AgdmFsdWVzXG4gIC8vIHRoYXQgYmVnaW4gd2l0aCBgL2AgYW5kIHRob3NlIHRoYXQgZG8gbm90LiBIb3dldmVyLCB0aGlzIGlzIHByb2JsZW1hdGljIGZvclxuICAvLyBgdG9gIHZhbHVlcyB0aGF0IGRvIG5vdCBwcm92aWRlIGEgcGF0aG5hbWUuIGB0b2AgY2FuIHNpbXBseSBiZSBhIHNlYXJjaCBvclxuICAvLyBoYXNoIHN0cmluZywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgYXNzdW1lIHRoYXQgdGhlIG5hdmlnYXRpb24gaXMgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24ncyBwYXRobmFtZSBhbmQgKm5vdCogdGhlIHJvdXRlIHBhdGhuYW1lLlxuICBsZXQgZnJvbTogc3RyaW5nO1xuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG5cbiAgICAgIC8vIEVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZVxuICAgICAgLy8gVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXkgZGlmZmVyZW5jZSBmcm9tIGhvdyA8YSBocmVmPiB3b3JrcyBhbmQgYVxuICAgICAgLy8gbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG4gICAgICB3aGlsZSAodG9TZWdtZW50c1swXSA9PT0gXCIuLlwiKSB7XG4gICAgICAgIHRvU2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgcm91dGVQYXRobmFtZUluZGV4IC09IDE7XG4gICAgICB9XG5cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBcIi4uXCIgc2VnbWVudHMgdGhhbiBwYXJlbnQgcm91dGVzLCByZXNvbHZlIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHJvb3QgLyBVUkwuXG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG5cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG5cbiAgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgdG8gdmFsdWUgaGFkIG9uZS5cbiAgaWYgKFxuICAgIHRvUGF0aG5hbWUgJiZcbiAgICB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJlxuICAgIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmXG4gICAgIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpXG4gICkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bzogVG8pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8ICh0byBhcyBQYXRoKS5wYXRobmFtZSA9PT0gXCJcIlxuICAgID8gXCIvXCJcbiAgICA6IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIlxuICAgID8gcGFyc2VQYXRoKHRvKS5wYXRobmFtZVxuICAgIDogdG8ucGF0aG5hbWU7XG59XG5cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aG5hbWU6IHN0cmluZywgYmFzZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG5cbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChiYXNlbmFtZS5sZW5ndGgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgLy8gcGF0aG5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCBiYXNlbmFtZS9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZS5zbGljZShiYXNlbmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xufVxuXG5jb25zdCBqb2luUGF0aHMgPSAocGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+XG4gIHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuXG5jb25zdCBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZTogc3RyaW5nKTogc3RyaW5nID0+XG4gIHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG5cbmNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IChzZWFyY2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCJcbiAgICA/IFwiXCJcbiAgICA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKVxuICAgID8gc2VhcmNoXG4gICAgOiBcIj9cIiArIHNlYXJjaDtcblxuY29uc3Qgbm9ybWFsaXplSGFzaCA9IChoYXNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERBTkdFUiEgUExFQVNFIFJFQUQgTUUhXG4vLyBXZSBwcm92aWRlIHRoZXNlIGV4cG9ydHMgYXMgYW4gZXNjYXBlIGhhdGNoIGluIHRoZSBldmVudCB0aGF0IHlvdSBuZWVkIGFueVxuLy8gcm91dGluZyBkYXRhIHRoYXQgd2UgZG9uJ3QgcHJvdmlkZSBhbiBleHBsaWNpdCBBUEkgZm9yLiBXaXRoIHRoYXQgc2FpZCwgd2Vcbi8vIHdhbnQgdG8gY292ZXIgeW91ciB1c2UgY2FzZSBpZiB3ZSBjYW4sIHNvIGlmIHlvdSBmZWVsIHRoZSBuZWVkIHRvIHVzZSB0aGVzZVxuLy8gd2Ugd2FudCB0byBoZWFyIGZyb20geW91LiBMZXQgdXMga25vdyB3aGF0IHlvdSdyZSBidWlsZGluZyBhbmQgd2UnbGwgZG8gb3VyXG4vLyBiZXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gc3VwcG9ydCB5b3UhXG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlc2UgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIGRvIG5vdCBndWFyYW50ZWVcbi8vIGFnYWluc3QgYW55IGJyZWFraW5nIGNoYW5nZXMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNlbXZlciByZWxlYXNlLiBVc2Ugd2l0aFxuLy8gZXh0cmVtZSBjYXV0aW9uIGFuZCBvbmx5IGlmIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuIEdvZHNwZWVkLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQge1xuICBOYXZpZ2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBSb3V0ZUNvbnRleHQgYXMgVU5TQUZFX1JvdXRlQ29udGV4dFxufTtcbiIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgQnJvd3Nlckhpc3RvcnksIEhhc2hIaXN0b3J5LCBIaXN0b3J5IH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlUGF0aCB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQge1xuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlcyxcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBnZW5lcmF0ZVBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBtYXRjaFBhdGgsXG4gIHJlc29sdmVQYXRoLFxuICByZW5kZXJNYXRjaGVzLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZU91dGxldENvbnRleHRcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IHR5cGUgeyBUbyB9IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuZnVuY3Rpb24gd2FybmluZyhjb25kOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCBSb3V0ZXIhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFJFLUVYUE9SVFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIE5vdGU6IEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJvdXRlciBleHBvcnRzIVxuZXhwb3J0IHtcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgZ2VuZXJhdGVQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgbWF0Y2hQYXRoLFxuICByZW5kZXJNYXRjaGVzLFxuICByZXNvbHZlUGF0aCxcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUm91dGVzLFxuICB1c2VPdXRsZXRDb250ZXh0XG59O1xuXG5leHBvcnQgdHlwZSB7XG4gIExvY2F0aW9uLFxuICBQYXRoLFxuICBUbyxcbiAgTmF2aWdhdGlvblR5cGUsXG4gIE1lbW9yeVJvdXRlclByb3BzLFxuICBOYXZpZ2F0ZUZ1bmN0aW9uLFxuICBOYXZpZ2F0ZU9wdGlvbnMsXG4gIE5hdmlnYXRlUHJvcHMsXG4gIE5hdmlnYXRvcixcbiAgT3V0bGV0UHJvcHMsXG4gIFBhcmFtcyxcbiAgUGF0aE1hdGNoLFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbiAgUm91dGVQcm9wcyxcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIExheW91dFJvdXRlUHJvcHMsXG4gIEluZGV4Um91dGVQcm9wcyxcbiAgUm91dGVyUHJvcHMsXG4gIFJvdXRlc1Byb3BzXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX1JvdXRlQ29udGV4dFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDT01QT05FTlRTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCcm93c2VyUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICB3aW5kb3dcbn06IEJyb3dzZXJSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxCcm93c2VySGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3cgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYXNoUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gSGFzaFJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgd2luZG93IH06IEhhc2hSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxIYXNoSGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3cgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5Um91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIHRoYXQgYWNjZXB0cyBhIHByZS1pbnN0YW50aWF0ZWQgaGlzdG9yeSBvYmplY3QuIEl0J3MgaW1wb3J0YW50XG4gKiB0byBub3RlIHRoYXQgdXNpbmcgeW91ciBvd24gaGlzdG9yeSBvYmplY3QgaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGFuZCBtYXkgYWRkXG4gKiB0d28gdmVyc2lvbnMgb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0byB5b3VyIGJ1bmRsZXMgdW5sZXNzIHlvdSB1c2UgdGhlIHNhbWVcbiAqIHZlcnNpb24gb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0aGF0IFJlYWN0IFJvdXRlciB1c2VzIGludGVybmFsbHkuXG4gKi9cbmZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIGhpc3RvcnkgfTogSGlzdG9yeVJvdXRlclByb3BzKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xufVxuXG5leHBvcnQgeyBIaXN0b3J5Um91dGVyIGFzIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIgfTtcblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PFJlYWN0LkFuY2hvckhUTUxBdHRyaWJ1dGVzPEhUTUxBbmNob3JFbGVtZW50PiwgXCJocmVmXCI+IHtcbiAgcmVsb2FkRG9jdW1lbnQ/OiBib29sZWFuO1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHRvOiBUbztcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSA8YT4uXG4gKi9cbmV4cG9ydCBjb25zdCBMaW5rID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQW5jaG9yRWxlbWVudCwgTGlua1Byb3BzPihcbiAgZnVuY3Rpb24gTGlua1dpdGhSZWYoXG4gICAgeyBvbkNsaWNrLCByZWxvYWREb2N1bWVudCwgcmVwbGFjZSA9IGZhbHNlLCBzdGF0ZSwgdGFyZ2V0LCB0bywgLi4ucmVzdCB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICAgIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7IHJlcGxhY2UsIHN0YXRlLCB0YXJnZXQgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soXG4gICAgICBldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQW5jaG9yRWxlbWVudCwgTW91c2VFdmVudD5cbiAgICApIHtcbiAgICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiAhcmVsb2FkRG9jdW1lbnQpIHtcbiAgICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgICAgPGFcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIGhyZWY9e2hyZWZ9XG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgdGFyZ2V0PXt0YXJnZXR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIExpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PExpbmtQcm9wcywgXCJjbGFzc05hbWVcIiB8IFwic3R5bGVcIiB8IFwiY2hpbGRyZW5cIj4ge1xuICBjaGlsZHJlbjpcbiAgICB8IFJlYWN0LlJlYWN0Tm9kZVxuICAgIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbiB9KSA9PiBSZWFjdC5SZWFjdE5vZGUpO1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2xhc3NOYW1lPzogc3RyaW5nIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbiB9KSA9PiBzdHJpbmcpO1xuICBlbmQ/OiBib29sZWFuO1xuICBzdHlsZT86XG4gICAgfCBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgfCAoKHByb3BzOiB7IGlzQWN0aXZlOiBib29sZWFuIH0pID0+IFJlYWN0LkNTU1Byb3BlcnRpZXMpO1xufVxuXG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5leHBvcnQgY29uc3QgTmF2TGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIE5hdkxpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKFxuICAgIHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICAgIHRvLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG5cbiAgICBsZXQgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIGxldCB0b1BhdGhuYW1lID0gcGF0aC5wYXRobmFtZTtcbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGxldCBpc0FjdGl2ZSA9XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8XG4gICAgICAoIWVuZCAmJlxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG5cbiAgICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBjbGFzc05hbWU6IHN0cmluZztcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcCh7IGlzQWN0aXZlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXG4gICAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICAgIGNsYXNzTmFtZSA9IFtjbGFzc05hbWVQcm9wLCBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGUgPVxuICAgICAgdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHsgaXNBY3RpdmUgfSkgOiBzdHlsZVByb3A7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPExpbmtcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIGFyaWEtY3VycmVudD17YXJpYUN1cnJlbnR9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICB0bz17dG99XG4gICAgICA+XG4gICAgICAgIHt0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKHsgaXNBY3RpdmUgfSkgOiBjaGlsZHJlbn1cbiAgICAgIDwvTGluaz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIT09LU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXG4gKiB5b3UgbmVlZCB0byBjcmVhdGUgY3VzdG9tIGA8TGluaz5gIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBjbGljayBiZWhhdmlvciB3ZVxuICogdXNlIGluIG91ciBleHBvcnRlZCBgPExpbms+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXI8RSBleHRlbmRzIEVsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudD4oXG4gIHRvOiBUbyxcbiAge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZVxuICB9OiB7XG4gICAgdGFyZ2V0PzogUmVhY3QuSFRNTEF0dHJpYnV0ZUFuY2hvclRhcmdldDtcbiAgICByZXBsYWNlPzogYm9vbGVhbjtcbiAgICBzdGF0ZT86IGFueTtcbiAgfSA9IHt9XG4pOiAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHZvaWQge1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBldmVudC5idXR0b24gPT09IDAgJiYgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICAgICAgICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBJZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICAgICAgKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZS5cbiAgICAgICAgbGV0IHJlcGxhY2UgPVxuICAgICAgICAgICEhcmVwbGFjZVByb3AgfHwgY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG5cbiAgICAgICAgbmF2aWdhdGUodG8sIHsgcmVwbGFjZSwgc3RhdGUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbbG9jYXRpb24sIG5hdmlnYXRlLCBwYXRoLCByZXBsYWNlUHJvcCwgc3RhdGUsIHRhcmdldCwgdG9dXG4gICk7XG59XG5cbi8qKlxuICogQSBjb252ZW5pZW50IHdyYXBwZXIgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgc2VhcmNoIHBhcmFtZXRlcnMgdmlhIHRoZVxuICogVVJMU2VhcmNoUGFyYW1zIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdD86IFVSTFNlYXJjaFBhcmFtc0luaXQpIHtcbiAgd2FybmluZyhcbiAgICB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIGBZb3UgY2Fubm90IHVzZSB0aGUgXFxgdXNlU2VhcmNoUGFyYW1zXFxgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3QgYCArXG4gICAgICBgc3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBgICtcbiAgICAgIGBFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBgICtcbiAgICAgIGBodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXNcXG5cXG5gICtcbiAgICAgIGBJZiB5b3UncmUgdW5zdXJlIGhvdyB0byBsb2FkIHBvbHlmaWxscywgd2UgcmVjb21tZW5kIHlvdSBjaGVjayBvdXQgYCArXG4gICAgICBgaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IGAgK1xuICAgICAgYHRvIGxvYWQgcG9seWZpbGxzIG9ubHkgZm9yIHVzZXJzIHRoYXQgbmVlZCB0aGVtLCBpbnN0ZWFkIG9mIGZvciBldmVyeSBgICtcbiAgICAgIGB1c2VyLmBcbiAgKTtcblxuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcblxuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpO1xuXG4gICAgZm9yIChsZXQga2V5IG9mIGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudC5rZXlzKCkpIHtcbiAgICAgIGlmICghc2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudC5nZXRBbGwoa2V5KS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xuICB9LCBbbG9jYXRpb24uc2VhcmNoXSk7XG5cbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChcbiAgICAgIG5leHRJbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0LFxuICAgICAgbmF2aWdhdGVPcHRpb25zPzogeyByZXBsYWNlPzogYm9vbGVhbjsgc3RhdGU/OiBhbnkgfVxuICAgICkgPT4ge1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBjcmVhdGVTZWFyY2hQYXJhbXMobmV4dEluaXQpLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgW25hdmlnYXRlXVxuICApO1xuXG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdIGFzIGNvbnN0O1xufVxuXG5leHBvcnQgdHlwZSBQYXJhbUtleVZhbHVlUGFpciA9IFtzdHJpbmcsIHN0cmluZ107XG5cbmV4cG9ydCB0eXBlIFVSTFNlYXJjaFBhcmFtc0luaXQgPVxuICB8IHN0cmluZ1xuICB8IFBhcmFtS2V5VmFsdWVQYWlyW11cbiAgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT5cbiAgfCBVUkxTZWFyY2hQYXJhbXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGluaXRpYWxpemVyLlxuICpcbiAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIGBuZXcgVVJMU2VhcmNoUGFyYW1zKGluaXQpYCBleGNlcHQgaXQgYWxzb1xuICogc3VwcG9ydHMgYXJyYXlzIGFzIHZhbHVlcyBpbiB0aGUgb2JqZWN0IGZvcm0gb2YgdGhlIGluaXRpYWxpemVyXG4gKiBpbnN0ZWFkIG9mIGp1c3Qgc3RyaW5ncy4gVGhpcyBpcyBjb252ZW5pZW50IHdoZW4geW91IG5lZWQgbXVsdGlwbGVcbiAqIHZhbHVlcyBmb3IgYSBnaXZlbiBrZXksIGJ1dCBkb24ndCB3YW50IHRvIHVzZSBhbiBhcnJheSBpbml0aWFsaXplci5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZjpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAqICAgICBbJ3NvcnQnLCAnbmFtZSddLFxuICogICAgIFsnc29ydCcsICdwcmljZSddXG4gKiAgIF0pO1xuICpcbiAqIHlvdSBjYW4gZG86XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKHtcbiAqICAgICBzb3J0OiBbJ25hbWUnLCAncHJpY2UnXVxuICogICB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgaW5pdDogVVJMU2VhcmNoUGFyYW1zSW5pdCA9IFwiXCJcbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKFxuICAgIHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiIHx8XG4gICAgQXJyYXkuaXNBcnJheShpbml0KSB8fFxuICAgIGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXNcbiAgICAgID8gaW5pdFxuICAgICAgOiBPYmplY3Qua2V5cyhpbml0KS5yZWR1Y2UoKG1lbW8sIGtleSkgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGluaXRba2V5XTtcbiAgICAgICAgICByZXR1cm4gbWVtby5jb25jYXQoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgW10gYXMgUGFyYW1LZXlWYWx1ZVBhaXJbXSlcbiAgKTtcbn1cbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogVGhlIG1vZGUgdG8gdXNlIHdoZW4gcnVubmluZyB0aGUgc2VydmVyLlxuICovXG5sZXQgU2VydmVyTW9kZTtcblxuKGZ1bmN0aW9uIChTZXJ2ZXJNb2RlKSB7XG4gIFNlcnZlck1vZGVbXCJEZXZlbG9wbWVudFwiXSA9IFwiZGV2ZWxvcG1lbnRcIjtcbiAgU2VydmVyTW9kZVtcIlByb2R1Y3Rpb25cIl0gPSBcInByb2R1Y3Rpb25cIjtcbiAgU2VydmVyTW9kZVtcIlRlc3RcIl0gPSBcInRlc3RcIjtcbn0pKFNlcnZlck1vZGUgfHwgKFNlcnZlck1vZGUgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc1NlcnZlck1vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50IHx8IHZhbHVlID09PSBTZXJ2ZXJNb2RlLlByb2R1Y3Rpb24gfHwgdmFsdWUgPT09IFNlcnZlck1vZGUuVGVzdDtcbn1cblxuZXhwb3J0IHsgU2VydmVyTW9kZSwgaXNTZXJ2ZXJNb2RlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vLyBOT1RFOiBtYWtlIHN1cmUgdG8gY2hhbmdlIHRoZSBSb3V0ZSBpbiByZW1peC1yZWFjdCBpZiB5b3UgY2hhbmdlIHRoaXNcbi8vIE5PVEU6IG1ha2Ugc3VyZSB0byBjaGFuZ2UgdGhlIEVudHJ5Um91dGUgaW4gcmVtaXgtcmVhY3QgaWYgeW91IGNoYW5nZSB0aGlzXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIHBhcmVudElkKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYW5pZmVzdCkuZmlsdGVyKGtleSA9PiBtYW5pZmVzdFtrZXldLnBhcmVudElkID09PSBwYXJlbnRJZCkubWFwKGlkID0+ICh7IC4uLm1hbmlmZXN0W2lkXSxcbiAgICBjaGlsZHJlbjogY3JlYXRlUm91dGVzKG1hbmlmZXN0LCBpZClcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVSb3V0ZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCBqc2VzYyBmcm9tICdqc2VzYyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZikge1xuICAvLyBVc2UganNlc2MgdG8gZXNjYXBlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgbG9hZGVycy4gVGhpcyBzdHJpbmcgaXNcbiAgLy8gaW5zZXJ0ZWQgZGlyZWN0bHkgaW50byB0aGUgSFRNTCBpbiB0aGUgYDxTY3JpcHRzPmAgZWxlbWVudC5cbiAgcmV0dXJuIGpzZXNjKHNlcnZlckhhbmRvZmYsIHtcbiAgICBpc1NjcmlwdENvbnRleHQ6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY3JlYXRlUmVxdWVzdEhhbmRsZXIgYXMgY3JlYXRlUmVxdWVzdEhhbmRsZXIkMSB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SGFuZGxlcih7XG4gIGJ1aWxkLFxuICBnZXRMb2FkQ29udGV4dCxcbiAgbW9kZVxufSkge1xuICBsZXQgcGxhdGZvcm0gPSB7fTtcbiAgbGV0IGhhbmRsZVJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0SGFuZGxlciQxKGJ1aWxkLCBwbGF0Zm9ybSwgbW9kZSk7XG4gIHJldHVybiBjb250ZXh0ID0+IHtcbiAgICBsZXQgbG9hZENvbnRleHQgPSB0eXBlb2YgZ2V0TG9hZENvbnRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGdldExvYWRDb250ZXh0KGNvbnRleHQpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBoYW5kbGVSZXF1ZXN0KGNvbnRleHQucmVxdWVzdCwgbG9hZENvbnRleHQpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIoe1xuICBidWlsZCxcbiAgZ2V0TG9hZENvbnRleHQsXG4gIG1vZGVcbn0pIHtcbiAgY29uc3QgaGFuZGxlUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3RIYW5kbGVyKHtcbiAgICBidWlsZCxcbiAgICBnZXRMb2FkQ29udGV4dCxcbiAgICBtb2RlXG4gIH0pO1xuXG4gIGNvbnN0IGhhbmRsZUZldGNoID0gYXN5bmMgY29udGV4dCA9PiB7XG4gICAgbGV0IHJlc3BvbnNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS93cmFuZ2xlcjIvaXNzdWVzLzExN1xuXG4gICAgY29udGV4dC5yZXF1ZXN0LmhlYWRlcnMuZGVsZXRlKFwiaWYtbm9uZS1tYXRjaFwiKTtcblxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGNvbnRleHQuZW52LkFTU0VUUy5mZXRjaChjb250ZXh0LnJlcXVlc3QudXJsLCBjb250ZXh0LnJlcXVlc3QuY2xvbmUoKSk7XG4gICAgICByZXNwb25zZSA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNDAwID8gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmJvZHksIHJlc3BvbnNlKSA6IHVuZGVmaW5lZDtcbiAgICB9IGNhdGNoIHt9XG5cbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZVJlcXVlc3QoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuXG4gIHJldHVybiBhc3luYyBjb250ZXh0ID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZUZldGNoKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiICYmIGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGUubWVzc2FnZSB8fCBlLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcIkludGVybmFsIEVycm9yXCIsIHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIsIGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH07XG4iLCAiXG5pbXBvcnQgKiBhcyBlbnRyeVNlcnZlciBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxcZW50cnkuc2VydmVyLmpzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUwIGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxyb290LmpzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUxIGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxyb3V0ZXNcXFxcaW5kZXguanN4XCI7XG4gIGV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzZXRzIH0gZnJvbSBcIkByZW1peC1ydW4vZGV2L2Fzc2V0cy1tYW5pZmVzdFwiO1xuICBleHBvcnQgY29uc3QgZW50cnkgPSB7IG1vZHVsZTogZW50cnlTZXJ2ZXIgfTtcbiAgZXhwb3J0IGNvbnN0IHJvdXRlcyA9IHtcbiAgICBcInJvb3RcIjoge1xuICAgICAgaWQ6IFwicm9vdFwiLFxuICAgICAgcGFyZW50SWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBhdGg6IFwiXCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTBcbiAgICB9LFxuICBcInJvdXRlcy9pbmRleFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvaW5kZXhcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgIGluZGV4OiB0cnVlLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTFcbiAgICB9XG4gIH07IiwgImltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcbmltcG9ydCB7IFJlbWl4U2VydmVyIH0gZnJvbSBcInJlbWl4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QoXG4gIHJlcXVlc3QsXG4gIHJlc3BvbnNlU3RhdHVzQ29kZSxcbiAgcmVzcG9uc2VIZWFkZXJzLFxuICByZW1peENvbnRleHRcbikge1xuICBjb25zdCBtYXJrdXAgPSByZW5kZXJUb1N0cmluZyhcbiAgICA8UmVtaXhTZXJ2ZXIgY29udGV4dD17cmVtaXhDb250ZXh0fSB1cmw9e3JlcXVlc3QudXJsfSAvPlxuICApO1xuXG4gIHJlc3BvbnNlSGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L2h0bWxcIik7XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcIjwhRE9DVFlQRSBodG1sPlwiICsgbWFya3VwLCB7XG4gICAgc3RhdHVzOiByZXNwb25zZVN0YXR1c0NvZGUsXG4gICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gIH0pO1xufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9IGZyb20gJ0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyc7XG5cbi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgY3JlYXRlQ29va2llLCBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSwgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsIGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVNlc3Npb25TdG9yYWdlLCBpc0Nvb2tpZSwgaXNTZXNzaW9uLCBqc29uLCByZWRpcmVjdCB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG4vKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IEZvcm0sIExpbmssIExpbmtzLCBMaXZlUmVsb2FkLCBNZXRhLCBOYXZMaW5rLCBPdXRsZXQsIFByZWZldGNoUGFnZUxpbmtzLCBSZW1peEJyb3dzZXIsIFJlbWl4U2VydmVyLCBTY3JpcHRzLCBTY3JvbGxSZXN0b3JhdGlvbiwgdXNlQWN0aW9uRGF0YSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VDYXRjaCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUhyZWYsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0LCB1c2VUcmFuc2l0aW9uIH0gZnJvbSAnQHJlbWl4LXJ1bi9yZWFjdCc7XG5cbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IFJlbWl4QnJvd3NlciB9IGZyb20gJy4vYnJvd3Nlci5qcyc7XG5leHBvcnQgeyBPdXRsZXQsIHVzZUhyZWYsIHVzZUxvY2F0aW9uLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuZXhwb3J0IHsgRm9ybSwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIFByZWZldGNoUGFnZUxpbmtzLCBTY3JpcHRzLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMb2FkZXJEYXRhLCB1c2VNYXRjaGVzLCB1c2VTdWJtaXQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuZXhwb3J0IHsgdXNlQ2F0Y2ggfSBmcm9tICcuL2Vycm9yQm91bmRhcmllcy5qcyc7XG5leHBvcnQgeyBTY3JvbGxSZXN0b3JhdGlvbiB9IGZyb20gJy4vc2Nyb2xsLXJlc3RvcmF0aW9uLmpzJztcbmV4cG9ydCB7IFJlbWl4U2VydmVyIH0gZnJvbSAnLi9zZXJ2ZXIuanMnO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VIcmVmLCBOYXZMaW5rIGFzIE5hdkxpbmskMSwgTGluayBhcyBMaW5rJDEsIHVzZUxvY2F0aW9uLCB1c2VSZXNvbHZlZFBhdGgsIHVzZU5hdmlnYXRlLCBSb3V0ZXIsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgUmVtaXhFcnJvckJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSB9IGZyb20gJy4vZXJyb3JCb3VuZGFyaWVzLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuaW1wb3J0IHsgZ2V0TGlua3NGb3JNYXRjaGVzLCBpc1BhZ2VMaW5rRGVzY3JpcHRvciwgZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzLCBnZXREYXRhTGlua0hyZWZzLCBnZXRNb2R1bGVMaW5rSHJlZnMsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzIH0gZnJvbSAnLi9saW5rcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sIH0gZnJvbSAnLi9tYXJrdXAuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZXMuanMnO1xuaW1wb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcuL3RyYW5zaXRpb24uanMnO1xuXG5jb25zdCBSZW1peEVudHJ5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHVzZVJlbWl4RW50cnlDb250ZXh0KCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVtaXhFbnRyeUNvbnRleHQpO1xuICBpbnZhcmlhbnQoY29udGV4dCwgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxSZW1peD4gZWxlbWVudFwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIFJlbWl4RW50cnkoe1xuICBjb250ZXh0OiBlbnRyeUNvbnRleHQsXG4gIGFjdGlvbixcbiAgbG9jYXRpb246IGhpc3RvcnlMb2NhdGlvbixcbiAgbmF2aWdhdG9yOiBfbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBsZXQge1xuICAgIG1hbmlmZXN0LFxuICAgIHJvdXRlRGF0YTogZG9jdW1lbnRMb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZyxcbiAgICBhcHBTdGF0ZTogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yXG4gIH0gPSBlbnRyeUNvbnRleHQ7XG4gIGxldCBjbGllbnRSb3V0ZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdC5yb3V0ZXMsIHJvdXRlTW9kdWxlcywgUmVtaXhSb3V0ZSksIFttYW5pZmVzdCwgcm91dGVNb2R1bGVzXSk7XG4gIGxldCBbY2xpZW50U3RhdGUsIHNldENsaWVudFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGVudHJ5Q29tcG9uZW50RGlkQ2F0Y2hFbXVsYXRvcik7XG4gIGxldCBbdHJhbnNpdGlvbk1hbmFnZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcih7XG4gICAgICByb3V0ZXM6IGNsaWVudFJvdXRlcyxcbiAgICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGE6IGRvY3VtZW50TG9hZGVyRGF0YSxcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBjYXRjaDogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yLmNhdGNoLFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkOiBlbnRyeUNvbXBvbmVudERpZENhdGNoRW11bGF0b3IuY2F0Y2hCb3VuZGFyeVJvdXRlSWQsXG4gICAgICBvblJlZGlyZWN0OiBfbmF2aWdhdG9yLnJlcGxhY2UsXG4gICAgICBvbkNoYW5nZTogc3RhdGUgPT4ge1xuICAgICAgICBzZXRDbGllbnRTdGF0ZSh7XG4gICAgICAgICAgY2F0Y2g6IHN0YXRlLmNhdGNoLFxuICAgICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgICAgICBjYXRjaEJvdW5kYXJ5Um91dGVJZDogc3RhdGUuY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgICAgIGxvYWRlckJvdW5kYXJ5Um91dGVJZDogc3RhdGUuZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICAgICAgICB0cmFja0JvdW5kYXJpZXM6IGZhbHNlLFxuICAgICAgICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIEVuc3VyZXMgcHVzaGVzIGludGVycnVwdGluZyBwZW5kaW5nIG5hdmlnYXRpb25zIHVzZSByZXBsYWNlXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBSZWFjdCBSb3V0ZXJcblxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHB1c2ggPSAodG8sIHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKS50cmFuc2l0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IF9uYXZpZ2F0b3IucmVwbGFjZSh0bywgc3RhdGUpIDogX25hdmlnYXRvci5wdXNoKHRvLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7IC4uLl9uYXZpZ2F0b3IsXG4gICAgICBwdXNoXG4gICAgfTtcbiAgfSwgW19uYXZpZ2F0b3IsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG4gIGxldCB7XG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGFcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7IC8vIFNlbmQgbmV3IGxvY2F0aW9uIHRvIHRoZSB0cmFuc2l0aW9uIG1hbmFnZXJcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBsb2NhdGlvblxuICAgIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChoaXN0b3J5TG9jYXRpb24gPT09IGxvY2F0aW9uKSByZXR1cm47XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiBcIm5hdmlnYXRpb25cIixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBzdWJtaXNzaW9uOiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCksXG4gICAgICBhY3Rpb25cbiAgICB9KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBoaXN0b3J5TG9jYXRpb24sIGFjdGlvbl0pOyAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoZSBhcHAgdGhyZXcgYmVmb3JlIHJlbmRlcmluZyBhbnlcbiAgLy8gcm91dGVzLCBnZXQgdGhlIGVycm9yIGFuZCBwYXNzIGl0IHRvIHRoZSBFcnJvckJvdW5kYXJ5IHRvIGVtdWxhdGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYFxuXG4gIGxldCBzc3JFcnJvckJlZm9yZVJvdXRlc1JlbmRlcmVkID0gY2xpZW50U3RhdGUuZXJyb3IgJiYgY2xpZW50U3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBudWxsICYmIGNsaWVudFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9PT0gbnVsbCA/IGRlc2VyaWFsaXplRXJyb3IoY2xpZW50U3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkO1xuICBsZXQgc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZCA9IGNsaWVudFN0YXRlLmNhdGNoICYmIGNsaWVudFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBudWxsID8gY2xpZW50U3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBhcHBTdGF0ZTogY2xpZW50U3RhdGUsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgY2xpZW50Um91dGVzLFxuICAgICAgcm91dGVEYXRhOiBsb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSxcbiAgICBlcnJvcjogc3NyRXJyb3JCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peENhdGNoQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSxcbiAgICBjYXRjaDogc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVzLCBudWxsKSkpKSk7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3IoZGF0YSkge1xuICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBkYXRhLnN0YWNrO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIFJvdXRlcygpIHtcbiAgLy8gVE9ETzogQWRkIGByZW5kZXJNYXRjaGVzYCBmdW5jdGlvbiB0byBSUiB0aGF0IHdlIGNhbiB1c2UgYW5kIHRoZW4gd2UgZG9uJ3RcbiAgLy8gbmVlZCB0aGlzIGNvbXBvbmVudCwgd2UgY2FuIGp1c3QgYHJlbmRlck1hdGNoZXNgIGZyb20gUmVtaXhFbnRyeVxuICBsZXQge1xuICAgIGNsaWVudFJvdXRlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTsgLy8gZmFsbGJhY2sgdG8gdGhlIHJvb3QgaWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoXG5cbiAgbGV0IGVsZW1lbnQgPSB1c2VSb3V0ZXMoY2xpZW50Um91dGVzKSB8fCBjbGllbnRSb3V0ZXNbMF0uZWxlbWVudDtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSZW1peFJvdXRlXG5cblxuY29uc3QgUmVtaXhSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VSZW1peFJvdXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlbWl4Um91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KGNvbnRleHQsIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbiBhIHJlbWl4IHJvdXRlIGVsZW1lbnRcIik7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Um91dGVDb21wb25lbnQoe1xuICBpZFxufSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHtpZH1cIiBoYXMgbm8gY29tcG9uZW50ISBQbGVhc2UgZ28gYWRkIGEgXFxgZGVmYXVsdFxcYCBleHBvcnQgaW4gdGhlIHJvdXRlIG1vZHVsZSBmaWxlLlxcbmAgKyBcIklmIHlvdSB3ZXJlIHRyeWluZyB0byBuYXZpZ2F0ZSBvciBzdWJtaXQgdG8gYSByZXNvdXJjZSByb3V0ZSwgdXNlIGA8YT5gIGluc3RlYWQgb2YgYDxMaW5rPmAgb3IgYDxGb3JtIHJlbG9hZERvY3VtZW50PmAuXCIpO1xufVxuXG5mdW5jdGlvbiBSZW1peFJvdXRlKHtcbiAgaWRcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHtcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGFwcFN0YXRlXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtpZF07XG4gIGxldCB7XG4gICAgZGVmYXVsdDogQ29tcG9uZW50LFxuICAgIENhdGNoQm91bmRhcnksXG4gICAgRXJyb3JCb3VuZGFyeVxuICB9ID0gcm91dGVNb2R1bGVzW2lkXTtcbiAgbGV0IGVsZW1lbnQgPSBDb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFJvdXRlQ29tcG9uZW50LCB7XG4gICAgaWQ6IGlkXG4gIH0pO1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBkYXRhLFxuICAgIGlkXG4gIH07XG5cbiAgaWYgKENhdGNoQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyQ2F1Z2h0ID0gYXBwU3RhdGUuY2F0Y2ggJiYgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPT09IGlkID8gYXBwU3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7IC8vIFRoaXMgbmVlZHMgdG8gcnVuIGFmdGVyIHdlIGNoZWNrIGZvciB0aGUgZXJyb3IgZnJvbSBhIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBpbmNvcnJlY3RseSByZW5kZXIgdGhpcyBib3VuZGFyeSBmb3IgYSBsb2FkZXIgZXJyb3JcbiAgICAvLyBkZWVwZXIgaW4gdGhlIHRyZWUuXG5cbiAgICBpZiAoYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyQ2F1Z2h0ID8ge1xuICAgICAgaWQsXG5cbiAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYSBjYXRjaCBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhDYXRjaEJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IENhdGNoQm91bmRhcnksXG4gICAgICBjYXRjaDogbWF5YmVTZXJ2ZXJDYXVnaHRcbiAgICB9LCBlbGVtZW50KTtcbiAgfSAvLyBPbmx5IHdyYXAgaW4gZXJyb3IgYm91bmRhcnkgaWYgdGhlIHJvdXRlIGRlZmluZWQgb25lLCBvdGhlcndpc2UgbGV0IHRoZVxuICAvLyBlcnJvciBidWJibGUgdG8gdGhlIHBhcmVudCBib3VuZGFyeS4gV2UgY291bGQgZGVmYXVsdCB0byB1c2luZyBlcnJvclxuICAvLyBib3VuZGFyaWVzIGFyb3VuZCBldmVyeSByb3V0ZSwgYnV0IG5vdyBpZiB0aGUgYXBwIGRvZXNuJ3Qgd2FudCB1c2Vyc1xuICAvLyBzZWVpbmcgdGhlIGRlZmF1bHQgUmVtaXggRXJyb3JCb3VuZGFyeSBjb21wb25lbnQsIHRoZXkgKm11c3QqIGRlZmluZSBhblxuICAvLyBlcnJvciBib3VuZGFyeSBmb3IgKmV2ZXJ5KiByb3V0ZSBhbmQgdGhhdCB3b3VsZCBiZSBhbm5veWluZy4gTWlnaHQgYXNcbiAgLy8gd2VsbCBtYWtlIGl0IHJlcXVpcmVkIGF0IHRoYXQgcG9pbnQuXG4gIC8vXG4gIC8vIEJ5IGNvbmRpdGlvbmFsbHkgd3JhcHBpbmcgbGlrZSB0aGlzLCB3ZSBhbGxvdyBhcHBzIHRvIGRlZmluZSBhIHRvcCBsZXZlbFxuICAvLyBFcnJvckJvdW5kYXJ5IGNvbXBvbmVudCBhbmQgYmUgZG9uZSB3aXRoIGl0LiBUaGVuLCBpZiB0aGV5IHdhbnQgdG8sIHRoZXlcbiAgLy8gY2FuIGFkZCBtb3JlIHNwZWNpZmljIGJvdW5kYXJpZXMgYnkgZXhwb3J0aW5nIEVycm9yQm91bmRhcnkgY29tcG9uZW50c1xuICAvLyBmb3Igd2hpY2hldmVyIHJvdXRlcyB0aGV5IHBsZWFzZS5cbiAgLy9cbiAgLy8gTk9URTogdGhpcyBraW5kIG9mIGxvZ2ljIHdpbGwgbW92ZSBpbnRvIFJlYWN0IFJvdXRlclxuXG5cbiAgaWYgKEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPSBhcHBTdGF0ZS5lcnJvciAmJiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkKSA/IGRlc2VyaWFsaXplRXJyb3IoYXBwU3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkOyAvLyBUaGlzIG5lZWRzIHRvIHJ1biBhZnRlciB3ZSBjaGVjayBmb3IgdGhlIGVycm9yIGZyb20gYSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgaW5jb3JyZWN0bHkgcmVuZGVyIHRoaXMgYm91bmRhcnkgZm9yIGEgbG9hZGVyIGVycm9yXG4gICAgLy8gZGVlcGVyIGluIHRoZSB0cmVlLlxuXG4gICAgaWYgKGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcykge1xuICAgICAgYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPyB7XG4gICAgICBpZCxcblxuICAgICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvciBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhFcnJvckJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IEVycm9yQm91bmRhcnksXG4gICAgICBlcnJvcjogbWF5YmVTZXJ2ZXJSZW5kZXJFcnJvclxuICAgIH0sIGVsZW1lbnQpO1xuICB9IC8vIEl0J3MgaW1wb3J0YW50IGZvciB0aGUgcm91dGUgY29udGV4dCB0byBiZSBhYm92ZSB0aGUgZXJyb3IgYm91bmRhcnkgc28gdGhhdFxuICAvLyBhIGNhbGwgdG8gYHVzZUxvYWRlckRhdGFgIGRvZXNuJ3QgYWNjaWRlbnRhbGx5IGdldCB0aGUgcGFyZW50cyByb3V0ZSdzIGRhdGEuXG5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCBlbGVtZW50KTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFB1YmxpYyBBUElcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwcmVmZXRjaGluZyBiZWhhdmlvciBvZiB0aGUgbGluazpcbiAqXG4gKiAtIFwiaW50ZW50XCI6IEZldGNoZWQgd2hlbiB0aGUgdXNlciBmb2N1c2VzIG9yIGhvdmVycyB0aGUgbGlua1xuICogLSBcInJlbmRlclwiOiBGZXRjaGVkIHdoZW4gdGhlIGxpbmsgaXMgcmVuZGVyZWRcbiAqIC0gXCJub25lXCI6IE5ldmVyIGZldGNoZWRcbiAqL1xuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGxldCB7XG4gICAgb25Gb2N1cyxcbiAgICBvbkJsdXIsXG4gICAgb25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnRcbiAgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICB9LCBbcHJlZmV0Y2hdKTtcblxuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJpbnRlbnRcIikge1xuICAgICAgc2V0TWF5YmVQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGNhbmNlbEludGVudCA9ICgpID0+IHtcbiAgICBpZiAocHJlZmV0Y2ggPT09IFwiaW50ZW50XCIpIHtcbiAgICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCB7XG4gICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQmx1ciwgY2FuY2VsSW50ZW50KSxcbiAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICBvblRvdWNoU3RhcnQ6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uVG91Y2hTdGFydCwgc2V0SW50ZW50KVxuICB9XTtcbn1cbi8qKlxuICogQSBzcGVjaWFsIGtpbmQgb2YgYDxMaW5rPmAgdGhhdCBrbm93cyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBcImFjdGl2ZVwiLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I25hdmxpbmtcbiAqL1xuXG5cbmxldCBOYXZMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgdG8sXG4gIHByZWZldGNoID0gXCJub25lXCIsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgbGV0IFtzaG91bGRQcmVmZXRjaCwgcHJlZmV0Y2hIYW5kbGVyc10gPSB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCBwcm9wcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2TGluayQxLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdG86IHRvXG4gIH0sIHByb3BzLCBwcmVmZXRjaEhhbmRsZXJzKSksIHNob3VsZFByZWZldGNoID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIHtcbiAgICBwYWdlOiBocmVmXG4gIH0pIDogbnVsbCk7XG59KTtcbi8qKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBhbiBhbmNob3IgdGFnIGFuZCBpcyB0aGUgcHJpbWFyeSB3YXkgdGhlIHVzZXIgd2lsbFxuICogbmF2aWdhdGUgYXJvdW5kIHlvdXIgd2Vic2l0ZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNsaW5rXG4gKi9cblxubGV0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0byxcbiAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rJDEsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB0bzogdG9cbiAgfSwgcHJvcHMsIHByZWZldGNoSGFuZGxlcnMpKSwgc2hvdWxkUHJlZmV0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywge1xuICAgIHBhZ2U6IGhyZWZcbiAgfSkgOiBudWxsKTtcbn0pO1xuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgdGhlaXJIYW5kbGVyICYmIHRoZWlySGFuZGxlcihldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgYDxsaW5rPmAgdGFncyBmb3IgdGhlIGN1cnJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbmZ1bmN0aW9uIExpbmtzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIG1hbmlmZXN0XG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbGlua3MgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSwgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsaW5rcy5tYXAobGluayA9PiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihsaW5rKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBsaW5rLnBhZ2VcbiAgfSwgbGluaykpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGxpbmsucmVsICsgbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGFsbCBvZiB0aGUgYDxsaW5rIHJlbD1cInByZWZldGNoXCI+YCBhbmRcbiAqIGA8bGluayByZWw9XCJtb2R1bGVwcmVsb2FkXCIvPmAgdGFncyBmb3IgYWxsIHRoZSBhc3NldHMgKGRhdGEsIG1vZHVsZXMsIGNzcykgb2ZcbiAqIGEgZ2l2ZW4gcGFnZS5cbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBwcm9wcy5wYWdlXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNwcmVmZXRjaHBhZ2VsaW5rcy1cbiAqL1xuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHtcbiAgICBjbGllbnRSb3V0ZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaENsaWVudFJvdXRlcyhjbGllbnRSb3V0ZXMsIHBhZ2UpLCBbY2xpZW50Um91dGVzLCBwYWdlXSk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgY29uc29sZS53YXJuKGBUcmllZCB0byBwcmVmZXRjaCAke3BhZ2V9IGJ1dCBubyByb3V0ZXMgbWF0Y2hlZC5gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rc0ltcGwsIF9leHRlbmRzKHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIG1hdGNoZXM6IG1hdGNoZXNcbiAgfSwgZGF0YUxpbmtQcm9wcykpO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaGVkU3R5bGVzaGVldHMobWF0Y2hlcykge1xuICBsZXQge1xuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IFtzdHlsZUxpbmtzLCBzZXRTdHlsZUxpbmtzXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMpLnRoZW4obGlua3MgPT4ge1xuICAgICAgaWYgKCFpbnRlcnJ1cHRlZCkgc2V0U3R5bGVMaW5rcyhsaW5rcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgcm91dGVNb2R1bGVzXSk7XG4gIHJldHVybiBzdHlsZUxpbmtzO1xufVxuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwoe1xuICBwYWdlLFxuICBtYXRjaGVzOiBuZXh0TWF0Y2hlcyxcbiAgLi4ubGlua1Byb3BzXG59KSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICBtYW5pZmVzdFxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JEYXRhID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uLCBcImRhdGFcIiksIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb25dKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JBc3NldHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb24sIFwiYXNzZXRzXCIpLCBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uXSk7XG4gIGxldCBkYXRhSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldERhdGFMaW5rSHJlZnMocGFnZSwgbmV3TWF0Y2hlc0ZvckRhdGEsIG1hbmlmZXN0KSwgW25ld01hdGNoZXNGb3JEYXRhLCBwYWdlLCBtYW5pZmVzdF0pO1xuICBsZXQgbW9kdWxlSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE1vZHVsZUxpbmtIcmVmcyhuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdCksIFtuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdF0pOyAvLyBuZWVkcyB0byBiZSBhIGhvb2sgd2l0aCBhc3luYyBiZWhhdmlvciBiZWNhdXNlIHdlIG5lZWQgdGhlIG1vZHVsZXMsIG5vdFxuICAvLyBqdXN0IHRoZSBtYW5pZmVzdCBsaWtlIHRoZSBvdGhlciBsaW5rcyBpbiBoZXJlLlxuXG4gIGxldCBzdHlsZUxpbmtzID0gdXNlUHJlZmV0Y2hlZFN0eWxlc2hlZXRzKG5ld01hdGNoZXNGb3JBc3NldHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGRhdGFIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICBhczogXCJmZXRjaFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBtb2R1bGVIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBzdHlsZUxpbmtzLm1hcChsaW5rID0+XG4gIC8qI19fUFVSRV9fKi9cbiAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gIC8vIGFscmVhZHkgd2l0aCB0aGVpciBvd24gcHJvcHNcbiAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgPHRpdGxlPmAgYW5kIGA8bWV0YT5gIHRhZ3MgZm9yIHRoZSBjdXJyZW50IHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNtZXRhLWxpbmtzLXNjcmlwdHNcbiAqL1xuXG5cbmZ1bmN0aW9uIE1ldGEoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWV0YSA9IHt9O1xuICBsZXQgcGFyZW50c0RhdGEgPSB7fTtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gbWF0Y2gucGFyYW1zO1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZUlkXTtcblxuICAgIGlmIChyb3V0ZU1vZHVsZS5tZXRhKSB7XG4gICAgICBsZXQgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYXJlbnRzRGF0YSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvblxuICAgICAgfSkgOiByb3V0ZU1vZHVsZS5tZXRhO1xuICAgICAgT2JqZWN0LmFzc2lnbihtZXRhLCByb3V0ZU1ldGEpO1xuICAgIH1cblxuICAgIHBhcmVudHNEYXRhW3JvdXRlSWRdID0gZGF0YTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgT2JqZWN0LmVudHJpZXMobWV0YSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgLy8gT3BlbiBHcmFwaCB0YWdzIHVzZSB0aGUgYHByb3BlcnR5YCBhdHRyaWJ1dGUsIHdoaWxlIG90aGVyIG1ldGEgdGFnc1xuICAgIC8vIHVzZSBgbmFtZWAuIFNlZSBodHRwczovL29ncC5tZS9cbiAgICBsZXQgaXNPcGVuR3JhcGhUYWcgPSBuYW1lLnN0YXJ0c1dpdGgoXCJvZzpcIik7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwidGl0bGVcIiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwge1xuICAgICAga2V5OiBcInRpdGxlXCJcbiAgICB9LCB2YWx1ZSkgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChjb250ZW50ID0+IGlzT3BlbkdyYXBoVGFnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogbmFtZSArIGNvbnRlbnQsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUgKyBjb250ZW50LFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSkgOiBpc09wZW5HcmFwaFRhZyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBuYW1lLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSk7XG4gIH0pKTtcbn1cbi8qKlxuICogVHJhY2tzIHdoZXRoZXIgUmVtaXggaGFzIGZpbmlzaGVkIGh5ZHJhdGluZyBvciBub3QsIHNvIHNjcmlwdHMgY2FuIGJlIHNraXBwZWRcbiAqIGR1cmluZyBjbGllbnQtc2lkZSB1cGRhdGVzLlxuICovXG5cbmxldCBpc0h5ZHJhdGVkID0gZmFsc2U7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgYDxzY3JpcHQ+YCB0YWdzIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLiBCdW5kbGVzIGZvclxuICogYWRkaXRpb25hbCByb3V0ZXMgYXJlIGxvYWRlZCBsYXRlciBhcyBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHByb3BzIEFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBhZGQgdG8gZWFjaCBzY3JpcHQgdGFnIHRoYXQgaXMgcmVuZGVyZWQuXG4gKiBJbiBhZGRpdGlvbiB0byBzY3JpcHRzLCBcXDxsaW5rIHJlbD1cIm1vZHVsZXByZWxvYWRcIj4gdGFncyByZWNlaXZlIHRoZSBjcm9zc09yaWdpblxuICogcHJvcGVydHkgaWYgcHJvdmlkZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHtcbiAgICBtYW5pZmVzdCxcbiAgICBtYXRjaGVzLFxuICAgIHBlbmRpbmdMb2NhdGlvbixcbiAgICBjbGllbnRSb3V0ZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZ1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBsZXQgaW5pdGlhbFNjcmlwdHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHNlcnZlckhhbmRvZmZTdHJpbmcgPyBgd2luZG93Ll9fcmVtaXhDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTtgIDogXCJcIjtcbiAgICBsZXQgcm91dGVNb2R1bGVzU2NyaXB0ID0gYCR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYGltcG9ydCAqIGFzIHJvdXRlJHtpbmRleH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlKX07YCkuam9pbihcIlxcblwiKX1cbndpbmRvdy5fX3JlbWl4Um91dGVNb2R1bGVzID0geyR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYCR7SlNPTi5zdHJpbmdpZnkobWF0Y2gucm91dGUuaWQpfTpyb3V0ZSR7aW5kZXh9YCkuam9pbihcIixcIil9fTtgO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChjb250ZXh0U2NyaXB0KVxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LnVybFxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChyb3V0ZU1vZHVsZXNTY3JpcHQpLFxuICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSxcbiAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICB9KSkpOyAvLyBkaXNhYmxlZCBkZXBzIGFycmF5IGJlY2F1c2Ugd2UgYXJlIHB1cnBvc2VmdWxseSBvbmx5IHJlbmRlcmluZyB0aGlzIG9uY2VcbiAgICAvLyBmb3IgaHlkcmF0aW9uLCBhZnRlciB0aGF0IHdlIHdhbnQgdG8ganVzdCBjb250aW51ZSByZW5kZXJpbmcgdGhlIGluaXRpYWxcbiAgICAvLyBzY3JpcHRzIGFzIHRoZXkgd2VyZSB3aGVuIHRoZSBwYWdlIGZpcnN0IGxvYWRlZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICB9LCBbXSk7IC8vIGF2b2lkIHdhdGVyZmFsbCB3aGVuIGltcG9ydGluZyB0aGUgbmV4dCByb3V0ZSBtb2R1bGVcblxuICBsZXQgbmV4dE1hdGNoZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uKSB7XG4gICAgICAvLyBGSVhNRTogY2FuIHByb2JhYmx5IHVzZSB0cmFuc2l0aW9uTWFuYWdlciBgbmV4dE1hdGNoZXNgXG4gICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKGNsaWVudFJvdXRlcywgcGVuZGluZ0xvY2F0aW9uKTtcbiAgICAgIGludmFyaWFudChtYXRjaGVzLCBgTm8gcm91dGVzIG1hdGNoIHBhdGggXCIke3BlbmRpbmdMb2NhdGlvbi5wYXRobmFtZX1cImApO1xuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LCBbcGVuZGluZ0xvY2F0aW9uLCBjbGllbnRSb3V0ZXNdKTtcbiAgbGV0IHJvdXRlUHJlbG9hZHMgPSBtYXRjaGVzLmNvbmNhdChuZXh0TWF0Y2hlcykubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiAocm91dGUuaW1wb3J0cyB8fCBbXSkuY29uY2F0KFtyb3V0ZS5tb2R1bGVdKTtcbiAgfSkuZmxhdCgxKTtcbiAgbGV0IHByZWxvYWRzID0gbWFuaWZlc3QuZW50cnkuaW1wb3J0cy5jb25jYXQocm91dGVQcmVsb2Fkcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZGVkdXBlKHByZWxvYWRzKS5tYXAocGF0aCA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgIGtleTogcGF0aCxcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IHBhdGgsXG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gIH0pKSwgaXNIeWRyYXRlZCA/IG51bGwgOiBpbml0aWFsU2NyaXB0cyk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cblxuLyoqXG4gKiBBIFJlbWl4LWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHQgdGhhdCB0aGVcbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNmb3JtXG4gKi9cbmxldCBGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSk7XG59KTtcbmxldCBGb3JtSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHJlbG9hZERvY3VtZW50ID0gZmFsc2UsXG4gIHJlcGxhY2UgPSBmYWxzZSxcbiAgbWV0aG9kID0gXCJnZXRcIixcbiAgYWN0aW9uID0gXCIuXCIsXG4gIGVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBmZXRjaEtleSxcbiAgb25TdWJtaXQsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoZmV0Y2hLZXkpO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCBmb3JtTWV0aG9kKTtcbiAgbGV0IGZvcm1SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgbGV0IHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGZvcm1SZWYpOyAvLyBXaGVuIGNhbGxpbmcgYHN1Ym1pdGAgb24gdGhlIGZvcm0gZWxlbWVudCBpdHNlbGYsIHdlIGRvbid0IGdldCBkYXRhIGZyb21cbiAgLy8gdGhlIGJ1dHRvbiB0aGF0IHN1Ym1pdHRlZCB0aGUgZXZlbnQuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAgIDxGb3JtPlxuICAvLyAgICAgPGJ1dHRvbiBuYW1lPVwic29tZXRoaW5nXCIgdmFsdWU9XCJ3aGF0ZXZlclwiPlN1Ym1pdDwvYnV0dG9uPlxuICAvLyAgIDwvRm9ybT5cbiAgLy9cbiAgLy8gZm9ybURhdGEuZ2V0KFwic29tZXRoaW5nXCIpIHNob3VsZCBiZSBcIndoYXRldmVyXCIsIGJ1dCB3ZSBkb24ndCBnZXQgdGhhdFxuICAvLyB1bmxlc3Mgd2UgY2FsbCBzdWJtaXQgb24gdGhlIGNsaWNrZWQgYnV0dG9uIGl0c2VsZi5cbiAgLy9cbiAgLy8gVG8gZmlndXJlIG91dCB3aGljaCBidXR0b24gdHJpZ2dlcmVkIHRoZSBzdWJtaXQsIHdlJ2xsIGF0dGFjaCBhIGNsaWNrXG4gIC8vIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBmb3JtLiBUaGUgY2xpY2sgZXZlbnQgaXMgYWx3YXlzIHRyaWdnZXJlZCBiZWZvcmVcbiAgLy8gdGhlIHN1Ym1pdCBldmVudCAoZXZlbiB3aGVuIHN1Ym1pdHRpbmcgdmlhIGtleWJvYXJkIHdoZW4gZm9jdXNlZCBvblxuICAvLyBhbm90aGVyIGZvcm0gZmllbGQsIHllZWVlZXQpIHNvIHdlIHNob3VsZCBoYXZlIGFjY2VzcyB0byB0aGF0IGJ1dHRvbidzXG4gIC8vIGRhdGEgZm9yIHVzZSBpbiB0aGUgc3VibWl0IGhhbmRsZXIuXG5cbiAgbGV0IGNsaWNrZWRCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZm9ybSA9IGZvcm1SZWYuY3VycmVudDtcbiAgICBpZiAoIWZvcm0pIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgbGV0IHN1Ym1pdEJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFwiYnV0dG9uLGlucHV0W3R5cGU9c3VibWl0XVwiKTtcblxuICAgICAgaWYgKHN1Ym1pdEJ1dHRvbiAmJiBzdWJtaXRCdXR0b24uZm9ybSA9PT0gZm9ybSAmJiBzdWJtaXRCdXR0b24udHlwZSA9PT0gXCJzdWJtaXRcIikge1xuICAgICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBzdWJtaXRCdXR0b247XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICBlbmNUeXBlOiBlbmNUeXBlLFxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IHVuZGVmaW5lZCA6IGV2ZW50ID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3VibWl0KGNsaWNrZWRCdXR0b25SZWYuY3VycmVudCB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVwbGFjZVxuICAgICAgfSk7XG4gICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgcHJvcHMpKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0FjdGlvblJlcXVlc3RNZXRob2QobWV0aG9kKSB7XG4gIG1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbWV0aG9kID09PSBcInBvc3RcIiB8fCBtZXRob2QgPT09IFwicHV0XCIgfHwgbWV0aG9kID09PSBcInBhdGNoXCIgfHwgbWV0aG9kID09PSBcImRlbGV0ZVwiO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBhIGA8Zm9ybSBhY3Rpb24+YCBwYXRoIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHJvdXRlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWZvcm1hY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uID0gXCIuXCIsIG1ldGhvZCA9IFwiZ2V0XCIpIHtcbiAgbGV0IHtcbiAgICBpZFxuICB9ID0gdXNlUmVtaXhSb3V0ZUNvbnRleHQoKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgoYWN0aW9uKTtcbiAgbGV0IHNlYXJjaCA9IHBhdGguc2VhcmNoO1xuICBsZXQgaXNJbmRleFJvdXRlID0gaWQuZW5kc1dpdGgoXCIvaW5kZXhcIik7XG5cbiAgaWYgKGFjdGlvbiA9PT0gXCIuXCIgJiYgaXNJbmRleFJvdXRlICYmIGlzQWN0aW9uUmVxdWVzdE1ldGhvZChtZXRob2QpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoID8gc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGgucGF0aG5hbWUgKyBzZWFyY2g7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VzdWJtaXRcbiAqL1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICByZXR1cm4gdXNlU3VibWl0SW1wbCgpO1xufVxuZnVuY3Rpb24gdXNlU3VibWl0SW1wbChrZXkpIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGRlZmF1bHRBY3Rpb24gPSB1c2VGb3JtQWN0aW9uKCk7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IGVuY1R5cGU7XG4gICAgbGV0IGZvcm1EYXRhO1xuXG4gICAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgbGV0IHN1Ym1pc3Npb25UcmlnZ2VyID0gb3B0aW9ucy5zdWJtaXNzaW9uVHJpZ2dlcjtcbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5tZXRob2Q7XG4gICAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCB0YXJnZXQuYWN0aW9uO1xuICAgICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCB0YXJnZXQuZW5jdHlwZTtcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG5cbiAgICAgIGlmIChzdWJtaXNzaW9uVHJpZ2dlciAmJiBzdWJtaXNzaW9uVHJpZ2dlci5uYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChzdWJtaXNzaW9uVHJpZ2dlci5uYW1lLCBzdWJtaXNzaW9uVHJpZ2dlci52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmICh0YXJnZXQudHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgICAgbGV0IGZvcm0gPSB0YXJnZXQuZm9ybTtcblxuICAgICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiB3aXRob3V0IGEgPGZvcm0+YCk7XG4gICAgICB9IC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG5cbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0ubWV0aG9kO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5hY3Rpb247XG4gICAgICBlbmNUeXBlID0gb3B0aW9ucy5lbmNUeXBlIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSB8fCBmb3JtLmVuY3R5cGU7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTsgLy8gSW5jbHVkZSBuYW1lICsgdmFsdWUgZnJvbSBhIDxidXR0b24+XG5cbiAgICAgIGlmICh0YXJnZXQubmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5zZXQodGFyZ2V0Lm5hbWUsIHRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgYCArIGA8aW5wdXQgdHlwZT1cInN1Ym1pdHxpbWFnZVwiPmApO1xuICAgICAgfVxuXG4gICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcImdldFwiO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgZGVmYXVsdEFjdGlvbjtcbiAgICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgIGZvcm1EYXRhID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSBjYWxsaW5nIHN1Ym1pdCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIuIFwiICsgXCJUcnkgY2FsbGluZyBzdWJtaXQgd2l0aGluIGEgYHVzZUVmZmVjdGAgb3IgY2FsbGJhY2sgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgbGV0IHVybCA9IG5ldyBVUkwoYWN0aW9uLCBgJHtwcm90b2NvbH0vLyR7aG9zdH1gKTtcblxuICAgIGlmIChtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIikge1xuICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBmb3JtRGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN1Ym1pdCBiaW5hcnkgZm9ybSBkYXRhIHVzaW5nIEdFVGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGFjdGlvbjogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBlbmNUeXBlLFxuICAgICAga2V5OiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOClcbiAgICB9O1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiZmV0Y2hlclwiLFxuICAgICAgICBocmVmOiBzdWJtaXNzaW9uLmFjdGlvbixcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0TmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pO1xuICAgICAgbmF2aWdhdGUodXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCwge1xuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2RlZmF1bHRBY3Rpb24sIGtleSwgbmF2aWdhdGUsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG59XG5sZXQgbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uO1xuXG5mdW5jdGlvbiBzZXROZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikge1xuICBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCkge1xuICBsZXQgc3VibWlzc2lvbiA9IG5leHROYXZpZ2F0aW9uU3VibWlzc2lvbjtcbiAgbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uID0gdW5kZWZpbmVkO1xuICByZXR1cm4gc3VibWlzc2lvbjtcbn1cblxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYGJlZm9yZXVubG9hZGAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcywgd2hpY2ggYXV0b21hdGljYWxseSBoYXBwZW5zIG9uIHRoZSBuZXh0IGA8TGluaz5gIGNsaWNrIHdoZW4gUmVtaXhcbiAqIGRldGVjdHMgYSBuZXcgdmVyc2lvbiBvZiB0aGUgYXBwIGlzIGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWJlZm9yZXVubG9hZFxuICovXG5cblxuZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNhbGxiYWNrKSB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrXSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm91dGUgbWF0Y2hlcyBvbiB0aGUgcGFnZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nXG4gKiBsYXlvdXQgYWJzdHJhY3Rpb25zIHdpdGggeW91ciBjdXJyZW50IHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VtYXRjaGVzXG4gKi9cblxuZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzLFxuICAgIHJvdXRlRGF0YSxcbiAgICByb3V0ZU1vZHVsZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICB2YXIgX3JvdXRlTW9kdWxlcyRtYXRjaCRyO1xuXG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IG1hdGNoO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogbWF0Y2gucm91dGUuaWQsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGRhdGE6IHJvdXRlRGF0YVttYXRjaC5yb3V0ZS5pZF0sXG4gICAgICAvLyBpZiB0aGUgbW9kdWxlIGZhaWxzIHRvIGxvYWQgb3IgYW4gZXJyb3IvcmVzcG9uc2UgaXMgdGhyb3duLCB0aGUgbW9kdWxlXG4gICAgICAvLyB3b24ndCBiZSBkZWZpbmVkLlxuICAgICAgaGFuZGxlOiAoX3JvdXRlTW9kdWxlcyRtYXRjaCRyID0gcm91dGVNb2R1bGVzW21hdGNoLnJvdXRlLmlkXSkgPT09IG51bGwgfHwgX3JvdXRlTW9kdWxlcyRtYXRjaCRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcm91dGVNb2R1bGVzJG1hdGNoJHIuaGFuZGxlXG4gICAgfTtcbiAgfSksIFttYXRjaGVzLCByb3V0ZURhdGEsIHJvdXRlTW9kdWxlc10pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIHBhcnNlZCBkYXRhIGZyb20gdGhlIGN1cnJlbnQgcm91dGUncyBgbG9hZGVyYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2Vsb2FkZXJkYXRhXG4gKi9cblxuZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgcmV0dXJuIHVzZVJlbWl4Um91dGVDb250ZXh0KCkuZGF0YTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgSlNPTiBwYXJzZWQgZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJvdXRlJ3MgYGFjdGlvbmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlYWN0aW9uZGF0YVxuICovXG5cbmZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKSB7XG4gIGxldCB7XG4gICAgaWQ6IHJvdXRlSWRcbiAgfSA9IHVzZVJlbWl4Um91dGVDb250ZXh0KCk7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCB7XG4gICAgYWN0aW9uRGF0YVxuICB9ID0gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgcmV0dXJuIGFjdGlvbkRhdGEgPyBhY3Rpb25EYXRhW3JvdXRlSWRdIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8ga25vdyBhYm91dCBhIHBhZ2UgdHJhbnNpdGlvbiB0byBidWlsZCBwZW5kaW5nXG4gKiBuYXZpZ2F0aW9uIGluZGljYXRvcnMgYW5kIG9wdGltaXN0aWMgVUkgb24gZGF0YSBtdXRhdGlvbnMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNldHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpLnRyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoS2V5KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIC8vIFRPRE86IG1ha2UgQU5PVEhFUiBmb3JtIHcvbyBhIGZldGNoS2V5IHByb3BcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcmVmOiByZWYsXG4gICAgICBmZXRjaEtleTogZmV0Y2hLZXlcbiAgICB9KSk7XG4gIH0pO1xufVxuXG5sZXQgZmV0Y2hlcklkID0gMDtcblxuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VmZXRjaGVyXG4gKi9cbmZ1bmN0aW9uIHVzZUZldGNoZXIoKSB7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBba2V5XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFN0cmluZygrK2ZldGNoZXJJZCkpO1xuICBsZXQgW0Zvcm1dID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlRmV0Y2hlckZvcm0oa2V5KSk7XG4gIGxldCBbbG9hZF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBocmVmID0+IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiZmV0Y2hlclwiLFxuICAgICAgaHJlZixcbiAgICAgIGtleVxuICAgIH0pO1xuICB9KTtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoa2V5KTtcbiAgbGV0IGZldGNoZXIgPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRGZXRjaGVyKGtleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgRm9ybSxcbiAgICBzdWJtaXQsXG4gICAgbG9hZCxcbiAgICAuLi5mZXRjaGVyXG4gIH0pLCBbZmV0Y2hlciwgRm9ybSwgc3VibWl0LCBsb2FkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBidXN0ZWQgd2hlbiB0aGUgUmVhY3QgdGVhbSBnZXRzIHJlYWwgd2VpcmQgYW5kIGNhbGxzIGVmZmVjdHNcbiAgICAvLyB0d2ljZSBvbiBtb3VudD8gIFdlIHJlYWxseSBqdXN0IG5lZWQgdG8gZ2FyYmFnZSBjb2xsZWN0IGhlcmUgd2hlbiB0aGlzXG4gICAgLy8gZmV0Y2hlciBpcyBubyBsb25nZXIgYXJvdW5kLlxuICAgIHJldHVybiAoKSA9PiB0cmFuc2l0aW9uTWFuYWdlci5kZWxldGVGZXRjaGVyKGtleSk7XG4gIH0sIFt0cmFuc2l0aW9uTWFuYWdlciwga2V5XSk7XG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG4vKipcbiAqIFByb3ZpZGVzIGFsbCBmZXRjaGVycyBjdXJyZW50bHkgb24gdGhlIHBhZ2UuIFVzZWZ1bCBmb3IgbGF5b3V0cyBhbmQgcGFyZW50XG4gKiByb3V0ZXMgdGhhdCBuZWVkIHRvIHByb3ZpZGUgcGVuZGluZy9vcHRpbWlzdGljIFVJIHJlZ2FyZGluZyB0aGUgZmV0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlZmV0Y2hlcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBmZXRjaGVyc1xuICB9ID0gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgcmV0dXJuIFsuLi5mZXRjaGVycy52YWx1ZXMoKV07XG59IC8vIERlYWQgQ29kZSBFbGltaW5hdGlvbiBtYWdpYyBmb3IgcHJvZHVjdGlvbiBidWlsZHMuXG4vLyBUaGlzIHdheSBkZXZzIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgZG9pbmcgdGhlIE5PREVfRU5WIGNoZWNrIHRoZW1zZWx2ZXMuXG5cbmNvbnN0IExpdmVSZWxvYWQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiID8gKCkgPT4gbnVsbCA6IGZ1bmN0aW9uIExpdmVSZWxvYWQoe1xuICBwb3J0ID0gTnVtYmVyKHByb2Nlc3MuZW52LlJFTUlYX0RFVl9TRVJWRVJfV1NfUE9SVCB8fCA4MDAyKVxufSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbmxldCBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICd3c3M6JyA6ICd3czonO1xubGV0IGhvc3QgPSBsb2NhdGlvbi5ob3N0bmFtZTtcbmxldCBzb2NrZXRQYXRoID0gcHJvdG9jb2wgKyAnLy8nICsgaG9zdCArICc6JHtwb3J0fS9zb2NrZXQnO1xuXG5sZXQgd3MgPSBuZXcgV2ViU29ja2V0KHNvY2tldFBhdGgpO1xud3Mub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gIGxldCBldmVudCA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTtcbiAgaWYgKGV2ZW50LnR5cGUgPT09IFwiTE9HXCIpIHtcbiAgICBjb25zb2xlLmxvZyhldmVudC5tZXNzYWdlKTtcbiAgfVxuICBpZiAoZXZlbnQudHlwZSA9PT0gXCJSRUxPQURcIikge1xuICAgIGNvbnNvbGUubG9nKFwiXHVEODNEXHVEQ0JGIFJlbG9hZGluZyB3aW5kb3cgLi4uXCIpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufTtcbndzLm9uZXJyb3IgPSBlcnJvciA9PiB7XG4gIGNvbnNvbGUubG9nKFwiUmVtaXggZGV2IGFzc2V0IHNlcnZlciB3ZWIgc29ja2V0IGVycm9yOlwiKTtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59O1xuICAgICAgICAgICAgICBgLnRyaW0oKVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB1c2VDb21wb3NlZFJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgZm9yIChsZXQgcmVmIG9mIHJlZnMpIHtcbiAgICAgIGlmIChyZWYgPT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG5cbiAgfSwgcmVmcyk7XG59XG5cbmV4cG9ydCB7IEZvcm0sIEZvcm1JbXBsLCBMaW5rLCBMaW5rcywgTGl2ZVJlbG9hZCwgTWV0YSwgTmF2TGluaywgUHJlZmV0Y2hQYWdlTGlua3MsIFJlbWl4RW50cnksIFJlbWl4RW50cnlDb250ZXh0LCBSZW1peFJvdXRlLCBTY3JpcHRzLCBjb21wb3NlRXZlbnRIYW5kbGVycywgdXNlQWN0aW9uRGF0YSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VGZXRjaGVyLCB1c2VGZXRjaGVycywgdXNlRm9ybUFjdGlvbiwgdXNlTG9hZGVyRGF0YSwgdXNlTWF0Y2hlcywgdXNlU3VibWl0LCB1c2VTdWJtaXRJbXBsLCB1c2VUcmFuc2l0aW9uIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBleHRlbmRzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbmNsYXNzIFJlbWl4RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCxcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvblxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgLy8gcHJldmlvdXMgcGFnZSB0aGF0IGRpZG4ndCBoYXZlIGFuIGVycm9yLiBCZWNhdXNlIHRoaXMgd3JhcHMgdGhlIGVudGlyZVxuICAgIC8vIGFwcGxpY2F0aW9uIChldmVuIHRoZSBIVE1MISkgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZVxuICAgIC8vIGNvbnRpbnVlcyB0byBkaXNwbGF5LiBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3JcbiAgICAvLyB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAvLyBjb21lcyBpbiBhbmQgdGhlIHVzZXIgcmVjb3ZlcnMgZnJvbSB0aGUgZXJyb3IuXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvblxuICAgICAgfTtcbiAgICB9IC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XG4gICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY29tcG9uZW50LCB7XG4gICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmVycm9yXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9XG5cbn1cbi8qKlxuICogV2hlbiBhcHAncyBkb24ndCBwcm92aWRlIGEgcm9vdCBsZXZlbCBFcnJvckJvdW5kYXJ5LCB3ZSBkZWZhdWx0IHRvIHRoaXMuXG4gKi9cblxuZnVuY3Rpb24gUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnkoe1xuICBlcnJvclxufSkge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCB7XG4gICAgbGFuZzogXCJlblwiXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgIGNoYXJTZXQ6IFwidXRmLThcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLHZpZXdwb3J0LWZpdD1jb3ZlclwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIFwiQXBwbGljYXRpb24gRXJyb3IhXCIpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWFpblwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRGYW1pbHk6IFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIsXG4gICAgICBwYWRkaW5nOiBcIjJyZW1cIlxuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiBcIjI0cHhcIlxuICAgIH1cbiAgfSwgXCJBcHBsaWNhdGlvbiBFcnJvclwiKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nOiBcIjJyZW1cIixcbiAgICAgIGJhY2tncm91bmQ6IFwiaHNsYSgxMCwgNTAlLCA1MCUsIDAuMSlcIixcbiAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgb3ZlcmZsb3c6IFwiYXV0b1wiXG4gICAgfVxuICB9LCBlcnJvci5zdGFjaykpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlx1RDgzRFx1RENCRiBIZXkgZGV2ZWxvcGVyXHVEODNEXHVEQzRCLiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMuIENoZWNrIG91dCBodHRwczovL3JlbWl4LnJ1bi9ndWlkZXMvZXJyb3JzIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBgXG4gICAgfVxuICB9KSkpO1xufVxubGV0IFJlbWl4Q2F0Y2hDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRocm93biByZXNwb25zZSBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL2NvbnZlbnRpb25zI2NhdGNoYm91bmRhcnlcbiAqL1xuXG5mdW5jdGlvbiB1c2VDYXRjaCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUmVtaXhDYXRjaENvbnRleHQpO1xufVxuZnVuY3Rpb24gUmVtaXhDYXRjaEJvdW5kYXJ5KHtcbiAgY2F0Y2g6IGNhdGNoVmFsLFxuICBjb21wb25lbnQ6IENvbXBvbmVudCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgaWYgKGNhdGNoVmFsKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlbWl4Q2F0Y2hDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY2F0Y2hWYWxcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBXaGVuIGFwcCdzIGRvbid0IHByb3ZpZGUgYSByb290IGxldmVsIENhdGNoQm91bmRhcnksIHdlIGRlZmF1bHQgdG8gdGhpcy5cbiAqL1xuXG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSgpIHtcbiAgbGV0IGNhdWdodCA9IHVzZUNhdGNoKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwge1xuICAgIGxhbmc6IFwiZW5cIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBcIlVuaGFuZGxlZCBUaHJvd24gUmVzcG9uc2UhXCIpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLFxuICAgICAgcGFkZGluZzogXCIycmVtXCJcbiAgICB9XG4gIH0sIGNhdWdodC5zdGF0dXMsIFwiIFwiLCBjYXVnaHQuc3RhdHVzVGV4dCksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiXHVEODNEXHVEQ0JGIEhleSBkZXZlbG9wZXJcdUQ4M0RcdURDNEIuIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIDQwNHMgKGFuZCBvdGhlciByZXNwb25zZXMpLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vZ3VpZGVzL25vdC1mb3VuZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYFxuICAgIH1cbiAgfSkpKTtcbn1cblxuZXhwb3J0IHsgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peEVycm9yQm91bmRhcnksIFJlbWl4Um9vdERlZmF1bHRDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgdXNlQ2F0Y2ggfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBpbnZhcmlhbnQgYXMgZGVmYXVsdCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfSBmcm9tICcuL3JvdXRlTW9kdWxlcy5qcyc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdldHMgYWxsIHRoZSBsaW5rcyBmb3IgYSBzZXQgb2YgbWF0Y2hlcy4gVGhlIG1vZHVsZXMgYXJlIGFzc3VtZWQgdG8gaGF2ZSBiZWVuXG4gKiBsb2FkZWQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpIHtcbiAgbGV0IGRlc2NyaXB0b3JzID0gbWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIHZhciBfbW9kdWxlJGxpbmtzO1xuXG4gICAgbGV0IG1vZHVsZSA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgcmV0dXJuICgoX21vZHVsZSRsaW5rcyA9IG1vZHVsZS5saW5rcykgPT09IG51bGwgfHwgX21vZHVsZSRsaW5rcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21vZHVsZSRsaW5rcy5jYWxsKG1vZHVsZSkpIHx8IFtdO1xuICB9KS5mbGF0KDEpO1xuICBsZXQgcHJlbG9hZHMgPSBnZXRDdXJyZW50UGFnZU1vZHVsZVByZWxvYWRIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCk7XG4gIHJldHVybiBkZWR1cGUoZGVzY3JpcHRvcnMsIHByZWxvYWRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZU1vZHVsZSkge1xuICBpZiAoIXJvdXRlTW9kdWxlLmxpbmtzKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IHJvdXRlTW9kdWxlLmxpbmtzKCk7XG4gIGlmICghZGVzY3JpcHRvcnMpIHJldHVybjtcbiAgbGV0IHN0eWxlTGlua3MgPSBbXTtcblxuICBmb3IgKGxldCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKCFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIpIHtcbiAgICAgIHN0eWxlTGlua3MucHVzaCh7IC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBkb24ndCBibG9jayBmb3Igbm9uLW1hdGNoaW5nIG1lZGlhIHF1ZXJpZXNcblxuXG4gIGxldCBtYXRjaGluZ0xpbmtzID0gc3R5bGVMaW5rcy5maWx0ZXIobGluayA9PiAhbGluay5tZWRpYSB8fCB3aW5kb3cubWF0Y2hNZWRpYShsaW5rLm1lZGlhKS5tYXRjaGVzKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hpbmdMaW5rcy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmsoZGVzY3JpcHRvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBPYmplY3QuYXNzaWduKGxpbmssIGRlc2NyaXB0b3IpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGluaygpIHtcbiAgICAgIC8vIGlmIGEgbmF2aWdhdGlvbiBpbnRlcnJ1cHRzIHRoaXMgcHJlZmV0Y2ggUmVhY3Qgd2lsbCB1cGRhdGUgdGhlIDxoZWFkPlxuICAgICAgLy8gYW5kIHJlbW92ZSB0aGUgbGluayB3ZSBwdXQgaW4gdGhlcmUgbWFudWFsbHksIHNvIHdlIGNoZWNrIGlmIGl0J3Mgc3RpbGxcbiAgICAgIC8vIHRoZXJlIGJlZm9yZSB0cnlpbmcgdG8gcmVtb3ZlIGl0XG4gICAgICBpZiAoZG9jdW1lbnQuaGVhZC5jb250YWlucyhsaW5rKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpbmsub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICBsaW5rLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gIH0pO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbmZ1bmN0aW9uIGlzUGFnZUxpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5wYWdlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNIdG1sTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmhyZWYgPT09IFwic3RyaW5nXCI7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IGxpbmtzID0gYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlcy5tYXAoYXN5bmMgbWF0Y2ggPT4ge1xuICAgIGxldCBtb2QgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGUobWF0Y2gucm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgcmV0dXJuIG1vZC5saW5rcyA/IG1vZC5saW5rcygpIDogW107XG4gIH0pKTtcbiAgcmV0dXJuIGxpbmtzLmZsYXQoMSkuZmlsdGVyKGlzSHRtbExpbmtEZXNjcmlwdG9yKS5maWx0ZXIobGluayA9PiBsaW5rLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgbGluay5yZWwgPT09IFwicHJlbG9hZFwiKS5tYXAoKHtcbiAgICByZWwsXG4gICAgLi4uYXR0cnNcbiAgfSkgPT4gcmVsID09PSBcInByZWxvYWRcIiA/IHtcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICAuLi5hdHRyc1xuICB9IDoge1xuICAgIHJlbDogXCJwcmVmZXRjaFwiLFxuICAgIGFzOiBcInN0eWxlXCIsXG4gICAgLi4uYXR0cnNcbiAgfSk7XG59IC8vIFRoaXMgaXMgcmlkaWN1bG91c2x5IGlkZW50aWNhbCB0byB0cmFuc2l0aW9uLnRzIGBmaWx0ZXJNYXRjaGVzVG9Mb2FkYFxuXG5mdW5jdGlvbiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIGN1cnJlbnRNYXRjaGVzLCBsb2NhdGlvbiwgbW9kZSkge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aFBhdGNoKHBhZ2UpO1xuXG4gIGxldCBpc05ldyA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRNYXRjaGVzW2luZGV4XSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUuaWQ7XG4gIH07XG5cbiAgbGV0IG1hdGNoUGF0aENoYW5nZWQgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgdmFyIF9jdXJyZW50TWF0Y2hlcyRpbmRleDtcblxuICAgIHJldHVybiAoLy8gcGFyYW0gY2hhbmdlLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgKChfY3VycmVudE1hdGNoZXMkaW5kZXggPSBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUucGF0aCkgPT09IG51bGwgfHwgX2N1cnJlbnRNYXRjaGVzJGluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY3VycmVudE1hdGNoZXMkaW5kZXguZW5kc1dpdGgoXCIqXCIpKSAmJiBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICAgICk7XG4gIH07IC8vIE5PVEU6IGtlZXAgdGhpcyBtb3N0bHkgdXAtdG8tZGF0ZSB3LyB0aGUgdHJhbnNpdGlvbiBkYXRhIGRpZmYsIGJ1dCB0aGlzXG4gIC8vIHZlcnNpb24gZG9lc24ndCBjYXJlIGFib3V0IHN1Ym1pc3Npb25zXG5cblxuICBsZXQgbmV3TWF0Y2hlcyA9IG1vZGUgPT09IFwiZGF0YVwiICYmIGxvY2F0aW9uLnNlYXJjaCAhPT0gcGF0aC5zZWFyY2ggPyAvLyB0aGlzIGlzIHJlYWxseSBzaW1pbGFyIHRvIHN0dWZmIGluIHRyYW5zaXRpb24udHMsIG1heWJlIHNvbWVib2R5IHNtYXJ0ZXJcbiAgLy8gdGhhbiBtZSAob3IgaW4gbGVzcyBvZiBhIGh1cnJ5KSBjYW4gc2hhcmUgc29tZSBvZiBpdC4gWW91J3JlIHRoZSBiZXN0LlxuICBuZXh0TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghbWF0Y2gucm91dGUuaGFzTG9hZGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKSB7XG4gICAgICByZXR1cm4gbWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKHtcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIHByZXZVcmw6IG5ldyBVUkwobG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoLCB3aW5kb3cub3JpZ2luKSxcbiAgICAgICAgdXJsOiBuZXcgVVJMKHBhZ2UsIHdpbmRvdy5vcmlnaW4pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgOiBuZXh0TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBtYXRjaC5yb3V0ZS5oYXNMb2FkZXIgJiYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKTtcbiAgfSk7XG4gIHJldHVybiBuZXdNYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2V0RGF0YUxpbmtIcmVmcyhwYWdlLCBtYXRjaGVzLCBtYW5pZmVzdCkge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aFBhdGNoKHBhZ2UpO1xuICByZXR1cm4gZGVkdXBlSHJlZnMobWF0Y2hlcy5maWx0ZXIobWF0Y2ggPT4gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXS5oYXNMb2FkZXIpLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoXG4gICAgfSA9IHBhdGg7XG4gICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiX2RhdGFcIiwgbWF0Y2gucm91dGUuaWQpO1xuICAgIHJldHVybiBgJHtwYXRobmFtZX0/JHtzZWFyY2hQYXJhbXN9YDtcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0UGF0Y2gpIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFBhdGNoLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG5cbiAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaW1wb3J0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWZzO1xuICB9KS5mbGF0KDEpKTtcbn0gLy8gVGhlIGA8U2NyaXB0PmAgd2lsbCByZW5kZXIgcmVsPW1vZHVsZXByZWxvYWQgZm9yIHRoZSBjdXJyZW50IHBhZ2UsIHdlIGRvbid0XG4vLyBuZWVkIHRvIGluY2x1ZGUgdGhlbSBpbiBhIHBhZ2UgcHJlZmV0Y2gsIHRoaXMgZ2l2ZXMgdXMgdGhlIGxpc3QgdG8gcmVtb3ZlXG4vLyB3aGlsZSBkZWR1cGluZy5cblxuZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2VNb2R1bGVQcmVsb2FkSHJlZnMobWF0Y2hlcywgbWFuaWZlc3QpIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCBocmVmcyA9IFtyb3V0ZS5tb2R1bGVdO1xuXG4gICAgaWYgKHJvdXRlLmltcG9ydHMpIHtcbiAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmcztcbiAgfSkuZmxhdCgxKSk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhyZWZzKGhyZWZzKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChocmVmcyldO1xufVxuXG5mdW5jdGlvbiBkZWR1cGUoZGVzY3JpcHRvcnMsIHByZWxvYWRzKSB7XG4gIGxldCBzZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwcmVsb2Fkc1NldCA9IG5ldyBTZXQocHJlbG9hZHMpO1xuICByZXR1cm4gZGVzY3JpcHRvcnMucmVkdWNlKChkZWR1cGVkLCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgbGV0IGFscmVhZHlNb2R1bGVQcmVsb2FkID0gIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IuYXMgPT09IFwic2NyaXB0XCIgJiYgZGVzY3JpcHRvci5ocmVmICYmIHByZWxvYWRzU2V0LmhhcyhkZXNjcmlwdG9yLmhyZWYpO1xuXG4gICAgaWYgKGFscmVhZHlNb2R1bGVQcmVsb2FkKSB7XG4gICAgICByZXR1cm4gZGVkdXBlZDtcbiAgICB9XG5cbiAgICBsZXQgc3RyID0gSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcik7XG5cbiAgICBpZiAoIXNldC5oYXMoc3RyKSkge1xuICAgICAgc2V0LmFkZChzdHIpO1xuICAgICAgZGVkdXBlZC5wdXNoKGRlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWR1cGVkO1xuICB9LCBbXSk7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS9pc3N1ZXMvODk3XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aFBhdGNoKGhyZWYpIHtcbiAgbGV0IHBhdGggPSBwYXJzZVBhdGgoaHJlZik7XG4gIGlmIChwYXRoLnNlYXJjaCA9PT0gdW5kZWZpbmVkKSBwYXRoLnNlYXJjaCA9IFwiXCI7XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgeyBkZWR1cGUsIGdldERhdGFMaW5rSHJlZnMsIGdldExpbmtzRm9yTWF0Y2hlcywgZ2V0TW9kdWxlTGlua0hyZWZzLCBnZXROZXdNYXRjaGVzRm9yTGlua3MsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzLCBpc0h0bWxMaW5rRGVzY3JpcHRvciwgaXNQYWdlTGlua0Rlc2NyaXB0b3IsIHByZWZldGNoU3R5bGVMaW5rcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbi8vIGFuZCBsZXZlcmFnZSBgcmVhY3Qtcm91dGVyYCBoZXJlIGluc3RlYWRcbi8vIFRPRE86IGltcG9ydC9leHBvcnQgZnJvbSByZWFjdC1yb3V0ZXItZG9tXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCB3aGVuIHRoZSBzZXJ2ZXIgdGhyb3dzIGEgUmVzcG9uc2UuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjY2F0Y2hib3VuZGFyeVxuICovXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIG9uIGEgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjZXJyb3Jib3VuZGFyeVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYDxsaW5rPmAgdGFncyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBgPGhlYWQ+YCBvZlxuICogdGhlIGRvY3VtZW50IG9uIHJvdXRlIHRyYW5zaXRpb25zLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9mIG5hbWUgKyBjb250ZW50IHBhaXJzIHRvIHVzZSBmb3JcbiAqIGA8bWV0YT5gIHRhZ3MgZm9yIGEgcm91dGUuIFRoZXNlIHRhZ3Mgd2lsbCBiZSBtZXJnZWQgd2l0aCAoYW5kIHRha2VcbiAqIHByZWNlZGVuY2Ugb3ZlcikgdGFncyBmcm9tIHBhcmVudCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cblxuLyoqXG4gKiBBIG5hbWUvY29udGVudCBwYWlyIHVzZWQgdG8gcmVuZGVyIGA8bWV0YT5gIHRhZ3MgaW4gYSBtZXRhIGZ1bmN0aW9uIGZvciBhXG4gKiByb3V0ZS4gVGhlIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcsIHdoaWNoIHdpbGwgcmVuZGVyIGEgc2luZ2xlIGA8bWV0YT5gXG4gKiB0YWcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHJlbmRlciBtdWx0aXBsZSB0YWdzIHdpdGggdGhlIHNhbWVcbiAqIGBuYW1lYCBhdHRyaWJ1dGUuXG4gKi9cblxuLyoqXG4gKiBEdXJpbmcgY2xpZW50IHNpZGUgdHJhbnNpdGlvbnMgUmVtaXggd2lsbCBvcHRpbWl6ZSByZWxvYWRpbmcgb2Ygcm91dGVzIHRoYXRcbiAqIGFyZSBjdXJyZW50bHkgb24gdGhlIHBhZ2UgYnkgYXZvaWRpbmcgbG9hZGluZyByb3V0ZXMgdGhhdCBhcmVuJ3QgY2hhbmdpbmcuXG4gKiBIb3dldmVyLCBpbiBzb21lIGNhc2VzLCBsaWtlIGZvcm0gc3VibWlzc2lvbnMgb3Igc2VhcmNoIHBhcmFtcyBSZW1peCBkb2Vzbid0XG4gKiBrbm93IHdoaWNoIHJvdXRlcyBuZWVkIHRvIGJlIHJlbG9hZGVkIHNvIGl0IHJlbG9hZHMgdGhlbSBhbGwgdG8gYmUgc2FmZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGxldHMgYXBwcyBmdXJ0aGVyIG9wdGltaXplIGJ5IHJldHVybmluZyBgZmFsc2VgIHdoZW4gUmVtaXggaXNcbiAqIGFib3V0IHRvIHJlbG9hZCB0aGUgcm91dGUuIEEgY29tbW9uIGNhc2UgaXMgYSByb290IGxvYWRlciB3aXRoIG5vdGhpbmcgYnV0XG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZXM6IGFmdGVyIGZvcm0gc3VibWlzc2lvbnMgdGhlIHJvb3QgcHJvYmFibHkgZG9lc24ndCBuZWVkXG4gKiB0byBiZSByZWxvYWRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9jb252ZW50aW9ucyN1bnN0YWJsZV9zaG91bGRyZWxvYWRcbiAqL1xuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgcmVuZGVyZWQgZm9yIGEgcm91dGUuXG4gKi9cblxuLyoqXG4gKiBBbiBhcmJpdHJhcnkgb2JqZWN0IHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjaGFuZGxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgaWYgKHJvdXRlLmlkIGluIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgaW1wb3J0KHJvdXRlLm1vZHVsZSk7XG4gICAgcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdID0gcm91dGVNb2R1bGU7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFVzZXIgZ290IGNhdWdodCBpbiB0aGUgbWlkZGxlIG9mIGEgZGVwbG95IGFuZCB0aGUgQ0ROIG5vIGxvbmdlciBoYXMgdGhlXG4gICAgLy8gYXNzZXQgd2UncmUgdHJ5aW5nIHRvIGltcG9ydCEgUmVsb2FkIGZyb20gdGhlIHNlcnZlciBhbmQgdGhlIHVzZXJcbiAgICAvLyAoc2hvdWxkKSBnZXQgdGhlIG5ldyBtYW5pZmVzdC0tdW5sZXNzIHRoZSBkZXZlbG9wZXIgcHVyZ2VkIHRoZSBzdGF0aWNcbiAgICAvLyBhc3NldHMsIHRoZSBtYW5pZmVzdCBwYXRoLCBidXQgbm90IHRoZSBkb2N1bWVudHMgXHVEODNEXHVERTJDXG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7Ly8gY2hlY2sgb3V0IG9mIHRoaXMgaG9vayBjYXVzZSB0aGUgREpzIG5ldmVyIGdvbm5hIHJlW3Ndb2x2ZSB0aGlzXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgbG9hZFJvdXRlTW9kdWxlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBjcmVhdGVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIHtcbiAgICBfX2h0bWw6IGh0bWxcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlSHRtbCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbG9hZFJvdXRlTW9kdWxlIH0gZnJvbSAnLi9yb3V0ZU1vZHVsZXMuanMnO1xuaW1wb3J0IHsgZmV0Y2hEYXRhLCBpc0NhdGNoUmVzcG9uc2UsIGV4dHJhY3REYXRhLCBpc1JlZGlyZWN0UmVzcG9uc2UgfSBmcm9tICcuL2RhdGEuanMnO1xuaW1wb3J0IHsgQ2F0Y2hWYWx1ZSwgVHJhbnNpdGlvblJlZGlyZWN0IH0gZnJvbSAnLi90cmFuc2l0aW9uLmpzJztcbmltcG9ydCB7IHByZWZldGNoU3R5bGVMaW5rcyB9IGZyb20gJy4vbGlua3MuanMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuL2ludmFyaWFudC5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlKGVudHJ5Um91dGUsIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXNlU2Vuc2l0aXZlOiAhIWVudHJ5Um91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICBlbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIGlkOiBlbnRyeVJvdXRlLmlkXG4gICAgfSksXG4gICAgaWQ6IGVudHJ5Um91dGUuaWQsXG4gICAgcGF0aDogZW50cnlSb3V0ZS5wYXRoLFxuICAgIGluZGV4OiBlbnRyeVJvdXRlLmluZGV4LFxuICAgIG1vZHVsZTogZW50cnlSb3V0ZS5tb2R1bGUsXG4gICAgbG9hZGVyOiBjcmVhdGVMb2FkZXIoZW50cnlSb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpLFxuICAgIGFjdGlvbjogY3JlYXRlQWN0aW9uKGVudHJ5Um91dGUpLFxuICAgIHNob3VsZFJlbG9hZDogY3JlYXRlU2hvdWxkUmVsb2FkKGVudHJ5Um91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSxcbiAgICBFcnJvckJvdW5kYXJ5OiBlbnRyeVJvdXRlLmhhc0Vycm9yQm91bmRhcnksXG4gICAgQ2F0Y2hCb3VuZGFyeTogZW50cnlSb3V0ZS5oYXNDYXRjaEJvdW5kYXJ5LFxuICAgIGhhc0xvYWRlcjogZW50cnlSb3V0ZS5oYXNMb2FkZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlcyhyb3V0ZU1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50LCBwYXJlbnRJZCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocm91dGVNYW5pZmVzdCkuZmlsdGVyKGtleSA9PiByb3V0ZU1hbmlmZXN0W2tleV0ucGFyZW50SWQgPT09IHBhcmVudElkKS5tYXAoa2V5ID0+IHtcbiAgICBsZXQgcm91dGUgPSBjcmVhdGVDbGllbnRSb3V0ZShyb3V0ZU1hbmlmZXN0W2tleV0sIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQpO1xuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNsaWVudFJvdXRlcyhyb3V0ZU1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50LCByb3V0ZS5pZCk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIHJvdXRlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hvdWxkUmVsb2FkKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IHNob3VsZFJlbG9hZCA9IGFyZyA9PiB7XG4gICAgbGV0IG1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZS5pZF07XG4gICAgaW52YXJpYW50KG1vZHVsZSwgYEV4cGVjdGVkIHJvdXRlIG1vZHVsZSB0byBiZSBsb2FkZWQgZm9yICR7cm91dGUuaWR9YCk7XG5cbiAgICBpZiAobW9kdWxlLnVuc3RhYmxlX3Nob3VsZFJlbG9hZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZS51bnN0YWJsZV9zaG91bGRSZWxvYWQoYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gc2hvdWxkUmVsb2FkO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgYXdhaXQgcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlTW9kdWxlKTtcbiAgcmV0dXJuIHJvdXRlTW9kdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2FkZXIocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgbG9hZGVyID0gYXN5bmMgKHtcbiAgICB1cmwsXG4gICAgc2lnbmFsLFxuICAgIHN1Ym1pc3Npb25cbiAgfSkgPT4ge1xuICAgIGlmIChyb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgIGxldCBbcmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaERhdGEodXJsLCByb3V0ZS5pZCwgc2lnbmFsLCBzdWJtaXNzaW9uKSwgbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcyldKTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmVzdWx0O1xuICAgICAgbGV0IHJlZGlyZWN0ID0gYXdhaXQgY2hlY2tSZWRpcmVjdChyZXN1bHQpO1xuICAgICAgaWYgKHJlZGlyZWN0KSByZXR1cm4gcmVkaXJlY3Q7XG5cbiAgICAgIGlmIChpc0NhdGNoUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2F0Y2hWYWx1ZShyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgYXdhaXQgZXh0cmFjdERhdGEocmVzdWx0LmNsb25lKCkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4dHJhY3REYXRhKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbG9hZGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24ocm91dGUpIHtcbiAgaWYgKCFyb3V0ZS5oYXNBY3Rpb24pIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgbGV0IGFjdGlvbiA9IGFzeW5jICh7XG4gICAgdXJsLFxuICAgIHNpZ25hbCxcbiAgICBzdWJtaXNzaW9uXG4gIH0pID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgcm91dGUuaWQsIHNpZ25hbCwgc3VibWlzc2lvbik7XG5cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBhd2FpdCBjaGVja1JlZGlyZWN0KHJlc3VsdCk7XG4gICAgaWYgKHJlZGlyZWN0KSByZXR1cm4gcmVkaXJlY3Q7XG5cbiAgICBpZiAoaXNDYXRjaFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBDYXRjaFZhbHVlKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBhd2FpdCBleHRyYWN0RGF0YShyZXN1bHQuY2xvbmUoKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBleHRyYWN0RGF0YShyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiBhY3Rpb247XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrUmVkaXJlY3QocmVzcG9uc2UpIHtcbiAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXNwb25zZS5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVkaXJlY3RcIiksIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuXG4gICAgaWYgKHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodXJsLmhyZWYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvblJlZGlyZWN0KHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBjcmVhdGVDbGllbnRSb3V0ZSwgY3JlYXRlQ2xpZW50Um91dGVzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJy4vaW52YXJpYW50LmpzJztcblxuZnVuY3Rpb24gaXNDYXRjaFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1DYXRjaFwiKSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1FcnJvclwiKSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSAhPSBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgcm91dGVJZCwgc2lnbmFsLCBzdWJtaXNzaW9uKSB7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX2RhdGFcIiwgcm91dGVJZCk7XG4gIGxldCBpbml0ID0gc3VibWlzc2lvbiA/IGdldEFjdGlvbkluaXQoc3VibWlzc2lvbiwgc2lnbmFsKSA6IHtcbiAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgIHNpZ25hbFxuICB9O1xuICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwuaHJlZiwgaW5pdCk7XG5cbiAgaWYgKGlzRXJyb3JSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICBlcnJvci5zdGFjayA9IGRhdGEuc3RhY2s7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcG9uc2UpIHtcbiAgLy8gVGhpcyBzYW1lIGFsZ29yaXRobSBpcyB1c2VkIG9uIHRoZSBzZXJ2ZXIgdG8gaW50ZXJwcmV0IGxvYWRcbiAgLy8gcmVzdWx0cyB3aGVuIHdlIHJlbmRlciB0aGUgSFRNTCBwYWdlLlxuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcblxuICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uSW5pdChzdWJtaXNzaW9uLCBzaWduYWwpIHtcbiAgbGV0IHtcbiAgICBlbmNUeXBlLFxuICAgIG1ldGhvZCxcbiAgICBmb3JtRGF0YVxuICB9ID0gc3VibWlzc2lvbjtcbiAgbGV0IGhlYWRlcnMgPSB1bmRlZmluZWQ7XG4gIGxldCBib2R5ID0gZm9ybURhdGE7XG5cbiAgaWYgKGVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpIHtcbiAgICBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhKSB7XG4gICAgICBpbnZhcmlhbnQodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLCBgRmlsZSBpbnB1dHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBlbmNUeXBlIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIHBsZWFzZSB1c2UgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgaW5zdGVhZC5gKTtcbiAgICAgIGJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBlbmNUeXBlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgaGVhZGVyc1xuICB9O1xufVxuXG5leHBvcnQgeyBleHRyYWN0RGF0YSwgZmV0Y2hEYXRhLCBpc0NhdGNoUmVzcG9uc2UsIGlzRXJyb3JSZXNwb25zZSwgaXNSZWRpcmVjdFJlc3BvbnNlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCB7IG1hdGNoQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZU1hdGNoaW5nLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuY2xhc3MgQ2F0Y2hWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikge1xuICByZXR1cm4gW1wiUE9TVFwiLCBcIlBVVFwiLCBcIlBBVENIXCIsIFwiREVMRVRFXCJdLmluY2x1ZGVzKHN1Ym1pc3Npb24ubWV0aG9kKTtcbn1cblxuZnVuY3Rpb24gaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pIHtcbiAgcmV0dXJuIHN1Ym1pc3Npb24ubWV0aG9kID09PSBcIkdFVFwiO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIEJvb2xlYW4obG9jYXRpb24uc3RhdGUpICYmIGxvY2F0aW9uLnN0YXRlLmlzUmVkaXJlY3Q7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImxvYWRlclwiO1xufVxuXG5mdW5jdGlvbiBpc0FjdGlvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJhY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pICYmIGxvY2F0aW9uLnN0YXRlLnR5cGUgPT09IFwiZmV0Y2hBY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImxvYWRlclN1Ym1pc3Npb25cIjtcbn1cblxuY2xhc3MgVHJhbnNpdGlvblJlZGlyZWN0IHtcbiAgY29uc3RydWN0b3IobG9jYXRpb24pIHtcbiAgICB0aGlzLmxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gbG9jYXRpb24gOiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbiAgfVxuXG59XG5jb25zdCBJRExFX1RSQU5TSVRJT04gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICB0eXBlOiBcImlkbGVcIlxufTtcbmNvbnN0IElETEVfRkVUQ0hFUiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICB0eXBlOiBcImluaXRcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbn07XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihpbml0KSB7XG4gIGxldCB7XG4gICAgcm91dGVzXG4gIH0gPSBpbml0O1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG4gIGxldCBuYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IG5ldyBNYXAoKTtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGluaXQubG9jYXRpb24pO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBDYXRjaEJvdW5kYXJ5IHRvIHRha2Ugb3ZlclxuICAgIG1hdGNoZXMgPSBbe1xuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgcm91dGU6IHJvdXRlc1swXVxuICAgIH1dO1xuICB9XG5cbiAgbGV0IHN0YXRlID0ge1xuICAgIGxvY2F0aW9uOiBpbml0LmxvY2F0aW9uLFxuICAgIGxvYWRlckRhdGE6IGluaXQubG9hZGVyRGF0YSB8fCB7fSxcbiAgICBhY3Rpb25EYXRhOiBpbml0LmFjdGlvbkRhdGEsXG4gICAgY2F0Y2g6IGluaXQuY2F0Y2gsXG4gICAgZXJyb3I6IGluaXQuZXJyb3IsXG4gICAgY2F0Y2hCb3VuZGFyeUlkOiBpbml0LmNhdGNoQm91bmRhcnlJZCB8fCBudWxsLFxuICAgIGVycm9yQm91bmRhcnlJZDogaW5pdC5lcnJvckJvdW5kYXJ5SWQgfHwgbnVsbCxcbiAgICBtYXRjaGVzLFxuICAgIG5leHRNYXRjaGVzOiB1bmRlZmluZWQsXG4gICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgIGZldGNoZXJzOiBuZXcgTWFwKClcbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGUodXBkYXRlcykge1xuICAgIHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHVwZGF0ZXMpO1xuICAgIGluaXQub25DaGFuZ2Uoc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXkpIHtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZW5kKGV2ZW50KSB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwibmF2aWdhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgc3VibWlzc2lvblxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKHJvdXRlcywgbG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICBtYXRjaGVzID0gW3tcbiAgICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgIHJvdXRlOiByb3V0ZXNbMF1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTm90Rm91bmROYXZpZ2F0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdWJtaXNzaW9uICYmIGlzSGFzaENoYW5nZU9ubHkobG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVIYXNoQ2hhbmdlKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIGJhY2svZm9yd2FyZCBidXR0b24sIHRyZWF0IGFsbCBhcyBub3JtYWwgbmF2aWdhdGlvblxuICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gQWN0aW9uLlBvcCkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyA8Rm9ybSBtZXRob2Q9XCJwb3N0IHwgcHV0IHwgZGVsZXRlIHwgcGF0Y2hcIj5cbiAgICAgICAgICBlbHNlIGlmIChzdWJtaXNzaW9uICYmIGlzQWN0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQWN0aW9uU3VibWlzc2lvbk5hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwiZ2V0XCIvPlxuICAgICAgICAgIGVsc2UgaWYgKHN1Ym1pc3Npb24gJiYgaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBhY3Rpb249PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNBY3Rpb25SZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwiZ2V0XCI+IC0tPiBsb2FkZXI9PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBsb2FkZXI9PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb2FkZXJSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gdXNlU3VibWlzc2lvbigpPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzRmV0Y2hBY3Rpb25SZWRpcmVjdChsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPExpbms+LCBuYXZpZ2F0ZSgpXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImZldGNoZXJcIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICAgICAgaHJlZlxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKHJvdXRlcywgaHJlZik7XG4gICAgICAgICAgaW52YXJpYW50KG1hdGNoZXMsIFwiTm8gbWF0Y2hlcyBmb3VuZFwiKTtcbiAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG5cbiAgICAgICAgICBpZiAoc3VibWlzc2lvbiAmJiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUFjdGlvbkZldGNoU3VibWlzc2lvbihrZXksIHN1Ym1pc3Npb24sIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN1Ym1pc3Npb24gJiYgaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJGZXRjaFN1Ym1pc3Npb24oaHJlZiwga2V5LCBzdWJtaXNzaW9uLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlckZldGNoKGhyZWYsIGtleSwgbWF0Y2gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgZXZlbnQgdHlwZTogJHtldmVudC50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcblxuICAgIGZvciAobGV0IFssIGNvbnRyb2xsZXJdIG9mIGZldGNoQ29udHJvbGxlcnMpIHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb25GZXRjaFN1Ym1pc3Npb24oa2V5LCBzdWJtaXNzaW9uLCBtYXRjaCkge1xuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25TdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZGF0YTogKGN1cnJlbnRGZXRjaGVyID09PSBudWxsIHx8IGN1cnJlbnRGZXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmV0Y2hlci5kYXRhKSB8fCB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGNvbnRyb2xsZXIpO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIG1hdGNoLCBjb250cm9sbGVyLnNpZ25hbCk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImZldGNoQWN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxvYWRGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWxvYWRcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IG1heWJlQWN0aW9uRXJyb3JSZXN1bHQgPSBpc0Vycm9yUmVzdWx0KHJlc3VsdCkgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQgPSBpc0NhdGNoUmVzdWx0KHJlc3VsdCkgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSBzdGF0ZS5uZXh0TWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzO1xuICAgIGxldCBocmVmVG9Mb2FkID0gY3JlYXRlSHJlZihzdGF0ZS50cmFuc2l0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uKTtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxMb2FkZXJzKHN0YXRlLCBjcmVhdGVVcmwoaHJlZlRvTG9hZCksIG1hdGNoZXNUb0xvYWQsIGNvbnRyb2xsZXIuc2lnbmFsLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0LCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBtYXRjaC5yb3V0ZS5pZCwgbG9hZEZldGNoZXIpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcblxuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBbZXJyb3IsIGVycm9yQm91bmRhcnlJZF0gPSBmaW5kRXJyb3JBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIHN0YXRlLm1hdGNoZXMsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQpO1xuICAgIGxldCBbY2F0Y2hWYWwsIGNhdGNoQm91bmRhcnlJZF0gPSBhd2FpdCBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIHN0YXRlLm1hdGNoZXMsIG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQpO1xuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgbGV0IGFib3J0ZWRLZXlzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcblxuICAgIGlmIChhYm9ydGVkS2V5cykge1xuICAgICAgbWFya0ZldGNoZXJzRG9uZShhYm9ydGVkS2V5cyk7XG4gICAgfVxuXG4gICAgbGV0IHllZXRlZE5hdmlnYXRpb24gPSB5ZWV0U3RhbGVOYXZpZ2F0aW9uTG9hZChsb2FkSWQpOyAvLyBuZWVkIHRvIGRvIHdoYXQgd2Ugd291bGQgaGF2ZSBkb25lIHdoZW4gdGhlIG5hdmlnYXRpb24gbG9hZCBjb21wbGV0ZWRcblxuICAgIGlmICh5ZWV0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICBsZXQge1xuICAgICAgICB0cmFuc2l0aW9uXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBpbnZhcmlhbnQodHJhbnNpdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIsIFwiRXhwZWN0ZWQgbG9hZGluZyB0cmFuc2l0aW9uXCIpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgbG9jYXRpb246IHRyYW5zaXRpb24ubG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IHN0YXRlLm5leHRNYXRjaGVzLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICBjYXRjaDogY2F0Y2hWYWwsXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZCxcbiAgICAgICAgbG9hZGVyRGF0YTogbWFrZUxvYWRlckRhdGEoc3RhdGUsIHJlc3VsdHMsIG1hdGNoZXNUb0xvYWQpLFxuICAgICAgICBhY3Rpb25EYXRhOiB0cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIgPyBzdGF0ZS5hY3Rpb25EYXRhIDogdW5kZWZpbmVkLFxuICAgICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgdGhlIGluZm8gZm9yIHRoZSBkYXRhXG4gICAgZWxzZSB7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5SWQsXG4gICAgICAgIGxvYWRlckRhdGE6IG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzVG9Mb2FkKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24geWVldFN0YWxlTmF2aWdhdGlvbkxvYWQobGFuZGVkSWQpIHtcbiAgICBsZXQgaXNMb2FkaW5nTmF2aWdhdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiO1xuXG4gICAgaWYgKGlzTG9hZGluZ05hdmlnYXRpb24gJiYgbmF2aWdhdGlvbkxvYWRJZCA8IGxhbmRlZElkKSB7XG4gICAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgICAgZGF0YTogZmV0Y2hlci5kYXRhLFxuICAgICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQpIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuXG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID8geWVldGVkS2V5cyA6IGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyRmV0Y2hTdWJtaXNzaW9uKGhyZWYsIGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpIHtcbiAgICBsZXQgY3VycmVudEZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIHR5cGU6IFwibG9hZGVyU3VibWlzc2lvblwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGRhdGE6IChjdXJyZW50RmV0Y2hlciA9PT0gbnVsbCB8fCBjdXJyZW50RmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZldGNoZXIuZGF0YSkgfHwgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBjb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlcihtYXRjaCwgY3JlYXRlVXJsKGhyZWYpLCBjb250cm9sbGVyLnNpZ25hbCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcblxuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyRmV0Y2goaHJlZiwga2V5LCBtYXRjaCkge1xuICAgIGlmICh0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVMb2FkZXJGZXRjaCB3YXMgY2FsbGVkIGR1cmluZyB0aGUgc2VydmVyIHJlbmRlciwgYnV0IGl0IHNob3VsZG4ndCBiZS4gXCIgKyBcIllvdSBhcmUgbGlrZWx5IGNhbGxpbmcgdXNlRmV0Y2hlci5sb2FkKCkgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICsgXCJUcnkgbW92aW5nIGl0IHRvIGEgdXNlRWZmZWN0IG9yIGEgY2FsbGJhY2suXCIpO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBkYXRhOiAoY3VycmVudEZldGNoZXIgPT09IG51bGwgfHwgY3VycmVudEZldGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGZXRjaGVyLmRhdGEpIHx8IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgY29udHJvbGxlcik7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXIobWF0Y2gsIGNyZWF0ZVVybChocmVmKSwgY29udHJvbGxlci5zaWduYWwpO1xuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSByZXR1cm47XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImxvYWRlclwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1heWJlQmFpbE9uRXJyb3IobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBtYXliZUJhaWxPbkNhdGNoKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZG9uZUZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSB7XG4gICAgaWYgKGlzQ2F0Y2hSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGNhdGNoQm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShtYXRjaCwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBjYXRjaDoge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZS5kYXRhLFxuICAgICAgICAgIHN0YXR1czogcmVzdWx0LnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXN1bHQudmFsdWUuc3RhdHVzVGV4dFxuICAgICAgICB9LFxuICAgICAgICBjYXRjaEJvdW5kYXJ5SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpIHtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3JCb3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaCwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgICAgZXJyb3I6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZU5vdEZvdW5kTmF2aWdhdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pOyAvLyBGb3JjZSBhc3luYyBzbyBVSSBjb2RlIGRvZXNuJ3QgaGF2ZSB0byBzcGVjaWFsIG5vdCBmb3VuZCByb3V0ZSBjaGFuZ2VzIG5vdFxuICAgIC8vIHNraXBwaW5nIHRoZSBwZW5kaW5nIHN0YXRlIChsaWtlIHNjcm9sbCByZXN0b3JhdGlvbiBnZXRzIHJlYWxseVxuICAgIC8vIGNvbXBsaWNhdGVkIHdpdGhvdXQgdGhlIHBlbmRpbmcgc3RhdGUsIG1heWJlIHdlIGNhbiBmaWd1cmUgc29tZXRoaW5nIGVsc2VcbiAgICAvLyBvdXQgbGF0ZXIsIGJ1dCB0aGlzIHdvcmtzIGdyZWF0LilcblxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGxldCBjYXRjaEJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobWF0Y2hlc1swXSwgbWF0Y2hlcyk7XG4gICAgdXBkYXRlKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGNhdGNoOiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICB9LFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb25TdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25TdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gICAgaWYgKCFpc0luZGV4UmVxdWVzdEFjdGlvbihzdWJtaXNzaW9uLmFjdGlvbikgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmlkLmVuZHNXaXRoKFwiL2luZGV4XCIpKSB7XG4gICAgICBtYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgbGV0IGxlYWZNYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIGxlYWZNYXRjaCwgY29udHJvbGxlci5zaWduYWwpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJhY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZXN1bHQudmFsdWUubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0NhdGNoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBbY2F0Y2hWYWwsIGNhdGNoQm91bmRhcnlJZF0gPSBhd2FpdCBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKFtyZXN1bHRdLCBtYXRjaGVzLCByZXN1bHQpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgICAgICBjYXRjaDogY2F0Y2hWYWwsXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxvYWRUcmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWxvYWRcIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb246IGxvYWRUcmFuc2l0aW9uLFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbbGVhZk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LnZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsZWFmTWF0Y2gucm91dGUuaWQsIHJlc3VsdCk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZShsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pOyAvLyBGb3JjZSBhc3luYyBzbyBVSSBjb2RlIGRvZXNuJ3QgaGF2ZSB0byBzcGVjaWFsIGNhc2UgaGFzaCBjaGFuZ2VzIG5vdFxuICAgIC8vIHNraXBwaW5nIHRoZSBwZW5kaW5nIHN0YXRlIChsaWtlIHNjcm9sbCByZXN0b3JhdGlvbiBnZXRzIHJlYWxseVxuICAgIC8vIGNvbXBsaWNhdGVkIHdpdGhvdXQgdGhlIHBlbmRpbmcgc3RhdGUsIG1heWJlIHdlIGNhbiBmaWd1cmUgc29tZXRoaW5nIGVsc2VcbiAgICAvLyBvdXQgbGF0ZXIsIGJ1dCB0aGlzIHdvcmtzIGdyZWF0LilcblxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWQobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsTG9hZFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGludmFyaWFudChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwibG9hZGVyU3VibWlzc2lvblwiLCBgVW5leHBlY3RlZCB0cmFuc2l0aW9uOiAke0pTT04uc3RyaW5naWZ5KHN0YXRlLnRyYW5zaXRpb24pfWApO1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uXG4gICAgfSA9IHN0YXRlLnRyYW5zaXRpb247XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImZldGNoQWN0aW9uUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgaW52YXJpYW50KHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25TdWJtaXNzaW9uXCIgfHwgLy8gbG9hZGVyIHJlZGlyZWN0ZWQgZHVyaW5nIGFjdGlvbiByZWxvYWRcbiAgICBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIsIGBVbmV4cGVjdGVkIHRyYW5zaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoc3RhdGUudHJhbnNpdGlvbil9YCk7XG4gICAgbGV0IHtcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9ID0gc3RhdGUudHJhbnNpdGlvbjtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhyZWYoc3RhdGUubG9jYXRpb24pID09PSBjcmVhdGVIcmVmKGxvY2F0aW9uKSAmJiBzdGF0ZS5sb2NhdGlvbi5oYXNoICE9PSBsb2NhdGlvbi5oYXNoO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgYWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IG1heWJlQWN0aW9uRXJyb3JSZXN1bHQgPSBhY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpID8gYWN0aW9uUmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIGxldCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0ID0gYWN0aW9uUmVzdWx0ICYmIGlzQ2F0Y2hSZXN1bHQoYWN0aW9uUmVzdWx0KSA/IGFjdGlvblJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIG5hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxMb2FkZXJzKHN0YXRlLCBjcmVhdGVVcmwoY3JlYXRlSHJlZihsb2NhdGlvbikpLCBtYXRjaGVzLCBjb250cm9sbGVyLnNpZ25hbCwgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCwgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG5cbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIC8vIGxvYWRlciByZWRpcmVjdGVkIGR1cmluZyBhbiBhY3Rpb24gcmVsb2FkLCB0cmVhdCBpdCBsaWtlIGFuXG4gICAgICAvLyBhY3Rpb25SZWRpcmVjdCBpbnN0ZWFkIHNvIHRoYXQgYWxsIHRoZSBsb2FkZXJzIGdldCBjYWxsZWQgYWdhaW4gYW5kIHRoZVxuICAgICAgLy8gc3VibWlzc2lvbiBzdGlja3MgYXJvdW5kIGZvciBvcHRpbWlzdGljL3BlbmRpbmcgVUkuXG4gICAgICBpZiAoc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiKSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJhY3Rpb25cIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwibG9hZGVyU3VibWlzc2lvblwiKSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCJcbiAgICAgICAgfTtcbiAgICAgICAgaW5pdC5vblJlZGlyZWN0KHJlZGlyZWN0LmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IFtlcnJvciwgZXJyb3JCb3VuZGFyeUlkXSA9IGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IFtjYXRjaFZhbCwgY2F0Y2hCb3VuZGFyeUlkXSA9IGF3YWl0IGZpbmRDYXRjaEFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IGFib3J0ZWRJZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhuYXZpZ2F0aW9uTG9hZElkKTtcblxuICAgIGlmIChhYm9ydGVkSWRzKSB7XG4gICAgICBtYXJrRmV0Y2hlcnNEb25lKGFib3J0ZWRJZHMpO1xuICAgIH1cblxuICAgIHVwZGF0ZSh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9yQm91bmRhcnlJZCxcbiAgICAgIGNhdGNoOiBjYXRjaFZhbCxcbiAgICAgIGNhdGNoQm91bmRhcnlJZCxcbiAgICAgIGxvYWRlckRhdGE6IG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzKSxcbiAgICAgIGFjdGlvbkRhdGE6IHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiA/IHN0YXRlLmFjdGlvbkRhdGEgOiB1bmRlZmluZWQsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICBmZXRjaGVyczogYWJvcnRlZElkcyA/IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIDogc3RhdGUuZmV0Y2hlcnNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpIHtcbiAgICB2YXIgX3BlbmRpbmdOYXZpZ2F0aW9uQ29uO1xuXG4gICAgKF9wZW5kaW5nTmF2aWdhdGlvbkNvbiA9IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikgPT09IG51bGwgfHwgX3BlbmRpbmdOYXZpZ2F0aW9uQ29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ05hdmlnYXRpb25Db24uYWJvcnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIGBFeHBlY3RlZCBmZXRjaCBjb250cm9sbGVyOiAke2tleX1gKTtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBnZXRTdGF0ZSxcbiAgICBnZXRGZXRjaGVyLFxuICAgIGRlbGV0ZUZldGNoZXIsXG4gICAgZGlzcG9zZSxcblxuICAgIGdldCBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzKCkge1xuICAgICAgcmV0dXJuIGZldGNoQ29udHJvbGxlcnM7XG4gICAgfVxuXG4gIH07XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzSW5kZXhSZXF1ZXN0QWN0aW9uKGFjdGlvbikge1xuICBsZXQgaW5kZXhSZXF1ZXN0ID0gZmFsc2U7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGFjdGlvbi5zcGxpdChcIj9cIiwgMilbMV0gfHwgXCJcIik7XG5cbiAgZm9yIChsZXQgcGFyYW0gb2Ygc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpKSB7XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgaW5kZXhSZXF1ZXN0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXhSZXF1ZXN0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVycyhzdGF0ZSwgdXJsLCBtYXRjaGVzLCBzaWduYWwsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpIHtcbiAgbGV0IG1hdGNoZXNUb0xvYWQgPSBmaWx0ZXJNYXRjaGVzVG9Mb2FkKHN0YXRlLCB1cmwsIG1hdGNoZXMsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwobWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlcihtYXRjaCwgdXJsLCBzaWduYWwpKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXIobWF0Y2gsIHVybCwgc2lnbmFsKSB7XG4gIGludmFyaWFudChtYXRjaC5yb3V0ZS5sb2FkZXIsIGBFeHBlY3RlZCBsb2FkZXIgZm9yICR7bWF0Y2gucm91dGUuaWR9YCk7XG5cbiAgdHJ5IHtcbiAgICBsZXQge1xuICAgICAgcGFyYW1zXG4gICAgfSA9IG1hdGNoO1xuICAgIGxldCB2YWx1ZSA9IGF3YWl0IG1hdGNoLnJvdXRlLmxvYWRlcih7XG4gICAgICBwYXJhbXMsXG4gICAgICB1cmwsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWU6IGVycm9yXG4gICAgfTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIG1hdGNoLCBzaWduYWwpIHtcbiAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBkb2VzIG5vdCBoYXZlIGFuIGFjdGlvbiwgYnV0IHlvdSBhcmUgdHJ5aW5nIGAgKyBgdG8gc3VibWl0IHRvIGl0LiBUbyBmaXggdGhpcywgcGxlYXNlIGFkZCBhbiBcXGBhY3Rpb25cXGAgZnVuY3Rpb24gdG8gdGhlIHJvdXRlYCk7XG4gIH1cblxuICB0cnkge1xuICAgIGxldCB2YWx1ZSA9IGF3YWl0IG1hdGNoLnJvdXRlLmFjdGlvbih7XG4gICAgICB1cmw6IGNyZWF0ZVVybChzdWJtaXNzaW9uLmFjdGlvbiksXG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWU6IGVycm9yXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJNYXRjaGVzVG9Mb2FkKHN0YXRlLCB1cmwsIG1hdGNoZXMsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpIHtcbiAgLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IHRoZSBwcm9ibGVtYXRpYyByb3V0ZSBhcyB0aGV5IGFyZW4ndCBnb2luZ1xuICAvLyB0byByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW0uXG4gIGlmIChzdWJtaXNzaW9uUm91dGVJZCAmJiAoYWN0aW9uQ2F0Y2hSZXN1bHQgfHwgYWN0aW9uRXJyb3JSZXN1bHQpKSB7XG4gICAgbGV0IGZvdW5kUHJvYmxlbWF0aWNSb3V0ZSA9IGZhbHNlO1xuICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiB7XG4gICAgICBpZiAoZm91bmRQcm9ibGVtYXRpY1JvdXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkID09PSBzdWJtaXNzaW9uUm91dGVJZCkge1xuICAgICAgICBmb3VuZFByb2JsZW1hdGljUm91dGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IGlzTmV3ID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICBpZiAoIXN0YXRlLm1hdGNoZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTsgLy8gW2EsIGJdIC0+IFthLCBjXVxuXG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBzdGF0ZS5tYXRjaGVzW2luZGV4XS5yb3V0ZS5pZDtcbiAgfTtcblxuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX3N0YXRlJG1hdGNoZXMkaW5kZXgkO1xuXG4gICAgcmV0dXJuICgvLyBwYXJhbSBjaGFuZ2UsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgICAgc3RhdGUubWF0Y2hlc1tpbmRleF0ucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8ICgoX3N0YXRlJG1hdGNoZXMkaW5kZXgkID0gc3RhdGUubWF0Y2hlc1tpbmRleF0ucm91dGUucGF0aCkgPT09IG51bGwgfHwgX3N0YXRlJG1hdGNoZXMkaW5kZXgkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkbWF0Y2hlcyRpbmRleCQuZW5kc1dpdGgoXCIqXCIpKSAmJiBzdGF0ZS5tYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTtcblxuICBsZXQgZmlsdGVyQnlSb3V0ZVByb3BzID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghbWF0Y2gucm91dGUubG9hZGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKSB7XG4gICAgICBsZXQgcHJldlVybCA9IGNyZWF0ZVVybChjcmVhdGVIcmVmKHN0YXRlLmxvY2F0aW9uKSk7XG4gICAgICByZXR1cm4gbWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKHtcbiAgICAgICAgcHJldlVybCxcbiAgICAgICAgdXJsLFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgbGV0IGlzSW5Sb290Q2F0Y2hCb3VuZGFyeSA9IHN0YXRlLm1hdGNoZXMubGVuZ3RoID09PSAxO1xuXG4gIGlmIChpc0luUm9vdENhdGNoQm91bmRhcnkpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIobWF0Y2ggPT4gISFtYXRjaC5yb3V0ZS5sb2FkZXIpO1xuICB9XG5cbiAgaWYgKChmZXRjaGVyID09PSBudWxsIHx8IGZldGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoZXIudHlwZSkgPT09IFwiYWN0aW9uUmVsb2FkXCIpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoZmlsdGVyQnlSb3V0ZVByb3BzKTtcbiAgfSBlbHNlIGlmICggLy8gbXV0YXRpb24sIHJlbG9hZCBmb3IgZnJlc2ggZGF0YVxuICBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIgfHwgc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlZGlyZWN0XCIgfHwgLy8gY2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gIGNyZWF0ZUhyZWYodXJsKSA9PT0gY3JlYXRlSHJlZihzdGF0ZS5sb2NhdGlvbikgfHwgLy8gc2VhcmNoIGFmZmVjdHMgYWxsIGxvYWRlcnNcbiAgdXJsLnNlYXJjaFBhcmFtcy50b1N0cmluZygpICE9PSBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoZmlsdGVyQnlSb3V0ZVByb3BzKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4LCBhcnIpID0+IHtcbiAgICAvLyBkb24ndCBsb2FkIGVycm9yZWQgYWN0aW9uIHJvdXRlXG4gICAgaWYgKChhY3Rpb25FcnJvclJlc3VsdCB8fCBhY3Rpb25DYXRjaFJlc3VsdCkgJiYgYXJyLmxlbmd0aCAtIDEgPT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmxvYWRlciAmJiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIFRyYW5zaXRpb25SZWRpcmVjdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICByZXR1cm4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZENhdGNoQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBhY3Rpb25DYXRjaFJlc3VsdCkge1xuICBsZXQgbG9hZGVyQ2F0Y2hSZXN1bHQ7XG5cbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNDYXRjaFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsb2FkZXJDYXRjaFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGxldCBleHRyYWN0Q2F0Y2hEYXRhID0gYXN5bmMgcmVzID0+ICh7XG4gICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNUZXh0LFxuICAgIGRhdGE6IHJlcy5kYXRhXG4gIH0pOyAvLyBXZWlyZCBjYXNlIHdoZXJlIGFjdGlvbiB0aHJldywgYW5kIHRoZW4gYSBwYXJlbnQgbG9hZGVyIEFMU08gdGhyZXcsIHdlXG4gIC8vIHVzZSB0aGUgYWN0aW9uIGNhdGNoIGJ1dCB0aGUgbG9hZGVyJ3MgbmVhcmVzdCBib3VuZGFyeSAoY2F1c2Ugd2UgY2FuJ3RcbiAgLy8gcmVuZGVyIGRvd24gdG8gdGhlIGJvdW5kYXJ5IHRoZSBhY3Rpb24gd291bGQgcHJlZmVyKVxuXG5cbiAgaWYgKGFjdGlvbkNhdGNoUmVzdWx0ICYmIGxvYWRlckNhdGNoUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobG9hZGVyQ2F0Y2hSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYXdhaXQgZXh0cmFjdENhdGNoRGF0YShhY3Rpb25DYXRjaFJlc3VsdC52YWx1ZSksIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGxvYWRlckNhdGNoUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobG9hZGVyQ2F0Y2hSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYXdhaXQgZXh0cmFjdENhdGNoRGF0YShsb2FkZXJDYXRjaFJlc3VsdC52YWx1ZSksIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5cbmZ1bmN0aW9uIGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgYWN0aW9uRXJyb3JSZXN1bHQpIHtcbiAgbGV0IGxvYWRlckVycm9yUmVzdWx0O1xuXG4gIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbG9hZGVyRXJyb3JSZXN1bHQgPSByZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gV2VpcmQgY2FzZSB3aGVyZSBhY3Rpb24gZXJyb3JlZCwgYW5kIHRoZW4gYSBwYXJlbnQgbG9hZGVyIEFMU08gZXJyb3JlZCwgd2VcbiAgLy8gdXNlIHRoZSBhY3Rpb24gZXJyb3IgYnV0IHRoZSBsb2FkZXIncyBuZWFyZXN0IGJvdW5kYXJ5IChjYXVzZSB3ZSBjYW4ndFxuICAvLyByZW5kZXIgZG93biB0byB0aGUgYm91bmRhcnkgdGhlIGFjdGlvbiB3b3VsZCBwcmVmZXIpXG5cblxuICBpZiAoYWN0aW9uRXJyb3JSZXN1bHQgJiYgbG9hZGVyRXJyb3JSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobG9hZGVyRXJyb3JSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYWN0aW9uRXJyb3JSZXN1bHQudmFsdWUsIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGFjdGlvbkVycm9yUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGFjdGlvbkVycm9yUmVzdWx0Lm1hdGNoLCBtYXRjaGVzKTtcbiAgICByZXR1cm4gW2FjdGlvbkVycm9yUmVzdWx0LnZhbHVlLCBib3VuZGFyeUlkXTtcbiAgfVxuXG4gIGlmIChsb2FkZXJFcnJvclJlc3VsdCkge1xuICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShsb2FkZXJFcnJvclJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFtsb2FkZXJFcnJvclJlc3VsdC52YWx1ZSwgYm91bmRhcnlJZF07XG4gIH1cblxuICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cblxuZnVuY3Rpb24gZmluZE5lYXJlc3RDYXRjaEJvdW5kYXJ5KG1hdGNoV2l0aEVycm9yLCBtYXRjaGVzKSB7XG4gIGxldCBuZWFyZXN0Qm91bmRhcnlJZCA9IG51bGw7XG5cbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5DYXRjaEJvdW5kYXJ5KSB7XG4gICAgICBuZWFyZXN0Qm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH0gLy8gb25seSBzZWFyY2ggcGFyZW50cyAoc3RvcCBhdCB0aHJvd2luZyBtYXRjaClcblxuXG4gICAgaWYgKG1hdGNoID09PSBtYXRjaFdpdGhFcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXJlc3RCb3VuZGFyeUlkO1xufVxuXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoV2l0aEVycm9yLCBtYXRjaGVzKSB7XG4gIGxldCBuZWFyZXN0Qm91bmRhcnlJZCA9IG51bGw7XG5cbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgICBuZWFyZXN0Qm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH0gLy8gb25seSBzZWFyY2ggcGFyZW50cyAoc3RvcCBhdCB0aHJvd2luZyBtYXRjaClcblxuXG4gICAgaWYgKG1hdGNoID09PSBtYXRjaFdpdGhFcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXJlc3RCb3VuZGFyeUlkO1xufVxuXG5mdW5jdGlvbiBtYWtlTG9hZGVyRGF0YShzdGF0ZSwgcmVzdWx0cywgbWF0Y2hlcykge1xuICBsZXQgbmV3RGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IHtcbiAgICBtYXRjaCxcbiAgICB2YWx1ZVxuICB9IG9mIHJlc3VsdHMpIHtcbiAgICBuZXdEYXRhW21hdGNoLnJvdXRlLmlkXSA9IHZhbHVlO1xuICB9XG5cbiAgbGV0IGxvYWRlckRhdGEgPSB7fTtcblxuICBmb3IgKGxldCB7XG4gICAgcm91dGVcbiAgfSBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IHZhbHVlID0gbmV3RGF0YVtyb3V0ZS5pZF0gIT09IHVuZGVmaW5lZCA/IG5ld0RhdGFbcm91dGUuaWRdIDogc3RhdGUubG9hZGVyRGF0YVtyb3V0ZS5pZF07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9hZGVyRGF0YVtyb3V0ZS5pZF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9hZGVyRGF0YTtcbn1cblxuZnVuY3Rpb24gaXNDYXRjaFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIENhdGNoVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXJsKGhyZWYpIHtcbiAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG59XG5cbmV4cG9ydCB7IENhdGNoVmFsdWUsIElETEVfRkVUQ0hFUiwgSURMRV9UUkFOU0lUSU9OLCBUcmFuc2l0aW9uUmVkaXJlY3QsIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBtYXRjaFJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuZnVuY3Rpb24gbWF0Y2hDbGllbnRSb3V0ZXMocm91dGVzLCBsb2NhdGlvbikge1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24pO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxvY2F0aW9uIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyB1c2VCZWZvcmVVbmxvYWQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuXG5sZXQgU1RPUkFHRV9LRVkgPSBcInBvc2l0aW9uc1wiO1xubGV0IHBvc2l0aW9ucyA9IHt9O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSk7XG5cbiAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICBwb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNzY3JvbGxyZXN0b3JhdGlvblxuICovXG5cblxuZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKCk7IC8vIHdhaXQgZm9yIHRoZSBicm93c2VyIHRvIHJlc3RvcmUgaXQgb24gaXRzIG93blxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICB9LCBbXSk7IC8vIGxldCB0aGUgYnJvd3NlciByZXN0b3JlIG9uIGl0J3Mgb3duIGZvciByZWZyZXNoXG5cbiAgdXNlQmVmb3JlVW5sb2FkKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICB9LCBbXSkpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbiAgICAgICAgICBsZXQgU1RPUkFHRV9LRVkgPSAke0pTT04uc3RyaW5naWZ5KFNUT1JBR0VfS0VZKX07XG4gICAgICAgICAgaWYgKCF3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCAhd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5KSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKDIpIH0sIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSkgfHwgJ3t9JylcbiAgICAgICAgICAgIGxldCBzdG9yZWRZID0gcG9zaXRpb25zW3dpbmRvdy5oaXN0b3J5LnN0YXRlLmtleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzdG9yZWRZKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKVxuICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIH1cbiAgfSk7XG59XG5sZXQgaHlkcmF0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB0cmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbigpO1xuICBsZXQgd2FzU3VibWlzc2lvblJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24uc3VibWlzc2lvbikge1xuICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24ubG9jYXRpb24pIHtcbiAgICAgIHBvc2l0aW9uc1tsb2NhdGlvbi5rZXldID0gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuICB9LCBbdHJhbnNpdGlvbiwgbG9jYXRpb25dKTtcbiAgdXNlQmVmb3JlVW5sb2FkKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShwb3NpdGlvbnMpKTtcbiAgfSwgW10pKTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIG9uIGh5ZHJhdGlvbiwgdGhlIGNvbXBvbmVudCBhbHJlYWR5IGRpZCB0aGlzIHdpdGggYW5cbiAgICAgIC8vIGlubGluZSBzY3JpcHQuXG4gICAgICBpZiAoIWh5ZHJhdGVkKSB7XG4gICAgICAgIGh5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgeSA9IHBvc2l0aW9uc1tsb2NhdGlvbi5rZXldOyAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcblxuICAgICAgaWYgKHkpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcblxuXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKTtcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBkb24ndCBkbyBhbnl0aGluZyBvbiBzdWJtaXNzaW9uc1xuXG5cbiAgICAgIGlmICh3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPT09IHRydWUpIHtcbiAgICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuXG5cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb25dKTtcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24uc3VibWlzc2lvbikge1xuICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uXSk7XG59XG5cbmV4cG9ydCB7IFNjcm9sbFJlc3RvcmF0aW9uIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBBY3Rpb24sIGNyZWF0ZVBhdGggfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlbWl4RW50cnkgfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuXG4vKipcbiAqIFRoZSBlbnRyeSBwb2ludCBmb3IgYSBSZW1peCBhcHAgd2hlbiBpdCBpcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyIChpblxuICogYGFwcC9lbnRyeS5zZXJ2ZXIuanNgKS4gVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgSFRNTCBpbiB0aGVcbiAqIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gUmVtaXhTZXJ2ZXIoe1xuICBjb250ZXh0LFxuICB1cmxcbn0pIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybCk7XG4gIH1cblxuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgaGFzaDogXCJcIixcbiAgICBzdGF0ZTogbnVsbCxcbiAgICBrZXk6IFwiZGVmYXVsdFwiXG4gIH07XG4gIGxldCBzdGF0aWNOYXZpZ2F0b3IgPSB7XG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgfSxcblxuICAgIHB1c2godG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIHJlcGxhY2UodG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9LCB7IHJlcGxhY2U6IHRydWUgfSlcXGAgc29tZXdoZXJlIGAgKyBgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5nbygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG5cbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuYmFjaygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH0sXG5cbiAgICBmb3J3YXJkKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH0sXG5cbiAgICBibG9jaygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJsb2NrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfVxuXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5LCB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBhY3Rpb246IEFjdGlvbi5Qb3AsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIG5hdmlnYXRvcjogc3RhdGljTmF2aWdhdG9yLFxuICAgIHN0YXRpYzogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHsgUmVtaXhTZXJ2ZXIgfTtcbiIsICJpbXBvcnQgTlByb2dyZXNzIGZyb20gXCJucHJvZ3Jlc3NcIlxuaW1wb3J0IG5Qcm9ncmVzc1N0eWxlcyBmcm9tIFwibnByb2dyZXNzL25wcm9ncmVzcy5jc3NcIlxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQge1xuXHRMaW5rcyxcblx0TGl2ZVJlbG9hZCxcblx0TWV0YSxcblx0T3V0bGV0LFxuXHRTY3JpcHRzLFxuXHRTY3JvbGxSZXN0b3JhdGlvbixcblx0dXNlVHJhbnNpdGlvbixcbn0gZnJvbSBcInJlbWl4XCJcblxuZXhwb3J0IGNvbnN0IGxpbmtzID0gKCkgPT4ge1xuXHRyZXR1cm4gW1xuXHRcdHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogblByb2dyZXNzU3R5bGVzIH1cblx0XVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWV0YSgpIHtcblx0cmV0dXJuIHsgdGl0bGU6IFwiVW5pa2V5IC0gQlx1MDBFMG4gcGhcdTAwRURtIHRpXHUxRUJGbmcgVmlcdTFFQzd0XCIgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoKSB7XG5cdGNvbnN0IHRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uKClcblxuXHRSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuXHRcdC8vIHdoZW4gdGhlIHN0YXRlIGlzIGlkbGUgdGhlbiB3ZSBjYW4gdG8gY29tcGxldGUgdGhlIHByb2dyZXNzIGJhclxuXHRcdGlmICh0cmFuc2l0aW9uLnN0YXRlID09PSBcImlkbGVcIikgTlByb2dyZXNzLmRvbmUoKVxuXHRcdC8vIGFuZCB3aGVuIGl0J3Mgc29tZXRoaW5nIGVsc2UgaXQgbWVhbnMgaXQncyBlaXRoZXIgc3VibWl0dGluZyBhIGZvcm0gb3Jcblx0XHQvLyB3YWl0aW5nIGZvciB0aGUgbG9hZGVycyBvZiB0aGUgbmV4dCBsb2NhdGlvbiBzbyB3ZSBzdGFydCBpdFxuXHRcdGVsc2UgTlByb2dyZXNzLnN0YXJ0KClcblx0fSwgW3RyYW5zaXRpb24uc3RhdGVdKVxuXG5cdHJldHVybiAoXG5cdFx0PGh0bWwgbGFuZz1cImVuXCI+XG5cdFx0XHQ8aGVhZD5cblx0XHRcdFx0PG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz5cblx0XHRcdFx0PG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTFcIiAvPlxuXHRcdFx0XHQ8TWV0YSAvPlxuXHRcdFx0XHQ8TGlua3MgLz5cblx0XHRcdDwvaGVhZD5cblx0XHRcdDxib2R5PlxuXHRcdFx0XHQ8T3V0bGV0IC8+XG5cdFx0XHRcdDxTY3JvbGxSZXN0b3JhdGlvbiAvPlxuXHRcdFx0XHQ8U2NyaXB0cyAvPlxuXHRcdFx0XHQ8TGl2ZVJlbG9hZCAvPlxuXHRcdFx0PC9ib2R5PlxuXHRcdDwvaHRtbD5cblx0KVxufVxuIiwgImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbmRleCgpIHtcblx0cmV0dXJuIChcblx0XHQ8bmF2PlxuXHRcdFx0PHVsPlxuXHRcdFx0XHQ8bGk+PHN0cm9uZz5VbmlLZXk8L3N0cm9uZz48L2xpPlxuXHRcdFx0PC91bD5cblx0XHRcdDx1bD5cblx0XHRcdFx0PGxpPjxhIGhyZWY9XCIjXCI+TGluazwvYT48L2xpPlxuXHRcdFx0XHQ8bGk+PGEgaHJlZj1cIiNcIj5MaW5rPC9hPjwvbGk+XG5cdFx0XHRcdDxsaT48YSBocmVmPVwiI1wiPkxpbms8L2E+PC9saT5cblx0XHRcdDwvdWw+XG5cdFx0PC9uYXY+XG5cdClcbn1cbiIsICJleHBvcnQgZGVmYXVsdCB7J3ZlcnNpb24nOic4MGI0OGNhMycsJ2VudHJ5Jzp7J21vZHVsZSc6Jy9idWlsZC9lbnRyeS5jbGllbnQtSUdaMjVRSFEuanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLVpPWERCWlo1LmpzJywnL2J1aWxkL19zaGFyZWQvY2h1bmstRTdWTU9VWUwuanMnXX0sJ3JvdXRlcyc6eydyb290Jzp7J2lkJzoncm9vdCcsJ3BhcmVudElkJzp1bmRlZmluZWQsJ3BhdGgnOicnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb290LUFLVVJHSEJYLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvaW5kZXgnOnsnaWQnOidyb3V0ZXMvaW5kZXgnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzp1bmRlZmluZWQsJ2luZGV4Jzp0cnVlLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvaW5kZXgtT0hESUpLVkMuanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6ZmFsc2UsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX19LCd1cmwnOicvYnVpbGQvbWFuaWZlc3QtODBCNDhDQTMuanMnfTsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUVBLFFBQUksd0JBQXdCLE9BQU87QUFDbkMsUUFBSSxrQkFBaUIsT0FBTyxVQUFV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QkFBZ0I7QUFBQSxVQUNoQixZQUFZO0FBQUEsVUFDWixhQUFhO0FBQUEsVUFDYixTQUFTO0FBQUEsVUFDVCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUEsVUFDWCxjQUFjO0FBQUEsVUFDZCxNQUFNO0FBQUEsVUFDTixJQUFJO0FBQUEsVUFDSixXQUFXO0FBQUEsVUFDWCxXQUFXO0FBQUEsVUFDWCxXQUFXO0FBQUEsVUFDWCxJQUFJO0FBQUEsVUFDSixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixXQUFXO0FBQUEsVUFDWCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixhQUFhO0FBQUEsVUFDYixjQUFjO0FBQUEsVUFDZCxLQUFLO0FBQUEsVUFDTCxXQUFXO0FBQUEsVUFDWCxPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixRQUFRO0FBQUEsVUFDUixLQUFLO0FBQUEsVUFDTCxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxhQUFhO0FBQUEsVUFDYixhQUFhO0FBQUEsVUFDYixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixVQUFVO0FBQUEsVUFDVixnQkFBZ0I7QUFBQSxVQUNoQixLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixZQUFZO0FBQUEsVUFDWixLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxTQUFTO0FBQUEsVUFDVCxVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFFTixPQUFPO0FBQUEsVUFDUCxjQUFjO0FBQUEsVUFDZCxpQkFBaUI7QUFBQSxVQUNqQixZQUFZO0FBQUEsVUFDWixVQUFVO0FBQUEsVUFDVixtQkFBbUI7QUFBQSxVQUNuQixzQkFBc0I7QUFBQSxVQUN0QixjQUFjO0FBQUEsVUFDZCxZQUFZO0FBQUEsVUFDWixXQUFXO0FBQUEsVUFDWCxZQUFZO0FBQUEsVUFDWixlQUFlO0FBQUEsVUFDZixRQUFRO0FBQUEsVUFDUixlQUFlO0FBQUEsVUFDZixlQUFlO0FBQUEsVUFDZixhQUFhO0FBQUEsVUFDYixTQUFTO0FBQUEsVUFDVCxlQUFlO0FBQUEsVUFDZixlQUFlO0FBQUEsVUFDZixrQkFBa0I7QUFBQSxVQUNsQixhQUFhO0FBQUEsVUFDYixNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixJQUFJO0FBQUEsVUFDSixVQUFVO0FBQUEsVUFDVixXQUFXO0FBQUEsVUFD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
