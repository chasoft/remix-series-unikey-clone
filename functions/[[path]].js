var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    init_react();
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty2.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty2.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement7(type, config2, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            self2 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape2("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext3(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef3(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render.displayName == null) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare3) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare3 === void 0 ? null : compare3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type.displayName == null) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext4(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState4(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init2);
        }
        function useRef5(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback5(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement7.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            new Map([[frozenObject, null]]);
            new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext3;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef3;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback5;
        exports.useContext = useContext4;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect4;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect4;
        exports.useMemo = useMemo4;
        exports.useReducer = useReducer;
        exports.useRef = useRef5;
        exports.useState = useState4;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/@remix-run/dev/compiler/shims/react.ts
var React;
var init_react = __esm({
  "node_modules/@remix-run/dev/compiler/shims/react.ts"() {
    React = __toModule(require_react());
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    init_react();
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValue = parts.shift().split("=");
      var name = nameValue.shift();
      var value = nameValue.join("=");
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      try {
        value = options2.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parse(input, options2) {
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!input) {
        if (!options2.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options2.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!options2.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options2);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options2);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse;
    module.exports.parse = parse;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports, module) {
    init_react();
    "use strict";
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty2.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach2 = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase)
        return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString3 = object.toString;
    var isArray3 = Array.isArray;
    var isBuffer2 = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject2 = (value) => {
      return toString3.call(value) == "[object Object]";
    };
    var isString2 = (value) => {
      return typeof value == "string" || toString3.call(value) == "[object String]";
    };
    var isNumber2 = (value) => {
      return typeof value == "number" || toString3.call(value) == "[object Number]";
    };
    var isFunction2 = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString3.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString3.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc2 = (argument, options2) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options2.indentLevel;
        indent = options2.indent.repeat(options2.indentLevel);
      };
      const defaults2 = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json2 = options2 && options2.json;
      if (json2) {
        defaults2.quotes = "double";
        defaults2.wrap = true;
      }
      options2 = extend(defaults2, options2);
      if (options2.quotes != "single" && options2.quotes != "double" && options2.quotes != "backtick") {
        options2.quotes = "single";
      }
      const quote = options2.quotes == "double" ? '"' : options2.quotes == "backtick" ? "`" : "'";
      const compact = options2.compact;
      const lowercaseHex = options2.lowercaseHex;
      let indent = options2.indent.repeat(options2.indentLevel);
      let oldIndent = "";
      const inline1 = options2.__inline1__;
      const inline2 = options2.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options2.numbers == "binary";
      const useOctNumbers = options2.numbers == "octal";
      const useDecNumbers = options2.numbers == "decimal";
      const useHexNumbers = options2.numbers == "hexadecimal";
      if (json2 && argument && isFunction2(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString2(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options2.__inline1__ = true;
            options2.__inline2__ = false;
          }
          return "new Map(" + jsesc2(Array.from(argument), options2) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc2(Array.from(argument), options2) + ")";
        }
        if (isBuffer2(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc2(Array.from(argument), options2) + ")";
        }
        if (isArray3(argument)) {
          result = [];
          options2.wrap = true;
          if (inline1) {
            options2.__inline1__ = false;
            options2.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach2(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options2.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent) + jsesc2(value, options2));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json2) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json2) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options2.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent) + jsesc2(key, options2) + ":" + (compact ? "" : " ") + jsesc2(value, options2));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options2.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options2.minimal)
            return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options2.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json2 && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options2.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options2.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json2 || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options2.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--");
      }
      if (options2.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc2.version = "3.0.2";
    module.exports = jsesc2;
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    init_react();
    "use strict";
    EventHandlers.prototype = Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain3;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain3 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain3) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain3;
          er.domainThrown = false;
          domain3.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain3.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance, performanceNow, startTime, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_react();
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_react();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_react();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    init_react();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_react();
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry2 = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry2;
      else
        this.head = entry2;
      this.tail = entry2;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry2 = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry2;
      this.head = entry2;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_react();
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options2, stream) {
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.readableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options2.encoding) {
    this.decoder = new StringDecoder(options2.encoding);
    this.encoding = options2.encoding;
  }
}
function Readable(options2) {
  if (!(this instanceof Readable))
    return new Readable(options2);
  this._readableState = new ReadableState(options2, this);
  this.readable = true;
  if (options2 && typeof options2.read === "function")
    this._read = options2.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    init_react();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    "use strict";
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options2, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.writableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options2.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options2);
  this._writableState = new WritableState(options2, this);
  this.writable = true;
  if (options2) {
    if (typeof options2.write === "function")
      this._write = options2.write;
    if (typeof options2.writev === "function")
      this._writev = options2.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry2;
    var count = 0;
    while (entry2) {
      buffer[count] = entry2;
      entry2 = entry2.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry2) {
      var chunk = entry2.chunk;
      var encoding = entry2.encoding;
      var cb = entry2.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry2 = entry2.next;
      if (state.writing) {
        break;
      }
    }
    if (entry2 === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry2;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry2 = _this.entry;
    _this.entry = null;
    while (entry2) {
      var cb = entry2.callback;
      state.pendingcb--;
      cb(err);
      entry2 = entry2.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_react();
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options2) {
  if (!(this instanceof Duplex))
    return new Duplex(options2);
  Readable.call(this, options2);
  Writable.call(this, options2);
  if (options2 && options2.readable === false)
    this.readable = false;
  if (options2 && options2.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options2 && options2.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_react();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options2) {
  if (!(this instanceof Transform))
    return new Transform(options2);
  Duplex.call(this, options2);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_react();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform.call(this, options2);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_react();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_react();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options2) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options2 || options2.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_react();
    var polyfill = (init_stream(), stream_exports);
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React17 = require_react();
        var _assign = require_object_assign();
        var stream = require_stream();
        var ReactVersion = "17.0.2";
        function formatProdErrorMessage(code) {
          var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;
          for (var i2 = 1; i2 < arguments.length; i2++) {
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
          }
          return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var ReactSharedInternals = React17.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var enableSuspenseServerRenderer = false;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutInvalidateContextType = new Set();
        }
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function maskContext(type, context) {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        }
        function checkContextTypes(typeSpecs, values, location) {
          {
            checkPropTypes(typeSpecs, values, location, "Component");
          }
        }
        function validateContextBounds(context, threadID) {
          for (var i2 = context._threadCount | 0; i2 <= threadID; i2++) {
            context[i2] = context._currentValue2;
            context._threadCount = i2 + 1;
          }
        }
        function processContext(type, context, threadID, isClass) {
          if (isClass) {
            var contextType = type.contextType;
            {
              if ("contextType" in type) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
                  didWarnAboutInvalidateContextType.add(type);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              validateContextBounds(contextType, threadID);
              return contextType[threadID];
            }
            {
              var maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, maskedContext, "context");
                }
              }
              return maskedContext;
            }
          } else {
            {
              var _maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, _maskedContext, "context");
                }
              }
              return _maskedContext;
            }
          }
        }
        var nextAvailableThreadIDs = new Uint16Array(16);
        for (var i = 0; i < 15; i++) {
          nextAvailableThreadIDs[i] = i + 1;
        }
        nextAvailableThreadIDs[15] = 0;
        function growThreadCountAndReturnNextAvailable() {
          var oldArray = nextAvailableThreadIDs;
          var oldSize = oldArray.length;
          var newSize = oldSize * 2;
          if (!(newSize <= 65536)) {
            {
              throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
            }
          }
          var newArray = new Uint16Array(newSize);
          newArray.set(oldArray);
          nextAvailableThreadIDs = newArray;
          nextAvailableThreadIDs[0] = oldSize + 1;
          for (var _i = oldSize; _i < newSize - 1; _i++) {
            nextAvailableThreadIDs[_i] = _i + 1;
          }
          nextAvailableThreadIDs[newSize - 1] = 0;
          return oldSize;
        }
        function allocThreadID() {
          var nextID = nextAvailableThreadIDs[0];
          if (nextID === 0) {
            return growThreadCountAndReturnNextAvailable();
          }
          nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
          return nextID;
        }
        function freeThreadID(id) {
          nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
          nextAvailableThreadIDs[0] = id;
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape2;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape2 = "&quot;";
                break;
              case 38:
                escape2 = "&amp;";
                break;
              case 39:
                escape2 = "&#x27;";
                break;
              case 60:
                escape2 = "&lt;";
                break;
              case 62:
                escape2 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape2;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        function quoteAttributeValueForBrowser(value) {
          return '"' + escapeTextForBrowser(value) + '"';
        }
        function createMarkupForRoot() {
          return ROOT_ATTRIBUTE_NAME + '=""';
        }
        function createMarkupForProperty(name, value) {
          var propertyInfo = getPropertyInfo(name);
          if (name !== "style" && shouldIgnoreAttribute(name, propertyInfo, false)) {
            return "";
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
            return "";
          }
          if (propertyInfo !== null) {
            var attributeName = propertyInfo.attributeName;
            var type = propertyInfo.type;
            if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
              return attributeName + '=""';
            } else {
              if (propertyInfo.sanitizeURL) {
                value = "" + value;
                sanitizeURL(value);
              }
              return attributeName + "=" + quoteAttributeValueForBrowser(value);
            }
          } else if (isAttributeNameSafe(name)) {
            return name + "=" + quoteAttributeValueForBrowser(value);
          }
          return "";
        }
        function createMarkupForCustomAttribute(name, value) {
          if (!isAttributeNameSafe(name) || value == null) {
            return "";
          }
          return name + "=" + quoteAttributeValueForBrowser(value);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (!(currentlyRenderingComponent !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
            if (objectIs(nextDeps[i2], prevDeps[i2])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            {
              {
                throw Error("Rendered more hooks than during the previous render");
              }
            }
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          {
            isInHookUserCodeInDev = false;
          }
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext(context, observedBits) {
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return context[threadID];
        }
        function useContext4(context, observedBits) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          return context[threadID];
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState4(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(basicStateReducer, initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init2 !== void 0 ? init2(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo4(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef5(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect4(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
            {
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback5(callback, deps) {
          return useMemo4(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function useTransition2() {
          resolveCurrentlyRenderingComponent();
          var startTransition = function(callback) {
            callback();
          };
          return [startTransition, false];
        }
        function useOpaqueIdentifier() {
          return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
        }
        function noop2() {
        }
        var currentPartialRenderer = null;
        function setCurrentPartialRenderer(renderer) {
          currentPartialRenderer = renderer;
        }
        var Dispatcher = {
          readContext,
          useContext: useContext4,
          useMemo: useMemo4,
          useReducer,
          useRef: useRef5,
          useState: useState4,
          useLayoutEffect: useLayoutEffect4,
          useCallback: useCallback5,
          useImperativeHandle: noop2,
          useEffect: noop2,
          useDebugValue: noop2,
          useDeferredValue,
          useTransition: useTransition2,
          useOpaqueIdentifier,
          useMutableSource
        };
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var ariaProperties = {
          "aria-current": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var toArray = React17.Children.toArray;
        var currentDebugStacks = [];
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1;
        var prevGetCurrentStackImpl = null;
        var getCurrentServerStackImpl = function() {
          return "";
        };
        var describeStackFrame = function(element) {
          return "";
        };
        var validatePropertiesInDevelopment = function(type, props) {
        };
        var pushCurrentDebugStack = function(stack) {
        };
        var pushElementToDebugStack = function(element) {
        };
        var popCurrentDebugStack = function() {
        };
        var hasWarnedAboutUsingContextAsConsumer = false;
        {
          ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
          };
          describeStackFrame = function(element) {
            return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
          };
          pushCurrentDebugStack = function(stack) {
            currentDebugStacks.push(stack);
            if (currentDebugStacks.length === 1) {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
            }
          };
          pushElementToDebugStack = function(element) {
            var stack = currentDebugStacks[currentDebugStacks.length - 1];
            var frame = stack[stack.length - 1];
            frame.debugElementStack.push(element);
          };
          popCurrentDebugStack = function() {
            currentDebugStacks.pop();
            if (currentDebugStacks.length === 0) {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              prevGetCurrentStackImpl = null;
            }
          };
          getCurrentServerStackImpl = function() {
            if (currentDebugStacks.length === 0) {
              return "";
            }
            var frames = currentDebugStacks[currentDebugStacks.length - 1];
            var stack = "";
            for (var i2 = frames.length - 1; i2 >= 0; i2--) {
              var frame = frames[i2];
              var debugElementStack = frame.debugElementStack;
              for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
                stack += describeStackFrame(debugElementStack[ii]);
              }
            }
            return stack;
          };
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUndefinedDerivedState = {};
        var didWarnAboutUninitializedState = {};
        var valuePropNames = ["value", "defaultValue"];
        var newlineEatingTags = {
          listing: true,
          pre: true,
          textarea: true
        };
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        function validateDangerousTag(tag) {
          if (!validatedTagCache.hasOwnProperty(tag)) {
            if (!VALID_TAG_REGEX.test(tag)) {
              {
                throw Error("Invalid tag: " + tag);
              }
            }
            validatedTagCache[tag] = true;
          }
        }
        var styleNameCache = {};
        var processStyleName = function(styleName) {
          if (styleNameCache.hasOwnProperty(styleName)) {
            return styleNameCache[styleName];
          }
          var result = hyphenateStyleName(styleName);
          styleNameCache[styleName] = result;
          return result;
        };
        function createMarkupForStyles(styles) {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            var styleValue = styles[styleName];
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styleValue);
              }
            }
            if (styleValue != null) {
              serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentName(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function getNonChildrenInnerMarkup(props) {
          var innerHTML = props.dangerouslySetInnerHTML;
          if (innerHTML != null) {
            if (innerHTML.__html != null) {
              return innerHTML.__html;
            }
          } else {
            var content = props.children;
            if (typeof content === "string" || typeof content === "number") {
              return escapeTextForBrowser(content);
            }
          }
          return null;
        }
        function flattenTopLevelChildren(children) {
          if (!React17.isValidElement(children)) {
            return toArray(children);
          }
          var element = children;
          if (element.type !== REACT_FRAGMENT_TYPE) {
            return [element];
          }
          var fragmentChildren = element.props.children;
          if (!React17.isValidElement(fragmentChildren)) {
            return toArray(fragmentChildren);
          }
          var fragmentChildElement = fragmentChildren;
          return [fragmentChildElement];
        }
        function flattenOptionChildren(children) {
          if (children === void 0 || children === null) {
            return children;
          }
          var content = "";
          React17.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Only strings and numbers are supported as <option> children.");
              }
            }
          });
          return content;
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var STYLE = "style";
        var RESERVED_PROPS = {
          children: null,
          dangerouslySetInnerHTML: null,
          suppressContentEditableWarning: null,
          suppressHydrationWarning: null
        };
        function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
          var ret = "<" + tagVerbatim;
          var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
          for (var propKey in props) {
            if (!hasOwnProperty$2.call(props, propKey)) {
              continue;
            }
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            if (propKey === STYLE) {
              propValue = createMarkupForStyles(propValue);
            }
            var markup = null;
            if (isCustomComponent$1) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += " " + markup;
            }
          }
          if (makeStaticMarkup) {
            return ret;
          }
          if (isRootElement) {
            ret += " " + createMarkupForRoot();
          }
          return ret;
        }
        function validateRenderResult(child, type) {
          if (child === void 0) {
            {
              {
                throw Error((getComponentName(type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
              }
            }
          }
        }
        function resolve(child, context, threadID) {
          while (React17.isValidElement(child)) {
            var element = child;
            var Component = element.type;
            {
              pushElementToDebugStack(element);
            }
            if (typeof Component !== "function") {
              break;
            }
            processChild(element, Component);
          }
          function processChild(element2, Component2) {
            var isClass = shouldConstruct$1(Component2);
            var publicContext = processContext(Component2, context, threadID, isClass);
            var queue2 = [];
            var replace = false;
            var updater = {
              isMounted: function(publicInstance) {
                return false;
              },
              enqueueForceUpdate: function(publicInstance) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "forceUpdate");
                  return null;
                }
              },
              enqueueReplaceState: function(publicInstance, completeState) {
                replace = true;
                queue2 = [completeState];
              },
              enqueueSetState: function(publicInstance, currentPartialState) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "setState");
                  return null;
                }
                queue2.push(currentPartialState);
              }
            };
            var inst;
            if (isClass) {
              inst = new Component2(element2.props, publicContext, updater);
              if (typeof Component2.getDerivedStateFromProps === "function") {
                {
                  if (inst.state === null || inst.state === void 0) {
                    var componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUninitializedState[componentName]) {
                      error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName);
                      didWarnAboutUninitializedState[componentName] = true;
                    }
                  }
                }
                var partialState = Component2.getDerivedStateFromProps.call(null, element2.props, inst.state);
                {
                  if (partialState === void 0) {
                    var _componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                      error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName);
                      didWarnAboutUndefinedDerivedState[_componentName] = true;
                    }
                  }
                }
                if (partialState != null) {
                  inst.state = _assign({}, inst.state, partialState);
                }
              }
            } else {
              {
                if (Component2.prototype && typeof Component2.prototype.render === "function") {
                  var _componentName2 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutBadClass[_componentName2]) {
                    error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2);
                    didWarnAboutBadClass[_componentName2] = true;
                  }
                }
              }
              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              inst = Component2(element2.props, publicContext, updater);
              inst = finishHooks(Component2, element2.props, inst, publicContext);
              {
                if (inst != null && inst.render != null) {
                  var _componentName3 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutModulePatternComponent[_componentName3]) {
                    error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3);
                    didWarnAboutModulePatternComponent[_componentName3] = true;
                  }
                }
              }
              if (inst == null || inst.render == null) {
                child = inst;
                validateRenderResult(child, Component2);
                return;
              }
            }
            inst.props = element2.props;
            inst.context = publicContext;
            inst.updater = updater;
            var initialState = inst.state;
            if (initialState === void 0) {
              inst.state = initialState = null;
            }
            if (typeof inst.UNSAFE_componentWillMount === "function" || typeof inst.componentWillMount === "function") {
              if (typeof inst.componentWillMount === "function") {
                {
                  if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                    var _componentName4 = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                      warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", _componentName4);
                      didWarnAboutDeprecatedWillMount[_componentName4] = true;
                    }
                  }
                }
                if (typeof Component2.getDerivedStateFromProps !== "function") {
                  inst.componentWillMount();
                }
              }
              if (typeof inst.UNSAFE_componentWillMount === "function" && typeof Component2.getDerivedStateFromProps !== "function") {
                inst.UNSAFE_componentWillMount();
              }
              if (queue2.length) {
                var oldQueue = queue2;
                var oldReplace = replace;
                queue2 = null;
                replace = false;
                if (oldReplace && oldQueue.length === 1) {
                  inst.state = oldQueue[0];
                } else {
                  var nextState = oldReplace ? oldQueue[0] : inst.state;
                  var dontMutate = true;
                  for (var i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2];
                    var _partialState = typeof partial === "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                    if (_partialState != null) {
                      if (dontMutate) {
                        dontMutate = false;
                        nextState = _assign({}, nextState, _partialState);
                      } else {
                        _assign(nextState, _partialState);
                      }
                    }
                  }
                  inst.state = nextState;
                }
              } else {
                queue2 = null;
              }
            }
            child = inst.render();
            {
              if (child === void 0 && inst.render._isMockFunction) {
                child = null;
              }
            }
            validateRenderResult(child, Component2);
            var childContext;
            {
              if (typeof inst.getChildContext === "function") {
                var _childContextTypes = Component2.childContextTypes;
                if (typeof _childContextTypes === "object") {
                  childContext = inst.getChildContext();
                  for (var contextKey in childContext) {
                    if (!(contextKey in _childContextTypes)) {
                      {
                        throw Error((getComponentName(Component2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                      }
                    }
                  }
                } else {
                  {
                    error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component2) || "Unknown");
                  }
                }
              }
              if (childContext) {
                context = _assign({}, context, childContext);
              }
            }
          }
          return {
            child,
            context
          };
        }
        var ReactDOMServerRenderer = /* @__PURE__ */ function() {
          function ReactDOMServerRenderer2(children, makeStaticMarkup, options2) {
            var flatChildren = flattenTopLevelChildren(children);
            var topFrame = {
              type: null,
              domNamespace: Namespaces.html,
              children: flatChildren,
              childIndex: 0,
              context: emptyObject,
              footer: ""
            };
            {
              topFrame.debugElementStack = [];
            }
            this.threadID = allocThreadID();
            this.stack = [topFrame];
            this.exhausted = false;
            this.currentSelectValue = null;
            this.previousWasTextNode = false;
            this.makeStaticMarkup = makeStaticMarkup;
            this.suspenseDepth = 0;
            this.contextIndex = -1;
            this.contextStack = [];
            this.contextValueStack = [];
            this.uniqueID = 0;
            this.identifierPrefix = options2 && options2.identifierPrefix || "";
            {
              this.contextProviderStack = [];
            }
          }
          var _proto = ReactDOMServerRenderer2.prototype;
          _proto.destroy = function destroy() {
            if (!this.exhausted) {
              this.exhausted = true;
              this.clearProviders();
              freeThreadID(this.threadID);
            }
          };
          _proto.pushProvider = function pushProvider(provider) {
            var index = ++this.contextIndex;
            var context = provider.type._context;
            var threadID = this.threadID;
            validateContextBounds(context, threadID);
            var previousValue = context[threadID];
            this.contextStack[index] = context;
            this.contextValueStack[index] = previousValue;
            {
              this.contextProviderStack[index] = provider;
            }
            context[threadID] = provider.props.value;
          };
          _proto.popProvider = function popProvider(provider) {
            var index = this.contextIndex;
            {
              if (index < 0 || provider !== this.contextProviderStack[index]) {
                error("Unexpected pop.");
              }
            }
            var context = this.contextStack[index];
            var previousValue = this.contextValueStack[index];
            this.contextStack[index] = null;
            this.contextValueStack[index] = null;
            {
              this.contextProviderStack[index] = null;
            }
            this.contextIndex--;
            context[this.threadID] = previousValue;
          };
          _proto.clearProviders = function clearProviders() {
            for (var index = this.contextIndex; index >= 0; index--) {
              var context = this.contextStack[index];
              var previousValue = this.contextValueStack[index];
              context[this.threadID] = previousValue;
            }
          };
          _proto.read = function read2(bytes) {
            if (this.exhausted) {
              return null;
            }
            var prevPartialRenderer = currentPartialRenderer;
            setCurrentPartialRenderer(this);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            try {
              var out = [""];
              var suspended = false;
              while (out[0].length < bytes) {
                if (this.stack.length === 0) {
                  this.exhausted = true;
                  freeThreadID(this.threadID);
                  break;
                }
                var frame = this.stack[this.stack.length - 1];
                if (suspended || frame.childIndex >= frame.children.length) {
                  var footer = frame.footer;
                  if (footer !== "") {
                    this.previousWasTextNode = false;
                  }
                  this.stack.pop();
                  if (frame.type === "select") {
                    this.currentSelectValue = null;
                  } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                    var provider = frame.type;
                    this.popProvider(provider);
                  } else if (frame.type === REACT_SUSPENSE_TYPE) {
                    this.suspenseDepth--;
                    var buffered = out.pop();
                    if (suspended) {
                      suspended = false;
                      var fallbackFrame = frame.fallbackFrame;
                      if (!fallbackFrame) {
                        {
                          throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                        }
                      }
                      this.stack.push(fallbackFrame);
                      out[this.suspenseDepth] += "<!--$!-->";
                      continue;
                    } else {
                      out[this.suspenseDepth] += buffered;
                    }
                  }
                  out[this.suspenseDepth] += footer;
                  continue;
                }
                var child = frame.children[frame.childIndex++];
                var outBuffer = "";
                if (true) {
                  pushCurrentDebugStack(this.stack);
                  frame.debugElementStack.length = 0;
                }
                try {
                  outBuffer += this.render(child, frame.context, frame.domNamespace);
                } catch (err) {
                  if (err != null && typeof err.then === "function") {
                    if (enableSuspenseServerRenderer) {
                      if (!(this.suspenseDepth > 0)) {
                        {
                          throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                        }
                      }
                      suspended = true;
                    } else {
                      if (true) {
                        {
                          throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                        }
                      }
                    }
                  } else {
                    throw err;
                  }
                } finally {
                  if (true) {
                    popCurrentDebugStack();
                  }
                }
                if (out.length <= this.suspenseDepth) {
                  out.push("");
                }
                out[this.suspenseDepth] += outBuffer;
              }
              return out[0];
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
              setCurrentPartialRenderer(prevPartialRenderer);
              resetHooksState();
            }
          };
          _proto.render = function render(child, context, parentNamespace) {
            if (typeof child === "string" || typeof child === "number") {
              var text = "" + child;
              if (text === "") {
                return "";
              }
              if (this.makeStaticMarkup) {
                return escapeTextForBrowser(text);
              }
              if (this.previousWasTextNode) {
                return "<!-- -->" + escapeTextForBrowser(text);
              }
              this.previousWasTextNode = true;
              return escapeTextForBrowser(text);
            } else {
              var nextChild;
              var _resolve = resolve(child, context, this.threadID);
              nextChild = _resolve.child;
              context = _resolve.context;
              if (nextChild === null || nextChild === false) {
                return "";
              } else if (!React17.isValidElement(nextChild)) {
                if (nextChild != null && nextChild.$$typeof != null) {
                  var $$typeof = nextChild.$$typeof;
                  if (!($$typeof !== REACT_PORTAL_TYPE)) {
                    {
                      throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                    }
                  }
                  {
                    {
                      throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                    }
                  }
                }
                var nextChildren = toArray(nextChild);
                var frame = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                {
                  frame.debugElementStack = [];
                }
                this.stack.push(frame);
                return "";
              }
              var nextElement = nextChild;
              var elementType = nextElement.type;
              if (typeof elementType === "string") {
                return this.renderDOM(nextElement, context, parentNamespace);
              }
              switch (elementType) {
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_FRAGMENT_TYPE: {
                  var _nextChildren = toArray(nextChild.props.children);
                  var _frame = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  {
                    _frame.debugElementStack = [];
                  }
                  this.stack.push(_frame);
                  return "";
                }
                case REACT_SUSPENSE_TYPE: {
                  {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support Suspense.");
                      }
                    }
                  }
                }
                case REACT_SCOPE_TYPE: {
                  {
                    {
                      throw Error("ReactDOMServer does not yet support scope components.");
                    }
                  }
                }
              }
              if (typeof elementType === "object" && elementType !== null) {
                switch (elementType.$$typeof) {
                  case REACT_FORWARD_REF_TYPE: {
                    var element = nextChild;
                    var _nextChildren5;
                    var componentIdentity = {};
                    prepareToUseHooks(componentIdentity);
                    _nextChildren5 = elementType.render(element.props, element.ref);
                    _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                    _nextChildren5 = toArray(_nextChildren5);
                    var _frame5 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren5,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame5.debugElementStack = [];
                    }
                    this.stack.push(_frame5);
                    return "";
                  }
                  case REACT_MEMO_TYPE: {
                    var _element = nextChild;
                    var _nextChildren6 = [React17.createElement(elementType.type, _assign({
                      ref: _element.ref
                    }, _element.props))];
                    var _frame6 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren6,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame6.debugElementStack = [];
                    }
                    this.stack.push(_frame6);
                    return "";
                  }
                  case REACT_PROVIDER_TYPE: {
                    var provider = nextChild;
                    var nextProps = provider.props;
                    var _nextChildren7 = toArray(nextProps.children);
                    var _frame7 = {
                      type: provider,
                      domNamespace: parentNamespace,
                      children: _nextChildren7,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame7.debugElementStack = [];
                    }
                    this.pushProvider(provider);
                    this.stack.push(_frame7);
                    return "";
                  }
                  case REACT_CONTEXT_TYPE: {
                    var reactContext = nextChild.type;
                    {
                      if (reactContext._context === void 0) {
                        if (reactContext !== reactContext.Consumer) {
                          if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                          }
                        }
                      } else {
                        reactContext = reactContext._context;
                      }
                    }
                    var _nextProps = nextChild.props;
                    var threadID = this.threadID;
                    validateContextBounds(reactContext, threadID);
                    var nextValue = reactContext[threadID];
                    var _nextChildren8 = toArray(_nextProps.children(nextValue));
                    var _frame8 = {
                      type: nextChild,
                      domNamespace: parentNamespace,
                      children: _nextChildren8,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame8.debugElementStack = [];
                    }
                    this.stack.push(_frame8);
                    return "";
                  }
                  case REACT_FUNDAMENTAL_TYPE: {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support the fundamental API.");
                      }
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var _element2 = nextChild;
                    var lazyComponent = nextChild.type;
                    var payload = lazyComponent._payload;
                    var init2 = lazyComponent._init;
                    var result = init2(payload);
                    var _nextChildren10 = [React17.createElement(result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame10 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren10,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame10.debugElementStack = [];
                    }
                    this.stack.push(_frame10);
                    return "";
                  }
                }
              }
              var info = "";
              {
                var owner = nextElement._owner;
                if (elementType === void 0 || typeof elementType === "object" && elementType !== null && Object.keys(elementType).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentName(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              {
                {
                  throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                }
              }
            }
          };
          _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
            var tag = element.type.toLowerCase();
            var namespace = parentNamespace;
            if (parentNamespace === Namespaces.html) {
              namespace = getIntrinsicNamespace(tag);
            }
            {
              if (namespace === Namespaces.html) {
                if (tag !== element.type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type);
                }
              }
            }
            validateDangerousTag(tag);
            var props = element.props;
            if (tag === "input") {
              {
                checkControlledValueProps("input", props);
                if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                  error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultChecked = true;
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                  error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultInputValue = true;
                }
              }
              props = _assign({
                type: void 0
              }, props, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: props.value != null ? props.value : props.defaultValue,
                checked: props.checked != null ? props.checked : props.defaultChecked
              });
            } else if (tag === "textarea") {
              {
                checkControlledValueProps("textarea", props);
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                  error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultTextareaValue = true;
                }
              }
              var initialValue = props.value;
              if (initialValue == null) {
                var defaultValue = props.defaultValue;
                var textareaChildren = props.children;
                if (textareaChildren != null) {
                  {
                    error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                  }
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(textareaChildren)) {
                    if (!(textareaChildren.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    textareaChildren = textareaChildren[0];
                  }
                  defaultValue = "" + textareaChildren;
                }
                if (defaultValue == null) {
                  defaultValue = "";
                }
                initialValue = defaultValue;
              }
              props = _assign({}, props, {
                value: void 0,
                children: "" + initialValue
              });
            } else if (tag === "select") {
              {
                checkControlledValueProps("select", props);
                for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                  var propName = valuePropNames[i2];
                  if (props[propName] == null) {
                    continue;
                  }
                  var isArray3 = Array.isArray(props[propName]);
                  if (props.multiple && !isArray3) {
                    error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                  } else if (!props.multiple && isArray3) {
                    error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                  }
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                  error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultSelectValue = true;
                }
              }
              this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
              props = _assign({}, props, {
                value: void 0
              });
            } else if (tag === "option") {
              var selected = null;
              var selectValue = this.currentSelectValue;
              var optionChildren = flattenOptionChildren(props.children);
              if (selectValue != null) {
                var value;
                if (props.value != null) {
                  value = props.value + "";
                } else {
                  value = optionChildren;
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                  for (var j = 0; j < selectValue.length; j++) {
                    if ("" + selectValue[j] === value) {
                      selected = true;
                      break;
                    }
                  }
                } else {
                  selected = "" + selectValue === value;
                }
                props = _assign({
                  selected: void 0,
                  children: void 0
                }, props, {
                  selected,
                  children: optionChildren
                });
              }
            }
            {
              validatePropertiesInDevelopment(tag, props);
            }
            assertValidProps(tag, props);
            var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
            var footer = "";
            if (omittedCloseTags.hasOwnProperty(tag)) {
              out += "/>";
            } else {
              out += ">";
              footer = "</" + element.type + ">";
            }
            var children;
            var innerMarkup = getNonChildrenInnerMarkup(props);
            if (innerMarkup != null) {
              children = [];
              if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === "\n") {
                out += "\n";
              }
              out += innerMarkup;
            } else {
              children = toArray(props.children);
            }
            var frame = {
              domNamespace: getChildNamespace(parentNamespace, element.type),
              type: tag,
              children,
              childIndex: 0,
              context,
              footer
            };
            {
              frame.debugElementStack = [];
            }
            this.stack.push(frame);
            this.previousWasTextNode = false;
            return out;
          };
          return ReactDOMServerRenderer2;
        }();
        function renderToString2(element, options2) {
          var renderer = new ReactDOMServerRenderer(element, false, options2);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToStaticMarkup(element, options2) {
          var renderer = new ReactDOMServerRenderer(element, true, options2);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
          _inheritsLoose(ReactMarkupReadableStream2, _Readable);
          function ReactMarkupReadableStream2(element, makeStaticMarkup, options2) {
            var _this;
            _this = _Readable.call(this, {}) || this;
            _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup, options2);
            return _this;
          }
          var _proto = ReactMarkupReadableStream2.prototype;
          _proto._destroy = function _destroy(err, callback) {
            this.partialRenderer.destroy();
            callback(err);
          };
          _proto._read = function _read(size) {
            try {
              this.push(this.partialRenderer.read(size));
            } catch (err) {
              this.destroy(err);
            }
          };
          return ReactMarkupReadableStream2;
        }(stream.Readable);
        function renderToNodeStream(element, options2) {
          return new ReactMarkupReadableStream(element, false, options2);
        }
        function renderToStaticNodeStream(element, options2) {
          return new ReactMarkupReadableStream(element, true, options2);
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString2;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_dom_server_node_development();
    }
  }
});

// node_modules/react-dom/server.js
var require_server = __commonJS({
  "node_modules/react-dom/server.js"(exports, module) {
    init_react();
    "use strict";
    module.exports = require_server_node();
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment3 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment3;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    init_react();
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    init_react();
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    init_react();
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    init_react();
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry2 = step.value;
                  if (entry2) {
                    if (!isNode(entry2[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    init_react();
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/nprogress/nprogress.js
var require_nprogress = __commonJS({
  "node_modules/nprogress/nprogress.js"(exports, module) {
    init_react();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.NProgress = factory();
      }
    })(exports, function() {
      var NProgress2 = {};
      NProgress2.version = "0.2.0";
      var Settings = NProgress2.settings = {
        minimum: 0.08,
        easing: "ease",
        positionUsing: "",
        speed: 200,
        trickle: true,
        trickleRate: 0.02,
        trickleSpeed: 800,
        showSpinner: true,
        barSelector: '[role="bar"]',
        spinnerSelector: '[role="spinner"]',
        parent: "body",
        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
      };
      NProgress2.configure = function(options2) {
        var key, value;
        for (key in options2) {
          value = options2[key];
          if (value !== void 0 && options2.hasOwnProperty(key))
            Settings[key] = value;
        }
        return this;
      };
      NProgress2.status = null;
      NProgress2.set = function(n) {
        var started = NProgress2.isStarted();
        n = clamp(n, Settings.minimum, 1);
        NProgress2.status = n === 1 ? null : n;
        var progress = NProgress2.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
        progress.offsetWidth;
        queue2(function(next) {
          if (Settings.positionUsing === "")
            Settings.positionUsing = NProgress2.getPositioningCSS();
          css(bar, barPositionCSS(n, speed, ease));
          if (n === 1) {
            css(progress, {
              transition: "none",
              opacity: 1
            });
            progress.offsetWidth;
            setTimeout(function() {
              css(progress, {
                transition: "all " + speed + "ms linear",
                opacity: 0
              });
              setTimeout(function() {
                NProgress2.remove();
                next();
              }, speed);
            }, speed);
          } else {
            setTimeout(next, speed);
          }
        });
        return this;
      };
      NProgress2.isStarted = function() {
        return typeof NProgress2.status === "number";
      };
      NProgress2.start = function() {
        if (!NProgress2.status)
          NProgress2.set(0);
        var work = function() {
          setTimeout(function() {
            if (!NProgress2.status)
              return;
            NProgress2.trickle();
            work();
          }, Settings.trickleSpeed);
        };
        if (Settings.trickle)
          work();
        return this;
      };
      NProgress2.done = function(force) {
        if (!force && !NProgress2.status)
          return this;
        return NProgress2.inc(0.3 + 0.5 * Math.random()).set(1);
      };
      NProgress2.inc = function(amount) {
        var n = NProgress2.status;
        if (!n) {
          return NProgress2.start();
        } else {
          if (typeof amount !== "number") {
            amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
          }
          n = clamp(n + amount, 0, 0.994);
          return NProgress2.set(n);
        }
      };
      NProgress2.trickle = function() {
        return NProgress2.inc(Math.random() * Settings.trickleRate);
      };
      (function() {
        var initial = 0, current = 0;
        NProgress2.promise = function($promise) {
          if (!$promise || $promise.state() === "resolved") {
            return this;
          }
          if (current === 0) {
            NProgress2.start();
          }
          initial++;
          current++;
          $promise.always(function() {
            current--;
            if (current === 0) {
              initial = 0;
              NProgress2.done();
            } else {
              NProgress2.set((initial - current) / initial);
            }
          });
          return this;
        };
      })();
      NProgress2.render = function(fromStart) {
        if (NProgress2.isRendered())
          return document.getElementById("nprogress");
        addClass(document.documentElement, "nprogress-busy");
        var progress = document.createElement("div");
        progress.id = "nprogress";
        progress.innerHTML = Settings.template;
        var bar = progress.querySelector(Settings.barSelector), perc = fromStart ? "-100" : toBarPerc(NProgress2.status || 0), parent = document.querySelector(Settings.parent), spinner;
        css(bar, {
          transition: "all 0 linear",
          transform: "translate3d(" + perc + "%,0,0)"
        });
        if (!Settings.showSpinner) {
          spinner = progress.querySelector(Settings.spinnerSelector);
          spinner && removeElement(spinner);
        }
        if (parent != document.body) {
          addClass(parent, "nprogress-custom-parent");
        }
        parent.appendChild(progress);
        return progress;
      };
      NProgress2.remove = function() {
        removeClass(document.documentElement, "nprogress-busy");
        removeClass(document.querySelector(Settings.parent), "nprogress-custom-parent");
        var progress = document.getElementById("nprogress");
        progress && removeElement(progress);
      };
      NProgress2.isRendered = function() {
        return !!document.getElementById("nprogress");
      };
      NProgress2.getPositioningCSS = function() {
        var bodyStyle = document.body.style;
        var vendorPrefix = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
        if (vendorPrefix + "Perspective" in bodyStyle) {
          return "translate3d";
        } else if (vendorPrefix + "Transform" in bodyStyle) {
          return "translate";
        } else {
          return "margin";
        }
      };
      function clamp(n, min, max) {
        if (n < min)
          return min;
        if (n > max)
          return max;
        return n;
      }
      function toBarPerc(n) {
        return (-1 + n) * 100;
      }
      function barPositionCSS(n, speed, ease) {
        var barCSS;
        if (Settings.positionUsing === "translate3d") {
          barCSS = { transform: "translate3d(" + toBarPerc(n) + "%,0,0)" };
        } else if (Settings.positionUsing === "translate") {
          barCSS = { transform: "translate(" + toBarPerc(n) + "%,0)" };
        } else {
          barCSS = { "margin-left": toBarPerc(n) + "%" };
        }
        barCSS.transition = "all " + speed + "ms " + ease;
        return barCSS;
      }
      var queue2 = function() {
        var pending = [];
        function next() {
          var fn = pending.shift();
          if (fn) {
            fn(next);
          }
        }
        return function(fn) {
          pending.push(fn);
          if (pending.length == 1)
            next();
        };
      }();
      var css = function() {
        var cssPrefixes = ["Webkit", "O", "Moz", "ms"], cssProps = {};
        function camelCase(string) {
          return string.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match, letter) {
            return letter.toUpperCase();
          });
        }
        function getVendorProp(name) {
          var style = document.body.style;
          if (name in style)
            return name;
          var i = cssPrefixes.length, capName = name.charAt(0).toUpperCase() + name.slice(1), vendorName;
          while (i--) {
            vendorName = cssPrefixes[i] + capName;
            if (vendorName in style)
              return vendorName;
          }
          return name;
        }
        function getStyleProp(name) {
          name = camelCase(name);
          return cssProps[name] || (cssProps[name] = getVendorProp(name));
        }
        function applyCss(element, prop, value) {
          prop = getStyleProp(prop);
          element.style[prop] = value;
        }
        return function(element, properties) {
          var args = arguments, prop, value;
          if (args.length == 2) {
            for (prop in properties) {
              value = properties[prop];
              if (value !== void 0 && properties.hasOwnProperty(prop))
                applyCss(element, prop, value);
            }
          } else {
            applyCss(element, args[1], args[2]);
          }
        };
      }();
      function hasClass(element, name) {
        var list = typeof element == "string" ? element : classList(element);
        return list.indexOf(" " + name + " ") >= 0;
      }
      function addClass(element, name) {
        var oldList = classList(element), newList = oldList + name;
        if (hasClass(oldList, name))
          return;
        element.className = newList.substring(1);
      }
      function removeClass(element, name) {
        var oldList = classList(element), newList;
        if (!hasClass(element, name))
          return;
        newList = oldList.replace(" " + name + " ", " ");
        element.className = newList.substring(1, newList.length - 1);
      }
      function classList(element) {
        return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
      }
      function removeElement(element) {
        element && element.parentNode && element.parentNode.removeChild(element);
      }
      return NProgress2;
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js"(exports, module) {
    init_react();
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject2(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module.exports.isNothing = isNothing;
    module.exports.isObject = isObject2;
    module.exports.toArray = toArray;
    module.exports.repeat = repeat;
    module.exports.isNegativeZero = isNegativeZero;
    module.exports.extend = extend;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js"(exports, module) {
    init_react();
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString3(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module.exports = YAMLException;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString3(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module.exports = Mark;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js"(exports, module) {
    init_react();
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options2) {
      options2 = options2 || {};
      Object.keys(options2).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options2["kind"] || null;
      this.resolve = options2["resolve"] || function() {
        return true;
      };
      this.construct = options2["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options2["instanceOf"] || null;
      this.predicate = options2["predicate"] || null;
      this.represent = options2["represent"] || null;
      this.defaultStyle = options2["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module.exports = Type;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types = common.toArray(types);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types
      });
    };
    module.exports = Schema;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    module.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull2(object) {
      return object === null;
    }
    module.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull2,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean2(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean2,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign2 = 1, ch, base, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign2 = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign2 * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign2 * parseInt(value, 16);
        return sign2 * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign2 * value;
      }
      return sign2 * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign2, base, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign2 = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign2 * value;
      }
      return sign2 * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      include: [
        require_json()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports, module) {
    init_react();
    "use strict";
    var NodeBuffer;
    try {
      _require = __require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys2, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys2 = Object.keys(pair);
        if (keys2.length !== 1)
          return false;
        result[index] = [keys2[0], pair[keys2[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys2, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys2 = Object.keys(pair);
        result[index] = [keys2[0], pair[keys2[0]]];
      }
      return result;
    }
    module.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = new Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined2(object) {
      return typeof object === "undefined";
    }
    module.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined2,
      represent: representJavascriptUndefined
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports, module) {
    init_react();
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null)
        return false;
      if (data.length === 0)
        return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp2(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp2,
      represent: representJavascriptRegExp
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports, module) {
    init_react();
    "use strict";
    var esprima;
    try {
      _require = __require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    var Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction2(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction2,
      represent: representJavascriptFunction
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports, module) {
    init_react();
    "use strict";
    var Schema = require_schema();
    module.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options2) {
      this.input = input;
      this.filename = options2["filename"] || null;
      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options2["onWarning"] || null;
      this.legacy = options2["legacy"] || false;
      this.json = options2["json"] || false;
      this.listener = options2["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle9, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle9 = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle9)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle9)) {
          throwError(state, 'there is a previously declared suffix for "' + handle9 + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle9] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options2) {
      input = String(input);
      options2 = options2 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options2);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options2) {
      if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options2);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options2) {
      var documents = loadDocuments(input, options2);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, iterator, options2) {
      if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    function safeLoad(input, options2) {
      return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    module.exports.loadAll = loadAll;
    module.exports.load = load;
    module.exports.safeLoadAll = safeLoadAll;
    module.exports.safeLoad = safeLoad;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports, module) {
    init_react();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys2, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys2 = Object.keys(map);
      for (index = 0, length = keys2.length; index < length; index += 1) {
        tag = keys2[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle9, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle9 = "x";
        length = 2;
      } else if (character <= 65535) {
        handle9 = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle9 = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle9 + common.repeat("0", length - string.length) + string;
    }
    function State(options2) {
      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options2["indent"] || 2);
      this.noArrayIndent = options2["noArrayIndent"] || false;
      this.skipInvalid = options2["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
      this.sortKeys = options2["sortKeys"] || false;
      this.lineWidth = options2["lineWidth"] || 80;
      this.noRefs = options2["noRefs"] || false;
      this.noCompatMode = options2["noCompatMode"] || false;
      this.condenseFlow = options2["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (index !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block2, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block2) {
        block2 = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block2 && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block2 && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options2) {
      options2 = options2 || {};
      var state = new State(options2);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options2) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    }
    module.exports.dump = dump;
    module.exports.safeDump = safeDump;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js"(exports, module) {
    init_react();
    "use strict";
    var loader8 = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module.exports.Type = require_type();
    module.exports.Schema = require_schema();
    module.exports.FAILSAFE_SCHEMA = require_failsafe();
    module.exports.JSON_SCHEMA = require_json();
    module.exports.CORE_SCHEMA = require_core();
    module.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module.exports.load = loader8.load;
    module.exports.loadAll = loader8.loadAll;
    module.exports.safeLoad = loader8.safeLoad;
    module.exports.safeLoadAll = loader8.safeLoadAll;
    module.exports.dump = dumper.dump;
    module.exports.safeDump = dumper.safeDump;
    module.exports.YAMLException = require_exception();
    module.exports.MINIMAL_SCHEMA = require_failsafe();
    module.exports.SAFE_SCHEMA = require_default_safe();
    module.exports.DEFAULT_SCHEMA = require_default_full();
    module.exports.scan = deprecated("scan");
    module.exports.parse = deprecated("parse");
    module.exports.compose = deprecated("compose");
    module.exports.addConstructor = deprecated("addConstructor");
  }
});

// node_modules/front-matter/node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/index.js"(exports, module) {
    init_react();
    "use strict";
    var yaml = require_js_yaml();
    module.exports = yaml;
  }
});

// node_modules/front-matter/index.js
var require_front_matter = __commonJS({
  "node_modules/front-matter/index.js"(exports, module) {
    init_react();
    var parser2 = require_js_yaml2();
    var optionalByteOrderMark = "\\ufeff?";
    var platform2 = typeof process !== "undefined" ? process.platform : "";
    var pattern = "^(" + optionalByteOrderMark + "(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$" + (platform2 === "win32" ? "\\r?" : "") + "(?:\\n)?)";
    var regex = new RegExp(pattern, "m");
    module.exports = extractor;
    module.exports.test = test;
    function extractor(string, options2) {
      string = string || "";
      var defaultOptions = { allowUnsafe: false };
      options2 = options2 instanceof Object ? __spreadValues(__spreadValues({}, defaultOptions), options2) : defaultOptions;
      options2.allowUnsafe = Boolean(options2.allowUnsafe);
      var lines = string.split(/(\r?\n)/);
      if (lines[0] && /= yaml =|---/.test(lines[0])) {
        return parse(string, options2.allowUnsafe);
      } else {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
    }
    function computeLocation(match, body) {
      var line = 1;
      var pos = body.indexOf("\n");
      var offset = match.index + match[0].length;
      while (pos !== -1) {
        if (pos >= offset) {
          return line;
        }
        line++;
        pos = body.indexOf("\n", pos + 1);
      }
      return line;
    }
    function parse(string, allowUnsafe) {
      var match = regex.exec(string);
      if (!match) {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
      var loader8 = allowUnsafe ? parser2.load : parser2.safeLoad;
      var yaml = match[match.length - 1].replace(/^\s+|\s+$/g, "");
      var attributes = loader8(yaml) || {};
      var body = string.replace(match[0], "");
      var line = computeLocation(match, string);
      return {
        attributes,
        body,
        bodyBegin: line,
        frontmatter: yaml
      };
    }
    function test(string) {
      string = string || "";
      return regex.test(string);
    }
  }
});

// server.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/index.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/cookieSigning.js
init_react();
var encoder = new TextEncoder();
async function sign(value, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["sign"]);
  let data = encoder.encode(value);
  let signature = await crypto.subtle.sign("HMAC", key, data);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
  return value + "." + hash;
}
async function unsign(cookie, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["verify"]);
  let value = cookie.slice(0, cookie.lastIndexOf("."));
  let hash = cookie.slice(cookie.lastIndexOf(".") + 1);
  let data = encoder.encode(value);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data);
  return valid ? value : false;
}
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
function installGlobals() {
  self.sign = sign;
  self.unsign = unsign;
}

// node_modules/@remix-run/cloudflare-pages/esm/sessions/cloudflareKVSessionStorage.js
init_react();

// node_modules/@remix-run/server-runtime/esm/index.js
init_react();

// node_modules/@remix-run/server-runtime/esm/responses.js
init_react();
function json(data, init2 = {}) {
  let responseInit = init2;
  if (typeof init2 === "number") {
    responseInit = {
      status: init2
    };
  }
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), __spreadProps(__spreadValues({}, responseInit), {
    headers
  }));
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
var redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response) {
  return redirectStatusCodes.has(response.status);
}
function isCatchResponse(response) {
  return response.headers.get("X-Remix-Catch") != null;
}

// node_modules/@remix-run/server-runtime/esm/server.js
init_react();

// node_modules/@remix-run/server-runtime/esm/data.js
init_react();
async function callRouteAction({
  loadContext,
  match,
  request
}) {
  let action = match.route.module.action;
  if (!action) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide an \`action\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await action({
      request: stripDataParam(stripIndexParam(request)),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
async function callRouteLoader({
  loadContext,
  match,
  request
}) {
  let loader8 = match.route.module.loader;
  if (!loader8) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await loader8({
      request: stripDataParam(stripIndexParam(request.clone())),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
function stripIndexParam(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_data");
  return new Request(url.href, request);
}
function extractData(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}

// node_modules/@remix-run/server-runtime/esm/entry.js
init_react();
function createEntryMatches(matches, routes2) {
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: routes2[match.route.id]
  }));
}
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo, routeId) => {
    memo[routeId] = manifest[routeId].module;
    return memo;
  }, {});
}

// node_modules/@remix-run/server-runtime/esm/errors.js
init_react();
async function serializeError(error) {
  return {
    message: error.message,
    stack: error.stack
  };
}

// node_modules/@remix-run/server-runtime/esm/headers.js
init_react();
var import_set_cookie_parser = __toModule(require_set_cookie());
function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
  return matches.reduce((parentHeaders, match, index) => {
    let routeModule = build.routes[match.route.id].module;
    let routeLoaderResponse = routeLoaderResponses[match.route.id];
    let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();
    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);
    cookies.forEach((cookie) => {
      childHeaders.append("Set-Cookie", cookie);
    });
  }
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
init_react();

// node_modules/react-router-dom/index.js
init_react();
var import_react2 = __toModule(require_react());

// node_modules/history/index.js
init_react();

// node_modules/@babel/runtime/helpers/esm/extends.js
init_react();

// node_modules/history/index.js
var r;
var B = r || (r = {});
B.Pop = "POP";
B.Push = "PUSH";
B.Replace = "REPLACE";
function I(b) {
  var h = b.pathname;
  h = h === void 0 ? "/" : h;
  var e = b.search;
  e = e === void 0 ? "" : e;
  b = b.hash;
  b = b === void 0 ? "" : b;
  e && e !== "?" && (h += e.charAt(0) === "?" ? e : "?" + e);
  b && b !== "#" && (h += b.charAt(0) === "#" ? b : "#" + b);
  return h;
}
function J(b) {
  var h = {};
  if (b) {
    var e = b.indexOf("#");
    0 <= e && (h.hash = b.substr(e), b = b.substr(0, e));
    e = b.indexOf("?");
    0 <= e && (h.search = b.substr(e), b = b.substr(0, e));
    b && (h.pathname = b);
  }
  return h;
}

// node_modules/react-router/index.js
init_react();
var import_react = __toModule(require_react());
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning(false, message) : void 0;
  }
}
var NavigationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = /* @__PURE__ */ (0, import_react.createContext)({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = r.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0, import_react.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = J(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = (0, import_react.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  true ? warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ (0, import_react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react.createElement)(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
function useHref(to) {
  !useInRouterContext() ? true ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0, import_react.useContext)(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  return (0, import_react.useContext)(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0, import_react.useCallback)(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options2.replace ? navigator.replace : navigator.push)(path, options2.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = /* @__PURE__ */ (0, import_react.createContext)(null);
function useOutlet(context) {
  let outlet = (0, import_react.useContext)(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ (0, import_react.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to) {
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0, import_react.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes2, locationArg) {
  !useInRouterContext() ? true ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    matches: parentMatches
  } = (0, import_react.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? J(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : void 0;
    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function matchRoutes(routes2, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? J(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes2.forEach((route, index) => {
    let meta2 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta2.relativePath.startsWith("/")) {
      !meta2.relativePath.startsWith(parentPath) ? true ? invariant(false, 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : invariant(false) : void 0;
      meta2.relativePath = meta2.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta2.relativePath]);
    let routesMeta = parentsMeta.concat(meta2);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ? true ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index) => {
    return /* @__PURE__ */ (0, import_react.createElement)(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : /* @__PURE__ */ (0, import_react.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')) : void 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    true ? warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")) : void 0;
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? J(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? J(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? J(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

// node_modules/react-router-dom/index.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0, import_react2.useState)({
    action: history.action,
    location: history.location
  });
  (0, import_react2.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0, import_react2.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var Link = /* @__PURE__ */ (0, import_react2.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ (0, import_react2.createElement)("a", _extends2({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = /* @__PURE__ */ (0, import_react2.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let location = useLocation();
  let path = useResolvedPath(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ (0, import_react2.createElement)(Link, _extends2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to);
  return (0, import_react2.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || I(location) === I(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/server-runtime/esm/mode.js
init_react();
var ServerMode;
(function(ServerMode2) {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
})(ServerMode || (ServerMode = {}));
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}

// node_modules/@remix-run/server-runtime/esm/routes.js
init_react();
function createRoutes(manifest, parentId) {
  return Object.keys(manifest).filter((key) => manifest[key].parentId === parentId).map((id) => __spreadProps(__spreadValues({}, manifest[id]), {
    children: createRoutes(manifest, id)
  }));
}

// node_modules/@remix-run/server-runtime/esm/serverHandoff.js
init_react();
var import_jsesc = __toModule(require_jsesc());
function createServerHandoffString(serverHandoff) {
  return (0, import_jsesc.default)(serverHandoff, {
    isScriptContext: true
  });
}

// node_modules/@remix-run/server-runtime/esm/server.js
function createRequestHandler(build, platform2, mode) {
  let routes2 = createRoutes(build.routes);
  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;
  return async function requestHandler(request, loadContext) {
    let url = new URL(request.url);
    let matches = matchServerRoutes(routes2, url.pathname);
    let requestType = getRequestType(url, matches);
    let response;
    switch (requestType) {
      case "data":
        response = await handleDataRequest({
          request,
          loadContext,
          matches,
          handleDataRequest: build.entry.module.handleDataRequest,
          serverMode
        });
        break;
      case "document":
        response = await renderDocumentRequest({
          build,
          loadContext,
          matches,
          request,
          routes: routes2,
          serverMode
        });
        break;
      case "resource":
        response = await handleResourceRequest({
          request,
          loadContext,
          matches,
          serverMode
        });
        break;
    }
    if (request.method.toLowerCase() === "head") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
}
async function handleDataRequest({
  handleDataRequest: handleDataRequest2,
  loadContext,
  matches,
  request,
  serverMode
}) {
  if (!isValidRequestMethod(request)) {
    return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
  }
  let url = new URL(request.url);
  if (!matches) {
    return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
  }
  let response;
  let match;
  try {
    if (isActionRequest(request)) {
      match = getActionRequestMatch(url, matches);
      response = await callRouteAction({
        loadContext,
        match,
        request
      });
    } else {
      let routeId = url.searchParams.get("_data");
      if (!routeId) {
        return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
      }
      let tempMatch = matches.find((match2) => match2.route.id === routeId);
      if (!tempMatch) {
        return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
      }
      match = tempMatch;
      response = await callRouteLoader({
        loadContext,
        match,
        request
      });
    }
    if (isRedirectResponse(response)) {
      let headers = new Headers(response.headers);
      headers.set("X-Remix-Redirect", headers.get("Location"));
      headers.delete("Location");
      return new Response(null, {
        status: 204,
        headers
      });
    }
    if (handleDataRequest2) {
      response = await handleDataRequest2(response.clone(), {
        context: loadContext,
        params: match.params,
        request: request.clone()
      });
    }
    return response;
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    if (serverMode === ServerMode.Development) {
      return errorBoundaryError(error, 500);
    }
    return errorBoundaryError(new Error("Unexpected Server Error"), 500);
  }
}
async function renderDocumentRequest({
  build,
  loadContext,
  matches,
  request,
  routes: routes2,
  serverMode
}) {
  let url = new URL(request.url);
  let appState = {
    trackBoundaries: true,
    trackCatchBoundaries: true,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: void 0,
    catch: void 0
  };
  if (!isValidRequestMethod(request)) {
    matches = null;
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 405,
      statusText: "Method Not Allowed"
    };
  } else if (!matches) {
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 404,
      statusText: "Not Found"
    };
  }
  let actionStatus;
  let actionData;
  let actionMatch;
  let actionResponse;
  if (matches && isActionRequest(request)) {
    actionMatch = getActionRequestMatch(url, matches);
    try {
      actionResponse = await callRouteAction({
        loadContext,
        match: actionMatch,
        request
      });
      if (isRedirectResponse(actionResponse)) {
        return actionResponse;
      }
      actionStatus = {
        status: actionResponse.status,
        statusText: actionResponse.statusText
      };
      if (isCatchResponse(actionResponse)) {
        appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
        appState.trackCatchBoundaries = false;
        appState.catch = __spreadProps(__spreadValues({}, actionStatus), {
          data: await extractData(actionResponse)
        });
      } else {
        actionData = {
          [actionMatch.route.id]: await extractData(actionResponse)
        };
      }
    } catch (error) {
      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the action for route ${actionMatch.route.id}`);
      }
    }
  }
  let routeModules = createEntryRouteModules(build.routes);
  let matchesToLoad = matches || [];
  if (appState.catch) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "CatchBoundary");
  } else if (appState.error) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "ErrorBoundary");
  }
  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? callRouteLoader({
    loadContext,
    match,
    request
  }) : Promise.resolve(void 0)));
  let actionCatch = appState.catch;
  let actionError = appState.error;
  let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
  let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
  appState.catch = void 0;
  appState.error = void 0;
  let routeLoaderResponses = {};
  let loaderStatusCodes = [];
  let routeData = {};
  for (let index = 0; index < matchesToLoad.length; index++) {
    let match = matchesToLoad[index];
    let result = routeLoaderResults[index];
    let error = result.status === "rejected" ? result.reason : void 0;
    let response = result.status === "fulfilled" ? result.value : void 0;
    let isRedirect = response ? isRedirectResponse(response) : false;
    let isCatch = response ? isCatchResponse(response) : false;
    if (appState.catch || appState.error) {
      break;
    }
    if (!actionCatch && !actionError && response && isRedirect) {
      return response;
    }
    if (match.route.module.CatchBoundary) {
      appState.catchBoundaryRouteId = match.route.id;
    }
    if (match.route.module.ErrorBoundary) {
      appState.loaderBoundaryRouteId = match.route.id;
    }
    if (error) {
      loaderStatusCodes.push(500);
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the data loader for route ${match.route.id}`);
      }
      break;
    } else if (response) {
      routeLoaderResponses[match.route.id] = response;
      loaderStatusCodes.push(response.status);
      if (isCatch) {
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: await extractData(response),
          status: response.status,
          statusText: response.statusText
        };
        break;
      } else {
        routeData[match.route.id] = await extractData(response);
      }
    }
  }
  if (!appState.catch) {
    appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
  }
  if (!appState.error) {
    appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
  }
  appState.catch = actionCatch || appState.catch;
  appState.error = actionError || appState.error;
  let renderableMatches = getRenderableMatches(matches, appState);
  if (!renderableMatches) {
    renderableMatches = [];
    let root = routes2[0];
    if (root !== null && root !== void 0 && root.module.CatchBoundary) {
      appState.catchBoundaryRouteId = "root";
      renderableMatches.push({
        params: {},
        pathname: "",
        route: routes2[0]
      });
    }
  }
  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
  let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
  let responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);
  let serverHandoff = {
    actionData,
    appState,
    matches: entryMatches,
    routeData
  };
  let entryContext = __spreadProps(__spreadValues({}, serverHandoff), {
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff)
  });
  let handleDocumentRequest = build.entry.module.default;
  try {
    return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
  } catch (error) {
    responseStatusCode = 500;
    appState.trackBoundaries = false;
    appState.error = await serializeError(error);
    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
    try {
      return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
    } catch (error2) {
      if (serverMode !== ServerMode.Test) {
        console.error(error2);
      }
      let message = "Unexpected Server Error";
      if (serverMode === ServerMode.Development) {
        message += `

${String(error2)}`;
      }
      return new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
  }
}
async function handleResourceRequest({
  loadContext,
  matches,
  request,
  serverMode
}) {
  let match = matches.slice(-1)[0];
  try {
    if (isActionRequest(request)) {
      return await callRouteAction({
        match,
        loadContext,
        request
      });
    } else {
      return await callRouteLoader({
        match,
        loadContext,
        request
      });
    }
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    let message = "Unexpected Server Error";
    if (serverMode === ServerMode.Development) {
      message += `

${String(error)}`;
    }
    return new Response(message, {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
}
function getRequestType(url, matches) {
  if (url.searchParams.has("_data")) {
    return "data";
  }
  if (!matches) {
    return "document";
  }
  let match = matches.slice(-1)[0];
  if (!match.route.module.default) {
    return "resource";
  }
  return "document";
}
function isActionRequest(request) {
  let method = request.method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function isHeadRequest(request) {
  return request.method.toLowerCase() === "head";
}
function isValidRequestMethod(request) {
  return request.method.toLowerCase() === "get" || isHeadRequest(request) || isActionRequest(request);
}
async function errorBoundaryError(error, status) {
  return json(await serializeError(error), {
    status,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function isIndexRequestUrl(url) {
  let indexRequest = false;
  for (let param of url.searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
function getActionRequestMatch(url, matches) {
  let match = matches.slice(-1)[0];
  if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
    return matches.slice(-2)[0];
  }
  return match;
}
function getDeepestRouteIdWithBoundary(matches, key) {
  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
  return matched ? matched.route.id : null;
}
function getMatchesUpToDeepestBoundary(matches, key) {
  let deepestBoundaryIndex = -1;
  matches.forEach((match, index) => {
    if (match.route.module[key]) {
      deepestBoundaryIndex = index;
    }
  });
  if (deepestBoundaryIndex === -1) {
    return [];
  }
  return matches.slice(0, deepestBoundaryIndex + 1);
}
function getRenderableMatches(matches, appState) {
  if (!matches) {
    return null;
  }
  if (!appState.catch && !appState.error) {
    return matches;
  }
  let lastRenderableIndex = -1;
  matches.forEach((match, index) => {
    let id = match.route.id;
    if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {
      lastRenderableIndex = index;
    }
  });
  return matches.slice(0, lastRenderableIndex + 1);
}

// node_modules/@remix-run/cloudflare-pages/esm/worker.js
init_react();
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let platform2 = {};
  let handleRequest3 = createRequestHandler(build, platform2, mode);
  return (context) => {
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(context) : void 0;
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  const handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  });
  const handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone());
      response = response && response.status >= 200 && response.status < 400 ? new Response(response.body, response) : void 0;
    } catch {
    }
    if (!response) {
      response = await handleRequest3(context);
    }
    return response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (e) {
      if (e instanceof Error) {
        console.error(e);
        return new Response(e.message || e.toString(), {
          status: 500
        });
      }
      return new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// node_modules/@remix-run/cloudflare-pages/esm/index.js
installGlobals();

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  entry: () => entry,
  routes: () => routes
});
init_react();

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
init_react();
var import_server3 = __toModule(require_server());

// node_modules/remix/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/components.js
init_react();

// node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js
init_react();
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// node_modules/@remix-run/react/esm/components.js
var React3 = __toModule(require_react());

// node_modules/@remix-run/react/esm/errorBoundaries.js
init_react();
var import_react3 = __toModule(require_react());
var RemixErrorBoundary = class extends import_react3.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ import_react3.default.createElement(this.props.component, {
        error: this.state.error
      });
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error
}) {
  console.error(error);
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react3.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
var RemixCatchContext = /* @__PURE__ */ import_react3.default.createContext(void 0);
function useCatch() {
  return (0, import_react3.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component,
  children
}) {
  if (catchVal) {
    return /* @__PURE__ */ import_react3.default.createElement(RemixCatchContext.Provider, {
      value: catchVal
    }, /* @__PURE__ */ import_react3.default.createElement(Component, null));
  }
  return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}

// node_modules/@remix-run/react/esm/invariant.js
init_react();
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// node_modules/@remix-run/react/esm/links.js
init_react();

// node_modules/@remix-run/react/esm/routeModules.js
init_react();
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push(__spreadProps(__spreadValues({}, descriptor), {
        rel: "preload",
        as: "style"
      }));
    }
  }
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  return object != null && typeof object.rel === "string" && typeof object.href === "string";
}
async function getStylesheetPrefetchLinks(matches, routeModules) {
  let links2 = await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(match.route, routeModules);
    return mod.links ? mod.links() : [];
  }));
  return links2.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((_a) => {
    var _b = _a, {
      rel
    } = _b, attrs = __objRest(_b, [
      "rel"
    ]);
    return rel === "preload" ? __spreadValues({
      rel: "prefetch"
    }, attrs) : __spreadValues({
      rel: "prefetch",
      as: "style"
    }, attrs);
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {
  let path = parsePathPatch(page);
  let isNew = (match, index) => {
    if (!currentMatches[index])
      return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _currentMatches$index;
    return currentMatches[index].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"];
  };
  let newMatches = mode === "data" && location.search !== path.search ? nextMatches.filter((match, index) => {
    if (!match.route.hasLoader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      return match.route.shouldReload({
        params: match.params,
        prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),
        url: new URL(page, window.origin)
      });
    }
    return true;
  }) : nextMatches.filter((match, index) => {
    return match.route.hasLoader && (isNew(match, index) || matchPathChanged(match, index));
  });
  return newMatches;
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path;
    let searchParams = new URLSearchParams(search);
    searchParams.set("_data", match.route.id);
    return `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let str = JSON.stringify(descriptor);
    if (!set.has(str)) {
      set.add(str);
      deduped.push(descriptor);
    }
    return deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = J(href);
  if (path.search === void 0)
    path.search = "";
  return path;
}

// node_modules/@remix-run/react/esm/markup.js
init_react();
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/esm/routes.js
init_react();
var React2 = __toModule(require_react());

// node_modules/@remix-run/react/esm/data.js
init_react();
function isCatchResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
async function fetchData(url, routeId, signal, submission) {
  url.searchParams.set("_data", routeId);
  let init2 = submission ? getActionInit(submission, signal) : {
    credentials: "same-origin",
    signal
  };
  let response = await fetch(url.href, init2);
  if (isErrorResponse(response)) {
    let data = await response.json();
    let error = new Error(data.message);
    error.stack = data.stack;
    return error;
  }
  return response;
}
async function extractData2(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission;
  let headers = void 0;
  let body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData) {
      invariant2(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
      body.append(key, value);
    }
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}

// node_modules/@remix-run/react/esm/transition.js
init_react();

// node_modules/@remix-run/react/esm/routeMatching.js
init_react();
function matchClientRoutes(routes2, location) {
  let matches = matchRoutes(routes2, location);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/react/esm/transition.js
var CatchValue = class {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText;
    this.data = data;
  }
};
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location) {
  return Boolean(location.state) && location.state.isRedirect;
}
function isLoaderRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loader";
}
function isActionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "action";
}
function isFetchActionRedirect(location) {
  return isRedirectLocation(location) && location.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loaderSubmission";
}
var TransitionRedirect = class {
  constructor(location) {
    this.location = typeof location === "string" ? location : location.pathname + location.search;
  }
};
var IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
};
var IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init2) {
  let {
    routes: routes2
  } = init2;
  let pendingNavigationController;
  let fetchControllers = new Map();
  let incrementingLoadId = 0;
  let navigationLoadId = -1;
  let fetchReloadIds = new Map();
  let matches = matchClientRoutes(routes2, init2.location);
  if (!matches) {
    matches = [{
      params: {},
      pathname: "",
      route: routes2[0]
    }];
  }
  let state = {
    location: init2.location,
    loaderData: init2.loaderData || {},
    actionData: init2.actionData,
    catch: init2.catch,
    error: init2.error,
    catchBoundaryId: init2.catchBoundaryId || null,
    errorBoundaryId: init2.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: new Map()
  };
  function update(updates) {
    state = Object.assign({}, state, updates);
    init2.onChange(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchReloadIds.delete(key);
    state.fetchers.delete(key);
  }
  async function send(event) {
    switch (event.type) {
      case "navigation": {
        let {
          action,
          location,
          submission
        } = event;
        let matches2 = matchClientRoutes(routes2, location);
        if (!matches2) {
          matches2 = [{
            params: {},
            pathname: "",
            route: routes2[0]
          }];
          await handleNotFoundNavigation(location, matches2);
        } else if (!submission && isHashChangeOnly(location)) {
          await handleHashChange(location, matches2);
        } else if (action === r.Pop) {
          await handleLoad(location, matches2);
        } else if (submission && isActionSubmission(submission)) {
          await handleActionSubmissionNavigation(location, submission, matches2);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderSubmissionNavigation(location, submission, matches2);
        } else if (isActionRedirectLocation(location)) {
          await handleActionRedirect(location, matches2);
        } else if (isLoaderSubmissionRedirectLocation(location)) {
          await handleLoaderSubmissionRedirect(location, matches2);
        } else if (isLoaderRedirectLocation(location)) {
          await handleLoaderRedirect(location, matches2);
        } else if (isFetchActionRedirect(location)) {
          await handleFetchActionRedirect(location, matches2);
        } else {
          await handleLoad(location, matches2);
        }
        navigationLoadId = -1;
        break;
      }
      case "fetcher": {
        let {
          key,
          submission,
          href
        } = event;
        let matches2 = matchClientRoutes(routes2, href);
        invariant2(matches2, "No matches found");
        let match = matches2.slice(-1)[0];
        if (fetchControllers.has(key))
          abortFetcher(key);
        if (submission && isActionSubmission(submission)) {
          await handleActionFetchSubmission(key, submission, match);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderFetchSubmission(href, key, submission, match);
        } else {
          await handleLoaderFetch(href, key, match);
        }
        break;
      }
      default: {
        throw new Error(`Unknown data event type: ${event.type}`);
      }
    }
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers) {
      controller.abort();
    }
  }
  async function handleActionFetchSubmission(key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callAction(submission, match, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "fetchAction"
      };
      init2.onRedirect(result.value.location, locationState);
      let doneFetcher2 = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher2);
      update({
        fetchers: new Map(state.fetchers)
      });
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let loadFetcher = {
      state: "loading",
      type: "actionReload",
      data: result.value,
      submission
    };
    state.fetchers.set(key, loadFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
    let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let matchesToLoad = state.nextMatches || state.matches;
    let hrefToLoad = createHref(state.transition.location || state.location);
    let results = await callLoaders(state, createUrl(hrefToLoad), matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
    if (controller.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    let redirect = findRedirect(results);
    if (redirect) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(redirect.location, locationState);
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult);
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    let abortedKeys = abortStaleFetchLoads(loadId);
    if (abortedKeys) {
      markFetchersDone(abortedKeys);
    }
    let yeetedNavigation = yeetStaleNavigationLoad(loadId);
    if (yeetedNavigation) {
      let {
        transition
      } = state;
      invariant2(transition.state === "loading", "Expected loading transition");
      update({
        location: transition.location,
        matches: state.nextMatches,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad),
        actionData: transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers)
      });
    } else {
      update({
        fetchers: new Map(state.fetchers),
        error,
        errorBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad)
      });
    }
  }
  function yeetStaleNavigationLoad(landedId) {
    let isLoadingNavigation = state.transition.state === "loading";
    if (isLoadingNavigation && navigationLoadId < landedId) {
      abortNormalNavigation();
      return true;
    }
    return false;
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant2(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    return yeetedKeys.length ? yeetedKeys : false;
  }
  async function handleLoaderFetchSubmission(href, key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    fetchControllers.delete(key);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function handleLoaderFetch(href, key, match) {
    if (typeof AbortController === "undefined") {
      throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
    }
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (controller.signal.aborted)
      return;
    fetchControllers.delete(key);
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function maybeBailOnCatch(match, key, result) {
    if (isCatchResult(result)) {
      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers),
        catch: {
          data: result.value.data,
          status: result.value.status,
          statusText: result.value.statusText
        },
        catchBoundaryId
      });
      return true;
    }
    return false;
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      });
      return true;
    }
    return false;
  }
  async function handleNotFoundNavigation(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
    update({
      location,
      matches: matches2,
      catch: {
        data: null,
        status: 404,
        statusText: "Not Found"
      },
      catchBoundaryId,
      transition: IDLE_TRANSITION
    });
  }
  async function handleActionSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    let controller = new AbortController();
    pendingNavigationController = controller;
    if (!isIndexRequestAction(submission.action) && matches2[matches2.length - 1].route.id.endsWith("/index")) {
      matches2 = matches2.slice(0, -1);
    }
    let leafMatch = matches2.slice(-1)[0];
    let result = await callAction(submission, leafMatch, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "action"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (isCatchResult(result)) {
      let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], matches2, result);
      update({
        transition: IDLE_TRANSITION,
        catch: catchVal,
        catchBoundaryId
      });
      return;
    }
    let loadTransition = {
      state: "loading",
      type: "actionReload",
      submission,
      location
    };
    update({
      transition: loadTransition,
      actionData: {
        [leafMatch.route.id]: result.value
      }
    });
    await loadPageData(location, matches2, submission, leafMatch.route.id, result);
  }
  async function handleLoaderSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleHashChange(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    update({
      location,
      matches: matches2,
      transition: IDLE_TRANSITION
    });
  }
  async function handleLoad(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderSubmissionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "loaderSubmissionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleFetchActionRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "fetchActionRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleActionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "actionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  function isHashChangeOnly(location) {
    return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;
  }
  async function loadPageData(location, matches2, submission, submissionRouteId, actionResult) {
    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
    let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
    let controller = new AbortController();
    pendingNavigationController = controller;
    navigationLoadId = ++incrementingLoadId;
    let results = await callLoaders(state, createUrl(createHref(location)), matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId);
    if (controller.signal.aborted) {
      return;
    }
    let redirect = findRedirect(results);
    if (redirect) {
      if (state.transition.type === "actionReload") {
        let locationState = {
          isRedirect: true,
          type: "action"
        };
        init2.onRedirect(redirect.location, locationState);
      } else if (state.transition.type === "loaderSubmission") {
        let locationState = {
          isRedirect: true,
          type: "loaderSubmission"
        };
        init2.onRedirect(redirect.location, locationState);
      } else {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init2.onRedirect(redirect.location, locationState);
      }
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult);
    let abortedIds = abortStaleFetchLoads(navigationLoadId);
    if (abortedIds) {
      markFetchersDone(abortedIds);
    }
    update({
      location,
      matches: matches2,
      error,
      errorBoundaryId,
      catch: catchVal,
      catchBoundaryId,
      loaderData: makeLoaderData(state, results, matches2),
      actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
      transition: IDLE_TRANSITION,
      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
    });
  }
  function abortNormalNavigation() {
    var _pendingNavigationCon;
    (_pendingNavigationCon = pendingNavigationController) === null || _pendingNavigationCon === void 0 ? void 0 : _pendingNavigationCon.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant2(controller, `Expected fetch controller: ${key}`);
    controller.abort();
    fetchControllers.delete(key);
  }
  return {
    send,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
function isIndexRequestAction(action) {
  let indexRequest = false;
  let searchParams = new URLSearchParams(action.split("?", 2)[1] || "");
  for (let param of searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
async function callLoaders(state, url, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  let matchesToLoad = filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher);
  return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
}
async function callLoader(match, url, signal) {
  invariant2(match.route.loader, `Expected loader for ${match.route.id}`);
  try {
    let {
      params
    } = match;
    let value = await match.route.loader({
      params,
      url,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
async function callAction(submission, match, signal) {
  if (!match.route.action) {
    throw new Error(`Route "${match.route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
  }
  try {
    let value = await match.route.action({
      url: createUrl(submission.action),
      params: match.params,
      submission,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
function filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  if (submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = false;
    matches = matches.filter((match) => {
      if (foundProblematicRoute) {
        return false;
      }
      if (match.route.id === submissionRouteId) {
        foundProblematicRoute = true;
        return false;
      }
      return true;
    });
  }
  let isNew = (match, index) => {
    if (!state.matches[index])
      return true;
    return match.route.id !== state.matches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _state$matches$index$;
    return state.matches[index].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index].params["*"] !== match.params["*"];
  };
  let filterByRouteProps = (match, index) => {
    if (!match.route.loader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return true;
  };
  let isInRootCatchBoundary = state.matches.length === 1;
  if (isInRootCatchBoundary) {
    return matches.filter((match) => !!match.route.loader);
  }
  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
    return matches.filter(filterByRouteProps);
  } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search) {
    return matches.filter(filterByRouteProps);
  }
  return matches.filter((match, index, arr) => {
    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index) {
      return false;
    }
    return match.route.loader && (isNew(match, index) || matchPathChanged(match, index));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location) {
  return location.pathname + location.search;
}
function findRedirect(results) {
  for (let result of results) {
    if (isRedirectResult(result)) {
      return result.value;
    }
  }
  return null;
}
async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  let loaderCatchResult;
  for (let result of results) {
    if (isCatchResult(result)) {
      loaderCatchResult = result;
      break;
    }
  }
  let extractCatchData = async (res) => ({
    status: res.status,
    statusText: res.statusText,
    data: res.data
  });
  if (actionCatchResult && loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(actionCatchResult.value), boundaryId];
  }
  if (loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(loaderCatchResult.value), boundaryId];
  }
  return [void 0, void 0];
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results) {
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.CatchBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.ErrorBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results) {
    newData[match.route.id] = value;
  }
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    if (value !== void 0) {
      loaderData[route.id] = value;
    }
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}

// node_modules/@remix-run/react/esm/routes.js
function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ React2.createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    if (children.length > 0)
      route.children = children;
    return route;
  });
}
function createShouldReload(route, routeModules) {
  let shouldReload = (arg) => {
    let module = routeModules[route.id];
    invariant2(module, `Expected route module to be loaded for ${route.id}`);
    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }
    return true;
  };
  return shouldReload;
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  await prefetchStyleLinks(routeModule);
  return routeModule;
}
function createLoader(route, routeModules) {
  let loader8 = async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect = await checkRedirect(result);
      if (redirect)
        return redirect;
      if (isCatchResponse2(result)) {
        throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
      }
      return extractData2(result);
    } else {
      await loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  };
  return loader8;
}
function createAction(route) {
  if (!route.hasAction)
    return void 0;
  let action = async ({
    url,
    signal,
    submission
  }) => {
    let result = await fetchData(url, route.id, signal, submission);
    if (result instanceof Error) {
      throw result;
    }
    let redirect = await checkRedirect(result);
    if (redirect)
      return redirect;
    if (isCatchResponse2(result)) {
      throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
    }
    return extractData2(result);
  };
  return action;
}
async function checkRedirect(response) {
  if (isRedirectResponse2(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
    if (url.origin !== window.location.origin) {
      await new Promise(() => {
        window.location.replace(url.href);
      });
    } else {
      return new TransitionRedirect(url.pathname + url.search);
    }
  }
  return null;
}

// node_modules/@remix-run/react/esm/components.js
var RemixEntryContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixEntryContext() {
  let context = React3.useContext(RemixEntryContext);
  invariant2(context, "You must render this element inside a <Remix> element");
  return context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = false
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext;
  let clientRoutes = React3.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
  let [clientState, setClientState] = React3.useState(entryComponentDidCatchEmulator);
  let [transitionManager] = React3.useState(() => {
    return createTransitionManager({
      routes: clientRoutes,
      actionData: documentActionData,
      loaderData: documentLoaderData,
      location: historyLocation,
      catch: entryComponentDidCatchEmulator.catch,
      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
      onRedirect: _navigator.replace,
      onChange: (state) => {
        setClientState({
          catch: state.catch,
          error: state.error,
          catchBoundaryRouteId: state.catchBoundaryId,
          loaderBoundaryRouteId: state.errorBoundaryId,
          renderBoundaryRouteId: null,
          trackBoundaries: false,
          trackCatchBoundaries: false
        });
      }
    });
  });
  let navigator = React3.useMemo(() => {
    let push = (to, state) => {
      return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
    };
    return __spreadProps(__spreadValues({}, _navigator), {
      push
    });
  }, [_navigator, transitionManager]);
  let {
    location,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  React3.useEffect(() => {
    let {
      location: location2
    } = transitionManager.getState();
    if (historyLocation === location2)
      return;
    transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ React3.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
    location,
    component: RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
    location,
    component: RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(Router, {
    navigationType: action,
    location,
    navigator,
    static: staticProp
  }, /* @__PURE__ */ React3.createElement(Routes2, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  error.stack = data.stack;
  return error;
}
function Routes2() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  let element = useRoutes(clientRoutes) || clientRoutes[0].element;
  return element;
}
var RemixRouteContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixRouteContext() {
  let context = React3.useContext(RemixRouteContext);
  invariant2(context, "You must render this element in a remix route element");
  return context;
}
function DefaultRouteComponent({
  id
}) {
  throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id
}) {
  let location = useLocation();
  let {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  let data = routeData[id];
  let {
    default: Component,
    CatchBoundary: CatchBoundary2,
    ErrorBoundary: ErrorBoundary2
  } = routeModules[id];
  let element = Component ? /* @__PURE__ */ React3.createElement(Component, null) : /* @__PURE__ */ React3.createElement(DefaultRouteComponent, {
    id
  });
  let context = {
    data,
    id
  };
  if (CatchBoundary2) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
    if (appState.trackCatchBoundaries) {
      appState.catchBoundaryRouteId = id;
    }
    context = maybeServerCaught ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
      location,
      component: CatchBoundary2,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary2) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
    if (appState.trackBoundaries) {
      appState.renderBoundaryRouteId = id;
    }
    context = maybeServerRenderError ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
      location,
      component: ErrorBoundary2,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ React3.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = React3.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = React3.useState(false);
  let {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  React3.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
  }, [prefetch]);
  let setIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(true);
    }
  };
  let cancelIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(false);
    }
  };
  React3.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  return [shouldPrefetch, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
var NavLink2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(NavLink, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
var Link2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Link, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext();
  let links2 = React3.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, links2.map((link) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, _extends3({
    key: link.page
  }, link)) : /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.rel + link.href
  }, link))));
}
function PrefetchPageLinks(_a) {
  var _b = _a, {
    page
  } = _b, dataLinkProps = __objRest(_b, [
    "page"
  ]);
  let {
    clientRoutes
  } = useRemixEntryContext();
  let matches = React3.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
  if (!matches) {
    console.warn(`Tried to prefetch ${page} but no routes matched.`);
    return null;
  }
  return /* @__PURE__ */ React3.createElement(PrefetchPageLinksImpl, _extends3({
    page,
    matches
  }, dataLinkProps));
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext();
  let [styleLinks, setStyleLinks] = React3.useState([]);
  React3.useEffect(() => {
    let interrupted = false;
    getStylesheetPrefetchLinks(matches, routeModules).then((links2) => {
      if (!interrupted)
        setStyleLinks(links2);
    });
    return () => {
      interrupted = true;
    };
  }, [matches, routeModules]);
  return styleLinks;
}
function PrefetchPageLinksImpl(_a) {
  var _b = _a, {
    page,
    matches: nextMatches
  } = _b, linkProps = __objRest(_b, [
    "page",
    "matches"
  ]);
  let location = useLocation();
  let {
    matches,
    manifest
  } = useRemixEntryContext();
  let newMatchesForData = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "data"), [page, nextMatches, matches, location]);
  let newMatchesForAssets = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "assets"), [page, nextMatches, matches, location]);
  let dataHrefs = React3.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
  let moduleHrefs = React3.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  let location = useLocation();
  let meta2 = {};
  let parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id;
    let data = routeData[routeId];
    let params = match.params;
    let routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location
      }) : routeModule.meta;
      Object.assign(meta2, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, Object.entries(meta2).map(([name, value]) => {
    let isOpenGraphTag = name.startsWith("og:");
    return name === "title" ? /* @__PURE__ */ React3.createElement("title", {
      key: "title"
    }, value) : Array.isArray(value) ? value.map((content) => isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      property: name,
      content
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      name,
      content
    })) : isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      property: name,
      content: value
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      name,
      content: value
    });
  }));
}
var isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  React3.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = React3.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
    let routeModulesScript = `${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};`;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(contextScript)
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.url
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module"
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.entry.module,
      type: "module"
    })));
  }, []);
  let nextMatches = React3.useMemo(() => {
    if (pendingLocation) {
      let matches2 = matchClientRoutes(clientRoutes, pendingLocation);
      invariant2(matches2, `No routes match path "${pendingLocation.pathname}"`);
      return matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]);
  let routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1);
  let preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dedupe2(preloads).map((path) => /* @__PURE__ */ React3.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe2(array) {
  return [...new Set(array)];
}
var nextNavigationSubmission;
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  nextNavigationSubmission = void 0;
  return submission;
}
function useBeforeUnload(callback) {
  React3.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}
function useLoaderData() {
  return useRemixRouteContext().data;
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
var LiveReload = false ? () => null : function LiveReload2({
  port = Number(8002)
}) {
  return /* @__PURE__ */ React3.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
let protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
let host = location.hostname;
let socketPath = protocol + '//' + host + ':${port}/socket';

let ws = new WebSocket(socketPath);
ws.onmessage = message => {
  let event = JSON.parse(message.data);
  if (event.type === "LOG") {
    console.log(event.message);
  }
  if (event.type === "RELOAD") {
    console.log("\u{1F4BF} Reloading window ...");
    window.location.reload();
  }
};
ws.onerror = error => {
  console.log("Remix dev asset server web socket error:");
  console.error(error);
};
              `.trim()
    }
  });
};

// node_modules/@remix-run/react/esm/scroll-restoration.js
init_react();
var React4 = __toModule(require_react());
var STORAGE_KEY = "positions";
var positions = {};
if (typeof document !== "undefined") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  if (sessionPositions) {
    positions = JSON.parse(sessionPositions);
  }
}
function ScrollRestoration() {
  useScrollRestoration();
  React4.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []);
  useBeforeUnload(React4.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  return /* @__PURE__ */ React4.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
          let STORAGE_KEY = ${JSON.stringify(STORAGE_KEY)};
          if (!window.history.state || !window.history.state.key) {
            window.history.replaceState({ key: Math.random().toString(32).slice(2) }, null);
          }
          try {
            let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || '{}')
            let storedY = positions[window.history.state.key];
            if (typeof storedY === 'number') {
              window.scrollTo(0, storedY)
            }
          } catch(error) {
            console.error(error)
            sessionStorage.removeItem(STORAGE_KEY)
          }
        `
    }
  });
}
var hydrated = false;
function useScrollRestoration() {
  let location = useLocation();
  let transition = useTransition();
  let wasSubmissionRef = React4.useRef(false);
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
  React4.useEffect(() => {
    if (transition.location) {
      positions[location.key] = window.scrollY;
    }
  }, [transition, location]);
  useBeforeUnload(React4.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, []));
  if (typeof document !== "undefined") {
    React4.useLayoutEffect(() => {
      if (!hydrated) {
        hydrated = true;
        return;
      }
      let y = positions[location.key];
      if (y) {
        window.scrollTo(0, y);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (wasSubmissionRef.current === true) {
        wasSubmissionRef.current = false;
        return;
      }
      window.scrollTo(0, 0);
    }, [location]);
  }
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
}

// node_modules/@remix-run/react/esm/server.js
init_react();
var React5 = __toModule(require_react());
function RemixServer({
  context,
  url
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let location = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  };
  let staticNavigator = {
    createHref(to) {
      return typeof to === "string" ? to : I(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    },
    block() {
      throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
    }
  };
  return /* @__PURE__ */ React5.createElement(RemixEntry, {
    context,
    action: r.Pop,
    location,
    navigator: staticNavigator,
    static: true
  });
}

// app/entry.server.tsx
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  const markup = (0, import_server3.renderToString)(/* @__PURE__ */ React.createElement(RemixServer, {
    context: remixContext,
    url: request.url
  }));
  responseHeaders.set("Content-Type", "text/html");
  return new Response("<!DOCTYPE html>" + markup, {
    status: responseStatusCode,
    headers: responseHeaders
  });
}

// route:D:\projects\unikey.org\app\root.tsx
var root_exports = {};
__export(root_exports, {
  CatchBoundary: () => CatchBoundary,
  ErrorBoundary: () => ErrorBoundary,
  default: () => App,
  links: () => links,
  meta: () => meta
});
init_react();
var import_react5 = __toModule(require_react());
var import_prop_types = __toModule(require_prop_types());
var import_nprogress = __toModule(require_nprogress());

// node_modules/nprogress/nprogress.css
var nprogress_default = "/build/_assets/nprogress-JFUSETFZ.css";

// app/styles/app.css
var app_default = "/build/_assets/app-OOE5OFR7.css";

// route:D:\projects\unikey.org\app\root.tsx
var links = () => {
  return [
    { rel: "stylesheet", href: app_default },
    { rel: "stylesheet", href: nprogress_default }
  ];
};
var meta = () => {
  return { title: "Unikey - B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t" };
};
var menuItems = [
  { to: "/about", text: "Gi\u1EDBi thi\u1EC7u" },
  { to: "/blog", text: "Blog" },
  { to: "/linux", text: "Linux" },
  { to: "/apple", text: "Apple" },
  { to: "/support", text: "Tr\u1EE3 gi\xFAp" },
  { to: "/source", text: "M\xE3 ngu\u1ED3n" }
];
function Document({ children, title: title2 }) {
  const transition = useTransition();
  import_react5.default.useEffect(() => {
    if (transition.state === "idle")
      import_nprogress.default.done();
    else
      import_nprogress.default.start();
  }, [transition.state]);
  return /* @__PURE__ */ import_react5.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react5.default.createElement("head", null, /* @__PURE__ */ import_react5.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react5.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1"
  }), /* @__PURE__ */ import_react5.default.createElement(Meta, null), title2 ? /* @__PURE__ */ import_react5.default.createElement("title", null, title2) : null, /* @__PURE__ */ import_react5.default.createElement(Links, null)), /* @__PURE__ */ import_react5.default.createElement("body", null, /* @__PURE__ */ import_react5.default.createElement("nav", {
    className: "bg-zinc-100 py-10"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "container max-w-screen-lg flex justify-between mx-auto"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: ""
  }, /* @__PURE__ */ import_react5.default.createElement("a", {
    href: "/"
  }, /* @__PURE__ */ import_react5.default.createElement("strong", null, "UniKey"))), /* @__PURE__ */ import_react5.default.createElement("ul", {
    className: "flex space-x-8"
  }, menuItems.map((menuItem) => {
    return /* @__PURE__ */ import_react5.default.createElement("li", {
      key: menuItem.to
    }, /* @__PURE__ */ import_react5.default.createElement(NavLink2, {
      to: menuItem.to
    }, menuItem.text));
  })))), /* @__PURE__ */ import_react5.default.createElement("main", {
    className: "mb-20"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "container max-w-screen-md mx-auto"
  }, children)), /* @__PURE__ */ import_react5.default.createElement("footer", {
    className: "mt-auto p-6 bg-slate-500"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "container max-w-screen-lg mx-auto text-white"
  }, "\xA9 2021 Pham Kim Long.")), /* @__PURE__ */ import_react5.default.createElement(ScrollRestoration, null), /* @__PURE__ */ import_react5.default.createElement(Scripts, null), /* @__PURE__ */ import_react5.default.createElement(LiveReload, null)));
}
Document.propTypes = {
  children: import_prop_types.default.node,
  title: import_prop_types.default.string
};
function App() {
  return /* @__PURE__ */ import_react5.default.createElement(Document, null, /* @__PURE__ */ import_react5.default.createElement(Outlet, null));
}
function CatchBoundary() {
  const caught = useCatch();
  return /* @__PURE__ */ import_react5.default.createElement(Document, {
    title: `${caught.status} ${caught.statusText}`
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "error-container"
  }, /* @__PURE__ */ import_react5.default.createElement("h1", null, caught.status, " ", caught.statusText)));
}
function ErrorBoundary({ error }) {
  console.error(error);
  return /* @__PURE__ */ import_react5.default.createElement(Document, {
    title: "Uh-oh!"
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "error-container"
  }, /* @__PURE__ */ import_react5.default.createElement("h1", null, "App Error"), /* @__PURE__ */ import_react5.default.createElement("pre", null, error.message)));
}
ErrorBoundary.propTypes = {
  error: import_prop_types.default.object
};

// route:D:\projects\unikey.org\app\routes\download.tsx
var download_exports = {};
__export(download_exports, {
  default: () => DownloadPage,
  handle: () => handle,
  loader: () => loader
});
init_react();
var import_react6 = __toModule(require_react());

// app/utils/getPageData.ts
init_react();

// node_modules/marked/lib/marked.esm.js
init_react();
function getDefaults() {
  return {
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = /[&<>"']/g;
var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain2 = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain2, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function merge(obj) {
  let i = 1, target, key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.substr(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title2 = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title: title2,
      text,
      tokens: lexer2.inlineTokens(text, [])
    };
    lexer2.state.inLink = false;
    return token;
  } else {
    return {
      type: "image",
      raw,
      href,
      title: title2,
      text: escape(text)
    };
  }
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim() : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *> ?/gm, "");
      return {
        type: "blockquote",
        raw: cap[0],
        tokens: this.lexer.blockTokens(text, []),
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0];
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            line = rawLine;
            if (this.options.pedantic) {
              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (nextBulletRegex.test(line)) {
              break;
            }
            if (line.search(/[^ ]/) >= indent || !line.trim()) {
              itemContents += "\n" + line.slice(indent);
            } else if (!blankLine) {
              itemContents += "\n" + line;
            } else {
              break;
            }
            if (!blankLine && !line.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        const spacers = list.items[i].tokens.filter((t) => t.type === "space");
        const hasMultipleLineBreaks = spacers.every((t) => {
          const chars = t.raw.split("");
          let lineBreaks = 0;
          for (const char of chars) {
            if (char === "\n") {
              lineBreaks += 1;
            }
            if (lineBreaks > 1) {
              return true;
            }
          }
          return false;
        });
        if (!list.loose && spacers.length && hasMultipleLineBreaks) {
          list.loose = true;
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        token.type = "paragraph";
        token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.tokens = [];
        this.lexer.inline(token.text, token.tokens);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      if (cap[3])
        cap[3] = cap[3].substring(1, cap[3].length - 1);
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      return {
        type: "def",
        tag,
        raw: cap[0],
        href: cap[2],
        title: cap[3]
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = [];
          this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = [];
            this.lexer.inlineTokens(row[k].text, row[k].tokens);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const token = {
        type: "paragraph",
        raw: cap[0],
        text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      const token = {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title2 = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title2 = link[3];
        }
      } else {
        title2 = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title2 ? title2.replace(this.rules.inline._escapes, "$1") : title2
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links2) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links2[link.toLowerCase()];
      if (!link || !link.href) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = src.slice(1, lLength + match.index + rLength);
          return {
            type: "em",
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text2,
            tokens: this.lexer.inlineTokens(text2, [])
          };
        }
        const text = src.slice(2, lLength + match.index + rLength - 1);
        return {
          type: "strong",
          raw: src.slice(0, lLength + match.index + rLength + 1),
          text,
          tokens: this.lexer.inlineTokens(text, [])
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2], [])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + text;
        } else {
          href = text;
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = merge({}, block);
block.gfm = merge({}, block.normal, {
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
});
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = merge({}, block.normal, {
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
});
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /\\\*|\\_/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = merge({}, inline);
inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
});
inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  static get rules() {
    return {
      block,
      inline
    };
  }
  static lex(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.lex(src);
  }
  static lexInline(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/^ +$/gm, "");
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens) {
    this.inlineQueue.push({ src, tokens });
  }
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links2 = Object.keys(this.tokens.links);
      if (links2.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links2.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return "<blockquote>\n" + quote + "</blockquote>\n";
  }
  html(html) {
    return html;
  }
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
    }
    return "<h" + level + ">" + text + "</h" + level + ">\n";
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text) {
    return "<li>" + text + "</li>\n";
  }
  checkbox(checked2) {
    return "<input " + (checked2 ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  paragraph(text) {
    return "<p>" + text + "</p>\n";
  }
  table(header, body) {
    if (body)
      body = "<tbody>" + body + "</tbody>";
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return "<tr>\n" + content + "</tr>\n";
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
    return tag + content + "</" + type + ">\n";
  }
  strong(text) {
    return "<strong>" + text + "</strong>";
  }
  em(text) {
    return "<em>" + text + "</em>";
  }
  codespan(text) {
    return "<code>" + text + "</code>";
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(text) {
    return "<del>" + text + "</del>";
  }
  link(href, title2, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + escape(href) + '"';
    if (title2) {
      out += ' title="' + title2 + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title2, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<img src="' + href + '" alt="' + text + '"';
    if (title2) {
      out += ' title="' + title2 + '"';
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var TextRenderer = class {
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title2, text) {
    return "" + text;
  }
  image(href, title2, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser = class {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  static parse(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parse(tokens);
  }
  static parseInline(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parseInline(tokens);
  }
  parse(tokens, top = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked2, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
          continue;
        }
        case "code": {
          out += this.renderer.code(token.text, token.lang, token.escaped);
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), { header: true, align: token.align[j] });
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: token.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked2 = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked2);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked2);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
function marked(src, opt, callback) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  if (typeof opt === "function") {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done2 = function(err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done2();
    }
    delete opt.highlight;
    if (!tokens.length)
      return done2();
    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === "code") {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done2(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done2();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done2();
    }
    return;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
}
marked.options = marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const opts = merge({}, ...args);
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  let hasExtensions;
  args.forEach((pack) => {
    if (pack.extensions) {
      hasExtensions = true;
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        pack.walkTokens.call(this, token);
        if (walkTokens2) {
          walkTokens2.call(this, token);
        }
      };
    }
    if (hasExtensions) {
      opts.extensions = extensions;
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  for (const token of tokens) {
    callback.call(marked, token);
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          marked.walkTokens(cell.tokens, callback);
        }
        for (const row of token.rows) {
          for (const cell of row) {
            marked.walkTokens(cell.tokens, callback);
          }
        }
        break;
      }
      case "list": {
        marked.walkTokens(token.items, callback);
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            marked.walkTokens(token[childTokens], callback);
          });
        } else if (token.tokens) {
          marked.walkTokens(token.tokens, callback);
        }
      }
    }
  }
};
marked.parseInline = function(src, opt) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked.parseInline(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  try {
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parseInline(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
};
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = Parser.parse;
var lexer = Lexer.lex;

// app/utils/getPageData.ts
var import_front_matter = __toModule(require_front_matter());
function getPageData(source) {
  const { attributes, body } = (0, import_front_matter.default)(source);
  const html = marked.parse(body);
  return { attributes, html };
}

// app/content/download.md.js
init_react();
var download_mdx = `---
title: Download UniKey
---
# Download UniKey

Tr\u01B0\u1EDBc khi ch\u1EA1y UniKey l\u1EA7n \u0111\u1EA7u ti\xEAn, b\u1EA1n h\xE3y xem h\u01B0\u1EDBng d\u1EABn v\u1EC1 vi\u1EC7c **ch\u1EE9ng th\u1EF1c UniKey v\u1EDBi ch\u1EEF k\xFD \u0111i\u1EC7n t\u1EED** \u0111\u1EC3 ch\u1EAFc ch\u1EAFn b\u1EA1n \u0111ang d\xF9ng b\u1EA3n UniKey s\u1EA1ch, xu\u1EA5t ph\xE1t t\u1EEB t\xE1c gi\u1EA3.

### UniKey 4.3 RC5

\u0110\xE2y l\xE0 phi\xEAn b\u1EA3n UniKey m\u1EDBi nh\u1EA5t.

* C\xE1c thay \u0111\u1ED5i c\u1EA3i ti\u1EBFn c\u1EE7a phi\xEAn b\u1EA3n n\xE0y: [Xem t\u1EA1i \u0111\xE2y](/)
* [UniKey 4.3 RC5, 64 bit, ZIP file](/): Build 200929. H\u1ED7 tr\u1EE3 Windows 64-bit.
* [UniKey 4.3 RC5, 32 bit, ZIP file](/): Build 200929. H\u1ED7 tr\u1EE3 Windows 32-bit v\xE0 64-bit.
* N\u1EBFu b\u1EA1n t\xECm th\u1EA5y l\u1ED7i trong UniKey, [xin h\xE3y b\xE1o l\u1ED7i t\u1EA1i \u0111\xE2y](/).

### UniKey 4.3 RC4

\u0110\xE2y l\xE0 phi\xEAn b\u1EA3n c\u0169, \u1ED5n \u0111\u1ECBnh, \u0111\u01B0\u1EE3c ph\xE1t h\xE0nh t\u1EEB th\xE1ng 7, n\u0103m 2018.

* [UniKey 4.3 RC4, 64 bit, ZIP file](/): Build 180714. H\u1ED7 tr\u1EE3 Windows 64-bit.
* [UniKey 4.3 RC4, 32 bit, ZIP file](/): Build 180714. H\u1ED7 tr\u1EE3 Windows 32-bit.

### UVConverter

UVConverter l\xE0 m\u1ED9t ch\u01B0\u01A1ng tr\xECnh d\xF2ng l\u1EC7nh \u0111a n\u0103ng d\xF9ng \u0111\u1EC3 chuy\u1EC3n \u0111\u1ED5i gi\u1EEFa c\xE1c b\u1EA3ng m\xE3 ti\u1EBFng Vi\u1EC7t kh\xE1c nhau.(Unicode, UTF8, TCVN3, VNI\u2026)

UVConverter c\xF3 c\xE1c phi\xEAn b\u1EA3n d\xE0nh cho Windows v\xE0 Linux.

[UVConverter 1.1.3b for Windows (12 KB)](/).
[UVConverter for Linux](/)

`;

// route:D:\projects\unikey.org\app\routes\download.tsx
var handle = {
  mainPages: () => /* @__PURE__ */ import_react6.default.createElement(Link2, {
    to: "/download"
  }, "Download")
};
var loader = () => {
  return getPageData(download_mdx);
};
function DownloadPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react6.default.createElement("div", {
    dangerouslySetInnerHTML: { __html: html }
  });
}

// route:D:\projects\unikey.org\app\routes\support.tsx
var support_exports = {};
__export(support_exports, {
  default: () => SupportPage,
  handle: () => handle2,
  loader: () => loader2
});
init_react();
var import_react7 = __toModule(require_react());

// app/content/support.md.js
init_react();
var support_mdx = `---
title: Tr\u1EE3 gi\xFAp
---
# Tr\u1EE3 gi\xFAp

### D\u1EF1 \xE1n UniKey

C\xE1c th\u1EA3o lu\u1EADn, c\xE1c phi\xEAn b\u1EA3n UniKey v\xE0 m\xE3 ngu\u1ED3n \u0111\u01B0\u1EE3c \u0111\u1EB7t t\u1EA1i website d\u1EF1 \xE1n: [UniKey Project](/)

N\u1EBFu g\u1EB7p l\u1ED7i v\u1EDBi UniKey b\u1EA1n c\xF3 th\u1EC3, [b\xE1o l\u1ED7i t\u1EA1i \u0111\xE2y](/).

### C\xE1c ch\xFA \xFD

1. X\xE1c th\u1EF1c UniKey

	\u0110\u1EC3 x\xE1c \u0111\u1ECBnh UniKey b\u1EA1n \u0111ang d\xF9ng c\xF3 ngu\u1ED3n g\u1ED1c s\u1EA1ch, kh\xF4ng b\u1ECB s\u1EEDa \u0111\u1ED5i, h\xE3y [ki\u1EC3m tra ch\u1EEF k\u1EF9 s\u1ED1 c\u1EE7a Unikey](/)

2. T\u1EF1 \u0111\u1ED9ng ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n adminstrator

	T\xF9y ch\u1ECDn Kh\u1EDFi \u0111\u1ED9ng c\xF9ng Windows trong UniKey kh\xF4ng c\xF3 t\xE1c d\u1EE5ng \u0111\u1EC3 ch\u1EA1y v\u1EDBi quy\u1EC1n administrator. B\u1EA1n c\u1EA7n ph\u1EA3i d\xF9ng Task Scheduler. Xem h\u01B0\u1EDBng d\u1EABn: [Ch\u1EA1y UniKey v\u1EDBi quy\u1EC1n administrator](/)

### H\u01B0\u1EDBng d\u1EABn s\u1EED d\u1EE5ng

[H\u01B0\u1EDBng d\u1EABn s\u1EED d\u1EE5ng UniKey](/): T\xE0i li\u1EC7u n\xE0y \u0111\xE3 c\xF3 nhi\u1EC1u ph\u1EA7n \u0111\xE3 l\u1EA1c h\u1EADu. R\u1EA5t ti\u1EBFc t\xF4i ch\u01B0a c\xF3 th\u1EDDi gian c\u1EADp nh\u1EADt t\xE0i li\u1EC7u n\xE0y.

[FAQ: C\xE1c c\xE2u h\u1ECFi th\u01B0\u1EDDng g\u1EB7p v\u1EC1 UniKey](/).

### C\xE1c b\u1ED9 font ch\u1EEF ti\u1EBFng Vi\u1EC7t

D\u01B0\u1EDBi \u0111\xE2y l\xE0 c\xE1c b\u1ED9 font ch\u1EEF c\u0169, ra \u0111\u1EDDi t\u1EEB tr\u01B0\u1EDBc khi c\xF3 c\xE1c b\u1ED9 font unicode c\xF3 h\u1ED7 tr\u1EE3 ti\u1EBFng Vi\u1EC7t. B\u1EA1n ch\u1EC9 n\xEAn d\xF9ng c\xE1c font n\xE0y khi c\xF3 l\xFD do th\u1EF1c s\u1EF1 c\u1EA7n thi\u1EBFt. Trong \u0111a s\u1ED1 tr\u01B0\u1EDDng h\u1EE3p, h\xE3y d\xF9ng c\xE1c b\u1ED9 font unicode.

[TCVN-ABC fonts (2.5 MB)](/)

[VNI fonts (300 KB)](/)
`;

// route:D:\projects\unikey.org\app\routes\support.tsx
var handle2 = {
  mainPages: () => /* @__PURE__ */ import_react7.default.createElement(Link2, {
    to: "/about"
  }, "Gi\u1EDBi thi\u1EC7u")
};
var loader2 = () => {
  return getPageData(support_mdx);
};
function SupportPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react7.default.createElement("div", {
    dangerouslySetInnerHTML: { __html: html }
  });
}

// route:D:\projects\unikey.org\app\routes\source.tsx
var source_exports = {};
__export(source_exports, {
  default: () => SourcePage,
  handle: () => handle3,
  loader: () => loader3
});
init_react();
var import_react8 = __toModule(require_react());

// app/content/source.md.js
init_react();
var source_mdx = `---
title: UniKey Source Code
---
# UniKey Source Code

All source code in this page is released under the terms of [the GNU General Public License](/). By downloading UniKey source code, you agree with all the terms of this license.

### UniKey Vietnamese Input Method

* In 2001, I released the source code of the core engine UniKey Vietnamese Input Method together with the x-unikey linux package. Since then, the UniKey engine has been integrated to different keyboard input programs in various platforms: Linux, [macOS and iOS](/), FreeBSD. The core engine is still pretty much unchanged in the latest version of UniKey for Windows. You can get the engine source code in the original x-unikey linux package.

	[x-unikey source code](/)

* For educational purposes, I have also released the full UniKey 3.6 (for Windows) source code. Please note that, UniKey 3.6was built with an old version of the UniKey Input Engine. You cand find the latest engine source code in the x-unikey package above.

	[UniKey 3.62 050711 - source code](/)

### UVConverter

UVConverter is a universal command-line Vietnamese encoding converter that supports 13 different charsets/encodings (Unicode, UTF8, TCVN3, VNI\u2026). UVConverter can be built in Windows, Linux, Mac OS X.

* Tar.gz format (for Linux, Mac OS X): [UVConverter 1.1.3b](/)
* Zip format (for Windows): [UVConverter 1.1.3b](/)

`;

// route:D:\projects\unikey.org\app\routes\source.tsx
var handle3 = {
  mainPages: () => /* @__PURE__ */ import_react8.default.createElement(Link2, {
    to: "/about"
  }, "Gi\u1EDBi thi\u1EC7u")
};
var loader3 = () => {
  return getPageData(source_mdx);
};
function SourcePage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react8.default.createElement("div", {
    dangerouslySetInnerHTML: { __html: html }
  });
}

// route:D:\projects\unikey.org\app\routes\about.tsx
var about_exports = {};
__export(about_exports, {
  default: () => AboutPage,
  handle: () => handle4,
  loader: () => loader4
});
init_react();
var import_react9 = __toModule(require_react());

// app/content/about.md.js
init_react();
var about_mdx = `---
title: Gi\u1EDBi thi\u1EC7u UniKey
---
# Gi\u1EDBi thi\u1EC7u UniKey

UniKey \u0111\u01B0\u1EE3c c\xF4ng b\u1ED1 l\u1EA7n \u0111\u1EA7u ti\xEAn v\xE0o n\u0103m 1999. Ngay t\u1EEB khi ra \u0111\u1EDDi, UniKey \u0111\xE3 \u0111\u01B0\u1EE3c ng\u01B0\u1EDDi d\xF9ng \u0111\xF3n nh\u1EADn r\u1EA5t t\xEDch c\u1EF1c nh\u1EDD t\xEDnh \u0111\u01A1n gi\u1EA3n, ti\u1EC7n d\u1EE5ng, t\u1ED1c \u0111\u1ED9, tin c\u1EADy. UniKey nhanh ch\xF3ng tr\u1EDF th\xE0nh ch\u01B0\u01A1ng tr\xECnh g\xF5 ti\u1EBFng Vi\u1EC7t t\u1ED1t nh\u1EA5t, ph\u1ED5 bi\u1EBFn nh\u1EA5t tr\xEAn Windows. Hi\u1EC7n nay UniKey c\xF3 m\u1EB7t h\u1EA7u nh\u01B0 tr\xEAn t\u1EA5t c\u1EA3 c\xE1c m\xE1y t\xEDnh ch\u1EA1y Windows c\u1EE7a ng\u01B0\u1EDDi Vi\u1EC7t.

**UniKey Vietnamese Input Method**, module ch\xEDnh x\u1EED l\xFD ti\u1EBFng Vi\u1EC7t (g\u1ED3m c\xE1c ph\u01B0\u01A1ng ph\xE1p g\xF5, thu\u1EADt to\xE1n chuy\u1EC3n \u0111\u1ED5i ti\u1EBFng Vi\u1EC7t) trong UniKey, \u0111\u01B0\u1EE3c open-source t\u1EEB n\u0103m 2001. B\u1EA3n open-source c\u1EE7a UniKey ch\u1EA1y tr\xEAn X-Window (Linux) \u0111\u01B0\u1EE3c c\xF4ng b\u1ED1 t\u1EEB n\u0103m 2001, d\u01B0\u1EDBi t\xEAn **x-unikey**. **x-unikey** l\xE0 m\u1ED9t trong nh\u1EEFng ch\u01B0\u01A1ng tr\xECnh g\xF5 ti\u1EBFng Vi\u1EC7t \u0111\u1EA7u ti\xEAn tr\xEAn Linux. T\u1EEB source code x-unikey, UniKey Input Engine \u0111\xE3 \u0111\u01B0\u1EE3c s\u1EED d\u1EE5ng v\xE0 t\xEDch h\u1EE3p v\xE0o c\xE1c b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t tr\xEAn Linux sau n\xE0y. B\u1ED9 g\xF5 ph\u1ED5 bi\u1EBFn nh\u1EA5t d\xF9ng l\xF5i UniKey tr\xEAn Linux hi\u1EC7n nay l\xE0 ibus-unikey (do L\xEA Qu\u1ED1c Tu\u1EA5n ph\xE1t tri\u1EC3n).

T\u1EEB n\u0103m 2006, t\xE1c gi\u1EA3 UniKey \u0111\xE3 cho ph\xE9p Apple d\xF9ng source code x-unikey trong c\xE1c s\u1EA3n ph\u1EA9m c\u1EE7a Apple theo c\xE1c \u0111i\u1EC1u kho\u1EA3n c\u1EE7a gi\u1EA5y ph\xE9p The MIT license. T\u1EEB phi\xEAn b\u1EA3n Tiger, b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n tr\xEAn Mac OS X \u0111\xE3 b\u1EAFt \u0111\u1EA7u d\xF9ng l\xF5i UniKey. \u0110\u1EBFn n\u0103m 2010, phi\xEAn b\u1EA3n iOS 4.0 c\u0169ng t\xEDch h\u1EE3p l\xF5i UniKey. \u0110\u1EBFn nay t\u1EA5t c\u1EA3 c\xE1c thi\u1EBFt b\u1ECB iPhone, iPad \u0111\u1EC1u \u0111ang s\u1EED d\u1EE5ng UniKey cho b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n.

UniKey \u0111\u01B0\u1EE3c ph\xE1t tri\u1EC3n b\u1EDFi *Ph\u1EA1m Kim Long*. Website ch\xEDnh th\u1EE9c duy nh\u1EA5t c\u1EE7a UniKey l\xE0 [http://unikey.org](http://unikey.org). T\xE1c gi\u1EA3 kh\xF4ng ch\u1ECBu tr\xE1ch nhi\u1EC7m v\u1EC1 b\u1EA5t c\u1EE9 website n\xE0o kh\xE1c cung c\u1EA5p c\xE1c ph\u1EA7n m\u1EC1m UniKey.
`;

// route:D:\projects\unikey.org\app\routes\about.tsx
var handle4 = {
  mainPages: () => /* @__PURE__ */ import_react9.default.createElement(Link2, {
    to: "/about"
  }, "Gi\u1EDBi thi\u1EC7u")
};
var loader4 = () => {
  return getPageData(about_mdx);
};
function AboutPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react9.default.createElement("div", {
    dangerouslySetInnerHTML: { __html: html }
  });
}

// route:D:\projects\unikey.org\app\routes\apple.tsx
var apple_exports = {};
__export(apple_exports, {
  default: () => ApplePage,
  handle: () => handle5,
  loader: () => loader5
});
init_react();
var import_react10 = __toModule(require_react());

// app/content/apple.md.js
init_react();
var apple_mdx = `---
title: UniKey cho macOS v\xE0 iOS
---
# UniKey cho macOS v\xE0 iOS

T\u1EEB n\u0103m 2006, t\xF4i \u0111\xE3 cho ph\xE9p Apple d\xF9ng source code **x-unikey** (phi\xEAn b\u1EA3n UniKey cho Linux, c\xF3 ch\u1EE9a module l\xF5i **Unikey Vietnamese Input Method**) trong c\xE1c s\u1EA3n ph\u1EA9m c\u1EE7a Apple theo c\xE1c \u0111i\u1EC1u kho\u1EA3n c\u1EE7a gi\u1EA5y ph\xE9p The MIT license. T\u1EEB phi\xEAn b\u1EA3n MacOS X Leopard, b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n tr\xEAn Mac OS X \u0111\xE3 b\u1EAFt \u0111\u1EA7u d\xF9ng l\xF5i UniKey. \u0110\u1EBFn n\u0103m 2010, phi\xEAn b\u1EA3n iOS 4.0 c\u0169ng t\xEDch h\u1EE3p l\xF5i UniKey. \u0110\u1EBFn nay t\u1EA5t c\u1EA3 c\xE1c thi\u1EBFt b\u1ECB iPhone, iPad \u0111\u1EC1u \u0111ang s\u1EED d\u1EE5ng UniKey cho b\u1ED9 g\xF5 ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n tr\xEAn m\xE1y.

B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t trong macOS c\xF3 t\xEAn Simple Telex s\u1EED d\u1EE5ng l\xF5i **Unikey Vietnamese Input Method**

![Telex in MacOS](/img/macos-telex.png)

Trong iOS, x\xE1c nh\u1EADn c\u1EE7a Apple v\u1EC1 vi\u1EC7c d\xF9ng UniKey c\xF3 th\u1EC3 t\xECm th\u1EA5y trong *C\xE0i \u0111\u1EB7t - C\xE0i \u0111\u1EB7t chung - Gi\u1EDBi thi\u1EC7u - Ph\xE1p l\xFD - Th\xF4ng b\xE1o ph\xE1p l\xFD*

![iOS Legal Notice](/img/ios-legal.jpg)

`;

// route:D:\projects\unikey.org\app\routes\apple.tsx
var handle5 = {
  mainPages: () => /* @__PURE__ */ import_react10.default.createElement(Link2, {
    to: "/about"
  }, "Gi\u1EDBi thi\u1EC7u")
};
var loader5 = () => {
  return getPageData(apple_mdx);
};
function ApplePage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react10.default.createElement("div", {
    dangerouslySetInnerHTML: { __html: html }
  });
}

// route:D:\projects\unikey.org\app\routes\index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index,
  handle: () => handle6,
  loader: () => loader6
});
init_react();
var import_react11 = __toModule(require_react());

// app/content/index.md.js
init_react();
var index_mdx = `---
title: UniKey - B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t
---
# UniKey - B\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t

Unikey l\xE0 ch\u01B0\u01A1ng tr\xECnh b\xE0n ph\xEDm ti\u1EBFng Vi\u1EC7t ph\u1ED5 bi\u1EBFn nh\u1EA5t tr\xEAn Windows. Ph\u1EA7n l\xF5i x\u1EED l\xFD ti\u1EBFng Vi\u1EC7t UniKey Input Engine c\u0169ng \u0111\u01B0\u1EE3c s\u1EED d\u1EE5ng trong c\xE1c ch\u01B0\u01A1ng tr\xECnh b\xE0n ph\xEDm m\u1EB7c \u0111\u1ECBnh c\u1EE7a c\xE1c h\u1EC7 \u0111i\u1EC1u h\xE0nh Linux, Mac OS X v\xE0 \u0111\u1EB7c bi\u1EC7t l\xE0 t\u1EA5t c\u1EA3 c\xE1c thi\u1EBFt b\u1ECB d\xF9ng iOS (iPhone, iPad). UniKey Input Engine c\xF3 m\xE3 ngu\u1ED3n m\u1EDF theo gi\u1EA5y ph\xE9p GNU General Public License.

Unikey.org l\xE0 website ch\xEDnh th\u1EE9c duy nh\u1EA5t c\u1EE7a ph\u1EA7n m\u1EC1m UniKey. T\xE1c gi\u1EA3 kh\xF4ng ch\u1ECBu tr\xE1ch nhi\u1EC7m v\u1EC1 t\u1EA5t c\u1EA3 c\xE1c website kh\xE1c l\u1EA5y t\xEAn ho\u1EB7c ph\xE2n ph\u1ED1i s\u1EA3n ph\u1EA9m UniKey.

## Tin t\u1EE9c

---

* Ng\xE0y 15/10/2020:

	* Ph\xE1t h\xE0nh [UniKey 4.3 RC5](/) h\u1ED7 tr\u1EE3 tr\xECnh duy\u1EC7t Edge m\u1EDBi t\u1ED1t h\u01A1n.

* Ng\xE0y 14/7/2018:

	* Ph\xE1t h\xE0nh [UniKey 4.3 RC4](/) s\u1EEDa m\u1ED9t l\u1ED7i kh\xF4ng g\xF5 \u0111\u01B0\u1EE3c trong m\u1ED9t s\u1ED1 app (console, game, UWP apps).

* Ng\xE0y 2/7/2018:

	* Ph\xE1t h\xE0nh [UniKey 4.3 RC3](/) s\u1EEDa \u0111\u01B0\u1EE3c l\u1ED7i v\u1EDBi Excel v\xE0 c\xE1c tr\xECnh duy\u1EC7t (Chrome, Edge, Firefox, Internet Explorer).

	* Ch\xFA \xFD: B\u1EA3n 4.2 RC2 ph\xE1t h\xE0nh ng\xE0y 1/7/2018 c\xF3 l\u1ED7i v\u1EDBi Edge. L\u1ED7i n\xE0y \u0111\xE3 \u0111\u01B0\u1EE3c s\u1EEDa ngay trong b\u1EA3n 4.3 RC3.

* Ng\xE0y 23/6/2018:

	* Ph\xE1t h\xE0nh UniKey 4.3 RC1
	
	* K\u1EC3 t\u1EEB phi\xEAn b\u1EA3n 4.3, c\xE1c b\u1EA3n UniKey \u0111\u01B0\u1EE3c ph\xE1t h\xE0nh \u0111i k\xE8m v\u1EDBi ch\u1EEF k\xFD s\u1ED1 c\xF3 ch\u1EE9ng th\u1EF1c \u0111\u1EC3 ch\u1ED1ng ph\u1EA7n m\u1EC1m gi\u1EA3 m\u1EA1o. Xem th\xEAm th\xF4ng tin t\u1EA1i [Ch\u1EE9ng th\u1EF1c UniKey](/).

## C\xE1c t\xEDnh n\u0103ng

---

UniKey h\u1ED7 tr\u1EE3:

* T\u1EA5t c\u1EA3 c\xE1c b\u1EA3ng m\xE3 ph\u1ED5 bi\u1EBFn:

	* Unicode, TCVN (ABC)

	* VIQR, VNI, VPS, VISCII, BK HCM1, BK HCM2,\u2026

	* Unicode UTF-8, Unicode NCR - for Web editors.

* 2 ph\u01B0\u01A1ng ph\xE1p g\xF5 th\xF4ng d\u1EE5ng: TELEX, VNI

* Cho ph\xE9p t\u1EF1 \u0111\u1ECBnh ngh\u0129a ki\u1EC3u g\xF5

* Cho ph\xE9p g\xF5 t\u1EAFt v\xE0 \u0111\u1ECBnh ngh\u0129a b\u1EA3ng g\xF5 t\u1EAFt.

* Ch\u1EA1y tr\xEAn t\u1EA5t c\u1EA3 c\xE1c phi\xEAn b\u1EA3n Windows: 10, 8, 7, Vista, 2000, XP, 9x.

UniKey r\u1EA5t g\u1ECDn nh\u1EB9, kh\xF4ng c\u1EA7n c\xE0i \u0111\u1EB7t.

`;

// route:D:\projects\unikey.org\app\routes\index.tsx
var handle6 = {
  mainPages: () => /* @__PURE__ */ import_react11.default.createElement(Link2, {
    to: "/"
  }, "Trang ch\u1EE7")
};
var loader6 = () => {
  return getPageData(index_mdx);
};
function Index() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react11.default.createElement("div", {
    dangerouslySetInnerHTML: { __html: html }
  });
}

// route:D:\projects\unikey.org\app\routes\linux.tsx
var linux_exports = {};
__export(linux_exports, {
  default: () => LinuxPage,
  handle: () => handle7,
  loader: () => loader7
});
init_react();
var import_react12 = __toModule(require_react());

// app/content/linux.md.js
init_react();
var linux_mdx = `---
title: UniKey Software for Linux
---
# UniKey Software for Linux

## X-Unikey

X-Unikey is Unikey ported to Linux and FreeBSD. X-Unikey lets you type Vietnamese in X Window environment. It has been tested with many popular programs, such as OpenOffice, emacs, vim, QT applications, GTK applications\u2026 X-Unikey has all the features of the Windows version, except that its GUI is still too simplified. All options are set through configuration file or keyboard shortcuts.

### Download X-Unikey

* Source code: [x-unikey 1.0.4](/)

### X-Unikey User Manual in Vietnamese

(User Manual in English is provided in the above packages)

* [X-Unikey Manual, HTML](/), edited by Pham Thanh Long.
* [X-Unikey Manual, PDF](/), LaTeX typesetting by Phan Vinh Thinh.

## UVConverter

UVConverter is a universal command-line Vietnamese encoding converter which supports all popular charsets/encodings (Unicode, UTF8, TCVN3, VNI\u2026). UVConverter is available in Windows, Linux, and Mac OS X.

* [UVConverter 1.1.3b for Windows (12 KB)](/).
* [UVConverter 1.1.3b - Source code](/).

## X-Chat Autovn Plugin

Autovn is a plugin for X-Chat that automatically converts all messages from VIQR encoding to UTF-8 encoding.

* [Autovn 0.2b (1/3/2004)- source code](/)

## Pine Vietnamese HOWTO

This HOWTO shows how Pine can be setup to read and write Vietnamese emails. One special feature is the ability to automatically convert back and forth between VIQR and Unicode charsets as you read or send emails. Emails received in VIQR charset can be viewed as if they were written in unicode!

* [Click here to read](/)

All software in this page are released under the terms of the GNU General Public License.
`;

// route:D:\projects\unikey.org\app\routes\linux.tsx
var handle7 = {
  mainPages: () => /* @__PURE__ */ import_react12.default.createElement(Link2, {
    to: "/about"
  }, "Gi\u1EDBi thi\u1EC7u")
};
var loader7 = () => {
  return getPageData(linux_mdx);
};
function LinuxPage() {
  const { attributes, html } = useLoaderData();
  return /* @__PURE__ */ import_react12.default.createElement("div", {
    dangerouslySetInnerHTML: { __html: html }
  });
}

// route:D:\projects\unikey.org\app\routes\blog.tsx
var blog_exports = {};
__export(blog_exports, {
  default: () => BlogPage,
  handle: () => handle8
});
init_react();
var import_react13 = __toModule(require_react());
var handle8 = {
  mainPages: () => /* @__PURE__ */ import_react13.default.createElement(Link2, {
    to: "/blog"
  }, "Blog")
};
function BlogPage() {
  return /* @__PURE__ */ import_react13.default.createElement(import_react13.default.Fragment, null, /* @__PURE__ */ import_react13.default.createElement("h1", null, "Blog"), /* @__PURE__ */ import_react13.default.createElement(Outlet, null));
}

// route:D:\projects\unikey.org\app\routes\blog\$slug.tsx
var slug_exports = {};
__export(slug_exports, {
  default: () => Blog3
});
init_react();
var import_react14 = __toModule(require_react());
function Blog3() {
  return /* @__PURE__ */ import_react14.default.createElement(import_react14.default.Fragment, null, /* @__PURE__ */ import_react14.default.createElement("h2", null, "Blog 3"));
}

// route:D:\projects\unikey.org\app\routes\blog\index.tsx
var blog_exports2 = {};
__export(blog_exports2, {
  default: () => AboutPageIndex
});
init_react();
var import_react15 = __toModule(require_react());
function AboutPageIndex() {
  return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement("ul", null, /* @__PURE__ */ import_react15.default.createElement("li", null, /* @__PURE__ */ import_react15.default.createElement(Link2, {
    to: "/blog/blog1"
  }, "Blog1")), /* @__PURE__ */ import_react15.default.createElement("li", null, /* @__PURE__ */ import_react15.default.createElement(Link2, {
    to: "/blog/blog2"
  }, "Blog2")), /* @__PURE__ */ import_react15.default.createElement("li", null, /* @__PURE__ */ import_react15.default.createElement(Link2, {
    to: "/blog/blog3"
  }, "Blog3"))));
}

// server-assets-manifest:@remix-run/dev/assets-manifest
init_react();
var assets_manifest_default = { "version": "df79a6d1", "entry": { "module": "/build/entry.client-UMQWG5JW.js", "imports": ["/build/_shared/chunk-KFJJVXGC.js", "/build/_shared/chunk-E7VMOUYL.js"] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "module": "/build/root-HWZ4SVNY.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": true, "hasErrorBoundary": true }, "routes/about": { "id": "routes/about", "parentId": "root", "path": "about", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/about-ROPLOH2D.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/apple": { "id": "routes/apple", "parentId": "root", "path": "apple", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/apple-PMWXT7Y2.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/blog": { "id": "routes/blog", "parentId": "root", "path": "blog", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/blog-RSA7OFUH.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/blog/$slug": { "id": "routes/blog/$slug", "parentId": "routes/blog", "path": ":slug", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/blog/$slug-4LMX2MVR.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/blog/index": { "id": "routes/blog/index", "parentId": "routes/blog", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/blog/index-RDY63VFM.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/download": { "id": "routes/download", "parentId": "root", "path": "download", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/download-ZOEQBRRM.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/index": { "id": "routes/index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/index-IEXM4BQY.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/linux": { "id": "routes/linux", "parentId": "root", "path": "linux", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/linux-P2YPTCAN.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/source": { "id": "routes/source", "parentId": "root", "path": "source", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/source-YIMUC4WX.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/support": { "id": "routes/support", "parentId": "root", "path": "support", "index": void 0, "caseSensitive": void 0, "module": "/build/routes/support-4USJIQSV.js", "imports": void 0, "hasAction": false, "hasLoader": true, "hasCatchBoundary": false, "hasErrorBoundary": false } }, "url": "/build/manifest-DF79A6D1.js" };

// server-entry-module:@remix-run/dev/server-build
var entry = { module: entry_server_exports };
var routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/download": {
    id: "routes/download",
    parentId: "root",
    path: "download",
    index: void 0,
    caseSensitive: void 0,
    module: download_exports
  },
  "routes/support": {
    id: "routes/support",
    parentId: "root",
    path: "support",
    index: void 0,
    caseSensitive: void 0,
    module: support_exports
  },
  "routes/source": {
    id: "routes/source",
    parentId: "root",
    path: "source",
    index: void 0,
    caseSensitive: void 0,
    module: source_exports
  },
  "routes/about": {
    id: "routes/about",
    parentId: "root",
    path: "about",
    index: void 0,
    caseSensitive: void 0,
    module: about_exports
  },
  "routes/apple": {
    id: "routes/apple",
    parentId: "root",
    path: "apple",
    index: void 0,
    caseSensitive: void 0,
    module: apple_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: routes_exports
  },
  "routes/linux": {
    id: "routes/linux",
    parentId: "root",
    path: "linux",
    index: void 0,
    caseSensitive: void 0,
    module: linux_exports
  },
  "routes/blog": {
    id: "routes/blog",
    parentId: "root",
    path: "blog",
    index: void 0,
    caseSensitive: void 0,
    module: blog_exports
  },
  "routes/blog/$slug": {
    id: "routes/blog/$slug",
    parentId: "routes/blog",
    path: ":slug",
    index: void 0,
    caseSensitive: void 0,
    module: slug_exports
  },
  "routes/blog/index": {
    id: "routes/blog/index",
    parentId: "routes/blog",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: blog_exports2
  }
};

// server.js
var handleRequest2 = createPagesFunctionHandler({
  build: server_build_exports,
  mode: "development",
  getLoadContext: (context) => context.env
});
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/**
 * @remix-run/cloudflare-pages v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vZGV2L2NvbXBpbGVyL3NoaW1zL3JlYWN0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvanNlc2MvanNlc2MuanMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpldmVudHMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpwcm9jZXNzIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9pbmhlcml0cy5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnV0aWwiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpidWZmZXIiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9idWZmZXItbGlzdC5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnN0cmluZ19kZWNvZGVyIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6c3RyZWFtIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6c3RyZWFtIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvY29tbW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbWFyay5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3N0ci5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2VxLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL251bGwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Jvb2wuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvZmxvYXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvanNvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS90aW1lc3RhbXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL29tYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL3JlZ2V4cC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvZnVuY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mcm9udC1tYXR0ZXIvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2Zyb250LW1hdHRlci9ub2RlX21vZHVsZXMvanMteWFtbC9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZnJvbnQtbWF0dGVyL2luZGV4LmpzIiwgIi4uL3NlcnZlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9nbG9iYWxzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL2Nvb2tpZVNpZ25pbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vc2Vzc2lvbnMvY2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yZXNwb25zZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3NlcnZlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZGF0YS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZW50cnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2Vycm9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vaGVhZGVycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vcm91dGVNYXRjaGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsICIuLi8uLi9wYWNrYWdlcy9yZWFjdC1yb3V0ZXIvaW5kZXgudHN4IiwgIi4uLy4uL3BhY2thZ2VzL3JlYWN0LXJvdXRlci1kb20vaW5kZXgudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9tb2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yb3V0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3NlcnZlckhhbmRvZmYuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vd29ya2VyLmpzIiwgInNlcnZlci1lbnRyeS1tb2R1bGU6QHJlbWl4LXJ1bi9kZXYvc2VydmVyLWJ1aWxkIiwgIi4uL2FwcC9lbnRyeS5zZXJ2ZXIudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9yZW1peC9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9jb21wb25lbnRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9lcnJvckJvdW5kYXJpZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2ludmFyaWFudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbGlua3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTW9kdWxlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbWFya3VwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9yb3V0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2RhdGEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3RyYW5zaXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTWF0Y2hpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3Njcm9sbC1yZXN0b3JhdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vc2VydmVyLmpzIiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb290LnRzeCIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxkb3dubG9hZC50c3giLCAiLi4vYXBwL3V0aWxzL2dldFBhZ2VEYXRhLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanMiLCAiLi4vYXBwL2NvbnRlbnQvZG93bmxvYWQubWQuanMiLCAicm91dGU6RDpcXHByb2plY3RzXFx1bmlrZXkub3JnXFxhcHBcXHJvdXRlc1xcc3VwcG9ydC50c3giLCAiLi4vYXBwL2NvbnRlbnQvc3VwcG9ydC5tZC5qcyIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxzb3VyY2UudHN4IiwgIi4uL2FwcC9jb250ZW50L3NvdXJjZS5tZC5qcyIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxhYm91dC50c3giLCAiLi4vYXBwL2NvbnRlbnQvYWJvdXQubWQuanMiLCAicm91dGU6RDpcXHByb2plY3RzXFx1bmlrZXkub3JnXFxhcHBcXHJvdXRlc1xcYXBwbGUudHN4IiwgIi4uL2FwcC9jb250ZW50L2FwcGxlLm1kLmpzIiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb3V0ZXNcXGluZGV4LnRzeCIsICIuLi9hcHAvY29udGVudC9pbmRleC5tZC5qcyIsICJyb3V0ZTpEOlxccHJvamVjdHNcXHVuaWtleS5vcmdcXGFwcFxccm91dGVzXFxsaW51eC50c3giLCAiLi4vYXBwL2NvbnRlbnQvbGludXgubWQuanMiLCAicm91dGU6RDpcXHByb2plY3RzXFx1bmlrZXkub3JnXFxhcHBcXHJvdXRlc1xcYmxvZy50c3giLCAicm91dGU6RDpcXHByb2plY3RzXFx1bmlrZXkub3JnXFxhcHBcXHJvdXRlc1xcYmxvZ1xcJHNsdWcudHN4IiwgInJvdXRlOkQ6XFxwcm9qZWN0c1xcdW5pa2V5Lm9yZ1xcYXBwXFxyb3V0ZXNcXGJsb2dcXGluZGV4LnRzeCIsICJzZXJ2ZXItYXNzZXRzLW1hbmlmZXN0OkByZW1peC1ydW4vZGV2L2Fzc2V0cy1tYW5pZmVzdCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsICIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5leHBvcnQgeyBSZWFjdCB9O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZGVmYXVsdFBhcnNlT3B0aW9ucyA9IHtcbiAgZGVjb2RlVmFsdWVzOiB0cnVlLFxuICBtYXA6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxufTtcblxuZnVuY3Rpb24gaXNOb25FbXB0eVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgISFzdHIudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzZXRDb29raWVWYWx1ZSwgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBzZXRDb29raWVWYWx1ZS5zcGxpdChcIjtcIikuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpO1xuICB2YXIgbmFtZVZhbHVlID0gcGFydHMuc2hpZnQoKS5zcGxpdChcIj1cIik7XG4gIHZhciBuYW1lID0gbmFtZVZhbHVlLnNoaWZ0KCk7XG4gIHZhciB2YWx1ZSA9IG5hbWVWYWx1ZS5qb2luKFwiPVwiKTsgLy8gZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgPSwgam9pbmVkIGJ5IGEgXCI9XCIgaWYgdGhlcmUgd2FzIG1vcmUgdGhhbiBvbmUgcGFydFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICB0cnkge1xuICAgIHZhbHVlID0gb3B0aW9ucy5kZWNvZGVWYWx1ZXMgPyBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7IC8vIGRlY29kZSBjb29raWUgdmFsdWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcInNldC1jb29raWUtcGFyc2VyIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGRlY29kaW5nIGEgY29va2llIHdpdGggdmFsdWUgJ1wiICtcbiAgICAgICAgdmFsdWUgK1xuICAgICAgICBcIicuIFNldCBvcHRpb25zLmRlY29kZVZhbHVlcyB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgZmVhdHVyZS5cIixcbiAgICAgIGVcbiAgICApO1xuICB9XG5cbiAgdmFyIGNvb2tpZSA9IHtcbiAgICBuYW1lOiBuYW1lLCAvLyBncmFiIGV2ZXJ5dGhpbmcgYmVmb3JlIHRoZSBmaXJzdCA9XG4gICAgdmFsdWU6IHZhbHVlLFxuICB9O1xuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB2YXIgc2lkZXMgPSBwYXJ0LnNwbGl0KFwiPVwiKTtcbiAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gc2lkZXMuam9pbihcIj1cIik7XG4gICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImh0dHBvbmx5XCIpIHtcbiAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgY29va2llLnNhbWVTaXRlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb2tpZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29va2llO1xufVxuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucylcbiAgICA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG5cbiAgaWYgKCFpbnB1dCkge1xuICAgIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnB1dC5oZWFkZXJzICYmIGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgLy8gZmFzdC1wYXRoIGZvciBub2RlLmpzICh3aGljaCBhdXRvbWF0aWNhbGx5IG5vcm1hbGl6ZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyLWNhc2VcbiAgICBpbnB1dCA9IGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdO1xuICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICAvLyBzbG93LXBhdGggZm9yIG90aGVyIGVudmlyb25tZW50cyAtIHNlZSAjMjVcbiAgICB2YXIgc2NoID1cbiAgICAgIGlucHV0LmhlYWRlcnNbXG4gICAgICAgIE9iamVjdC5rZXlzKGlucHV0LmhlYWRlcnMpLmZpbmQoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCI7XG4gICAgICAgIH0pXG4gICAgICBdO1xuICAgIC8vIHdhcm4gaWYgY2FsbGVkIG9uIGEgcmVxdWVzdC1saWtlIG9iamVjdCB3aXRoIGEgY29va2llIGhlYWRlciByYXRoZXIgdGhhbiBhIHNldC1jb29raWUgaGVhZGVyIC0gc2VlICMzNCwgMzZcbiAgICBpZiAoIXNjaCAmJiBpbnB1dC5oZWFkZXJzLmNvb2tpZSAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJXYXJuaW5nOiBzZXQtY29va2llLXBhcnNlciBhcHBlYXJzIHRvIGhhdmUgYmVlbiBjYWxsZWQgb24gYSByZXF1ZXN0IG9iamVjdC4gSXQgaXMgZGVzaWduZWQgdG8gcGFyc2UgU2V0LUNvb2tpZSBoZWFkZXJzIGZyb20gcmVzcG9uc2VzLCBub3QgQ29va2llIGhlYWRlcnMgZnJvbSByZXF1ZXN0cy4gU2V0IHRoZSBvcHRpb24ge3NpbGVudDogdHJ1ZX0gdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpbnB1dCA9IHNjaDtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBbaW5wdXRdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29va2llcyA9IHt9O1xuICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykucmVkdWNlKGZ1bmN0aW9uIChjb29raWVzLCBzdHIpIHtcbiAgICAgIHZhciBjb29raWUgPSBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgY29va2llc1tjb29raWUubmFtZV0gPSBjb29raWU7XG4gICAgICByZXR1cm4gY29va2llcztcbiAgICB9LCBjb29raWVzKTtcbiAgfVxufVxuXG4vKlxuICBTZXQtQ29va2llIGhlYWRlciBmaWVsZC12YWx1ZXMgYXJlIHNvbWV0aW1lcyBjb21tYSBqb2luZWQgaW4gb25lIHN0cmluZy4gVGhpcyBzcGxpdHMgdGhlbSB3aXRob3V0IGNob2tpbmcgb24gY29tbWFzXG4gIHRoYXQgYXJlIHdpdGhpbiBhIHNpbmdsZSBzZXQtY29va2llIGZpZWxkLXZhbHVlLCBzdWNoIGFzIGluIHRoZSBFeHBpcmVzIHBvcnRpb24uXG5cbiAgVGhpcyBpcyB1bmNvbW1vbiwgYnV0IGV4cGxpY2l0bHkgYWxsb3dlZCAtIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNiNzZWN0aW9uLTQuMlxuICBOb2RlLmpzIGRvZXMgdGhpcyBmb3IgZXZlcnkgaGVhZGVyICpleGNlcHQqIHNldC1jb29raWUgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZDVlMzYzYjc3ZWJhZjFjYWY2N2NkNzUyODIyNGI2NTFjODY4MTVjMS9saWIvX2h0dHBfaW5jb21pbmcuanMjTDEyOFxuICBSZWFjdCBOYXRpdmUncyBmZXRjaCBkb2VzIHRoaXMgZm9yICpldmVyeSogaGVhZGVyLCBpbmNsdWRpbmcgc2V0LWNvb2tpZS5cblxuICBCYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9qMm9iamMvY29tbWl0LzE2ODIwZmRiYzhmNzZjYTBjMzM0NzI4MTBjZTBjYjAzZDIwZWZlMjVcbiAgQ3JlZGl0cyB0bzogaHR0cHM6Ly9naXRodWIuY29tL3RvbWJhbGwgZm9yIG9yaWdpbmFsIGFuZCBodHRwczovL2dpdGh1Yi5jb20vY2hydXNhcnQgZm9yIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiovXG5mdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llc1N0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzU3RyaW5nKSkge1xuICAgIHJldHVybiBjb29raWVzU3RyaW5nO1xuICB9XG4gIGlmICh0eXBlb2YgY29va2llc1N0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgY2g7XG4gIHZhciBsYXN0Q29tbWE7XG4gIHZhciBuZXh0U3RhcnQ7XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG5cbiAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gIH1cblxuICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHBvcztcbiAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICBpZiAoY2ggPT09IFwiLFwiKSB7XG4gICAgICAgIC8vICcsJyBpcyBhIGNvb2tpZSBzZXBhcmF0b3IgaWYgd2UgaGF2ZSBsYXRlciBmaXJzdCAnPScsIG5vdCAnOycgb3IgJywnXG4gICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgcG9zICs9IDE7XG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50bHkgc3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgLy8gd2UgZm91bmQgY29va2llcyBzZXBhcmF0b3JcbiAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgIC8vIHBvcyBpcyBpbnNpZGUgdGhlIG5leHQgY29va2llLCBzbyBiYWNrIHVwIGFuZCByZXR1cm4gaXQuXG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHBhcmFtICcsJyBvciBwYXJhbSBzZXBhcmF0b3IgJzsnLFxuICAgICAgICAgIC8vIHdlIGNvbnRpbnVlIGZyb20gdGhhdCBjb21tYVxuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29va2llc1N0cmluZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbm1vZHVsZS5leHBvcnRzLnNwbGl0Q29va2llc1N0cmluZyA9IHNwbGl0Q29va2llc1N0cmluZztcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9iamVjdCA9IHt9O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5jb25zdCBmb3JPd24gPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcblx0XHRcdGNhbGxiYWNrKGtleSwgb2JqZWN0W2tleV0pO1xuXHRcdH1cblx0fVxufTtcblxuY29uc3QgZXh0ZW5kID0gKGRlc3RpbmF0aW9uLCBzb3VyY2UpID0+IHtcblx0aWYgKCFzb3VyY2UpIHtcblx0XHRyZXR1cm4gZGVzdGluYXRpb247XG5cdH1cblx0Zm9yT3duKHNvdXJjZSwgKGtleSwgdmFsdWUpID0+IHtcblx0XHRkZXN0aW5hdGlvbltrZXldID0gdmFsdWU7XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb247XG59O1xuXG5jb25zdCBmb3JFYWNoID0gKGFycmF5LCBjYWxsYmFjaykgPT4ge1xuXHRjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdGxldCBpbmRleCA9IC0xO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdGNhbGxiYWNrKGFycmF5W2luZGV4XSk7XG5cdH1cbn07XG5cbmNvbnN0IGZvdXJIZXhFc2NhcGUgPSAoaGV4KSA9PiB7XG5cdHJldHVybiAnXFxcXHUnICsgKCcwMDAwJyArIGhleCkuc2xpY2UoLTQpO1xufVxuXG5jb25zdCBoZXhhZGVjaW1hbCA9IChjb2RlLCBsb3dlcmNhc2UpID0+IHtcblx0bGV0IGhleGFkZWNpbWFsID0gY29kZS50b1N0cmluZygxNik7XG5cdGlmIChsb3dlcmNhc2UpIHJldHVybiBoZXhhZGVjaW1hbDtcblx0cmV0dXJuIGhleGFkZWNpbWFsLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5jb25zdCB0b1N0cmluZyA9IG9iamVjdC50b1N0cmluZztcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNCdWZmZXIgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKTtcbn07XG5jb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4ge1xuXHQvLyBUaGlzIGlzIGEgdmVyeSBzaW1wbGUgY2hlY2ssIGJ1dCBpdFx1MjAxOXMgZ29vZCBlbm91Z2ggZm9yIHdoYXQgd2UgbmVlZC5cblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE9iamVjdF0nO1xufTtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcblx0XHR0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG5cdFx0dG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG59O1xuY29uc3QgaXNNYXAgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE1hcF0nO1xufTtcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBTZXRdJztcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lc2NhcGVzI3NpbmdsZVxuY29uc3Qgc2luZ2xlRXNjYXBlcyA9IHtcblx0J1xcXFwnOiAnXFxcXFxcXFwnLFxuXHQnXFxiJzogJ1xcXFxiJyxcblx0J1xcZic6ICdcXFxcZicsXG5cdCdcXG4nOiAnXFxcXG4nLFxuXHQnXFxyJzogJ1xcXFxyJyxcblx0J1xcdCc6ICdcXFxcdCdcblx0Ly8gYFxcdmAgaXMgb21pdHRlZCBpbnRlbnRpb25hbGx5LCBiZWNhdXNlIGluIElFIDwgOSwgJ1xcdicgPT0gJ3YnLlxuXHQvLyAnXFx2JzogJ1xcXFx4MEInXG59O1xuY29uc3QgcmVnZXhTaW5nbGVFc2NhcGUgPSAvW1xcXFxcXGJcXGZcXG5cXHJcXHRdLztcblxuY29uc3QgcmVnZXhEaWdpdCA9IC9bMC05XS87XG5jb25zdCByZWdleFdoaXRlc3BhY2UgPSAvW1xceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwXS87XG5cbmNvbnN0IGVzY2FwZUV2ZXJ5dGhpbmdSZWdleCA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSl8KFtcXHVEODAwLVxcdURGRkZdKXwoWydcImBdKXxbXl0vZztcbmNvbnN0IGVzY2FwZU5vbkFzY2lpUmVnZXggPSAvKFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0pfChbXFx1RDgwMC1cXHVERkZGXSl8KFsnXCJgXSl8W14gISMtJlxcKC1cXFtcXF0tX2Etfl0vZztcblxuY29uc3QganNlc2MgPSAoYXJndW1lbnQsIG9wdGlvbnMpID0+IHtcblx0Y29uc3QgaW5jcmVhc2VJbmRlbnRhdGlvbiA9ICgpID0+IHtcblx0XHRvbGRJbmRlbnQgPSBpbmRlbnQ7XG5cdFx0KytvcHRpb25zLmluZGVudExldmVsO1xuXHRcdGluZGVudCA9IG9wdGlvbnMuaW5kZW50LnJlcGVhdChvcHRpb25zLmluZGVudExldmVsKVxuXHR9O1xuXHQvLyBIYW5kbGUgb3B0aW9uc1xuXHRjb25zdCBkZWZhdWx0cyA9IHtcblx0XHQnZXNjYXBlRXZlcnl0aGluZyc6IGZhbHNlLFxuXHRcdCdtaW5pbWFsJzogZmFsc2UsXG5cdFx0J2lzU2NyaXB0Q29udGV4dCc6IGZhbHNlLFxuXHRcdCdxdW90ZXMnOiAnc2luZ2xlJyxcblx0XHQnd3JhcCc6IGZhbHNlLFxuXHRcdCdlczYnOiBmYWxzZSxcblx0XHQnanNvbic6IGZhbHNlLFxuXHRcdCdjb21wYWN0JzogdHJ1ZSxcblx0XHQnbG93ZXJjYXNlSGV4JzogZmFsc2UsXG5cdFx0J251bWJlcnMnOiAnZGVjaW1hbCcsXG5cdFx0J2luZGVudCc6ICdcXHQnLFxuXHRcdCdpbmRlbnRMZXZlbCc6IDAsXG5cdFx0J19faW5saW5lMV9fJzogZmFsc2UsXG5cdFx0J19faW5saW5lMl9fJzogZmFsc2Vcblx0fTtcblx0Y29uc3QganNvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uO1xuXHRpZiAoanNvbikge1xuXHRcdGRlZmF1bHRzLnF1b3RlcyA9ICdkb3VibGUnO1xuXHRcdGRlZmF1bHRzLndyYXAgPSB0cnVlO1xuXHR9XG5cdG9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRpZiAoXG5cdFx0b3B0aW9ucy5xdW90ZXMgIT0gJ3NpbmdsZScgJiZcblx0XHRvcHRpb25zLnF1b3RlcyAhPSAnZG91YmxlJyAmJlxuXHRcdG9wdGlvbnMucXVvdGVzICE9ICdiYWNrdGljaydcblx0KSB7XG5cdFx0b3B0aW9ucy5xdW90ZXMgPSAnc2luZ2xlJztcblx0fVxuXHRjb25zdCBxdW90ZSA9IG9wdGlvbnMucXVvdGVzID09ICdkb3VibGUnID9cblx0XHQnXCInIDpcblx0XHQob3B0aW9ucy5xdW90ZXMgPT0gJ2JhY2t0aWNrJyA/XG5cdFx0XHQnYCcgOlxuXHRcdFx0J1xcJydcblx0XHQpO1xuXHRjb25zdCBjb21wYWN0ID0gb3B0aW9ucy5jb21wYWN0O1xuXHRjb25zdCBsb3dlcmNhc2VIZXggPSBvcHRpb25zLmxvd2VyY2FzZUhleDtcblx0bGV0IGluZGVudCA9IG9wdGlvbnMuaW5kZW50LnJlcGVhdChvcHRpb25zLmluZGVudExldmVsKTtcblx0bGV0IG9sZEluZGVudCA9ICcnO1xuXHRjb25zdCBpbmxpbmUxID0gb3B0aW9ucy5fX2lubGluZTFfXztcblx0Y29uc3QgaW5saW5lMiA9IG9wdGlvbnMuX19pbmxpbmUyX187XG5cdGNvbnN0IG5ld0xpbmUgPSBjb21wYWN0ID8gJycgOiAnXFxuJztcblx0bGV0IHJlc3VsdDtcblx0bGV0IGlzRW1wdHkgPSB0cnVlO1xuXHRjb25zdCB1c2VCaW5OdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdiaW5hcnknO1xuXHRjb25zdCB1c2VPY3ROdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdvY3RhbCc7XG5cdGNvbnN0IHVzZURlY051bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2RlY2ltYWwnO1xuXHRjb25zdCB1c2VIZXhOdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdoZXhhZGVjaW1hbCc7XG5cblx0aWYgKGpzb24gJiYgYXJndW1lbnQgJiYgaXNGdW5jdGlvbihhcmd1bWVudC50b0pTT04pKSB7XG5cdFx0YXJndW1lbnQgPSBhcmd1bWVudC50b0pTT04oKTtcblx0fVxuXG5cdGlmICghaXNTdHJpbmcoYXJndW1lbnQpKSB7XG5cdFx0aWYgKGlzTWFwKGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGFyZ3VtZW50LnNpemUgPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ25ldyBNYXAoKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbXBhY3QpIHtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTFfXyA9IHRydWU7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnbmV3IE1hcCgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdH1cblx0XHRpZiAoaXNTZXQoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoYXJndW1lbnQuc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnbmV3IFNldCgpJztcblx0XHRcdH1cblx0XHRcdHJldHVybiAnbmV3IFNldCgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdH1cblx0XHRpZiAoaXNCdWZmZXIoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoYXJndW1lbnQubGVuZ3RoID09IDApIHtcblx0XHRcdFx0cmV0dXJuICdCdWZmZXIuZnJvbShbXSknO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICdCdWZmZXIuZnJvbSgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdH1cblx0XHRpZiAoaXNBcnJheShhcmd1bWVudCkpIHtcblx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0b3B0aW9ucy53cmFwID0gdHJ1ZTtcblx0XHRcdGlmIChpbmxpbmUxKSB7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUxX18gPSBmYWxzZTtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTJfXyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlubGluZTIpIHtcblx0XHRcdFx0aW5jcmVhc2VJbmRlbnRhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yRWFjaChhcmd1bWVudCwgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdGlzRW1wdHkgPSBmYWxzZTtcblx0XHRcdFx0aWYgKGlubGluZTIpIHtcblx0XHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0KGNvbXBhY3QgfHwgaW5saW5lMiA/ICcnIDogaW5kZW50KSArXG5cdFx0XHRcdFx0anNlc2ModmFsdWUsIG9wdGlvbnMpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0VtcHR5KSB7XG5cdFx0XHRcdHJldHVybiAnW10nO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlubGluZTIpIHtcblx0XHRcdFx0cmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICdbJyArIG5ld0xpbmUgKyByZXN1bHQuam9pbignLCcgKyBuZXdMaW5lKSArIG5ld0xpbmUgK1xuXHRcdFx0XHQoY29tcGFjdCA/ICcnIDogb2xkSW5kZW50KSArICddJztcblx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGpzb24pIHtcblx0XHRcdFx0Ly8gU29tZSBudW1iZXIgdmFsdWVzIChlLmcuIGBJbmZpbml0eWApIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OLlxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJndW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZURlY051bWJlcnMpIHtcblx0XHRcdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlSGV4TnVtYmVycykge1xuXHRcdFx0XHRsZXQgaGV4YWRlY2ltYWwgPSBhcmd1bWVudC50b1N0cmluZygxNik7XG5cdFx0XHRcdGlmICghbG93ZXJjYXNlSGV4KSB7XG5cdFx0XHRcdFx0aGV4YWRlY2ltYWwgPSBoZXhhZGVjaW1hbC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnMHgnICsgaGV4YWRlY2ltYWw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlQmluTnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gJzBiJyArIGFyZ3VtZW50LnRvU3RyaW5nKDIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZU9jdE51bWJlcnMpIHtcblx0XHRcdFx0cmV0dXJuICcwbycgKyBhcmd1bWVudC50b1N0cmluZyg4KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc09iamVjdChhcmd1bWVudCkpIHtcblx0XHRcdGlmIChqc29uKSB7XG5cdFx0XHRcdC8vIEZvciBzb21lIHZhbHVlcyAoZS5nLiBgdW5kZWZpbmVkYCwgYGZ1bmN0aW9uYCBvYmplY3RzKSxcblx0XHRcdFx0Ly8gYEpTT04uc3RyaW5naWZ5KHZhbHVlKWAgcmV0dXJucyBgdW5kZWZpbmVkYCAod2hpY2ggaXNuXHUyMDE5dCB2YWxpZFxuXHRcdFx0XHQvLyBKU09OKSBpbnN0ZWFkIG9mIGAnbnVsbCdgLlxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJndW1lbnQpIHx8ICdudWxsJztcblx0XHRcdH1cblx0XHRcdHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xuXHRcdH0gZWxzZSB7IC8vIGl0XHUyMDE5cyBhbiBvYmplY3Rcblx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0b3B0aW9ucy53cmFwID0gdHJ1ZTtcblx0XHRcdGluY3JlYXNlSW5kZW50YXRpb24oKTtcblx0XHRcdGZvck93bihhcmd1bWVudCwgKGtleSwgdmFsdWUpID0+IHtcblx0XHRcdFx0aXNFbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHQoY29tcGFjdCA/ICcnIDogaW5kZW50KSArXG5cdFx0XHRcdFx0anNlc2Moa2V5LCBvcHRpb25zKSArICc6JyArXG5cdFx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6ICcgJykgK1xuXHRcdFx0XHRcdGpzZXNjKHZhbHVlLCBvcHRpb25zKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoaXNFbXB0eSkge1xuXHRcdFx0XHRyZXR1cm4gJ3t9Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiAneycgKyBuZXdMaW5lICsgcmVzdWx0LmpvaW4oJywnICsgbmV3TGluZSkgKyBuZXdMaW5lICtcblx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IG9sZEluZGVudCkgKyAnfSc7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgcmVnZXggPSBvcHRpb25zLmVzY2FwZUV2ZXJ5dGhpbmcgPyBlc2NhcGVFdmVyeXRoaW5nUmVnZXggOiBlc2NhcGVOb25Bc2NpaVJlZ2V4O1xuXHRyZXN1bHQgPSBhcmd1bWVudC5yZXBsYWNlKHJlZ2V4LCAoY2hhciwgcGFpciwgbG9uZSwgcXVvdGVDaGFyLCBpbmRleCwgc3RyaW5nKSA9PiB7XG5cdFx0aWYgKHBhaXIpIHtcblx0XHRcdGlmIChvcHRpb25zLm1pbmltYWwpIHJldHVybiBwYWlyO1xuXHRcdFx0Y29uc3QgZmlyc3QgPSBwYWlyLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRjb25zdCBzZWNvbmQgPSBwYWlyLmNoYXJDb2RlQXQoMSk7XG5cdFx0XHRpZiAob3B0aW9ucy5lczYpIHtcblx0XHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRcdGNvbnN0IGNvZGVQb2ludCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG5cdFx0XHRcdGNvbnN0IGhleCA9IGhleGFkZWNpbWFsKGNvZGVQb2ludCwgbG93ZXJjYXNlSGV4KTtcblx0XHRcdFx0cmV0dXJuICdcXFxcdXsnICsgaGV4ICsgJ30nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZvdXJIZXhFc2NhcGUoaGV4YWRlY2ltYWwoZmlyc3QsIGxvd2VyY2FzZUhleCkpICsgZm91ckhleEVzY2FwZShoZXhhZGVjaW1hbChzZWNvbmQsIGxvd2VyY2FzZUhleCkpO1xuXHRcdH1cblxuXHRcdGlmIChsb25lKSB7XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXhhZGVjaW1hbChsb25lLmNoYXJDb2RlQXQoMCksIGxvd2VyY2FzZUhleCkpO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdGNoYXIgPT0gJ1xcMCcgJiZcblx0XHRcdCFqc29uICYmXG5cdFx0XHQhcmVnZXhEaWdpdC50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXggKyAxKSlcblx0XHQpIHtcblx0XHRcdHJldHVybiAnXFxcXDAnO1xuXHRcdH1cblxuXHRcdGlmIChxdW90ZUNoYXIpIHtcblx0XHRcdGlmIChxdW90ZUNoYXIgPT0gcXVvdGUgfHwgb3B0aW9ucy5lc2NhcGVFdmVyeXRoaW5nKSB7XG5cdFx0XHRcdHJldHVybiAnXFxcXCcgKyBxdW90ZUNoYXI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVvdGVDaGFyO1xuXHRcdH1cblxuXHRcdGlmIChyZWdleFNpbmdsZUVzY2FwZS50ZXN0KGNoYXIpKSB7XG5cdFx0XHQvLyBubyBuZWVkIGZvciBhIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2sgaGVyZVxuXHRcdFx0cmV0dXJuIHNpbmdsZUVzY2FwZXNbY2hhcl07XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMubWluaW1hbCAmJiAhcmVnZXhXaGl0ZXNwYWNlLnRlc3QoY2hhcikpIHtcblx0XHRcdHJldHVybiBjaGFyO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhleCA9IGhleGFkZWNpbWFsKGNoYXIuY2hhckNvZGVBdCgwKSwgbG93ZXJjYXNlSGV4KTtcblx0XHRpZiAoanNvbiB8fCBoZXgubGVuZ3RoID4gMikge1xuXHRcdFx0cmV0dXJuIGZvdXJIZXhFc2NhcGUoaGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgaGV4KS5zbGljZSgtMik7XG5cdH0pO1xuXG5cdGlmIChxdW90ZSA9PSAnYCcpIHtcblx0XHRyZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFwkXFx7L2csICdcXFxcJHsnKTtcblx0fVxuXHRpZiAob3B0aW9ucy5pc1NjcmlwdENvbnRleHQpIHtcblx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZXRhZ29cblx0XHRyZXN1bHQgPSByZXN1bHRcblx0XHRcdC5yZXBsYWNlKC88XFwvKHNjcmlwdHxzdHlsZSkvZ2ksICc8XFxcXC8kMScpXG5cdFx0XHQucmVwbGFjZSgvPCEtLS9nLCBqc29uID8gJ1xcXFx1MDAzQyEtLScgOiAnXFxcXHgzQyEtLScpO1xuXHR9XG5cdGlmIChvcHRpb25zLndyYXApIHtcblx0XHRyZXN1bHQgPSBxdW90ZSArIHJlc3VsdCArIHF1b3RlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5qc2VzYy52ZXJzaW9uID0gJzMuMC4yJztcblxubW9kdWxlLmV4cG9ydHMgPSBqc2VzYztcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBkb21haW47XG5cbi8vIFRoaXMgY29uc3RydWN0b3IgaXMgdXNlZCB0byBzdG9yZSBldmVudCBoYW5kbGVycy4gSW5zdGFudGlhdGluZyB0aGlzIGlzXG4vLyBmYXN0ZXIgdGhhbiBleHBsaWNpdGx5IGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIHRvIGdldCBhIFwiY2xlYW5cIiBlbXB0eVxuLy8gb2JqZWN0ICh0ZXN0ZWQgd2l0aCB2OCB2NC45KS5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlcnMoKSB7fVxuRXZlbnRIYW5kbGVycy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXI7XG5leHBvcnQge0V2ZW50RW1pdHRlcn07XG5cbi8vIG5vZGVqcyBvZGRpdHlcbi8vIHJlcXVpcmUoJ2V2ZW50cycpID09PSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXJcblxuRXZlbnRFbWl0dGVyLnVzaW5nRG9tYWlucyA9IGZhbHNlO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmRvbWFpbiA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kb21haW4gPSBudWxsO1xuICBpZiAoRXZlbnRFbWl0dGVyLnVzaW5nRG9tYWlucykge1xuICAgIC8vIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBkb21haW4sIHRoZW4gYXR0YWNoIHRvIGl0LlxuICAgIGlmIChkb21haW4uYWN0aXZlICYmICEodGhpcyBpbnN0YW5jZW9mIGRvbWFpbi5Eb21haW4pKSB7XG4gICAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbi5hY3RpdmU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cywgZG9tYWluO1xuICB2YXIgbmVlZERvbWFpbkV4aXQgPSBmYWxzZTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBkb21haW4gPSB0aGlzLmRvbWFpbjtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGRvbWFpbikge1xuICAgICAgaWYgKCFlcilcbiAgICAgICAgZXIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQnKTtcbiAgICAgIGVyLmRvbWFpbkVtaXR0ZXIgPSB0aGlzO1xuICAgICAgZXIuZG9tYWluID0gZG9tYWluO1xuICAgICAgZXIuZG9tYWluVGhyb3duID0gZmFsc2U7XG4gICAgICBkb21haW4uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgaWYgKG5lZWREb21haW5FeGl0KVxuICAgIGRvbWFpbi5leGl0KCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgdHlwZSArICcgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgZW1pdFdhcm5pbmcodyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGVtaXRXYXJuaW5nKGUpIHtcbiAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnNvbGUud2FybihlKSA6IGNvbnNvbGUubG9nKGUpO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgZmlyZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHJldHVybiBnO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCAobGlzdC5saXN0ZW5lciAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGxpc3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cztcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleTsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBkbyB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSB3aGlsZSAobGlzdGVuZXJzWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICB2YXIgZXZsaXN0ZW5lcjtcbiAgdmFyIHJldDtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXQgPSBbXTtcbiAgZWxzZSB7XG4gICAgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgICByZXQgPSBbXTtcbiAgICBlbHNlIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHJldCA9IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBpKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwgIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuLy8gYmFzZWQgb2ZmIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzcy9ibG9iL21hc3Rlci9icm93c2VyLmpzXG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxudmFyIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5pZiAodHlwZW9mIGdsb2JhbC5zZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG59XG5pZiAodHlwZW9mIGdsb2JhbC5jbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG59XG5cbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIG5leHRUaWNrKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59XG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xudmFyIHRpdGxlID0gJ2Jyb3dzZXInO1xudmFyIHBsYXRmb3JtID0gJ2Jyb3dzZXInO1xudmFyIGJyb3dzZXIgPSB0cnVlO1xudmFyIGVudiA9IHt9O1xudmFyIGFyZ3YgPSBbXTtcbnZhciB2ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG52YXIgdmVyc2lvbnMgPSB7fTtcbnZhciByZWxlYXNlID0ge307XG52YXIgY29uZmlnID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgb24gPSBub29wO1xudmFyIGFkZExpc3RlbmVyID0gbm9vcDtcbnZhciBvbmNlID0gbm9vcDtcbnZhciBvZmYgPSBub29wO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnZhciByZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xudmFyIGVtaXQgPSBub29wO1xuXG5mdW5jdGlvbiBiaW5kaW5nKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbmZ1bmN0aW9uIGN3ZCAoKSB7IHJldHVybiAnLycgfVxuZnVuY3Rpb24gY2hkaXIgKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59ZnVuY3Rpb24gdW1hc2soKSB7IHJldHVybiAwOyB9XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2t1bWF2aXMvYnJvd3Nlci1wcm9jZXNzLWhydGltZS9ibG9iL21hc3Rlci9pbmRleC5qc1xudmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xudmFyIHBlcmZvcm1hbmNlTm93ID1cbiAgcGVyZm9ybWFuY2Uubm93ICAgICAgICB8fFxuICBwZXJmb3JtYW5jZS5tb3pOb3cgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgfHxcbiAgcGVyZm9ybWFuY2Uub05vdyAgICAgICB8fFxuICBwZXJmb3JtYW5jZS53ZWJraXROb3cgIHx8XG4gIGZ1bmN0aW9uKCl7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH07XG5cbi8vIGdlbmVyYXRlIHRpbWVzdGFtcCBvciBkZWx0YVxuLy8gc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2hydGltZVxuZnVuY3Rpb24gaHJ0aW1lKHByZXZpb3VzVGltZXN0YW1wKXtcbiAgdmFyIGNsb2NrdGltZSA9IHBlcmZvcm1hbmNlTm93LmNhbGwocGVyZm9ybWFuY2UpKjFlLTM7XG4gIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpO1xuICB2YXIgbmFub3NlY29uZHMgPSBNYXRoLmZsb29yKChjbG9ja3RpbWUlMSkqMWU5KTtcbiAgaWYgKHByZXZpb3VzVGltZXN0YW1wKSB7XG4gICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXTtcbiAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMV07XG4gICAgaWYgKG5hbm9zZWNvbmRzPDApIHtcbiAgICAgIHNlY29uZHMtLTtcbiAgICAgIG5hbm9zZWNvbmRzICs9IDFlOTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzZWNvbmRzLG5hbm9zZWNvbmRzXVxufVxuXG52YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbmZ1bmN0aW9uIHVwdGltZSgpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgdmFyIGRpZiA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmIC8gMTAwMDtcbn1cblxudmFyIGJyb3dzZXIkMSA9IHtcbiAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICB0aXRsZTogdGl0bGUsXG4gIGJyb3dzZXI6IGJyb3dzZXIsXG4gIGVudjogZW52LFxuICBhcmd2OiBhcmd2LFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICB2ZXJzaW9uczogdmVyc2lvbnMsXG4gIG9uOiBvbixcbiAgYWRkTGlzdGVuZXI6IGFkZExpc3RlbmVyLFxuICBvbmNlOiBvbmNlLFxuICBvZmY6IG9mZixcbiAgcmVtb3ZlTGlzdGVuZXI6IHJlbW92ZUxpc3RlbmVyLFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IHJlbW92ZUFsbExpc3RlbmVycyxcbiAgZW1pdDogZW1pdCxcbiAgYmluZGluZzogYmluZGluZyxcbiAgY3dkOiBjd2QsXG4gIGNoZGlyOiBjaGRpcixcbiAgdW1hc2s6IHVtYXNrLFxuICBocnRpbWU6IGhydGltZSxcbiAgcGxhdGZvcm06IHBsYXRmb3JtLFxuICByZWxlYXNlOiByZWxlYXNlLFxuICBjb25maWc6IGNvbmZpZyxcbiAgdXB0aW1lOiB1cHRpbWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJyb3dzZXIkMTtcbmV4cG9ydCB7IGFkZExpc3RlbmVyLCBhcmd2LCBiaW5kaW5nLCBicm93c2VyLCBjaGRpciwgY29uZmlnLCBjd2QsIGVtaXQsIGVudiwgaHJ0aW1lLCBuZXh0VGljaywgb2ZmLCBvbiwgb25jZSwgcGxhdGZvcm0sIHJlbGVhc2UsIHJlbW92ZUFsbExpc3RlbmVycywgcmVtb3ZlTGlzdGVuZXIsIHRpdGxlLCB1bWFzaywgdXB0aW1lLCB2ZXJzaW9uLCB2ZXJzaW9ucyB9O1xuIiwgIlxudmFyIGluaGVyaXRzO1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKXtcbiAgaW5oZXJpdHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgaW5oZXJpdHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgaW5oZXJpdHM7XG4iLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5pbXBvcnQgcHJvY2VzcyBmcm9tICdwcm9jZXNzJztcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z2xvZyhzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSAwO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIF9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCdWZmZXIobWF5YmVCdWYpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihtYXliZUJ1Zik7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydCBmdW5jdGlvbiBsb2coKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbn1cblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuaW1wb3J0IGluaGVyaXRzIGZyb20gJy4vaW5oZXJpdHMnO1xuZXhwb3J0IHtpbmhlcml0c31cblxuZXhwb3J0IGZ1bmN0aW9uIF9leHRlbmQob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICBfZXh0ZW5kOiBfZXh0ZW5kLFxuICBsb2c6IGxvZyxcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzRXJyb3I6IGlzRXJyb3IsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc1N5bWJvbDogaXNTeW1ib2wsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc051bGxPclVuZGVmaW5lZDogaXNOdWxsT3JVbmRlZmluZWQsXG4gIGlzTnVsbDogaXNOdWxsLFxuICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaW5zcGVjdDogaW5zcGVjdCxcbiAgZGVwcmVjYXRlOiBkZXByZWNhdGUsXG4gIGZvcm1hdDogZm9ybWF0LFxuICBkZWJ1Z2xvZzogZGVidWdsb2dcbn1cbiIsICJ2YXIgbG9va3VwID0gW107XG52YXIgcmV2TG9va3VwID0gW107XG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoO1xuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwO1xuXG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTtcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbjtcblxuICB2YXIgTCA9IDA7XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KTtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXA7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciB0bXA7XG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGg7XG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMzsgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpO1xuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPT0nO1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz0nO1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpO1xuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiByZWFkIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gLTc7XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDA7XG4gIHZhciBkID0gaXNMRSA/IC0xIDogMTtcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZnVuY3Rpb24gd3JpdGUgKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKTtcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKTtcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbnZhciBfa01heExlbmd0aCA9IGtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5CdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbmZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihhKSB8fCAhaW50ZXJuYWxJc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59O1xuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXTtcbiAgYltuXSA9IGJbbV07XG4gIGJbbV0gPSBpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7XG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7XG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMDtcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMDtcbiAgZW5kID4+Pj0gMDtcbiAgdGhpc1N0YXJ0ID4+Pj0gMDtcbiAgdGhpc0VuZCA+Pj49IDA7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG4gIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KTtcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZjtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7XG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OyAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwO1xuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyO1xuICAgICAgYXJyTGVuZ3RoIC89IDI7XG4gICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXg7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn07XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwO1xuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7XG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIHZhciBpID0gc3RhcnQ7XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDE7XG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDA7XG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICB2YXIgb3V0ID0gJyc7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIHN0YXJ0ID0gfn5zdGFydDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuO1xuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwO1xuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgdmFyIG5ld0J1ZjtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydDtcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn07XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuICB2YXIgbXVsID0gMTtcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTtcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59O1xuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogODtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDE7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCk7XG4gIH1cbiAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDtcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBsZW5cbn07XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTU7XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cbiAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cbiAgdmFyIGk7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IGludGVybmFsSXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufTtcblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2c7XG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJyk7XG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9JztcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgdmFyIGNvZGVQb2ludDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG87XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoaSA9IGMgPj4gODtcbiAgICBsbyA9IGMgJSAyNTY7XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgIGJ5dGVBcnJheS5wdXNoKGhpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIHRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuZXhwb3J0IHsgQnVmZmVyLCBJTlNQRUNUX01BWF9CWVRFUywgU2xvd0J1ZmZlciwgaXNCdWZmZXIsIF9rTWF4TGVuZ3RoIGFzIGtNYXhMZW5ndGggfTtcbiIsICJpbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyTGlzdDtcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgdGhpcy50YWlsID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgdGhpcy5oZWFkID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gIC0tdGhpcy5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHJldCArPSBzICsgcC5kYXRhO1xuICB9cmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChuKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxuZXhwb3J0IGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge2luaGVyaXRzLCBkZWJ1Z2xvZ30gZnJvbSAndXRpbCc7XG5pbXBvcnQgQnVmZmVyTGlzdCBmcm9tICcuL2J1ZmZlci1saXN0JztcbmltcG9ydCB7U3RyaW5nRGVjb2Rlcn0gZnJvbSAnc3RyaW5nX2RlY29kZXInO1xuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vZHVwbGV4JztcbmltcG9ydCB7bmV4dFRpY2t9IGZyb20gJ3Byb2Nlc3MnO1xuXG52YXIgZGVidWcgPSBkZWJ1Z2xvZygnc3RyZWFtJyk7XG5pbmhlcml0cyhSZWFkYWJsZSwgRXZlbnRFbWl0dGVyKTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKVxuICAgICAgZW1pdHRlci5vbihldmVudCwgZm4pO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO1xuICAgIGVsc2VcbiAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50IChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFJlYWRhYmxlO1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBuZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgbmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKTtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIG5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIHNyYy5saXN0ZW5lcnMoJ2RhdGEnKS5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbjsgX2krKykge1xuICAgICAgZGVzdHNbX2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgbmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsICIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cblxuaW1wb3J0IHtpbmhlcml0cywgZGVwcmVjYXRlfSBmcm9tICd1dGlsJztcbmltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5pbXBvcnQge0V2ZW50RW1pdHRlcn0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL2R1cGxleCc7XG5pbXBvcnQge25leHRUaWNrfSBmcm9tICdwcm9jZXNzJztcbmluaGVyaXRzKFdyaXRhYmxlLCBFdmVudEVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYnVmZmVyJywge1xuICAgIGdldDogZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgfSk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdyaXRhYmxlO1xuZXhwb3J0IGZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBuZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuICAvLyBBbHdheXMgdGhyb3cgZXJyb3IgaWYgYSBudWxsIGlzIHdyaXR0ZW5cbiAgLy8gaWYgd2UgYXJlIG5vdCBpbiBvYmplY3QgbW9kZSB0aGVuIHRocm93XG4gIC8vIGlmIGl0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBvciB1bmRlZmluZWQuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgbmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBuZXh0VGljayhjYiwgZXIpO2Vsc2UgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICAgIG5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgbmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59XG4iLCAiXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmltcG9ydCB7bmV4dFRpY2t9IGZyb20gJ3Byb2Nlc3MnO1xuaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSAnLi9yZWFkYWJsZSc7XG5pbXBvcnQge1dyaXRhYmxlfSBmcm9tICcuL3dyaXRhYmxlJztcblxuXG5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5leHBvcnQgZGVmYXVsdCBEdXBsZXg7XG5leHBvcnQgZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgbmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuIiwgIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuXG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuXG5cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm07XG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlcikge1xuICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCAiXG5pbXBvcnQge1RyYW5zZm9ybX0gZnJvbSAnLi90cmFuc2Zvcm0nO1xuXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2g7XG5leHBvcnQgZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iLCAiaW1wb3J0IEVFIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyc7XG5pbXBvcnQge1JlYWRhYmxlfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyc7XG5pbXBvcnQge1dyaXRhYmxlfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyc7XG5pbXBvcnQge1RyYW5zZm9ybX0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7UGFzc1Rocm91Z2h9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJztcbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG5TdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcblN0cmVhbS5EdXBsZXggPSBEdXBsZXg7XG5TdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gUGFzc1Rocm91Z2g7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5leHBvcnQgZGVmYXVsdCBTdHJlYW07XG5leHBvcnQge1JlYWRhYmxlLFdyaXRhYmxlLER1cGxleCxUcmFuc2Zvcm0sUGFzc1Rocm91Z2gsU3RyZWFtfVxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwgIlxuY29uc3QgcG9seWZpbGwgPSByZXF1aXJlKCdzdHJlYW0nKVxuXG5pZiAocG9seWZpbGwgJiYgcG9seWZpbGwuZGVmYXVsdCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWZpbGwuZGVmYXVsdFxuICAgIGZvciAobGV0IGsgaW4gcG9seWZpbGwpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNba10gPSBwb2x5ZmlsbFtrXVxuICAgIH1cbn0gZWxzZSBpZiAocG9seWZpbGwpICB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbFxufVxuXG5cbiIsICIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4yJztcblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMgd2l0aFxuLy8gdGVtcGxhdGUgbGl0ZXJhbCBzdHJpbmdzLiBUaGUgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4vLyBkdXJpbmcgYnVpbGQuXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgdmFyIHVybCA9ICdodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHVybCArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgKyBjb2RlICsgXCI7IHZpc2l0IFwiICsgdXJsICsgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgXCIgKyAndXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCAnICsgJ2hlbHBmdWwgd2FybmluZ3MuJztcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgPSBmYWxzZTtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbn1cblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpIHtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcblxuICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29udGV4dFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbikge1xuICB7XG4gICAgY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCAnQ29tcG9uZW50Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgZW5vdWdoIHNsb3RzIGluIHRoaXMgY29udGV4dCB0byBzdG9yZSB0aGlzIHRocmVhZElELFxuICAvLyBmaWxsIGl0IGluIHdpdGhvdXQgbGVhdmluZyBhbnkgaG9sZXMgdG8gZW5zdXJlIHRoYXQgdGhlIFZNIG9wdGltaXplc1xuICAvLyB0aGlzIGFzIG5vbi1ob2xleSBpbmRleCBwcm9wZXJ0aWVzLlxuICAvLyAoTm90ZTogSWYgYHJlYWN0YCBwYWNrYWdlIGlzIDwgMTYuNiwgX3RocmVhZENvdW50IGlzIHVuZGVmaW5lZC4pXG4gIGZvciAodmFyIGkgPSBjb250ZXh0Ll90aHJlYWRDb3VudCB8IDA7IGkgPD0gdGhyZWFkSUQ7IGkrKykge1xuICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGRlZmF1bHRWYWx1ZSB3aGljaCBtaWdodCBub3QgYmVcbiAgICAvLyB0cnVlIGlmIHdlJ3JlIHJlbmRlcmluZyBpbnNpZGUgYSBzZWNvbmRhcnkgcmVuZGVyZXIgYnV0IHRoZXkgYXJlXG4gICAgLy8gc2Vjb25kYXJ5IGJlY2F1c2UgdGhlc2UgdXNlIGNhc2VzIGFyZSB2ZXJ5IHJhcmUuXG4gICAgY29udGV4dFtpXSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBpICsgMTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbnRleHQodHlwZSwgY29udGV4dCwgdGhyZWFkSUQsIGlzQ2xhc3MpIHtcbiAgaWYgKGlzQ2xhc3MpIHtcbiAgICB2YXIgY29udGV4dFR5cGUgPSB0eXBlLmNvbnRleHRUeXBlO1xuXG4gICAge1xuICAgICAgaWYgKCdjb250ZXh0VHlwZScgaW4gdHlwZSkge1xuICAgICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuICAgICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXModHlwZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKHR5cGUpO1xuICAgICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dFR5cGUsIHRocmVhZElEKTtcbiAgICAgIHJldHVybiBjb250ZXh0VHlwZVt0aHJlYWRJRF07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG1hc2tlZENvbnRleHQgPSBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICBjaGVja0NvbnRleHRUeXBlcyh0eXBlLmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgdmFyIF9tYXNrZWRDb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tDb250ZXh0VHlwZXModHlwZS5jb250ZXh0VHlwZXMsIF9tYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWFza2VkQ29udGV4dDtcbiAgICB9XG4gIH1cbn1cblxudmFyIG5leHRBdmFpbGFibGVUaHJlYWRJRHMgPSBuZXcgVWludDE2QXJyYXkoMTYpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyspIHtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tpXSA9IGkgKyAxO1xufVxuXG5uZXh0QXZhaWxhYmxlVGhyZWFkSURzWzE1XSA9IDA7XG5cbmZ1bmN0aW9uIGdyb3dUaHJlYWRDb3VudEFuZFJldHVybk5leHRBdmFpbGFibGUoKSB7XG4gIHZhciBvbGRBcnJheSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHM7XG4gIHZhciBvbGRTaXplID0gb2xkQXJyYXkubGVuZ3RoO1xuICB2YXIgbmV3U2l6ZSA9IG9sZFNpemUgKiAyO1xuXG4gIGlmICghKG5ld1NpemUgPD0gMHgxMDAwMCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJNYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IFJlYWN0IHJlbmRlcmVycyBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbm90IHByb3Blcmx5IGRlc3Ryb3lpbmcgdGhlIFJlYWRhYmxlIHByb3ZpZGVkIGJ5IFJlYWN0LiBFbnN1cmUgdGhhdCB5b3UgY2FsbCAuZGVzdHJveSgpIG9uIGl0IGlmIHlvdSBubyBsb25nZXIgd2FudCB0byByZWFkIGZyb20gaXQsIGFuZCBkaWQgbm90IHJlYWQgdG8gdGhlIGVuZC4gSWYgeW91IHVzZSAucGlwZSgpIHRoaXMgc2hvdWxkIGJlIGF1dG9tYXRpYy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdBcnJheSA9IG5ldyBVaW50MTZBcnJheShuZXdTaXplKTtcbiAgbmV3QXJyYXkuc2V0KG9sZEFycmF5KTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEcyA9IG5ld0FycmF5O1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gb2xkU2l6ZSArIDE7XG5cbiAgZm9yICh2YXIgX2kgPSBvbGRTaXplOyBfaSA8IG5ld1NpemUgLSAxOyBfaSsrKSB7XG4gICAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tfaV0gPSBfaSArIDE7XG4gIH1cblxuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW25ld1NpemUgLSAxXSA9IDA7XG4gIHJldHVybiBvbGRTaXplO1xufVxuXG5mdW5jdGlvbiBhbGxvY1RocmVhZElEKCkge1xuICB2YXIgbmV4dElEID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXTtcblxuICBpZiAobmV4dElEID09PSAwKSB7XG4gICAgcmV0dXJuIGdyb3dUaHJlYWRDb3VudEFuZFJldHVybk5leHRBdmFpbGFibGUoKTtcbiAgfVxuXG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW25leHRJRF07XG4gIHJldHVybiBuZXh0SUQ7XG59XG5mdW5jdGlvbiBmcmVlVGhyZWFkSUQoaWQpIHtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tpZF0gPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdO1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gaWQ7XG59XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDsgLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIGZpbHRlciBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG5cbnZhciBTVFJJTkcgPSAxOyAvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cblxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjsgLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG5cbnZhciBCT09MRUFOID0gMzsgLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBOVU1FUklDID0gNTsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG5cbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG5cbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuXG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG5cbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlLCBzYW5pdGl6ZVVSTCwgcmVtb3ZlRW1wdHlTdHJpbmcpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2FuaXRpemVVUkwgPSBzYW5pdGl6ZVVSTDtcbiAgdGhpcy5yZW1vdmVFbXB0eVN0cmluZyA9IHJlbW92ZUVtcHR5U3RyaW5nO1xufSAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cblxuXG52YXIgcHJvcGVydGllcyA9IHt9OyAvLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblxudmFyIHJlc2VydmVkUHJvcHMgPSBbJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ107XG5yZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUkVTRVJWRUQsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cblxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmb2N1c2FibGUnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJywgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblxuWydjaGVja2VkJywgLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5cblsnY2FwdHVyZScsICdkb3dubG9hZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pO1xudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xuXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07IC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5cblxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblxuWyd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuXG5bJ3RhYkluZGV4JywgJ2Nyb3NzT3JpZ2luJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cblxudmFyIHhsaW5rSHJlZiA9ICd4bGlua0hyZWYnO1xucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbmZhbHNlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUsIC8vIHNhbml0aXplVVJMXG4gIHRydWUpO1xufSk7XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeSh1cmwpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG4vKipcbiAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBIVE1MIGVudGl0aWVzIGluIGEgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgSFRNTCBzdHJpbmcgdG8gZXNjYXBlIGZvciBsYXRlciBpbnNlcnRpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXg7XG4gIHZhciBsYXN0SW5kZXggPSAwO1xuXG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIC8vIFwiXG4gICAgICAgIGVzY2FwZSA9ICcmcXVvdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59IC8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclJvb3QoKSB7XG4gIHJldHVybiBST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbn1cbi8qKlxuICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbnZhciBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDsgLy8gV2hldGhlciB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rIGlzIGEgcmUtcmVuZGVyZWQgaG9va1xuXG52YXIgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGR1cmluZyB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXIgcGFzcy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gTGF6aWx5IGNyZWF0ZWQgbWFwIG9mIHJlbmRlci1waGFzZSB1cGRhdGVzXG5cbnZhciByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsOyAvLyBDb3VudGVyIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG5cbnZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7XG52YXIgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbmZ1bmN0aW9uIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKSB7XG4gIGlmICghKGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9vaygpIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID4gMCkge1xuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgaWYgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7XG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcblxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBjb21wb25lbnRJZGVudGl0eTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxufVxuZnVuY3Rpb24gZmluaXNoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgY2hpbGRyZW4sIHJlZk9yQ29udGV4dCkge1xuICAvLyBUaGlzIG11c3QgYmUgY2FsbGVkIGFmdGVyIGV2ZXJ5IGZ1bmN0aW9uIGNvbXBvbmVudCB0byBwcmV2ZW50IGhvb2tzIGZyb21cbiAgLy8gYmVpbmcgdXNlZCBpbiBjbGFzc2VzLlxuICB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIC8vIFVwZGF0ZXMgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoZXkgYXJlIHN0b3JlZCBpblxuICAgIC8vIHRoZSBgcmVuZGVyUGhhc2VVcGRhdGVzYCBtYXAuIENhbGwgdGhlIGNvbXBvbmVudCBhZ2FpbiwgcmV1c2luZyB0aGVcbiAgICAvLyB3b3JrLWluLXByb2dyZXNzIGhvb2tzIGFuZCBhcHBseWluZyB0aGUgYWRkaXRpb25hbCB1cGRhdGVzIG9uIHRvcC4gS2VlcFxuICAgIC8vIHJlc3RhcnRpbmcgdW50aWwgbm8gbW9yZSB1cGRhdGVzIGFyZSBzY2hlZHVsZWQuXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICB9XG5cbiAgcmVzZXRIb29rc1N0YXRlKCk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn0gLy8gUmVzZXQgdGhlIGludGVybmFsIGhvb2tzIHN0YXRlIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSByZW5kZXJpbmcgYSBjb21wb25lbnRcblxuZnVuY3Rpb24gcmVzZXRIb29rc1N0YXRlKCkge1xuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgdmFyIHRocmVhZElEID0gY3VycmVudFBhcnRpYWxSZW5kZXJlci50aHJlYWRJRDtcbiAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250ZXh0W3RocmVhZElEXTtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICB9XG5cbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB2YXIgdGhyZWFkSUQgPSBjdXJyZW50UGFydGlhbFJlbmRlcmVyLnRocmVhZElEO1xuICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuICByZXR1cm4gY29udGV4dFt0aHJlYWRJRF07XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgfVxuXG4gIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCAvLyB1c2VSZWR1Y2VyIGhhcyBhIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IGxhenkgdXNlU3RhdGUgaW5pdGlhbGl6ZXJzXG4gIGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAge1xuICAgIGlmIChyZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoaXNSZVJlbmRlcikge1xuICAgIC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gICAgLy8gY3VycmVudCBob29rLlxuICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZTtcbiAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlbmRlciBwaGFzZSB1cGRhdGVzIGFyZSBzdG9yZWQgaW4gYSBtYXAgb2YgcXVldWUgLT4gbGlua2VkIGxpc3RcbiAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLmRlbGV0ZShxdWV1ZSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIHJlbmRlcidzLlxuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICAgIGlmIChyZWR1Y2VyID09PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBgdXNlU3RhdGVgLlxuICAgICAgaW5pdGlhbFN0YXRlID0gdHlwZW9mIGluaXRpYWxBcmcgPT09ICdmdW5jdGlvbicgPyBpbml0aWFsQXJnKCkgOiBpbml0aWFsQXJnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSBpbml0ICE9PSB1bmRlZmluZWQgPyBpbml0KGluaXRpYWxBcmcpIDogaW5pdGlhbEFyZztcbiAgICB9XG5cbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblxuICAgIHZhciBfcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7XG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIF9kaXNwYXRjaCA9IF9xdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LCBfcXVldWUpO1xuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgX2Rpc3BhdGNoXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcHJldmlvdXNSZWYgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldmlvdXNSZWYgPT09IG51bGwpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcblxuICAgIHtcbiAgICAgIE9iamVjdC5zZWFsKHJlZik7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgaW5wdXRzKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuXG4gICAgZXJyb3IoJ3VzZUxheW91dEVmZmVjdCBkb2VzIG5vdGhpbmcgb24gdGhlIHNlcnZlciwgYmVjYXVzZSBpdHMgZWZmZWN0IGNhbm5vdCAnICsgXCJiZSBlbmNvZGVkIGludG8gdGhlIHNlcnZlciByZW5kZXJlcidzIG91dHB1dCBmb3JtYXQuIFRoaXMgd2lsbCBsZWFkIFwiICsgJ3RvIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgaW5pdGlhbCwgbm9uLWh5ZHJhdGVkIFVJIGFuZCB0aGUgaW50ZW5kZWQgJyArICdVSS4gVG8gYXZvaWQgdGhpcywgdXNlTGF5b3V0RWZmZWN0IHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gJyArICdjb21wb25lbnRzIHRoYXQgcmVuZGVyIGV4Y2x1c2l2ZWx5IG9uIHRoZSBjbGllbnQuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91c2VsYXlvdXRlZmZlY3Qtc3NyIGZvciBjb21tb24gZml4ZXMuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKCEobnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCIgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCkge1xuICAgIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuICAgIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgICAvLyBhbmQgYXBwbHkgdGhlIHN0YXNoZWQgdXBkYXRlcyBvbiB0b3Agb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICB3aGlsZSAobGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9LCBkZXBzKTtcbn0gLy8gVE9ETyBEZWNpZGUgb24gaG93IHRvIGltcGxlbWVudCB0aGlzIGhvb2sgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4vLyBJZiBhIG11dGF0aW9uIG9jY3VycyBkdXJpbmcgcmVuZGVyLCBjb25zaWRlciB0cmlnZ2VyaW5nIGEgU3VzcGVuc2UgYm91bmRhcnlcbi8vIGFuZCBmYWxsaW5nIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cblxuZnVuY3Rpb24gdXNlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gZ2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG5cbiAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG5cbiAgcmV0dXJuIFtzdGFydFRyYW5zaXRpb24sIGZhbHNlXTtcbn1cblxuZnVuY3Rpb24gdXNlT3BhcXVlSWRlbnRpZmllcigpIHtcbiAgcmV0dXJuIChjdXJyZW50UGFydGlhbFJlbmRlcmVyLmlkZW50aWZpZXJQcmVmaXggfHwgJycpICsgJ1I6JyArIChjdXJyZW50UGFydGlhbFJlbmRlcmVyLnVuaXF1ZUlEKyspLnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBjdXJyZW50UGFydGlhbFJlbmRlcmVyID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgY3VycmVudFBhcnRpYWxSZW5kZXJlciA9IHJlbmRlcmVyO1xufVxudmFyIERpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgdXNlTGF5b3V0RWZmZWN0OiB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayxcbiAgLy8gdXNlSW1wZXJhdGl2ZUhhbmRsZSBpcyBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnRcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbm9vcCxcbiAgLy8gRWZmZWN0cyBhcmUgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VFZmZlY3Q6IG5vb3AsXG4gIC8vIERlYnVnZ2luZyBlZmZlY3RcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCxcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdXNlVHJhbnNpdGlvbjogdXNlVHJhbnNpdGlvbixcbiAgdXNlT3BhcXVlSWRlbnRpZmllcjogdXNlT3BhcXVlSWRlbnRpZmllcixcbiAgLy8gU3Vic2NyaXB0aW9ucyBhcmUgbm90IHNldHVwIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VNdXRhYmxlU291cmNlOiB1c2VNdXRhYmxlU291cmNlXG59O1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG52YXIgTUFUSF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG52YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG52YXIgTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogSFRNTF9OQU1FU1BBQ0UsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTsgLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIFNWR19OQU1FU1BBQ0U7XG5cbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuXG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9IC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuXG5cbiAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZTtcbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG5cbn07XG5cbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG5cblxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICBpZiAoIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCB0YWcgKyBcIiBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJiBwcm9wcy5jb250ZW50RWRpdGFibGUgJiYgcHJvcHMuY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gdXNpbmcgSlNYLlwiICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGNvbHVtbnM6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkQXJlYTogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG5cblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTsgLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcblxuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovXG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGVudGVya2V5aGludDogJ2VudGVyS2V5SGludCcsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgdG9BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXk7IC8vIFRoaXMgaXMgb25seSB1c2VkIGluIERFVi5cbi8vIEVhY2ggZW50cnkgaXMgYHRoaXMuc3RhY2tgIGZyb20gYSBjdXJyZW50bHkgZXhlY3V0aW5nIHJlbmRlcmVyIGluc3RhbmNlLlxuLy8gKFRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGJlY2F1c2UgUmVhY3RET01TZXJ2ZXIgaXMgcmVlbnRyYW50KS5cbi8vIEVhY2ggc3RhY2sgaXMgYW4gYXJyYXkgb2YgZnJhbWVzIHdoaWNoIG1heSBjb250YWluIG5lc3RlZCBzdGFja3Mgb2YgZWxlbWVudHMuXG5cbnZhciBjdXJyZW50RGVidWdTdGFja3MgPSBbXTtcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMTtcbnZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IG51bGw7XG5cbnZhciBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJyc7XG59O1xuXG52YXIgZGVzY3JpYmVTdGFja0ZyYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHt9O1xuXG52YXIgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7fTtcblxudmFyIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnQpIHt9O1xuXG52YXIgcG9wQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBudWxsKTtcbiAgfTtcblxuICBkZXNjcmliZVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG51bGwpO1xuICB9O1xuXG4gIHB1c2hDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIGN1cnJlbnREZWJ1Z1N0YWNrcy5wdXNoKHN0YWNrKTtcblxuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBXZSBhcmUgZW50ZXJpbmcgYSBzZXJ2ZXIgcmVuZGVyZXIuXG4gICAgICAvLyBSZW1lbWJlciB0aGUgcHJldmlvdXMgKGUuZy4gY2xpZW50KSBnbG9iYWwgc3RhY2sgaW1wbGVtZW50YXRpb24uXG4gICAgICBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2s7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbDtcbiAgICB9XG4gIH07XG5cbiAgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2sgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIEZvciB0aGUgaW5uZXJtb3N0IGV4ZWN1dGluZyBSZWFjdERPTVNlcnZlciBjYWxsLFxuICAgIHZhciBzdGFjayA9IGN1cnJlbnREZWJ1Z1N0YWNrc1tjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoIC0gMV07IC8vIFRha2UgdGhlIGlubmVybW9zdCBleGVjdXRpbmcgZnJhbWUgKGUuZy4gPEZvbz4pLFxuXG4gICAgdmFyIGZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07IC8vIGFuZCByZWNvcmQgdGhhdCBpdCBoYXMgb25lIG1vcmUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggaXQuXG5cbiAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjay5wdXNoKGVsZW1lbnQpOyAvLyBXZSBvbmx5IG5lZWQgdGhpcyBiZWNhdXNlIHdlIHRhaWwtb3B0aW1pemUgc2luZ2xlLWVsZW1lbnRcbiAgICAvLyBjaGlsZHJlbiBhbmQgZGlyZWN0bHkgaGFuZGxlIHRoZW0gaW4gYW4gaW5uZXIgbG9vcCBpbnN0ZWFkIG9mXG4gICAgLy8gY3JlYXRpbmcgc2VwYXJhdGUgZnJhbWVzIGZvciB0aGVtLlxuICB9O1xuXG4gIHBvcEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnREZWJ1Z1N0YWNrcy5wb3AoKTtcblxuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBXZSBhcmUgZXhpdGluZyB0aGUgc2VydmVyIHJlbmRlcmVyLlxuICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgKGUuZy4gY2xpZW50KSBnbG9iYWwgc3RhY2sgaW1wbGVtZW50YXRpb24uXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFja0ltcGw7XG4gICAgICBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGN1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHJlbmRlcmluZy5cbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFJlYWN0RE9NU2VydmVyIGlzIHJlZW50cmFudCBzbyB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgY2FsbHMgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBUYWtlIHRoZSBmcmFtZXMgZnJvbSB0aGUgaW5uZXJtb3N0IGNhbGwgd2hpY2ggaXMgdGhlIGxhc3QgaW4gdGhlIGFycmF5LlxuXG5cbiAgICB2YXIgZnJhbWVzID0gY3VycmVudERlYnVnU3RhY2tzW2N1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gR28gdGhyb3VnaCBldmVyeSBmcmFtZSBpbiB0aGUgc3RhY2sgZnJvbSB0aGUgaW5uZXJtb3N0IG9uZS5cblxuICAgIGZvciAodmFyIGkgPSBmcmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tpXTsgLy8gRXZlcnkgZnJhbWUgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGRlYnVnIGVsZW1lbnQgc3RhY2sgZW50cnkgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHNpbmdsZS1jaGlsZCBuZXN0aW5nIGRvZXNuJ3QgY3JlYXRlIG1hdGVyaWFsaXplZCBmcmFtZXMuXG4gICAgICAvLyBJbnN0ZWFkIGl0IHdvdWxkIHB1c2ggdGhlbSB0aHJvdWdoIGBwdXNoRWxlbWVudFRvRGVidWdTdGFjaygpYC5cblxuICAgICAgdmFyIGRlYnVnRWxlbWVudFN0YWNrID0gZnJhbWUuZGVidWdFbGVtZW50U3RhY2s7XG5cbiAgICAgIGZvciAodmFyIGlpID0gZGVidWdFbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICBzdGFjayArPSBkZXNjcmliZVN0YWNrRnJhbWUoZGVidWdFbGVtZW50U3RhY2tbaWldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbnZhciBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xudmFyIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0ge307XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0ge307XG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICBsaXN0aW5nOiB0cnVlLFxuICBwcmU6IHRydWUsXG4gIHRleHRhcmVhOiB0cnVlXG59OyAvLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxuXG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghdmFsaWRhdGVkVGFnQ2FjaGUuaGFzT3duUHJvcGVydHkodGFnKSkge1xuICAgIGlmICghVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgc3R5bGVOYW1lQ2FjaGUgPSB7fTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIGlmIChzdHlsZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgcmV0dXJuIHN0eWxlTmFtZUNhY2hlW3N0eWxlTmFtZV07XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG4gIHN0eWxlTmFtZUNhY2hlW3N0eWxlTmFtZV0gPSByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciBzZXJpYWxpemVkID0gJyc7XG4gIHZhciBkZWxpbWl0ZXIgPSAnJztcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIChpc0N1c3RvbVByb3BlcnR5ID8gc3R5bGVOYW1lIDogcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpKSArICc6JztcbiAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgZ2V0Q29tcG9uZW50TmFtZShfY29uc3RydWN0b3IpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcignJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBnZXROb25DaGlsZHJlbklubmVyTWFya3VwKHByb3BzKSB7XG4gIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MLl9faHRtbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvbnRlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Ub3BMZXZlbENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoY2hpbGRyZW4pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjaGlsZHJlbjtcblxuICBpZiAoZWxlbWVudC50eXBlICE9PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgcmV0dXJuIFtlbGVtZW50XTtcbiAgfVxuXG4gIHZhciBmcmFnbWVudENoaWxkcmVuID0gZWxlbWVudC5wcm9wcy5jaGlsZHJlbjtcblxuICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGZyYWdtZW50Q2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZnJhZ21lbnRDaGlsZHJlbik7XG4gIH1cblxuICB2YXIgZnJhZ21lbnRDaGlsZEVsZW1lbnQgPSBmcmFnbWVudENoaWxkcmVuO1xuICByZXR1cm4gW2ZyYWdtZW50Q2hpbGRFbGVtZW50XTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNoaWxkICE9PSAnbnVtYmVyJykge1xuICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogbnVsbCxcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiBudWxsLFxuICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU9wZW5UYWdNYXJrdXAodGFnVmVyYmF0aW0sIHRhZ0xvd2VyY2FzZSwgcHJvcHMsIG5hbWVzcGFjZSwgbWFrZVN0YXRpY01hcmt1cCwgaXNSb290RWxlbWVudCkge1xuICB2YXIgcmV0ID0gJzwnICsgdGFnVmVyYmF0aW07XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudCQxID0gaXNDdXN0b21Db21wb25lbnQodGFnTG93ZXJjYXNlLCBwcm9wcyk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkkMi5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHByb3BWYWx1ZSA9IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBtYXJrdXAgPSBudWxsO1xuXG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50JDEpIHtcbiAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgbWFya3VwID0gY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmt1cCkge1xuICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICB9XG4gIH0gLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gIC8vIGJ5dGVzLlxuXG5cbiAgaWYgKG1ha2VTdGF0aWNNYXJrdXApIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGlzUm9vdEVsZW1lbnQpIHtcbiAgICByZXQgKz0gJyAnICsgY3JlYXRlTWFya3VwRm9yUm9vdCgpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIHR5cGUpIHtcbiAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnQ29tcG9uZW50JykgKyBcIiguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoY2hpbGQsIGNvbnRleHQsIHRocmVhZElEKSB7XG4gIHdoaWxlIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAvLyBTYWZlIGJlY2F1c2Ugd2UganVzdCBjaGVja2VkIGl0J3MgYW4gZWxlbWVudC5cbiAgICB2YXIgZWxlbWVudCA9IGNoaWxkO1xuICAgIHZhciBDb21wb25lbnQgPSBlbGVtZW50LnR5cGU7XG5cbiAgICB7XG4gICAgICBwdXNoRWxlbWVudFRvRGVidWdTdGFjayhlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0NoaWxkKGVsZW1lbnQsIENvbXBvbmVudCk7XG4gIH0gLy8gRXh0cmEgY2xvc3VyZSBzbyBxdWV1ZSBhbmQgcmVwbGFjZSBjYW4gYmUgY2FwdHVyZWQgcHJvcGVybHlcblxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDaGlsZChlbGVtZW50LCBDb21wb25lbnQpIHtcbiAgICB2YXIgaXNDbGFzcyA9IHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCk7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSBwcm9jZXNzQ29udGV4dChDb21wb25lbnQsIGNvbnRleHQsIHRocmVhZElELCBpc0NsYXNzKTtcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgcmVwbGFjZSA9IGZhbHNlO1xuICAgIHZhciB1cGRhdGVyID0ge1xuICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgICAgICByZXBsYWNlID0gdHJ1ZTtcbiAgICAgICAgcXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGN1cnJlbnRQYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVldWUucHVzaChjdXJyZW50UGFydGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbnN0O1xuXG4gICAgaWYgKGlzQ2xhc3MpIHtcbiAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KGVsZW1lbnQucHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZXIpO1xuXG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpbnN0LnN0YXRlID09PSBudWxsIHx8IGluc3Quc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3Quc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5jYWxsKG51bGwsIGVsZW1lbnQucHJvcHMsIGluc3Quc3RhdGUpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlW19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlW19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IF9hc3NpZ24oe30sIGluc3Quc3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbX2NvbXBvbmVudE5hbWUyXSkge1xuICAgICAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gICAgICBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSk7XG4gICAgICBpbnN0ID0gQ29tcG9uZW50KGVsZW1lbnQucHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZXIpO1xuICAgICAgaW5zdCA9IGZpbmlzaEhvb2tzKENvbXBvbmVudCwgZWxlbWVudC5wcm9wcywgaW5zdCwgcHVibGljQ29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICAgICAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0LnJlbmRlciAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSkge1xuICAgICAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUzLCBfY29tcG9uZW50TmFtZTMsIF9jb21wb25lbnROYW1lMyk7XG5cbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIElmIHRoZSBmbGFnIGlzIG9uLCBldmVyeXRoaW5nIGlzIGFzc3VtZWQgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGFsc28gZG8gdGhlIHVuZm9ydHVuYXRlIGR5bmFtaWMgY2hlY2tzLlxuXG5cbiAgICAgIGlmICggaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBpbnN0O1xuICAgICAgICB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgQ29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QucHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcblxuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3QuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIGluc3QuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICAgICAgICB3YXJuKCAvLyBrZWVwIHRoaXMgd2FybmluZyBpbiBzeW5jIHdpdGggUmVhY3RTdHJpY3RNb2RlV2FybmluZy5qc1xuICAgICAgICAgICAgICAnY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgJyArICdvciB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfY29tcG9uZW50TmFtZTQpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgICAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGFueSBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGdEU0ZQLlxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBhbnkgY29tcG9uZW50IHdpdGggdGhlIG5ldyBnRFNGUC5cbiAgICAgICAgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHZhciBvbGRSZXBsYWNlID0gcmVwbGFjZTtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgICByZXBsYWNlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9sZFJlcGxhY2UgJiYgb2xkUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IG9sZFF1ZXVlWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0LnN0YXRlO1xuICAgICAgICAgIHZhciBkb250TXV0YXRlID0gdHJ1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7IGkgPCBvbGRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXTtcblxuICAgICAgICAgICAgdmFyIF9wYXJ0aWFsU3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIGVsZW1lbnQucHJvcHMsIHB1YmxpY0NvbnRleHQpIDogcGFydGlhbDtcblxuICAgICAgICAgICAgaWYgKF9wYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoZG9udE11dGF0ZSkge1xuICAgICAgICAgICAgICAgIGRvbnRNdXRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSBfYXNzaWduKHt9LCBuZXh0U3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGluc3QucmVuZGVyKCk7XG5cbiAgICB7XG4gICAgICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgY2hpbGQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUmVuZGVyUmVzdWx0KGNoaWxkLCBDb21wb25lbnQpO1xuICAgIHZhciBjaGlsZENvbnRleHQ7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGluc3QuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfY2hpbGRDb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcblxuICAgICAgICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIShjb250ZXh0S2V5IGluIF9jaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gX2Fzc2lnbih7fSwgY29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoaWxkOiBjaGlsZCxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH07XG59XG5cbnZhciBSZWFjdERPTVNlcnZlclJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogdHlwZSB0aGlzIG1vcmUgc3RyaWN0bHk6XG4gIC8vIERFVi1vbmx5XG4gIGZ1bmN0aW9uIFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoY2hpbGRyZW4sIG1ha2VTdGF0aWNNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZmxhdENoaWxkcmVuID0gZmxhdHRlblRvcExldmVsQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIHZhciB0b3BGcmFtZSA9IHtcbiAgICAgIHR5cGU6IG51bGwsXG4gICAgICAvLyBBc3N1bWUgYWxsIHRyZWVzIHN0YXJ0IGluIHRoZSBIVE1MIG5hbWVzcGFjZSAobm90IHRvdGFsbHkgdHJ1ZSwgYnV0XG4gICAgICAvLyB0aGlzIGlzIHdoYXQgd2UgZGlkIGhpc3RvcmljYWxseSlcbiAgICAgIGRvbU5hbWVzcGFjZTogTmFtZXNwYWNlcy5odG1sLFxuICAgICAgY2hpbGRyZW46IGZsYXRDaGlsZHJlbixcbiAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICBjb250ZXh0OiBlbXB0eU9iamVjdCxcbiAgICAgIGZvb3RlcjogJydcbiAgICB9O1xuXG4gICAge1xuICAgICAgdG9wRnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnRocmVhZElEID0gYWxsb2NUaHJlYWRJRCgpO1xuICAgIHRoaXMuc3RhY2sgPSBbdG9wRnJhbWVdO1xuICAgIHRoaXMuZXhoYXVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgIHRoaXMubWFrZVN0YXRpY01hcmt1cCA9IG1ha2VTdGF0aWNNYXJrdXA7XG4gICAgdGhpcy5zdXNwZW5zZURlcHRoID0gMDsgLy8gQ29udGV4dCAobmV3IEFQSSlcblxuICAgIHRoaXMuY29udGV4dEluZGV4ID0gLTE7XG4gICAgdGhpcy5jb250ZXh0U3RhY2sgPSBbXTtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrID0gW107IC8vIHVzZU9wYXF1ZUlkZW50aWZpZXIgSURcblxuICAgIHRoaXMudW5pcXVlSUQgPSAwO1xuICAgIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IHx8ICcnO1xuXG4gICAge1xuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFjayA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdERPTVNlcnZlclJlbmRlcmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmV4aGF1c3RlZCkge1xuICAgICAgdGhpcy5leGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jbGVhclByb3ZpZGVycygpO1xuICAgICAgZnJlZVRocmVhZElEKHRoaXMudGhyZWFkSUQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTm90ZTogV2UgdXNlIGp1c3QgdHdvIHN0YWNrcyByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGNvbnRleHQgcHJvdmlkZXJzIHlvdSBoYXZlLlxuICAgKiBQcm92aWRlcnMgYXJlIGFsd2F5cyBwb3BwZWQgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdG8gaG93IHRoZXkgd2VyZSBwdXNoZWRcbiAgICogc28gd2UgYWx3YXlzIGtub3cgb24gdGhlIHdheSBkb3duIHdoaWNoIHByb3ZpZGVyIHlvdSdsbCBlbmNvdW50ZXIgbmV4dCBvbiB0aGUgd2F5IHVwLlxuICAgKiBPbiB0aGUgd2F5IGRvd24sIHdlIHB1c2ggdGhlIGN1cnJlbnQgcHJvdmlkZXIsIGFuZCBpdHMgY29udGV4dCB2YWx1ZSAqYmVmb3JlKlxuICAgKiB3ZSBtdXRhdGVkIGl0LCBvbnRvIHRoZSBzdGFja3MuIFRoZXJlZm9yZSwgb24gdGhlIHdheSB1cCwgd2UgYWx3YXlzIGtub3cgd2hpY2hcbiAgICogcHJvdmlkZXIgbmVlZHMgdG8gYmUgXCJyZXN0b3JlZFwiIHRvIHdoaWNoIHZhbHVlLlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMjk4NSNpc3N1ZWNvbW1lbnQtMzk2MzAxMjQ4XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnB1c2hQcm92aWRlciA9IGZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlcikge1xuICAgIHZhciBpbmRleCA9ICsrdGhpcy5jb250ZXh0SW5kZXg7XG4gICAgdmFyIGNvbnRleHQgPSBwcm92aWRlci50eXBlLl9jb250ZXh0O1xuICAgIHZhciB0aHJlYWRJRCA9IHRoaXMudGhyZWFkSUQ7XG4gICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGNvbnRleHRbdGhyZWFkSURdOyAvLyBSZW1lbWJlciB3aGljaCB2YWx1ZSB0byByZXN0b3JlIHRoaXMgY29udGV4dCB0byBvbiBvdXIgd2F5IHVwLlxuXG4gICAgdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdID0gY29udGV4dDtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XSA9IHByZXZpb3VzVmFsdWU7XG5cbiAgICB7XG4gICAgICAvLyBPbmx5IHVzZWQgZm9yIHB1c2gvcG9wIG1pc21hdGNoIHdhcm5pbmdzLlxuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0gPSBwcm92aWRlcjtcbiAgICB9IC8vIE11dGF0ZSB0aGUgY3VycmVudCB2YWx1ZS5cblxuXG4gICAgY29udGV4dFt0aHJlYWRJRF0gPSBwcm92aWRlci5wcm9wcy52YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8ucG9wUHJvdmlkZXIgPSBmdW5jdGlvbiBwb3BQcm92aWRlcihwcm92aWRlcikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dEluZGV4O1xuXG4gICAge1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBwcm92aWRlciAhPT0gdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0pIHtcbiAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF07IC8vIFwiSGlkZVwiIHRoZXNlIG51bGwgYXNzaWdubWVudHMgZnJvbSBGbG93IGJ5IHVzaW5nIGBhbnlgXG4gICAgLy8gYmVjYXVzZSBjb25jZXB0dWFsbHkgdGhleSBhcmUgZGVsZXRpb25zLS1hcyBsb25nIGFzIHdlXG4gICAgLy8gcHJvbWlzZSB0byBuZXZlciBhY2Nlc3MgdmFsdWVzIGJleW9uZCBgdGhpcy5jb250ZXh0SW5kZXhgLlxuXG4gICAgdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAgICB7XG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0SW5kZXgtLTsgLy8gUmVzdG9yZSB0byB0aGUgcHJldmlvdXMgdmFsdWUgd2Ugc3RvcmVkIGFzIHdlIHdlcmUgd2Fsa2luZyBkb3duLlxuICAgIC8vIFdlJ3ZlIGFscmVhZHkgdmVyaWZpZWQgdGhhdCB0aGlzIGNvbnRleHQgaGFzIGJlZW4gZXhwYW5kZWQgdG8gYWNjb21tb2RhdGVcbiAgICAvLyB0aGlzIHRocmVhZCBpZCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBpdCBhZ2Fpbi5cblxuICAgIGNvbnRleHRbdGhpcy50aHJlYWRJRF0gPSBwcmV2aW91c1ZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5jbGVhclByb3ZpZGVycyA9IGZ1bmN0aW9uIGNsZWFyUHJvdmlkZXJzKCkge1xuICAgIC8vIFJlc3RvcmUgYW55IHJlbWFpbmluZyBwcm92aWRlcnMgb24gdGhlIHN0YWNrIHRvIHByZXZpb3VzIHZhbHVlc1xuICAgIGZvciAodmFyIGluZGV4ID0gdGhpcy5jb250ZXh0SW5kZXg7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdO1xuICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XTtcbiAgICAgIGNvbnRleHRbdGhpcy50aHJlYWRJRF0gPSBwcmV2aW91c1ZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVhZCA9IGZ1bmN0aW9uIHJlYWQoYnl0ZXMpIHtcbiAgICBpZiAodGhpcy5leGhhdXN0ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwcmV2UGFydGlhbFJlbmRlcmVyID0gY3VycmVudFBhcnRpYWxSZW5kZXJlcjtcbiAgICBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHRoaXMpO1xuICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gRGlzcGF0Y2hlcjtcblxuICAgIHRyeSB7XG4gICAgICAvLyBNYXJrdXAgZ2VuZXJhdGVkIHdpdGhpbiA8U3VzcGVuc2U+IGVuZHMgdXAgYnVmZmVyZWQgdW50aWwgd2Uga25vd1xuICAgICAgLy8gbm90aGluZyBpbiB0aGF0IGJvdW5kYXJ5IHN1c3BlbmRlZFxuICAgICAgdmFyIG91dCA9IFsnJ107XG4gICAgICB2YXIgc3VzcGVuZGVkID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChvdXRbMF0ubGVuZ3RoIDwgYnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5leGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGZyZWVUaHJlYWRJRCh0aGlzLnRocmVhZElEKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc3VzcGVuZGVkIHx8IGZyYW1lLmNoaWxkSW5kZXggPj0gZnJhbWUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGZvb3RlciA9IGZyYW1lLmZvb3RlcjtcblxuICAgICAgICAgIGlmIChmb290ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZS50eXBlICE9IG51bGwgJiYgZnJhbWUudHlwZS50eXBlICE9IG51bGwgJiYgZnJhbWUudHlwZS50eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBmcmFtZS50eXBlO1xuICAgICAgICAgICAgdGhpcy5wb3BQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZS50eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFKSB7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNlRGVwdGgtLTtcbiAgICAgICAgICAgIHZhciBidWZmZXJlZCA9IG91dC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICBzdXNwZW5kZWQgPSBmYWxzZTsgLy8gSWYgcmVuZGVyaW5nIHdhcyBzdXNwZW5kZWQgYXQgdGhpcyBib3VuZGFyeSwgcmVuZGVyIHRoZSBmYWxsYmFja0ZyYW1lXG5cbiAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrRnJhbWUgPSBmcmFtZS5mYWxsYmFja0ZyYW1lO1xuXG4gICAgICAgICAgICAgIGlmICghZmFsbGJhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRydWUgPyBcIlJlYWN0RE9NU2VydmVyIGRpZCBub3QgZmluZCBhbiBpbnRlcm5hbCBmYWxsYmFjayBmcmFtZSBmb3IgU3VzcGVuc2UuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMDMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZmFsbGJhY2tGcmFtZSk7XG4gICAgICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9ICc8IS0tJCEtLT4nOyAvLyBTa2lwIGZsdXNoaW5nIG91dHB1dCBzaW5jZSB3ZSdyZSBzd2l0Y2hpbmcgdG8gdGhlIGZhbGxiYWNrXG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBidWZmZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIEZsdXNoIG91dHB1dFxuXG5cbiAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBmb290ZXI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBmcmFtZS5jaGlsZHJlbltmcmFtZS5jaGlsZEluZGV4KytdO1xuICAgICAgICB2YXIgb3V0QnVmZmVyID0gJyc7XG5cbiAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICBwdXNoQ3VycmVudERlYnVnU3RhY2sodGhpcy5zdGFjayk7IC8vIFdlJ3JlIHN0YXJ0aW5nIHdvcmsgb24gdGhpcyBmcmFtZSwgc28gcmVzZXQgaXRzIGlubmVyIHN0YWNrLlxuXG4gICAgICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0QnVmZmVyICs9IHRoaXMucmVuZGVyKGNoaWxkLCBmcmFtZS5jb250ZXh0LCBmcmFtZS5kb21OYW1lc3BhY2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwgJiYgdHlwZW9mIGVyci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICAgICAgICBpZiAoISh0aGlzLnN1c3BlbnNlRGVwdGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRydWUgPyBcIkEgUmVhY3QgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZW5kZXJpbmcsIGJ1dCBubyBmYWxsYmFjayBVSSB3YXMgc3BlY2lmaWVkLlxcblxcbkFkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gcHJvdmlkZSBhIGxvYWRpbmcgaW5kaWNhdG9yIG9yIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkuXCIgOiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0MikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWZhbHNlKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodHJ1ZSA/IFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgU3VzcGVuc2UuXCIgOiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5NCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICBwb3BDdXJyZW50RGVidWdTdGFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXQubGVuZ3RoIDw9IHRoaXMuc3VzcGVuc2VEZXB0aCkge1xuICAgICAgICAgIG91dC5wdXNoKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IG91dEJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dFswXTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIHNldEN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIocHJldlBhcnRpYWxSZW5kZXJlcik7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjaGlsZCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHRleHQgPSAnJyArIGNoaWxkO1xuXG4gICAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYWtlU3RhdGljTWFya3VwKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSkge1xuICAgICAgICByZXR1cm4gJzwhLS0gLS0+JyArIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dENoaWxkO1xuXG4gICAgICB2YXIgX3Jlc29sdmUgPSByZXNvbHZlKGNoaWxkLCBjb250ZXh0LCB0aGlzLnRocmVhZElEKTtcblxuICAgICAgbmV4dENoaWxkID0gX3Jlc29sdmUuY2hpbGQ7XG4gICAgICBjb250ZXh0ID0gX3Jlc29sdmUuY29udGV4dDtcblxuICAgICAgaWYgKG5leHRDaGlsZCA9PT0gbnVsbCB8fCBuZXh0Q2hpbGQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gZWxzZSBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRDaGlsZCkpIHtcbiAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIG5leHRDaGlsZC4kJHR5cGVvZiAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ2F0Y2ggdW5leHBlY3RlZCBzcGVjaWFsIHR5cGVzIGVhcmx5LlxuICAgICAgICAgIHZhciAkJHR5cGVvZiA9IG5leHRDaGlsZC4kJHR5cGVvZjtcblxuICAgICAgICAgIGlmICghKCQkdHlwZW9mICE9PSBSRUFDVF9QT1JUQUxfVFlQRSkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIENhdGNoLWFsbCB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AgaWYgUmVhY3QuQ2hpbGRyZW4udG9BcnJheSgpIHN1cHBvcnRzIHNvbWUgbmV3IHR5cGUuXG5cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biBlbGVtZW50LWxpa2Ugb2JqZWN0IHR5cGU6IFwiICsgJCR0eXBlb2YudG9TdHJpbmcoKSArIFwiLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gdG9BcnJheShuZXh0Q2hpbGQpO1xuICAgICAgICB2YXIgZnJhbWUgPSB7XG4gICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dENoaWxkcmVuLFxuICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAge1xuICAgICAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnJhbWUpO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IC8vIFNhZmUgYmVjYXVzZSB3ZSBqdXN0IGNoZWNrZWQgaXQncyBhbiBlbGVtZW50LlxuXG5cbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZDtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IG5leHRFbGVtZW50LnR5cGU7XG5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckRPTShuZXh0RWxlbWVudCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlbGVtZW50VHlwZSkge1xuICAgICAgICAvLyBUT0RPOiBMZWdhY3lIaWRkZW4gYWN0cyB0aGUgc2FtZSBhcyBhIGZyYWdtZW50LiBUaGlzIG9ubHkgd29ya3NcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBjdXJyZW50bHkgYXNzdW1lIHRoYXQgZXZlcnkgaW5zdGFuY2Ugb2YgTGVnYWN5SGlkZGVuIGlzXG4gICAgICAgIC8vIGFjY29tcGFuaWVkIGJ5IGEgaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdFxuICAgICAgICAvLyBjb21wb25lbnQgaXMgZ2l2ZW4gYSBgaGlkZGVuYCBhdHRyaWJ1dGUsIHdoaWNoIGVuc3VyZXMgdGhhdCB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBIVE1MIGlzIG5vdCB2aXNpYmxlLiBUbyBzdXBwb3J0IHRoZSB1c2Ugb2YgTGVnYWN5SGlkZGVuIGFzIGFcbiAgICAgICAgLy8gdHJ1ZSBmcmFnbWVudCwgd2l0aG91dCBhbiBleHRyYSBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZVxuICAgICAgICAvLyBpbml0aWFsIEhUTUwgaW4gc29tZSBvdGhlciB3YXkuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbiA9IHRvQXJyYXkobmV4dENoaWxkLnByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdmFyIF9mcmFtZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9mcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IFN1c3BlbnNlLlwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG4gICAgICAgICAge1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBzY29wZSBjb21wb25lbnRzLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudFR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbmV4dENoaWxkO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNTtcblxuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgICAgICAgICAgICAgcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNSA9IGVsZW1lbnRUeXBlLnJlbmRlcihlbGVtZW50LnByb3BzLCBlbGVtZW50LnJlZik7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW41ID0gZmluaXNoSG9va3MoZWxlbWVudFR5cGUucmVuZGVyLCBlbGVtZW50LnByb3BzLCBfbmV4dENoaWxkcmVuNSwgZWxlbWVudC5yZWYpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNSA9IHRvQXJyYXkoX25leHRDaGlsZHJlbjUpO1xuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuNSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU1LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNSk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX2VsZW1lbnQgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNiA9IFtSZWFjdC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlLnR5cGUsIF9hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHJlZjogX2VsZW1lbnQucmVmXG4gICAgICAgICAgICAgIH0sIF9lbGVtZW50LnByb3BzKSldO1xuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuNixcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU2LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNik7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgbmV4dFByb3BzID0gcHJvdmlkZXIucHJvcHM7XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW43ID0gdG9BcnJheShuZXh0UHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICAgIHZhciBfZnJhbWU3ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuNyxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU3LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnB1c2hQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU3KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZWFjdENvbnRleHQgPSBuZXh0Q2hpbGQudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gICAgICAgICAgICAgIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gICAgICAgICAgICAgIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAgICAgICAgICAgICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAgICAgICAgICAgICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAgICAgICAgICAgICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgICAgICAgICAgICAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhY3RDb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgICAgICAgICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgICAgICAgICAgICAgaWYgKHJlYWN0Q29udGV4dCAhPT0gcmVhY3RDb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVhY3RDb250ZXh0ID0gcmVhY3RDb250ZXh0Ll9jb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBfbmV4dFByb3BzID0gbmV4dENoaWxkLnByb3BzO1xuICAgICAgICAgICAgICB2YXIgdGhyZWFkSUQgPSB0aGlzLnRocmVhZElEO1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMocmVhY3RDb250ZXh0LCB0aHJlYWRJRCk7XG4gICAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSByZWFjdENvbnRleHRbdGhyZWFkSURdO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuOCA9IHRvQXJyYXkoX25leHRQcm9wcy5jaGlsZHJlbihuZXh0VmFsdWUpKTtcblxuICAgICAgICAgICAgICB2YXIgX2ZyYW1lOCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBuZXh0Q2hpbGQsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW44LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTguZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU4KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFOlxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgZnVuZGFtZW50YWwgQVBJLlwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGVtZW50MiA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSBuZXh0Q2hpbGQudHlwZTsgLy8gQXR0ZW1wdCB0byBpbml0aWFsaXplIGxhenkgY29tcG9uZW50IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVcbiAgICAgICAgICAgICAgLy8gc3VzcGVuc2Ugc2VydmVyLXNpZGUgcmVuZGVyZXIgaXMgZW5hYmxlZCBzbyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgIC8vIHJlc29sdmVkIGNvbnN0cnVjdG9ycyBhcmUgc3VwcG9ydGVkLlxuXG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4xMCA9IFtSZWFjdC5jcmVhdGVFbGVtZW50KHJlc3VsdCwgX2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgcmVmOiBfZWxlbWVudDIucmVmXG4gICAgICAgICAgICAgIH0sIF9lbGVtZW50Mi5wcm9wcykpXTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTEwID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW4xMCxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWUxMC5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTEwKTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIG93bmVyID0gbmV4dEVsZW1lbnQuX293bmVyO1xuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZWxlbWVudFR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWUob3duZXIpIDogbnVsbDtcblxuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogXCIgKyAoZWxlbWVudFR5cGUgPT0gbnVsbCA/IGVsZW1lbnRUeXBlIDogdHlwZW9mIGVsZW1lbnRUeXBlKSArIFwiLlwiICsgaW5mbyApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXJET00gPSBmdW5jdGlvbiByZW5kZXJET00oZWxlbWVudCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gICAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBuYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBOYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIG5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IE5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgICAgaWYgKHRhZyAhPT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZXJyb3IoJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnICsgJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnICsgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLCBlbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgICB2YXIgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAge1xuICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlKSB7XG4gICAgICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSBfYXNzaWduKHtcbiAgICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgICB9LCBwcm9wcywge1xuICAgICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgY2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAge1xuICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlKSB7XG4gICAgICAgICAgZXJyb3IoJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaW5pdGlhbFZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgICAgIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlOyAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuXG4gICAgICAgIHZhciB0ZXh0YXJlYUNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKHRleHRhcmVhQ2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dGFyZWFDaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGlmICghKHRleHRhcmVhQ2hpbGRyZW4ubGVuZ3RoIDw9IDEpKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0YXJlYUNoaWxkcmVuID0gdGV4dGFyZWFDaGlsZHJlblswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIHRleHRhcmVhQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBjaGlsZHJlbjogJycgKyBpbml0aWFsVmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAge1xuICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdzZWxlY3QnLCBwcm9wcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuXG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcblxuICAgICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4nLCBwcm9wTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJywgcHJvcE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlKSB7XG4gICAgICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgcHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ29wdGlvbicpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgICB2YXIgc2VsZWN0VmFsdWUgPSB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZTtcbiAgICAgIHZhciBvcHRpb25DaGlsZHJlbiA9IGZsYXR0ZW5PcHRpb25DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbkNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2pdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMgPSBfYXNzaWduKHtcbiAgICAgICAgICBzZWxlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWRcbiAgICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgY2hpbGRyZW46IG9wdGlvbkNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKTtcbiAgICB2YXIgb3V0ID0gY3JlYXRlT3BlblRhZ01hcmt1cChlbGVtZW50LnR5cGUsIHRhZywgcHJvcHMsIG5hbWVzcGFjZSwgdGhpcy5tYWtlU3RhdGljTWFya3VwLCB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMSk7XG4gICAgdmFyIGZvb3RlciA9ICcnO1xuXG4gICAgaWYgKG9taXR0ZWRDbG9zZVRhZ3MuaGFzT3duUHJvcGVydHkodGFnKSkge1xuICAgICAgb3V0ICs9ICcvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnPic7XG4gICAgICBmb290ZXIgPSAnPC8nICsgZWxlbWVudC50eXBlICsgJz4nO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbjtcbiAgICB2YXIgaW5uZXJNYXJrdXAgPSBnZXROb25DaGlsZHJlbklubmVyTWFya3VwKHByb3BzKTtcblxuICAgIGlmIChpbm5lck1hcmt1cCAhPSBudWxsKSB7XG4gICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3MuaGFzT3duUHJvcGVydHkodGFnKSAmJiBpbm5lck1hcmt1cC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICAgIG91dCArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IGlubmVyTWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbiA9IHRvQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHZhciBmcmFtZSA9IHtcbiAgICAgIGRvbU5hbWVzcGFjZTogZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCBlbGVtZW50LnR5cGUpLFxuICAgICAgdHlwZTogdGFnLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBmb290ZXI6IGZvb3RlclxuICAgIH07XG5cbiAgICB7XG4gICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucHVzaChmcmFtZSk7XG4gICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICByZXR1cm4gUmVhY3RET01TZXJ2ZXJSZW5kZXJlcjtcbn0oKTtcblxuLyoqXG4gKiBSZW5kZXIgYSBSZWFjdEVsZW1lbnQgdG8gaXRzIGluaXRpYWwgSFRNTC4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIG9uIHRoZVxuICogc2VydmVyLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciByZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIGZhbHNlLCBvcHRpb25zKTtcblxuICB0cnkge1xuICAgIHZhciBtYXJrdXAgPSByZW5kZXJlci5yZWFkKEluZmluaXR5KTtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfVxufVxuLyoqXG4gKiBTaW1pbGFyIHRvIHJlbmRlclRvU3RyaW5nLCBleGNlcHQgdGhpcyBkb2Vzbid0IGNyZWF0ZSBleHRyYSBET00gYXR0cmlidXRlc1xuICogc3VjaCBhcyBkYXRhLXJlYWN0LWlkIHRoYXQgUmVhY3QgdXNlcyBpbnRlcm5hbGx5LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdGF0aWNtYXJrdXBcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciByZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIHRydWUsIG9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgdmFyIG1hcmt1cCA9IHJlbmRlcmVyLnJlYWQoSW5maW5pdHkpO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH0gZmluYWxseSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFkYWJsZSkge1xuICBfaW5oZXJpdHNMb29zZShSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtLCBfUmVhZGFibGUpO1xuXG4gIGZ1bmN0aW9uIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgbWFrZVN0YXRpY01hcmt1cCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIC8vIENhbGxzIHRoZSBzdHJlYW0uUmVhZGFibGUob3B0aW9ucykgY29uc3RydWN0b3IuIENvbnNpZGVyIGV4cG9zaW5nIGJ1aWx0LWluXG4gICAgLy8gZmVhdHVyZXMgbGlrZSBoaWdoV2F0ZXJNYXJrIGluIHRoZSBmdXR1cmUuXG4gICAgX3RoaXMgPSBfUmVhZGFibGUuY2FsbCh0aGlzLCB7fSkgfHwgdGhpcztcbiAgICBfdGhpcy5wYXJ0aWFsUmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCBtYWtlU3RhdGljTWFya3VwLCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgIHRoaXMucGFydGlhbFJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuXG4gIF9wcm90by5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKHNpemUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wdXNoKHRoaXMucGFydGlhbFJlbmRlcmVyLnJlYWQoc2l6ZSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0cm95KGVycik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtO1xufShzdHJlYW0uUmVhZGFibGUpO1xuLyoqXG4gKiBSZW5kZXIgYSBSZWFjdEVsZW1lbnQgdG8gaXRzIGluaXRpYWwgSFRNTC4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIG9uIHRoZVxuICogc2VydmVyLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9ub2Rlc3RyZWFtXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW0oZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgZmFsc2UsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBTaW1pbGFyIHRvIHJlbmRlclRvTm9kZVN0cmVhbSwgZXhjZXB0IHRoaXMgZG9lc24ndCBjcmVhdGUgZXh0cmEgRE9NIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgZGF0YS1yZWFjdC1pZCB0aGF0IFJlYWN0IHVzZXMgaW50ZXJuYWxseS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RhdGljbm9kZXN0cmVhbVxuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbShlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCB0cnVlLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5yZW5kZXJUb05vZGVTdHJlYW0gPSByZW5kZXJUb05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTm9kZVN0cmVhbSA9IHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdHJpbmcgPSByZW5kZXJUb1N0cmluZztcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NlcnZlci5ub2RlJyk7XG4iLCAiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCAibW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkgeyAvKiovIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgK1xuICAgICAgICAgICAgICAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwgIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsICIvKiBOUHJvZ3Jlc3MsIChjKSAyMDEzLCAyMDE0IFJpY28gU3RhLiBDcnV6IC0gaHR0cDovL3JpY29zdGFjcnV6LmNvbS9ucHJvZ3Jlc3NcbiAqIEBsaWNlbnNlIE1JVCAqL1xuXG47KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuTlByb2dyZXNzID0gZmFjdG9yeSgpO1xuICB9XG5cbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICB2YXIgTlByb2dyZXNzID0ge307XG5cbiAgTlByb2dyZXNzLnZlcnNpb24gPSAnMC4yLjAnO1xuXG4gIHZhciBTZXR0aW5ncyA9IE5Qcm9ncmVzcy5zZXR0aW5ncyA9IHtcbiAgICBtaW5pbXVtOiAwLjA4LFxuICAgIGVhc2luZzogJ2Vhc2UnLFxuICAgIHBvc2l0aW9uVXNpbmc6ICcnLFxuICAgIHNwZWVkOiAyMDAsXG4gICAgdHJpY2tsZTogdHJ1ZSxcbiAgICB0cmlja2xlUmF0ZTogMC4wMixcbiAgICB0cmlja2xlU3BlZWQ6IDgwMCxcbiAgICBzaG93U3Bpbm5lcjogdHJ1ZSxcbiAgICBiYXJTZWxlY3RvcjogJ1tyb2xlPVwiYmFyXCJdJyxcbiAgICBzcGlubmVyU2VsZWN0b3I6ICdbcm9sZT1cInNwaW5uZXJcIl0nLFxuICAgIHBhcmVudDogJ2JvZHknLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cImJhclwiIHJvbGU9XCJiYXJcIj48ZGl2IGNsYXNzPVwicGVnXCI+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cInNwaW5uZXJcIiByb2xlPVwic3Bpbm5lclwiPjxkaXYgY2xhc3M9XCJzcGlubmVyLWljb25cIj48L2Rpdj48L2Rpdj4nXG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5jb25maWd1cmUoe1xuICAgKiAgICAgICBtaW5pbXVtOiAwLjFcbiAgICogICAgIH0pO1xuICAgKi9cbiAgTlByb2dyZXNzLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5LCB2YWx1ZTtcbiAgICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkgU2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMYXN0IG51bWJlci5cbiAgICovXG5cbiAgTlByb2dyZXNzLnN0YXR1cyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb2dyZXNzIGJhciBzdGF0dXMsIHdoZXJlIGBuYCBpcyBhIG51bWJlciBmcm9tIGAwLjBgIHRvIGAxLjBgLlxuICAgKlxuICAgKiAgICAgTlByb2dyZXNzLnNldCgwLjQpO1xuICAgKiAgICAgTlByb2dyZXNzLnNldCgxLjApO1xuICAgKi9cblxuICBOUHJvZ3Jlc3Muc2V0ID0gZnVuY3Rpb24obikge1xuICAgIHZhciBzdGFydGVkID0gTlByb2dyZXNzLmlzU3RhcnRlZCgpO1xuXG4gICAgbiA9IGNsYW1wKG4sIFNldHRpbmdzLm1pbmltdW0sIDEpO1xuICAgIE5Qcm9ncmVzcy5zdGF0dXMgPSAobiA9PT0gMSA/IG51bGwgOiBuKTtcblxuICAgIHZhciBwcm9ncmVzcyA9IE5Qcm9ncmVzcy5yZW5kZXIoIXN0YXJ0ZWQpLFxuICAgICAgICBiYXIgICAgICA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MuYmFyU2VsZWN0b3IpLFxuICAgICAgICBzcGVlZCAgICA9IFNldHRpbmdzLnNwZWVkLFxuICAgICAgICBlYXNlICAgICA9IFNldHRpbmdzLmVhc2luZztcblxuICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICBxdWV1ZShmdW5jdGlvbihuZXh0KSB7XG4gICAgICAvLyBTZXQgcG9zaXRpb25Vc2luZyBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldFxuICAgICAgaWYgKFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09ICcnKSBTZXR0aW5ncy5wb3NpdGlvblVzaW5nID0gTlByb2dyZXNzLmdldFBvc2l0aW9uaW5nQ1NTKCk7XG5cbiAgICAgIC8vIEFkZCB0cmFuc2l0aW9uXG4gICAgICBjc3MoYmFyLCBiYXJQb3NpdGlvbkNTUyhuLCBzcGVlZCwgZWFzZSkpO1xuXG4gICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAvLyBGYWRlIG91dFxuICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnLCBcbiAgICAgICAgICBvcGFjaXR5OiAxIFxuICAgICAgICB9KTtcbiAgICAgICAgcHJvZ3Jlc3Mub2Zmc2V0V2lkdGg7IC8qIFJlcGFpbnQgKi9cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNzcyhwcm9ncmVzcywgeyBcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdhbGwgJyArIHNwZWVkICsgJ21zIGxpbmVhcicsIFxuICAgICAgICAgICAgb3BhY2l0eTogMCBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgTlByb2dyZXNzLnJlbW92ZSgpO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH0sIHNwZWVkKTtcbiAgICAgICAgfSwgc3BlZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChuZXh0LCBzcGVlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBOUHJvZ3Jlc3MuaXNTdGFydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBOUHJvZ3Jlc3Muc3RhdHVzID09PSAnbnVtYmVyJztcbiAgfTtcblxuICAvKipcbiAgICogU2hvd3MgdGhlIHByb2dyZXNzIGJhci5cbiAgICogVGhpcyBpcyB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMCUsIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgZ28gYmFja3dhcmRzLlxuICAgKlxuICAgKiAgICAgTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAqXG4gICAqL1xuICBOUHJvZ3Jlc3Muc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIU5Qcm9ncmVzcy5zdGF0dXMpIE5Qcm9ncmVzcy5zZXQoMCk7XG5cbiAgICB2YXIgd29yayA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSByZXR1cm47XG4gICAgICAgIE5Qcm9ncmVzcy50cmlja2xlKCk7XG4gICAgICAgIHdvcmsoKTtcbiAgICAgIH0sIFNldHRpbmdzLnRyaWNrbGVTcGVlZCk7XG4gICAgfTtcblxuICAgIGlmIChTZXR0aW5ncy50cmlja2xlKSB3b3JrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSGlkZXMgdGhlIHByb2dyZXNzIGJhci5cbiAgICogVGhpcyBpcyB0aGUgKnNvcnQgb2YqIHRoZSBzYW1lIGFzIHNldHRpbmcgdGhlIHN0YXR1cyB0byAxMDAlLCB3aXRoIHRoZVxuICAgKiBkaWZmZXJlbmNlIGJlaW5nIGBkb25lKClgIG1ha2VzIHNvbWUgcGxhY2VibyBlZmZlY3Qgb2Ygc29tZSByZWFsaXN0aWMgbW90aW9uLlxuICAgKlxuICAgKiAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICpcbiAgICogSWYgYHRydWVgIGlzIHBhc3NlZCwgaXQgd2lsbCBzaG93IHRoZSBwcm9ncmVzcyBiYXIgZXZlbiBpZiBpdHMgaGlkZGVuLlxuICAgKlxuICAgKiAgICAgTlByb2dyZXNzLmRvbmUodHJ1ZSk7XG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5kb25lID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICBpZiAoIWZvcmNlICYmICFOUHJvZ3Jlc3Muc3RhdHVzKSByZXR1cm4gdGhpcztcblxuICAgIHJldHVybiBOUHJvZ3Jlc3MuaW5jKDAuMyArIDAuNSAqIE1hdGgucmFuZG9tKCkpLnNldCgxKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVtZW50cyBieSBhIHJhbmRvbSBhbW91bnQuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5pbmMgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICB2YXIgbiA9IE5Qcm9ncmVzcy5zdGF0dXM7XG5cbiAgICBpZiAoIW4pIHtcbiAgICAgIHJldHVybiBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGFtb3VudCA9ICgxIC0gbikgKiBjbGFtcChNYXRoLnJhbmRvbSgpICogbiwgMC4xLCAwLjk1KTtcbiAgICAgIH1cblxuICAgICAgbiA9IGNsYW1wKG4gKyBhbW91bnQsIDAsIDAuOTk0KTtcbiAgICAgIHJldHVybiBOUHJvZ3Jlc3Muc2V0KG4pO1xuICAgIH1cbiAgfTtcblxuICBOUHJvZ3Jlc3MudHJpY2tsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBOUHJvZ3Jlc3MuaW5jKE1hdGgucmFuZG9tKCkgKiBTZXR0aW5ncy50cmlja2xlUmF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhbGwgc3VwcGxpZWQgalF1ZXJ5IHByb21pc2VzIGFuZFxuICAgKiBpbmNyZWFzZXMgdGhlIHByb2dyZXNzIGFzIHRoZSBwcm9taXNlcyByZXNvbHZlLlxuICAgKlxuICAgKiBAcGFyYW0gJHByb21pc2UgalFVZXJ5IFByb21pc2VcbiAgICovXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5pdGlhbCA9IDAsIGN1cnJlbnQgPSAwO1xuXG4gICAgTlByb2dyZXNzLnByb21pc2UgPSBmdW5jdGlvbigkcHJvbWlzZSkge1xuICAgICAgaWYgKCEkcHJvbWlzZSB8fCAkcHJvbWlzZS5zdGF0ZSgpID09PSBcInJlc29sdmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSAwKSB7XG4gICAgICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsKys7XG4gICAgICBjdXJyZW50Kys7XG5cbiAgICAgICRwcm9taXNlLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgY3VycmVudC0tO1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgICAgaW5pdGlhbCA9IDA7XG4gICAgICAgICAgICBOUHJvZ3Jlc3MuZG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTlByb2dyZXNzLnNldCgoaW5pdGlhbCAtIGN1cnJlbnQpIC8gaW5pdGlhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgcmVuZGVycyB0aGUgcHJvZ3Jlc3MgYmFyIG1hcmt1cCBiYXNlZCBvbiB0aGUgYHRlbXBsYXRlYFxuICAgKiBzZXR0aW5nLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVuZGVyID0gZnVuY3Rpb24oZnJvbVN0YXJ0KSB7XG4gICAgaWYgKE5Qcm9ncmVzcy5pc1JlbmRlcmVkKCkpIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbnByb2dyZXNzJyk7XG5cbiAgICBhZGRDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICducHJvZ3Jlc3MtYnVzeScpO1xuICAgIFxuICAgIHZhciBwcm9ncmVzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHByb2dyZXNzLmlkID0gJ25wcm9ncmVzcyc7XG4gICAgcHJvZ3Jlc3MuaW5uZXJIVE1MID0gU2V0dGluZ3MudGVtcGxhdGU7XG5cbiAgICB2YXIgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgcGVyYyAgICAgPSBmcm9tU3RhcnQgPyAnLTEwMCcgOiB0b0JhclBlcmMoTlByb2dyZXNzLnN0YXR1cyB8fCAwKSxcbiAgICAgICAgcGFyZW50ICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksXG4gICAgICAgIHNwaW5uZXI7XG4gICAgXG4gICAgY3NzKGJhciwge1xuICAgICAgdHJhbnNpdGlvbjogJ2FsbCAwIGxpbmVhcicsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgcGVyYyArICclLDAsMCknXG4gICAgfSk7XG5cbiAgICBpZiAoIVNldHRpbmdzLnNob3dTcGlubmVyKSB7XG4gICAgICBzcGlubmVyID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5zcGlubmVyU2VsZWN0b3IpO1xuICAgICAgc3Bpbm5lciAmJiByZW1vdmVFbGVtZW50KHNwaW5uZXIpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgIT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgYWRkQ2xhc3MocGFyZW50LCAnbnByb2dyZXNzLWN1c3RvbS1wYXJlbnQnKTtcbiAgICB9XG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocHJvZ3Jlc3MpO1xuICAgIHJldHVybiBwcm9ncmVzcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudC4gT3Bwb3NpdGUgb2YgcmVuZGVyKCkuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICducHJvZ3Jlc3MtYnVzeScpO1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MucGFyZW50KSwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgdmFyIHByb2dyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICAgIHByb2dyZXNzICYmIHJlbW92ZUVsZW1lbnQocHJvZ3Jlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHByb2dyZXNzIGJhciBpcyByZW5kZXJlZC5cbiAgICovXG5cbiAgTlByb2dyZXNzLmlzUmVuZGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbnByb2dyZXNzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGljaCBwb3NpdGlvbmluZyBDU1MgcnVsZSB0byB1c2UuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNuaWZmIG9uIGRvY3VtZW50LmJvZHkuc3R5bGVcbiAgICB2YXIgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcblxuICAgIC8vIFNuaWZmIHByZWZpeGVzXG4gICAgdmFyIHZlbmRvclByZWZpeCA9ICgnV2Via2l0VHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ1dlYmtpdCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAoJ01velRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdNb3onIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdtc1RyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdtcycgOlxuICAgICAgICAgICAgICAgICAgICAgICAoJ09UcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTycgOiAnJztcblxuICAgIGlmICh2ZW5kb3JQcmVmaXggKyAnUGVyc3BlY3RpdmUnIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXJzIHdpdGggM0Qgc3VwcG9ydCwgZS5nLiBXZWJraXQsIElFMTBcbiAgICAgIHJldHVybiAndHJhbnNsYXRlM2QnO1xuICAgIH0gZWxzZSBpZiAodmVuZG9yUHJlZml4ICsgJ1RyYW5zZm9ybScgaW4gYm9keVN0eWxlKSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IDNEIHN1cHBvcnQsIGUuZy4gSUU5XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJyb3dzZXJzIHdpdGhvdXQgdHJhbnNsYXRlKCkgc3VwcG9ydCwgZS5nLiBJRTctOFxuICAgICAgcmV0dXJuICdtYXJnaW4nO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyc1xuICAgKi9cblxuICBmdW5jdGlvbiBjbGFtcChuLCBtaW4sIG1heCkge1xuICAgIGlmIChuIDwgbWluKSByZXR1cm4gbWluO1xuICAgIGlmIChuID4gbWF4KSByZXR1cm4gbWF4O1xuICAgIHJldHVybiBuO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgY29udmVydHMgYSBwZXJjZW50YWdlIChgMC4uMWApIHRvIGEgYmFyIHRyYW5zbGF0ZVhcbiAgICogcGVyY2VudGFnZSAoYC0xMDAlLi4wJWApLlxuICAgKi9cblxuICBmdW5jdGlvbiB0b0JhclBlcmMobikge1xuICAgIHJldHVybiAoLTEgKyBuKSAqIDEwMDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgcmV0dXJucyB0aGUgY29ycmVjdCBDU1MgZm9yIGNoYW5naW5nIHRoZSBiYXInc1xuICAgKiBwb3NpdGlvbiBnaXZlbiBhbiBuIHBlcmNlbnRhZ2UsIGFuZCBzcGVlZCBhbmQgZWFzZSBmcm9tIFNldHRpbmdzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJhclBvc2l0aW9uQ1NTKG4sIHNwZWVkLCBlYXNlKSB7XG4gICAgdmFyIGJhckNTUztcblxuICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAndHJhbnNsYXRlM2QnKSB7XG4gICAgICBiYXJDU1MgPSB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcrdG9CYXJQZXJjKG4pKyclLDAsMCknIH07XG4gICAgfSBlbHNlIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAndHJhbnNsYXRlJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyt0b0JhclBlcmMobikrJyUsMCknIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhckNTUyA9IHsgJ21hcmdpbi1sZWZ0JzogdG9CYXJQZXJjKG4pKyclJyB9O1xuICAgIH1cblxuICAgIGJhckNTUy50cmFuc2l0aW9uID0gJ2FsbCAnK3NwZWVkKydtcyAnK2Vhc2U7XG5cbiAgICByZXR1cm4gYmFyQ1NTO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUXVldWVzIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqL1xuXG4gIHZhciBxdWV1ZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgcGVuZGluZyA9IFtdO1xuICAgIFxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgZm4gPSBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4obmV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICBwZW5kaW5nLnB1c2goZm4pO1xuICAgICAgaWYgKHBlbmRpbmcubGVuZ3RoID09IDEpIG5leHQoKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEFwcGxpZXMgY3NzIHByb3BlcnRpZXMgdG8gYW4gZWxlbWVudCwgc2ltaWxhciB0byB0aGUgalF1ZXJ5IFxuICAgKiBjc3MgbWV0aG9kLlxuICAgKlxuICAgKiBXaGlsZSB0aGlzIGhlbHBlciBkb2VzIGFzc2lzdCB3aXRoIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eSBuYW1lcywgaXQgXG4gICAqIGRvZXMgbm90IHBlcmZvcm0gYW55IG1hbmlwdWxhdGlvbiBvZiB2YWx1ZXMgcHJpb3IgdG8gc2V0dGluZyBzdHlsZXMuXG4gICAqL1xuXG4gIHZhciBjc3MgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNzc1ByZWZpeGVzID0gWyAnV2Via2l0JywgJ08nLCAnTW96JywgJ21zJyBdLFxuICAgICAgICBjc3NQcm9wcyAgICA9IHt9O1xuXG4gICAgZnVuY3Rpb24gY2FtZWxDYXNlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9eLW1zLS8sICdtcy0nKS5yZXBsYWNlKC8tKFtcXGRhLXpdKS9naSwgZnVuY3Rpb24obWF0Y2gsIGxldHRlcikge1xuICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWZW5kb3JQcm9wKG5hbWUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICBpZiAobmFtZSBpbiBzdHlsZSkgcmV0dXJuIG5hbWU7XG5cbiAgICAgIHZhciBpID0gY3NzUHJlZml4ZXMubGVuZ3RoLFxuICAgICAgICAgIGNhcE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcbiAgICAgICAgICB2ZW5kb3JOYW1lO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2ZW5kb3JOYW1lID0gY3NzUHJlZml4ZXNbaV0gKyBjYXBOYW1lO1xuICAgICAgICBpZiAodmVuZG9yTmFtZSBpbiBzdHlsZSkgcmV0dXJuIHZlbmRvck5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0eWxlUHJvcChuYW1lKSB7XG4gICAgICBuYW1lID0gY2FtZWxDYXNlKG5hbWUpO1xuICAgICAgcmV0dXJuIGNzc1Byb3BzW25hbWVdIHx8IChjc3NQcm9wc1tuYW1lXSA9IGdldFZlbmRvclByb3AobmFtZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm9wID0gZ2V0U3R5bGVQcm9wKHByb3ApO1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBwcm9wLCBcbiAgICAgICAgICB2YWx1ZTtcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIpIHtcbiAgICAgICAgZm9yIChwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgYXBwbHlDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBseUNzcyhlbGVtZW50LCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgRGV0ZXJtaW5lcyBpZiBhbiBlbGVtZW50IG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzIGNvbnRhaW5zIGEgY2xhc3MgbmFtZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBsaXN0ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgPyBlbGVtZW50IDogY2xhc3NMaXN0KGVsZW1lbnQpO1xuICAgIHJldHVybiBsaXN0LmluZGV4T2YoJyAnICsgbmFtZSArICcgJykgPj0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEFkZHMgYSBjbGFzcyB0byBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3QgPSBvbGRMaXN0ICsgbmFtZTtcblxuICAgIGlmIChoYXNDbGFzcyhvbGRMaXN0LCBuYW1lKSkgcmV0dXJuOyBcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgc3BhY2UuXG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBuZXdMaXN0LnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFJlbW92ZXMgYSBjbGFzcyBmcm9tIGFuIGVsZW1lbnQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgb2xkTGlzdCA9IGNsYXNzTGlzdChlbGVtZW50KSxcbiAgICAgICAgbmV3TGlzdDtcblxuICAgIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkpIHJldHVybjtcblxuICAgIC8vIFJlcGxhY2UgdGhlIGNsYXNzIG5hbWUuXG4gICAgbmV3TGlzdCA9IG9sZExpc3QucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuXG4gICAgLy8gVHJpbSB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBzcGFjZXMuXG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBuZXdMaXN0LnN1YnN0cmluZygxLCBuZXdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgR2V0cyBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIHRoZSBjbGFzcyBuYW1lcyBvbiB0aGUgZWxlbWVudC4gXG4gICAqIFRoZSBsaXN0IGlzIHdyYXBwZWQgd2l0aCBhIHNpbmdsZSBzcGFjZSBvbiBlYWNoIGVuZCB0byBmYWNpbGl0YXRlIGZpbmRpbmcgXG4gICAqIG1hdGNoZXMgd2l0aGluIHRoZSBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiBjbGFzc0xpc3QoZWxlbWVudCkge1xuICAgIHJldHVybiAoJyAnICsgKGVsZW1lbnQuY2xhc3NOYW1lIHx8ICcnKSArICcgJykucmVwbGFjZSgvXFxzKy9naSwgJyAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBOUHJvZ3Jlc3M7XG59KTtcblxuIiwgIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKHN1YmplY3QgPT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChzdWJqZWN0ICE9PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO1xuICBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIFsgc2VxdWVuY2UgXTtcbn1cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIGtleSwgc291cmNlS2V5cztcblxuICBpZiAoc291cmNlKSB7XG4gICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsIGN5Y2xlO1xuXG4gIGZvciAoY3ljbGUgPSAwOyBjeWNsZSA8IGNvdW50OyBjeWNsZSArPSAxKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyID09PSAwKSAmJiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSAxIC8gbnVtYmVyKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5pc05vdGhpbmcgICAgICA9IGlzTm90aGluZztcbm1vZHVsZS5leHBvcnRzLmlzT2JqZWN0ICAgICAgID0gaXNPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cy50b0FycmF5ICAgICAgICA9IHRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0cy5yZXBlYXQgICAgICAgICA9IHJlcGVhdDtcbm1vZHVsZS5leHBvcnRzLmlzTmVnYXRpdmVaZXJvID0gaXNOZWdhdGl2ZVplcm87XG5tb2R1bGUuZXhwb3J0cy5leHRlbmQgICAgICAgICA9IGV4dGVuZDtcbiIsICIvLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcbi8vXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24ocmVhc29uLCBtYXJrKSB7XG4gIC8vIFN1cGVyIGNvbnN0cnVjdG9yXG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5uYW1lID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gKHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJykgKyAodGhpcy5tYXJrID8gJyAnICsgdGhpcy5tYXJrLnRvU3RyaW5nKCkgOiAnJyk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb247XG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLm5hbWUgKyAnOiAnO1xuXG4gIHJlc3VsdCArPSB0aGlzLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xuICAgIHJlc3VsdCArPSAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWUFNTEV4Y2VwdGlvbjtcbiIsICIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikgcmV0dXJuIG51bGw7XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpID09PSAtMSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpID09PSAtMSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy50YWcgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XG4gIHRoaXMuc3R5bGVBbGlhc2VzID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxudmFyIGNvbW1vbiAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIFR5cGUgICAgICAgICAgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUsIHJlc3VsdCkge1xuICB2YXIgZXhjbHVkZSA9IFtdO1xuXG4gIHNjaGVtYS5pbmNsdWRlLmZvckVhY2goZnVuY3Rpb24gKGluY2x1ZGVkU2NoZW1hKSB7XG4gICAgcmVzdWx0ID0gY29tcGlsZUxpc3QoaW5jbHVkZWRTY2hlbWEsIG5hbWUsIHJlc3VsdCk7XG4gIH0pO1xuXG4gIHNjaGVtYVtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50VHlwZSkge1xuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiYgcHJldmlvdXNUeXBlLmtpbmQgPT09IGN1cnJlbnRUeXBlLmtpbmQpIHtcbiAgICAgICAgZXhjbHVkZS5wdXNoKHByZXZpb3VzSW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdWx0LnB1c2goY3VycmVudFR5cGUpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZXhjbHVkZS5pbmRleE9mKGluZGV4KSA9PT0gLTE7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVNYXAoLyogbGlzdHMuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc2NhbGFyOiB7fSxcbiAgICAgICAgc2VxdWVuY2U6IHt9LFxuICAgICAgICBtYXBwaW5nOiB7fSxcbiAgICAgICAgZmFsbGJhY2s6IHt9XG4gICAgICB9LCBpbmRleCwgbGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUeXBlKHR5cGUpIHtcbiAgICByZXN1bHRbdHlwZS5raW5kXVt0eXBlLnRhZ10gPSByZXN1bHRbJ2ZhbGxiYWNrJ11bdHlwZS50YWddID0gdHlwZTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEoZGVmaW5pdGlvbikge1xuICB0aGlzLmluY2x1ZGUgID0gZGVmaW5pdGlvbi5pbmNsdWRlICB8fCBbXTtcbiAgdGhpcy5pbXBsaWNpdCA9IGRlZmluaXRpb24uaW1wbGljaXQgfHwgW107XG4gIHRoaXMuZXhwbGljaXQgPSBkZWZpbml0aW9uLmV4cGxpY2l0IHx8IFtdO1xuXG4gIHRoaXMuaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlLmxvYWRLaW5kICYmIHR5cGUubG9hZEtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmNvbXBpbGVkSW1wbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnaW1wbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRFeHBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdleHBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZFR5cGVNYXAgID0gY29tcGlsZU1hcCh0aGlzLmNvbXBpbGVkSW1wbGljaXQsIHRoaXMuY29tcGlsZWRFeHBsaWNpdCk7XG59XG5cblxuU2NoZW1hLkRFRkFVTFQgPSBudWxsO1xuXG5cblNjaGVtYS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVTY2hlbWEoKSB7XG4gIHZhciBzY2hlbWFzLCB0eXBlcztcblxuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICBzY2hlbWFzID0gU2NoZW1hLkRFRkFVTFQ7XG4gICAgICB0eXBlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgc2NoZW1hcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIFNjaGVtYS5jcmVhdGUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHNjaGVtYXMgPSBjb21tb24udG9BcnJheShzY2hlbWFzKTtcbiAgdHlwZXMgPSBjb21tb24udG9BcnJheSh0eXBlcyk7XG5cbiAgaWYgKCFzY2hlbWFzLmV2ZXJ5KGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYTsgfSkpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2Ygc3VwZXIgc2NoZW1hcyAob3IgYSBzaW5nbGUgU2NoZW1hIG9iamVjdCkgY29udGFpbnMgYSBub24tU2NoZW1hIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmICghdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBUeXBlOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNjaGVtYSh7XG4gICAgaW5jbHVkZTogc2NoZW1hcyxcbiAgICBleHBsaWNpdDogdHlwZXNcbiAgfSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7IH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTsgfVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307IH1cbn0pO1xuIiwgIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDIzNDZcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NlcScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWFwJylcbiAgXVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxOdWxsKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gMSAmJiBkYXRhID09PSAnficpIHx8XG4gICAgICAgICAobWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQm9vbGVhbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cbiAgICAvLyBiYXNlIDhcbiAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApIG9yIGJhc2UgNjBcblxuICAvLyB2YWx1ZSBzaG91bGQgbm90IHN0YXJ0IHdpdGggYF9gO1xuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmIChjaCA9PT0gJzonKSBicmVhaztcbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gaWYgIWJhc2U2MCAtIGRvbmU7XG4gIGlmIChjaCAhPT0gJzonKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBiYXNlNjAgYWxtb3N0IG5vdCB1c2VkLCBubyBuZWVkcyB0byBvcHRpbWl6ZVxuICByZXR1cm4gL14oOlswLTVdP1swLTldKSskLy50ZXN0KGRhdGEuc2xpY2UoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2gsIGJhc2UsIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSBzaWduID0gLTE7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICBjaCA9IHZhbHVlWzBdO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnMCcpIHJldHVybiAwO1xuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnYicpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgOCk7XG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VJbnQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiZcbiAgICAgICAgIChvYmplY3QgJSAxID09PSAwICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwYicgKyBvYmoudG9TdHJpbmcoMikgOiAnLTBiJyArIG9iai50b1N0cmluZygyKS5zbGljZSgxKTsgfSxcbiAgICBvY3RhbDogICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMCcgICsgb2JqLnRvU3RyaW5nKDgpIDogJy0wJyAgKyBvYmoudG9TdHJpbmcoOCkuc2xpY2UoMSk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iai50b1N0cmluZygxMCk7IH0sXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcweCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgOiAgJy0weCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkuc2xpY2UoMSk7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnZGVjaW1hbCcsXG4gIHN0eWxlQWxpYXNlczoge1xuICAgIGJpbmFyeTogICAgICBbIDIsICAnYmluJyBdLFxuICAgIG9jdGFsOiAgICAgICBbIDgsICAnb2N0JyBdLFxuICAgIGRlY2ltYWw6ICAgICBbIDEwLCAnZGVjJyBdLFxuICAgIGhleGFkZWNpbWFsOiBbIDE2LCAnaGV4JyBdXG4gIH1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gIC8vIDIuNWU0LCAyLjUgYW5kIGludGVnZXJzXG4gICdeKD86Wy0rXT8oPzowfFsxLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC4yZTQsIC4yXG4gIC8vIHNwZWNpYWwgY2FzZSwgc2VlbXMgbm90IGZyb20gc3BlY1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIDIwOjU5XG4gICd8Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKicgK1xuICAvLyAuaW5mXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAvLyAubmFuXG4gICd8XFxcXC4oPzpuYW58TmFOfE5BTikpJCcpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEZsb2F0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIVlBTUxfRkxPQVRfUEFUVEVSTi50ZXN0KGRhdGEpIHx8XG4gICAgICAvLyBRdWljayBoYWNrIHRvIG5vdCBhbGxvdyBpbnRlZ2VycyBlbmQgd2l0aCBgX2BcbiAgICAgIC8vIFByb2JhYmx5IHNob3VsZCB1cGRhdGUgcmVnZXhwICYgY2hlY2sgc3BlZWRcbiAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gJ18nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxGbG9hdChkYXRhKSB7XG4gIHZhciB2YWx1ZSwgc2lnbiwgYmFzZSwgZGlnaXRzO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcbiAgZGlnaXRzID0gW107XG5cbiAgaWYgKCcrLScuaW5kZXhPZih2YWx1ZVswXSkgPj0gMCkge1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcuaW5mJykge1xuICAgIHJldHVybiAoc2lnbiA9PT0gMSkgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy5uYW4nKSB7XG4gICAgcmV0dXJuIE5hTjtcblxuICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUZsb2F0KHYsIDEwKSk7XG4gICAgfSk7XG5cbiAgICB2YWx1ZSA9IDAuMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSBkICogYmFzZTtcbiAgICAgIGJhc2UgKj0gNjA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbiAqIHZhbHVlO1xuXG4gIH1cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG59XG5cblxudmFyIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QgPSAvXlstK10/WzAtOV0rZS87XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxGbG9hdChvYmplY3QsIHN0eWxlKSB7XG4gIHZhciByZXM7XG5cbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5uYW4nO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuTkFOJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcuaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLS5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICctLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG5cbiAgcmVzID0gb2JqZWN0LnRvU3RyaW5nKDEwKTtcblxuICAvLyBKUyBzdHJpbmdpZmllciBjYW4gYnVpbGQgc2NpZW50aWZpYyBmb3JtYXQgd2l0aG91dCBkb3RzOiA1ZS0xMDAsXG4gIC8vIHdoaWxlIFlBTUwgcmVxdXJlcyBkb3Q6IDUuZS0xMDAuIEZpeCBpdCB3aXRoIHNpbXBsZSBoYWNrXG5cbiAgcmV0dXJuIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QudGVzdChyZXMpID8gcmVzLnJlcGxhY2UoJ2UnLCAnLmUnKSA6IHJlcztcbn1cblxuZnVuY3Rpb24gaXNGbG9hdChvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpICYmXG4gICAgICAgICAob2JqZWN0ICUgMSAhPT0gMCB8fCBjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxGbG9hdCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sRmxvYXQsXG4gIHByZWRpY2F0ZTogaXNGbG9hdCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sRmxvYXQsXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwgIi8vIFN0YW5kYXJkIFlBTUwncyBKU09OIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMzIzMVxuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIHRoaXMgc2NoZW1hIGlzIG5vdCBzdWNoIHN0cmljdCBhcyBkZWZpbmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vLyBJdCBhbGxvd3MgbnVtYmVycyBpbiBiaW5hcnkgbm90YWlvbiwgdXNlIGBOdWxsYCBhbmQgYE5VTExgIGFzIGBudWxsYCwgZXRjLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZmFpbHNhZmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvbnVsbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvYm9vbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvaW50JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9mbG9hdCcpXG4gIF1cbn0pO1xuIiwgIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vanNvbicpXG4gIF1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX0RBVEVfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XSkkJyk7ICAgICAgICAgICAgICAgICAgIC8vIFszXSBkYXlcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbM10gZGF5XG4gICcoPzpbVHRdfFsgXFxcXHRdKyknICAgICAgICAgICAgICAgICArIC8vIC4uLlxuICAnKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgICsgLy8gWzRdIGhvdXJcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs1XSBtaW51dGVcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs2XSBzZWNvbmRcbiAgJyg/OlxcXFwuKFswLTldKikpPycgICAgICAgICAgICAgICAgICsgLy8gWzddIGZyYWN0aW9uXG4gICcoPzpbIFxcXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pJyArIC8vIFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXJcbiAgJyg/OjooWzAtOV1bMC05XSkpPykpPyQnKTsgICAgICAgICAgIC8vIFsxMV0gdHpfbWludXRlXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGlmIChZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpO1xuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gZGVsdGEpO1xuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG52YXIgTm9kZUJ1ZmZlcjtcblxudHJ5IHtcbiAgLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24sIHRvIG5vdCBpbmNsdWRlIGBCdWZmZXJgIHNoaW1cbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZTtcbiAgTm9kZUJ1ZmZlciA9IF9yZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG59IGNhdGNoIChfXykge31cblxudmFyIFR5cGUgICAgICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSBjb250aW51ZTtcblxuICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICAvLyBTdXBwb3J0IG5vZGUgNi4rIEJ1ZmZlciBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICByZXR1cm4gTm9kZUJ1ZmZlci5mcm9tID8gTm9kZUJ1ZmZlci5mcm9tKHJlc3VsdCkgOiBuZXcgTm9kZUJ1ZmZlcihyZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iamVjdCkge1xuICByZXR1cm4gTm9kZUJ1ZmZlciAmJiBOb2RlQnVmZmVyLmlzQnVmZmVyKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIGlmIChvYmplY3Rba2V5XSAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sU2V0KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcbiIsICIvLyBKUy1ZQU1MJ3MgZGVmYXVsdCBzY2hlbWEgZm9yIGBzYWZlTG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gc3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hIGFuZCBpbmNsdWRlcyBtb3N0IG9mXG4vLyBleHRyYSB0eXBlcyBkZXNjcmliZWQgYXQgWUFNTCB0YWcgcmVwb3NpdG9yeS4gKGh0dHA6Ly95YW1sLm9yZy90eXBlLylcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2NvcmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvdGltZXN0YW1wJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tZXJnZScpXG4gIF0sXG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9iaW5hcnknKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL29tYXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3BhaXJzJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXQnKVxuICBdXG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gaWYgcmVnZXhwIHN0YXJ0cyB3aXRoICcvJyBpdCBjYW4gaGF2ZSBtb2RpZmllcnMgYW5kIG11c3QgYmUgcHJvcGVybHkgY2xvc2VkXG4gIC8vIGAvZm9vL2dpbWAgLSBtb2RpZmllcnMgdGFpbCBjYW4gYmUgbWF4aW11bSAzIGNoYXJzXG4gIGlmIChyZWdleHBbMF0gPT09ICcvJykge1xuICAgIGlmICh0YWlsKSBtb2RpZmllcnMgPSB0YWlsWzFdO1xuXG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gaWYgZXhwcmVzc2lvbiBzdGFydHMgd2l0aCAvLCBpcyBzaG91bGQgYmUgcHJvcGVybHkgdGVybWluYXRlZFxuICAgIGlmIChyZWdleHBbcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxXSAhPT0gJy8nKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGAvZm9vL2dpbWAgLSB0YWlsIGNhbiBiZSBtYXhpbXVtIDQgY2hhcnNcbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgcmVnZXhwID0gcmVnZXhwLnNsaWNlKDEsIHJlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG1vZGlmaWVycyk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRSZWdFeHAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnLycgKyBvYmplY3Quc291cmNlICsgJy8nO1xuXG4gIGlmIChvYmplY3QuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAob2JqZWN0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKG9iamVjdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9yZWdleHAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwLFxuICBwcmVkaWNhdGU6IGlzUmVnRXhwLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRSZWdFeHBcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGVzcHJpbWE7XG5cbi8vIEJyb3dzZXJpZmllZCB2ZXJzaW9uIGRvZXMgbm90IGhhdmUgZXNwcmltYVxuLy9cbi8vIDEuIEZvciBub2RlLmpzIGp1c3QgcmVxdWlyZSBtb2R1bGUgYXMgZGVwc1xuLy8gMi4gRm9yIGJyb3dzZXIgdHJ5IHRvIHJlcXVpcmUgbXVkdWxlIHZpYSBleHRlcm5hbCBBTUQgc3lzdGVtLlxuLy8gICAgSWYgbm90IGZvdW5kIC0gdHJ5IHRvIGZhbGxiYWNrIHRvIHdpbmRvdy5lc3ByaW1hLiBJZiBub3Rcbi8vICAgIGZvdW5kIHRvbyAtIHRoZW4gZmFpbCB0byBwYXJzZS5cbi8vXG50cnkge1xuICAvLyB3b3JrYXJvdW5kIHRvIGV4Y2x1ZGUgcGFja2FnZSBmcm9tIGJyb3dzZXJpZnkgbGlzdC5cbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZTtcbiAgZXNwcmltYSA9IF9yZXF1aXJlKCdlc3ByaW1hJyk7XG59IGNhdGNoIChfKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuICAvKiBnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZXNwcmltYSA9IHdpbmRvdy5lc3ByaW1hO1xufVxuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSk7XG5cbiAgICBpZiAoYXN0LnR5cGUgICAgICAgICAgICAgICAgICAgICE9PSAnUHJvZ3JhbScgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHlbMF0udHlwZSAgICAgICAgICAgICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHxcbiAgICAgICAgKGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyAmJlxuICAgICAgICAgIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICAvKmpzbGludCBldmlsOnRydWUqL1xuXG4gIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSksXG4gICAgICBwYXJhbXMgPSBbXSxcbiAgICAgIGJvZHk7XG5cbiAgaWYgKGFzdC50eXBlICAgICAgICAgICAgICAgICAgICAhPT0gJ1Byb2dyYW0nICAgICAgICAgICAgIHx8XG4gICAgICBhc3QuYm9keS5sZW5ndGggICAgICAgICAgICAgIT09IDEgICAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgYXN0LmJvZHlbMF0udHlwZSAgICAgICAgICAgICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHxcbiAgICAgIChhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicgJiZcbiAgICAgICAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBhc3QuYm9keVswXS5leHByZXNzaW9uLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHBhcmFtcy5wdXNoKHBhcmFtLm5hbWUpO1xuICB9KTtcblxuICBib2R5ID0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5ib2R5LnJhbmdlO1xuXG4gIC8vIEVzcHJpbWEncyByYW5nZXMgaW5jbHVkZSB0aGUgZmlyc3QgJ3snIGFuZCB0aGUgbGFzdCAnfScgY2hhcmFjdGVycyBvblxuICAvLyBmdW5jdGlvbiBleHByZXNzaW9ucy4gU28gY3V0IHRoZW0gb3V0LlxuICBpZiAoYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5ib2R5LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jKi9cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKHBhcmFtcywgc291cmNlLnNsaWNlKGJvZHlbMF0gKyAxLCBib2R5WzFdIC0gMSkpO1xuICB9XG4gIC8vIEVTNiBhcnJvdyBmdW5jdGlvbnMgY2FuIG9taXQgdGhlIEJsb2NrU3RhdGVtZW50LiBJbiB0aGF0IGNhc2UsIGp1c3QgcmV0dXJuXG4gIC8vIHRoZSBib2R5LlxuICAvKmVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jKi9cbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihwYXJhbXMsICdyZXR1cm4gJyArIHNvdXJjZS5zbGljZShib2R5WzBdLCBib2R5WzFdKSk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvbihvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIHByZWRpY2F0ZTogaXNGdW5jdGlvbixcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb25cbn0pO1xuIiwgIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYGxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIEpTLVlBTUwncyBkZWZhdWx0IHNhZmUgc2NoZW1hIGFuZCBpbmNsdWRlc1xuLy8gSmF2YVNjcmlwdC1zcGVjaWZpYyB0eXBlczogISFqcy91bmRlZmluZWQsICEhanMvcmVnZXhwIGFuZCAhIWpzL2Z1bmN0aW9uLlxuLy9cbi8vIEFsc28gdGhpcyBzY2hlbWEgaXMgdXNlZCBhcyBkZWZhdWx0IGJhc2Ugc2NoZW1hIGF0IGBTY2hlbWEuY3JlYXRlYCBmdW5jdGlvbi5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hLkRFRkFVTFQgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZGVmYXVsdF9zYWZlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL3VuZGVmaW5lZCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvcmVnZXhwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9mdW5jdGlvbicpXG4gIF1cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIE1hcmsgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL21hcmsnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbnZhciBDT05URVhUX0ZMT1dfSU4gICA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCAgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcbnZhciBDT05URVhUX0JMT0NLX09VVCA9IDQ7XG5cblxudmFyIENIT01QSU5HX0NMSVAgID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xuXG5cbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbnZhciBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyA9IC9bXFx4ODVcXHUyMDI4XFx1MjAyOV0vO1xudmFyIFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTICAgICAgID0gL1ssXFxbXFxdXFx7XFx9XS87XG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSAgICAgICAgICAgICAgID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MEEvKiBMRiAqLykgfHwgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dISVRFX1NQQUNFKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fCAoYyA9PT0gMHgyMC8qIFNwYWNlICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBBLyogTEYgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQy8qICwgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUIvKiBbICovIHx8XG4gICAgICAgICBjID09PSAweDVELyogXSAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3Qi8qIHsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0QvKiB9ICovO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbiAgcmV0dXJuIChjID09PSAweDMwLyogMCAqLykgPyAnXFx4MDAnIDpcbiAgICAgICAgKGMgPT09IDB4NjEvKiBhICovKSA/ICdcXHgwNycgOlxuICAgICAgICAoYyA9PT0gMHg2Mi8qIGIgKi8pID8gJ1xceDA4JyA6XG4gICAgICAgIChjID09PSAweDc0LyogdCAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4MDkvKiBUYWIgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDZFLyogbiAqLykgPyAnXFx4MEEnIDpcbiAgICAgICAgKGMgPT09IDB4NzYvKiB2ICovKSA/ICdcXHgwQicgOlxuICAgICAgICAoYyA9PT0gMHg2Ni8qIGYgKi8pID8gJ1xceDBDJyA6XG4gICAgICAgIChjID09PSAweDcyLyogciAqLykgPyAnXFx4MEQnIDpcbiAgICAgICAgKGMgPT09IDB4NjUvKiBlICovKSA/ICdcXHgxQicgOlxuICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSA/ICcgJyA6XG4gICAgICAgIChjID09PSAweDIyLyogXCIgKi8pID8gJ1xceDIyJyA6XG4gICAgICAgIChjID09PSAweDJGLyogLyAqLykgPyAnLycgOlxuICAgICAgICAoYyA9PT0gMHg1Qy8qIFxcICovKSA/ICdcXHg1QycgOlxuICAgICAgICAoYyA9PT0gMHg0RS8qIE4gKi8pID8gJ1xceDg1JyA6XG4gICAgICAgIChjID09PSAweDVGLyogXyAqLykgPyAnXFx4QTAnIDpcbiAgICAgICAgKGMgPT09IDB4NEMvKiBMICovKSA/ICdcXHUyMDI4JyA6XG4gICAgICAgIChjID09PSAweDUwLyogUCAqLykgPyAnXFx1MjAyOScgOiAnJztcbn1cblxuZnVuY3Rpb24gY2hhckZyb21Db2RlcG9pbnQoYykge1xuICBpZiAoYyA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfVxuICAvLyBFbmNvZGUgVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgKChjIC0gMHgwMTAwMDApID4+IDEwKSArIDB4RDgwMCxcbiAgICAoKGMgLSAweDAxMDAwMCkgJiAweDAzRkYpICsgMHhEQzAwXG4gICk7XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcbiAgdGhpcy5qc29uICAgICAgPSBvcHRpb25zWydqc29uJ10gICAgICB8fCBmYWxzZTtcbiAgdGhpcy5saXN0ZW5lciAgPSBvcHRpb25zWydsaXN0ZW5lciddICB8fCBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCAgICAgICA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcblxuICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gICA9IDA7XG4gIHRoaXMubGluZSAgICAgICA9IDA7XG4gIHRoaXMubGluZVN0YXJ0ICA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFlBTUxFeGNlcHRpb24oXG4gICAgbWVzc2FnZSxcbiAgICBuZXcgTWFyayhzdGF0ZS5maWxlbmFtZSwgc3RhdGUuaW5wdXQsIHN0YXRlLnBvc2l0aW9uLCBzdGF0ZS5saW5lLCAoc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQpKSk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHRocm93V2FybmluZyhzdGF0ZSwgbWVzc2FnZSkge1xuICBpZiAoc3RhdGUub25XYXJuaW5nKSB7XG4gICAgc3RhdGUub25XYXJuaW5nLmNhbGwobnVsbCwgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkpO1xuICB9XG59XG5cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuXG4gIFlBTUw6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBtYXRjaCwgbWFqb3IsIG1pbm9yO1xuXG4gICAgaWYgKHN0YXRlLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuXG4gICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcblxuICBUQUc6IGZ1bmN0aW9uIGhhbmRsZVRhZ0RpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnVEFHIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgdHdvIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGhhbmRsZSA9IGFyZ3NbMF07XG4gICAgcHJlZml4ID0gYXJnc1sxXTtcblxuICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIGhhbmRsZSAoZmlyc3QgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJyArIGhhbmRsZSArICdcIiB0YWcgaGFuZGxlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoZGVzdGluYXRpb24sIGtleSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIG92ZXJyaWRhYmxlS2V5c1trZXldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgc3RhcnRMaW5lLCBzdGFydFBvcykge1xuICB2YXIgaW5kZXgsIHF1YW50aXR5O1xuXG4gIC8vIFRoZSBvdXRwdXQgaXMgYSBwbGFpbiBvYmplY3QgaGVyZSwgc28ga2V5cyBjYW4gb25seSBiZSBzdHJpbmdzLlxuICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQga2V5Tm9kZSB0byBhIHN0cmluZywgYnV0IGRvaW5nIHNvIGNhbiBoYW5nIHRoZSBwcm9jZXNzXG4gIC8vIChkZWVwbHkgbmVzdGVkIGFycmF5cyB0aGF0IGV4cGxvZGUgZXhwb25lbnRpYWxseSB1c2luZyBhbGlhc2VzKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Tm9kZSkpIHtcbiAgICBrZXlOb2RlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoa2V5Tm9kZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBrZXlOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Tm9kZVtpbmRleF0pKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduZXN0ZWQgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBrZXlzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGVbaW5kZXhdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAga2V5Tm9kZVtpbmRleF0gPSAnW29iamVjdCBPYmplY3RdJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBdm9pZCBjb2RlIGV4ZWN1dGlvbiBpbiBsb2FkKCkgdmlhIHRvU3RyaW5nIHByb3BlcnR5XG4gIC8vIChzdGlsbCB1c2UgaXRzIG93biB0b1N0cmluZyBmb3IgYXJyYXlzLCB0aW1lc3RhbXBzLFxuICAvLyBhbmQgd2hhdGV2ZXIgdXNlciBzY2hlbWEgZXh0ZW5zaW9ucyBoYXBwZW4gdG8gaGF2ZSBAQHRvU3RyaW5nVGFnKVxuICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBrZXlOb2RlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuXG4gIGtleU5vZGUgPSBTdHJpbmcoa2V5Tm9kZSk7XG5cbiAgaWYgKF9yZXN1bHQgPT09IG51bGwpIHtcbiAgICBfcmVzdWx0ID0ge307XG4gIH1cblxuICBpZiAoa2V5VGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVOb2RlKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gdmFsdWVOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGVbaW5kZXhdLCBvdmVycmlkYWJsZUtleXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUsIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc3RhdGUuanNvbiAmJlxuICAgICAgICAhX2hhc093blByb3BlcnR5LmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJlxuICAgICAgICBfaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuICAgIF9yZXN1bHRba2V5Tm9kZV0gPSB2YWx1ZU5vZGU7XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9yZXN1bHQsXG4gICAgICBfYW5jaG9yICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfcG9zID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhazsgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9wb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cblxuICAvLyBTcGVjaWFsIGNhc2U6IGxhc3QgbWFwcGluZydzIG5vZGUgY29udGFpbnMgb25seSB0aGUga2V5IGluIGV4cGxpY2l0IG5vdGF0aW9uLlxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlLFxuICAgICAgZmxvd0luZGVudCxcbiAgICAgIGJsb2NrSW5kZW50O1xuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdvcGVuJywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUudGFnICAgID0gbnVsbDtcbiAgc3RhdGUuYW5jaG9yID0gbnVsbDtcbiAgc3RhdGUua2luZCAgID0gbnVsbDtcbiAgc3RhdGUucmVzdWx0ID0gbnVsbDtcblxuICBhbGxvd0Jsb2NrU3R5bGVzID0gYWxsb3dCbG9ja1NjYWxhcnMgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPVxuICAgIENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCB8fFxuICAgIENPTlRFWFRfQkxPQ0tfSU4gID09PSBub2RlQ29udGV4dDtcblxuICBpZiAoYWxsb3dUb1NlZWspIHtcbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBhdE5ld0xpbmUgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgd2hpbGUgKHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkgfHwgcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSkge1xuICAgICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgICBhdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhbGxvd0Jsb2NrU3R5bGVzO1xuXG4gICAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFsbG93QmxvY2tDb2xsZWN0aW9ucykge1xuICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGF0TmV3TGluZSB8fCBhbGxvd0NvbXBhY3Q7XG4gIH1cblxuICBpZiAoaW5kZW50U3RhdHVzID09PSAxIHx8IENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgIGlmIChDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0IHx8IENPTlRFWFRfRkxPV19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50ICsgMTtcbiAgICB9XG5cbiAgICBibG9ja0luZGVudCA9IHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0O1xuXG4gICAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgICAgaWYgKGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJlxuICAgICAgICAgIChyZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpIHx8XG4gICAgICAgICAgIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIGJsb2NrSW5kZW50LCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChhbGxvd0Jsb2NrU2NhbGFycyAmJiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgICAgcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkgfHxcbiAgICAgICAgICAgIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkQWxpYXMoc3RhdGUpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsIHx8IHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2FsaWFzIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGFueSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZFBsYWluU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUudGFnID0gJz8nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5kZW50U3RhdHVzID09PSAwKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2U6IGJsb2NrIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCB0byBoYXZlIHNhbWUgaW5kZW50YXRpb24gbGV2ZWwgYXMgdGhlIHBhcmVudC5cbiAgICAgIC8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjc5OTc4NFxuICAgICAgaGFzQ29udGVudCA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoc3RhdGUudGFnID09PSAnPycpIHtcbiAgICAgIC8vIEltcGxpY2l0IHJlc29sdmluZyBpcyBub3QgYWxsb3dlZCBmb3Igbm9uLXNjYWxhciB0eXBlcywgYW5kICc/J1xuICAgICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gY2hlY2sga2luZCBjb25mb3JtaXR5IGluIGNhc2UgdXNlciBleHBsaWNpdGx5IGFzc2lnbnMgJz8nXG4gICAgICAvLyB0YWcsIGZvciBleGFtcGxlIGxpa2UgdGhpczogXCIhPD8+IFswXVwiXG4gICAgICAvL1xuICAgICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiBzdGF0ZS5raW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITw/PiB0YWc7IGl0IHNob3VsZCBiZSBcInNjYWxhclwiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyB0eXBlSW5kZXggPCB0eXBlUXVhbnRpdHk7IHR5cGVJbmRleCArPSAxKSB7XG4gICAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcblxuICAgICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdjbG9zZScsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudGFnICE9PSBudWxsIHx8ICBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IHt9O1xuICBzdGF0ZS5hbmNob3JNYXAgPSB7fTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlTmFtZV0oc3RhdGUsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIGRvY3VtZW50IGRpcmVjdGl2ZSBcIicgKyBkaXJlY3RpdmVOYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSAwICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAgICAgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikgPT09IDB4MkQvKiAtICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiZcbiAgICAgIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTLnRlc3Qoc3RhdGUuaW5wdXQuc2xpY2UoZG9jdW1lbnRTdGFydCwgc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ25vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudCcpO1xuICB9XG5cbiAgc3RhdGUuZG9jdW1lbnRzLnB1c2goc3RhdGUucmVzdWx0KTtcblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG5cbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkUvKiAuICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSB7XG4gIGlucHV0ID0gU3RyaW5nKGlucHV0KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gMCkge1xuXG4gICAgLy8gQWRkIHRhaWxpbmcgYFxcbmAgaWYgbm90IGV4aXN0c1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBBLyogTEYgKi8gJiZcbiAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwRC8qIENSICovKSB7XG4gICAgICBpbnB1dCArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBTdHJpcCBCT01cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgdmFyIG51bGxwb3MgPSBpbnB1dC5pbmRleE9mKCdcXDAnKTtcblxuICBpZiAobnVsbHBvcyAhPT0gLTEpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiA9IG51bGxwb3M7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ251bGwgYnl0ZSBpcyBub3QgYWxsb3dlZCBpbiBpbnB1dCcpO1xuICB9XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzWzBdO1xuICB9XG4gIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yID09PSAnb2JqZWN0JyAmJiBpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gaXRlcmF0b3I7XG4gICAgaXRlcmF0b3IgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID0gMHgwOTsgLyogVGFiICovXG52YXIgQ0hBUl9MSU5FX0ZFRUQgICAgICAgICAgICA9IDB4MEE7IC8qIExGICovXG52YXIgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gICAgICA9IDB4MEQ7IC8qIENSICovXG52YXIgQ0hBUl9TUEFDRSAgICAgICAgICAgICAgICA9IDB4MjA7IC8qIFNwYWNlICovXG52YXIgQ0hBUl9FWENMQU1BVElPTiAgICAgICAgICA9IDB4MjE7IC8qICEgKi9cbnZhciBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgID0gMHgyMjsgLyogXCIgKi9cbnZhciBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID0gMHgyMzsgLyogIyAqL1xudmFyIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgPSAweDI1OyAvKiAlICovXG52YXIgQ0hBUl9BTVBFUlNBTkQgICAgICAgICAgICA9IDB4MjY7IC8qICYgKi9cbnZhciBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID0gMHgyNzsgLyogJyAqL1xudmFyIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgPSAweDJBOyAvKiAqICovXG52YXIgQ0hBUl9DT01NQSAgICAgICAgICAgICAgICA9IDB4MkM7IC8qICwgKi9cbnZhciBDSEFSX01JTlVTICAgICAgICAgICAgICAgID0gMHgyRDsgLyogLSAqL1xudmFyIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPSAweDNBOyAvKiA6ICovXG52YXIgQ0hBUl9FUVVBTFMgICAgICAgICAgICAgICA9IDB4M0Q7IC8qID0gKi9cbnZhciBDSEFSX0dSRUFURVJfVEhBTiAgICAgICAgID0gMHgzRTsgLyogPiAqL1xudmFyIENIQVJfUVVFU1RJT04gICAgICAgICAgICAgPSAweDNGOyAvKiA/ICovXG52YXIgQ0hBUl9DT01NRVJDSUFMX0FUICAgICAgICA9IDB4NDA7IC8qIEAgKi9cbnZhciBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgID0gMHg1QjsgLyogWyAqL1xudmFyIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgPSAweDVEOyAvKiBdICovXG52YXIgQ0hBUl9HUkFWRV9BQ0NFTlQgICAgICAgICA9IDB4NjA7IC8qIGAgKi9cbnZhciBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgID0gMHg3QjsgLyogeyAqL1xudmFyIENIQVJfVkVSVElDQUxfTElORSAgICAgICAgPSAweDdDOyAvKiB8ICovXG52YXIgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9IDB4N0Q7IC8qIH0gKi9cblxudmFyIEVTQ0FQRV9TRVFVRU5DRVMgPSB7fTtcblxuRVNDQVBFX1NFUVVFTkNFU1sweDAwXSAgID0gJ1xcXFwwJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwN10gICA9ICdcXFxcYSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDhdICAgPSAnXFxcXGInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA5XSAgID0gJ1xcXFx0JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQV0gICA9ICdcXFxcbic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEJdICAgPSAnXFxcXHYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBDXSAgID0gJ1xcXFxmJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwRF0gICA9ICdcXFxccic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MUJdICAgPSAnXFxcXGUnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIyXSAgID0gJ1xcXFxcIic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4NUNdICAgPSAnXFxcXFxcXFwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDg1XSAgID0gJ1xcXFxOJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHhBMF0gICA9ICdcXFxcXyc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOF0gPSAnXFxcXEwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjldID0gJ1xcXFxQJztcblxudmFyIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYID0gW1xuICAneScsICdZJywgJ3llcycsICdZZXMnLCAnWUVTJywgJ29uJywgJ09uJywgJ09OJyxcbiAgJ24nLCAnTicsICdubycsICdObycsICdOTycsICdvZmYnLCAnT2ZmJywgJ09GRidcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG1hcCkge1xuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xuXG4gIGlmIChtYXAgPT09IG51bGwpIHJldHVybiB7fTtcblxuICByZXN1bHQgPSB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHRhZyA9IGtleXNbaW5kZXhdO1xuICAgIHN0eWxlID0gU3RyaW5nKG1hcFt0YWddKTtcblxuICAgIGlmICh0YWcuc2xpY2UoMCwgMikgPT09ICchIScpIHtcbiAgICAgIHRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFsnZmFsbGJhY2snXVt0YWddO1xuXG4gICAgaWYgKHR5cGUgJiYgX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5zdHlsZUFsaWFzZXMsIHN0eWxlKSkge1xuICAgICAgc3R5bGUgPSB0eXBlLnN0eWxlQWxpYXNlc1tzdHlsZV07XG4gICAgfVxuXG4gICAgcmVzdWx0W3RhZ10gPSBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG5cbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBTdGF0ZShvcHRpb25zKSB7XG4gIHRoaXMuc2NoZW1hICAgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgICA9IE1hdGgubWF4KDEsIChvcHRpb25zWydpbmRlbnQnXSB8fCAyKSk7XG4gIHRoaXMubm9BcnJheUluZGVudCA9IG9wdGlvbnNbJ25vQXJyYXlJbmRlbnQnXSB8fCBmYWxzZTtcbiAgdGhpcy5za2lwSW52YWxpZCAgID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICAgID0gKGNvbW1vbi5pc05vdGhpbmcob3B0aW9uc1snZmxvd0xldmVsJ10pID8gLTEgOiBvcHRpb25zWydmbG93TGV2ZWwnXSk7XG4gIHRoaXMuc3R5bGVNYXAgICAgICA9IGNvbXBpbGVTdHlsZU1hcCh0aGlzLnNjaGVtYSwgb3B0aW9uc1snc3R5bGVzJ10gfHwgbnVsbCk7XG4gIHRoaXMuc29ydEtleXMgICAgICA9IG9wdGlvbnNbJ3NvcnRLZXlzJ10gfHwgZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoICAgICA9IG9wdGlvbnNbJ2xpbmVXaWR0aCddIHx8IDgwO1xuICB0aGlzLm5vUmVmcyAgICAgICAgPSBvcHRpb25zWydub1JlZnMnXSB8fCBmYWxzZTtcbiAgdGhpcy5ub0NvbXBhdE1vZGUgID0gb3B0aW9uc1snbm9Db21wYXRNb2RlJ10gfHwgZmFsc2U7XG4gIHRoaXMuY29uZGVuc2VGbG93ICA9IG9wdGlvbnNbJ2NvbmRlbnNlRmxvdyddIHx8IGZhbHNlO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMuZXhwbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkRXhwbGljaXQ7XG5cbiAgdGhpcy50YWcgPSBudWxsO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIHRoaXMuZHVwbGljYXRlcyA9IFtdO1xuICB0aGlzLnVzZWREdXBsaWNhdGVzID0gbnVsbDtcbn1cblxuLy8gSW5kZW50cyBldmVyeSBsaW5lIGluIGEgc3RyaW5nLiBFbXB0eSBsaW5lcyAoXFxuIG9ubHkpIGFyZSBub3QgaW5kZW50ZWQuXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RyaW5nLCBzcGFjZXMpIHtcbiAgdmFyIGluZCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBzcGFjZXMpLFxuICAgICAgcG9zaXRpb24gPSAwLFxuICAgICAgbmV4dCA9IC0xLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBsaW5lLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICBuZXh0ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIHBvc2l0aW9uKTtcbiAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24pO1xuICAgICAgcG9zaXRpb24gPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24sIG5leHQgKyAxKTtcbiAgICAgIHBvc2l0aW9uID0gbmV4dCArIDE7XG4gICAgfVxuXG4gICAgaWYgKGxpbmUubGVuZ3RoICYmIGxpbmUgIT09ICdcXG4nKSByZXN1bHQgKz0gaW5kO1xuXG4gICAgcmVzdWx0ICs9IGxpbmU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCkge1xuICByZXR1cm4gJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgc3RhdGUuaW5kZW50ICogbGV2ZWwpO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cikge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwgdHlwZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbaW5kZXhdO1xuXG4gICAgaWYgKHR5cGUucmVzb2x2ZShzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFszM10gcy13aGl0ZSA6Oj0gcy1zcGFjZSB8IHMtdGFiXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICByZXR1cm4gYyA9PT0gQ0hBUl9TUEFDRSB8fCBjID09PSBDSEFSX1RBQjtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIHByaW50ZWQgd2l0aG91dCBlc2NhcGluZy5cbi8vIEZyb20gWUFNTCAxLjI6IFwiYW55IGFsbG93ZWQgY2hhcmFjdGVycyBrbm93biB0byBiZSBub24tcHJpbnRhYmxlXG4vLyBzaG91bGQgYWxzbyBiZSBlc2NhcGVkLiBbSG93ZXZlcixdIFRoaXMgaXNuXHUyMDE5dCBtYW5kYXRvcnlcIlxuLy8gRGVyaXZlZCBmcm9tIG5iLWNoYXIgLSBcXHQgLSAjeDg1IC0gI3hBMCAtICN4MjAyOCAtICN4MjAyOS5cbmZ1bmN0aW9uIGlzUHJpbnRhYmxlKGMpIHtcbiAgcmV0dXJuICAoMHgwMDAyMCA8PSBjICYmIGMgPD0gMHgwMDAwN0UpXG4gICAgICB8fCAoKDB4MDAwQTEgPD0gYyAmJiBjIDw9IDB4MDBEN0ZGKSAmJiBjICE9PSAweDIwMjggJiYgYyAhPT0gMHgyMDI5KVxuICAgICAgfHwgKCgweDBFMDAwIDw9IGMgJiYgYyA8PSAweDAwRkZGRCkgJiYgYyAhPT0gMHhGRUZGIC8qIEJPTSAqLylcbiAgICAgIHx8ICAoMHgxMDAwMCA8PSBjICYmIGMgPD0gMHgxMEZGRkYpO1xufVxuXG4vLyBbMzRdIG5zLWNoYXIgOjo9IG5iLWNoYXIgLSBzLXdoaXRlXG4vLyBbMjddIG5iLWNoYXIgOjo9IGMtcHJpbnRhYmxlIC0gYi1jaGFyIC0gYy1ieXRlLW9yZGVyLW1hcmtcbi8vIFsyNl0gYi1jaGFyICA6Oj0gYi1saW5lLWZlZWQgfCBiLWNhcnJpYWdlLXJldHVyblxuLy8gWzI0XSBiLWxpbmUtZmVlZCAgICAgICA6Oj0gICAgICN4QSAgICAvKiBMRiAqL1xuLy8gWzI1XSBiLWNhcnJpYWdlLXJldHVybiA6Oj0gICAgICN4RCAgICAvKiBDUiAqL1xuLy8gWzNdICBjLWJ5dGUtb3JkZXItbWFyayA6Oj0gICAgICN4RkVGRlxuZnVuY3Rpb24gaXNOc0NoYXIoYykge1xuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgIWlzV2hpdGVzcGFjZShjKVxuICAgIC8vIGJ5dGUtb3JkZXItbWFya1xuICAgICYmIGMgIT09IDB4RkVGRlxuICAgIC8vIGItY2hhclxuICAgICYmIGMgIT09IENIQVJfQ0FSUklBR0VfUkVUVVJOXG4gICAgJiYgYyAhPT0gQ0hBUl9MSU5FX0ZFRUQ7XG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYWZ0ZXIgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMsIHByZXYpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBuYi1jaGFyIC0gYy1mbG93LWluZGljYXRvciAtIFwiOlwiIC0gXCIjXCJcbiAgLy8gd2hlcmUgbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFyay5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRlxuICAgIC8vIC0gYy1mbG93LWluZGljYXRvclxuICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgICAvLyAtIFwiOlwiIC0gXCIjXCJcbiAgICAvLyAvKiBBbiBucy1jaGFyIHByZWNlZGluZyAqLyBcIiNcIlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiAoKGMgIT09IENIQVJfU0hBUlApIHx8IChwcmV2ICYmIGlzTnNDaGFyKHByZXYpKSk7XG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlRmlyc3QoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5zLWNoYXIgLSBjLWluZGljYXRvclxuICAvLyB3aGVyZSBucy1jaGFyID0gbmItY2hhciAtIHMtd2hpdGUuXG4gIHJldHVybiBpc1ByaW50YWJsZShjKSAmJiBjICE9PSAweEZFRkZcbiAgICAmJiAhaXNXaGl0ZXNwYWNlKGMpIC8vIC0gcy13aGl0ZVxuICAgIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAgIC8vIFx1MjAxQy1cdTIwMUQgfCBcdTIwMUM/XHUyMDFEIHwgXHUyMDFDOlx1MjAxRCB8IFx1MjAxQyxcdTIwMUQgfCBcdTIwMUNbXHUyMDFEIHwgXHUyMDFDXVx1MjAxRCB8IFx1MjAxQ3tcdTIwMUQgfCBcdTIwMUN9XHUyMDFEXG4gICAgJiYgYyAhPT0gQ0hBUl9NSU5VU1xuICAgICYmIGMgIT09IENIQVJfUVVFU1RJT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIHwgXHUyMDFDI1x1MjAxRCB8IFx1MjAxQyZcdTIwMUQgfCBcdTIwMUMqXHUyMDFEIHwgXHUyMDFDIVx1MjAxRCB8IFx1MjAxQ3xcdTIwMUQgfCBcdTIwMUM9XHUyMDFEIHwgXHUyMDFDPlx1MjAxRCB8IFx1MjAxQydcdTIwMUQgfCBcdTIwMUNcIlx1MjAxRFxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9FUVVBTFNcbiAgICAmJiBjICE9PSBDSEFSX0dSRUFURVJfVEhBTlxuICAgICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFXG4gICAgJiYgYyAhPT0gQ0hBUl9ET1VCTEVfUVVPVEVcbiAgICAvLyB8IFx1MjAxQyVcdTIwMUQgfCBcdTIwMUNAXHUyMDFEIHwgXHUyMDFDYFx1MjAxRClcbiAgICAmJiBjICE9PSBDSEFSX1BFUkNFTlRcbiAgICAmJiBjICE9PSBDSEFSX0NPTU1FUkNJQUxfQVRcbiAgICAmJiBjICE9PSBDSEFSX0dSQVZFX0FDQ0VOVDtcbn1cblxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1b3VzVHlwZSkge1xuICB2YXIgaTtcbiAgdmFyIGNoYXIsIHByZXZfY2hhcjtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KHN0cmluZy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAgICYmICFpc1doaXRlc3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHByZXZfY2hhciA9IGkgPiAwID8gc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpIDogbnVsbDtcbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldl9jaGFyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZTogYmxvY2sgc3R5bGVzIHBlcm1pdHRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY2hhciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgaGFzTGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgY2FuIGJlIGZvbGRlZC5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrV2lkdGgpIHtcbiAgICAgICAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHxcbiAgICAgICAgICAgIC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKTtcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwcmV2X2NoYXIgPSBpID4gMCA/IHN0cmluZy5jaGFyQ29kZUF0KGkgLSAxKSA6IG51bGw7XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZfY2hhcik7XG4gICAgfVxuICAgIC8vIGluIGNhc2UgdGhlIGVuZCBpcyBtaXNzaW5nIGEgXFxuXG4gICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8IChzaG91bGRUcmFja1dpZHRoICYmXG4gICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpKTtcbiAgfVxuICAvLyBBbHRob3VnaCBldmVyeSBzdHlsZSBjYW4gcmVwcmVzZW50IFxcbiB3aXRob3V0IGVzY2FwaW5nLCBwcmVmZXIgYmxvY2sgc3R5bGVzXG4gIC8vIGZvciBtdWx0aWxpbmUsIHNpbmNlIHRoZXkncmUgbW9yZSByZWFkYWJsZSBhbmQgdGhleSBkb24ndCBhZGQgZW1wdHkgbGluZXMuXG4gIC8vIEFsc28gcHJlZmVyIGZvbGRpbmcgYSBzdXBlci1sb25nIGxpbmUuXG4gIGlmICghaGFzTGluZUJyZWFrICYmICFoYXNGb2xkYWJsZUxpbmUpIHtcbiAgICAvLyBTdHJpbmdzIGludGVycHJldGFibGUgYXMgYW5vdGhlciB0eXBlIGhhdmUgdG8gYmUgcXVvdGVkO1xuICAgIC8vIGUuZy4gdGhlIHN0cmluZyAndHJ1ZScgdnMuIHRoZSBib29sZWFuIHRydWUuXG4gICAgcmV0dXJuIHBsYWluICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpXG4gICAgICA/IFNUWUxFX1BMQUlOIDogU1RZTEVfU0lOR0xFO1xuICB9XG4gIC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuICBpZiAoaW5kZW50UGVyTGV2ZWwgPiA5ICYmIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSkge1xuICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gIH1cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IGJsb2NrIHN0eWxlcyBhcmUgdmFsaWQuXG4gIC8vIFByZWZlciBsaXRlcmFsIHN0eWxlIHVubGVzcyB3ZSB3YW50IHRvIGZvbGQuXG4gIHJldHVybiBoYXNGb2xkYWJsZUxpbmUgPyBTVFlMRV9GT0xERUQgOiBTVFlMRV9MSVRFUkFMO1xufVxuXG4vLyBOb3RlOiBsaW5lIGJyZWFraW5nL2ZvbGRpbmcgaXMgaW1wbGVtZW50ZWQgZm9yIG9ubHkgdGhlIGZvbGRlZCBzdHlsZS5cbi8vIE5CLiBXZSBkcm9wIHRoZSBsYXN0IHRyYWlsaW5nIG5ld2xpbmUgKGlmIGFueSkgb2YgYSByZXR1cm5lZCBibG9jayBzY2FsYXJcbi8vICBzaW5jZSB0aGUgZHVtcGVyIGFkZHMgaXRzIG93biBuZXdsaW5lLiBUaGlzIGFsd2F5cyB3b3Jrczpcbi8vICAgIFx1MjAyMiBObyBlbmRpbmcgbmV3bGluZSA9PiB1bmFmZmVjdGVkOyBhbHJlYWR5IHVzaW5nIHN0cmlwIFwiLVwiIGNob21waW5nLlxuLy8gICAgXHUyMDIyIEVuZGluZyBuZXdsaW5lICAgID0+IHJlbW92ZWQgdGhlbiByZXN0b3JlZC5cbi8vICBJbXBvcnRhbnRseSwgdGhpcyBrZWVwcyB0aGUgXCIrXCIgY2hvbXAgaW5kaWNhdG9yIGZyb20gZ2FpbmluZyBhbiBleHRyYSBsaW5lLlxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5KSB7XG4gIHN0YXRlLmR1bXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCInJ1wiO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLm5vQ29tcGF0TW9kZSAmJlxuICAgICAgICBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKHN0cmluZykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcgKyBcIidcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ICogTWF0aC5tYXgoMSwgbGV2ZWwpOyAvLyBubyAwLWluZGVudCBzY2FsYXJzXG4gICAgLy8gQXMgaW5kZW50YXRpb24gZ2V0cyBkZWVwZXIsIGxldCB0aGUgd2lkdGggZGVjcmVhc2UgbW9ub3RvbmljYWxseVxuICAgIC8vIHRvIHRoZSBsb3dlciBib3VuZCBtaW4oc3RhdGUubGluZVdpZHRoLCA0MCkuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaW1wbGllc1xuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggXHUyMjY0IDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBpcyBmaXhlZCBhdCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCA+IDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBkZWNyZWFzZXMgdW50aWwgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vIFRoaXMgYmVoYXZlcyBiZXR0ZXIgdGhhbiBhIGNvbnN0YW50IG1pbmltdW0gd2lkdGggd2hpY2ggZGlzYWxsb3dzIG5hcnJvd2VyIG9wdGlvbnMsXG4gICAgLy8gb3IgYW4gaW5kZW50IHRocmVzaG9sZCB3aGljaCBjYXVzZXMgdGhlIHdpZHRoIHRvIHN1ZGRlbmx5IGluY3JlYXNlLlxuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGggPT09IC0xXG4gICAgICA/IC0xIDogTWF0aC5tYXgoTWF0aC5taW4oc3RhdGUubGluZVdpZHRoLCA0MCksIHN0YXRlLmxpbmVXaWR0aCAtIGluZGVudCk7XG5cbiAgICAvLyBXaXRob3V0IGtub3dpbmcgaWYga2V5cyBhcmUgaW1wbGljaXQvZXhwbGljaXQsIGFzc3VtZSBpbXBsaWNpdCBmb3Igc2FmZXR5LlxuICAgIHZhciBzaW5nbGVMaW5lT25seSA9IGlza2V5XG4gICAgICAvLyBObyBibG9jayBzdHlsZXMgaW4gZmxvdyBtb2RlLlxuICAgICAgfHwgKHN0YXRlLmZsb3dMZXZlbCA+IC0xICYmIGxldmVsID49IHN0YXRlLmZsb3dMZXZlbCk7XG4gICAgZnVuY3Rpb24gdGVzdEFtYmlndWl0eShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cmluZyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBzdGF0ZS5pbmRlbnQsIGxpbmVXaWR0aCwgdGVzdEFtYmlndWl0eSkpIHtcbiAgICAgIGNhc2UgU1RZTEVfUExBSU46XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICBjYXNlIFNUWUxFX1NJTkdMRTpcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nLnJlcGxhY2UoLycvZywgXCInJ1wiKSArIFwiJ1wiO1xuICAgICAgY2FzZSBTVFlMRV9MSVRFUkFMOlxuICAgICAgICByZXR1cm4gJ3wnICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoc3RyaW5nLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRk9MREVEOlxuICAgICAgICByZXR1cm4gJz4nICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoZm9sZFN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCksIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9ET1VCTEU6XG4gICAgICAgIHJldHVybiAnXCInICsgZXNjYXBlU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSArICdcIic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignaW1wb3NzaWJsZSBlcnJvcjogaW52YWxpZCBzY2FsYXIgc3R5bGUnKTtcbiAgICB9XG4gIH0oKSk7XG59XG5cbi8vIFByZS1jb25kaXRpb25zOiBzdHJpbmcgaXMgdmFsaWQgZm9yIGEgYmxvY2sgc2NhbGFyLCAxIDw9IGluZGVudFBlckxldmVsIDw9IDkuXG5mdW5jdGlvbiBibG9ja0hlYWRlcihzdHJpbmcsIGluZGVudFBlckxldmVsKSB7XG4gIHZhciBpbmRlbnRJbmRpY2F0b3IgPSBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7XG5cbiAgLy8gbm90ZSB0aGUgc3BlY2lhbCBjYXNlOiB0aGUgc3RyaW5nICdcXG4nIGNvdW50cyBhcyBhIFwidHJhaWxpbmdcIiBlbXB0eSBsaW5lLlxuICB2YXIgY2xpcCA9ICAgICAgICAgIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogKGNsaXAgPyAnJyA6ICctJyk7XG5cbiAgcmV0dXJuIGluZGVudEluZGljYXRvciArIGNob21wICsgJ1xcbic7XG59XG5cbi8vIChTZWUgdGhlIG5vdGUgZm9yIHdyaXRlU2NhbGFyLilcbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuXG4vLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuZnVuY3Rpb24gZm9sZFN0cmluZyhzdHJpbmcsIHdpZHRoKSB7XG4gIC8vIEluIGZvbGRlZCBzdHlsZSwgJGskIGNvbnNlY3V0aXZlIG5ld2xpbmVzIG91dHB1dCBhcyAkaysxJCBuZXdsaW5lc1x1MjAxNFxuICAvLyB1bmxlc3MgdGhleSdyZSBiZWZvcmUgb3IgYWZ0ZXIgYSBtb3JlLWluZGVudGVkIGxpbmUsIG9yIGF0IHRoZSB2ZXJ5XG4gIC8vIGJlZ2lubmluZyBvciBlbmQsIGluIHdoaWNoIGNhc2UgJGskIG1hcHMgdG8gJGskLlxuICAvLyBUaGVyZWZvcmUsIHBhcnNlIGVhY2ggY2h1bmsgYXMgbmV3bGluZShzKSBmb2xsb3dlZCBieSBhIGNvbnRlbnQgbGluZS5cbiAgdmFyIGxpbmVSZSA9IC8oXFxuKykoW15cXG5dKikvZztcblxuICAvLyBmaXJzdCBsaW5lIChwb3NzaWJseSBhbiBlbXB0eSBsaW5lKVxuICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKSk7XG4gIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgZmlyc3QgY29udGVudCBsaW5lIHlldCwgZG9uJ3QgYWRkIGFuIGV4dHJhIFxcbi5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkO1xuXG4gIC8vIHJlc3Qgb2YgdGhlIGxpbmVzXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVSZS5leGVjKHN0cmluZykpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLCBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gKGxpbmVbMF0gPT09ICcgJyk7XG4gICAgcmVzdWx0ICs9IHByZWZpeFxuICAgICAgKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJ1xuICAgICAgICA/ICdcXG4nIDogJycpXG4gICAgICArIGZvbGRMaW5lKGxpbmUsIHdpZHRoKTtcbiAgICBwcmV2TW9yZUluZGVudGVkID0gbW9yZUluZGVudGVkO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR3JlZWR5IGxpbmUgYnJlYWtpbmcuXG4vLyBQaWNrcyB0aGUgbG9uZ2VzdCBsaW5lIHVuZGVyIHRoZSBsaW1pdCBlYWNoIHRpbWUsXG4vLyBvdGhlcndpc2Ugc2V0dGxlcyBmb3IgdGhlIHNob3J0ZXN0IGxpbmUgb3ZlciB0aGUgbGltaXQuXG4vLyBOQi4gTW9yZS1pbmRlbnRlZCBsaW5lcyAqY2Fubm90KiBiZSBmb2xkZWQsIGFzIHRoYXQgd291bGQgYWRkIGFuIGV4dHJhIFxcbi5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lO1xuXG4gIC8vIFNpbmNlIGEgbW9yZS1pbmRlbnRlZCBsaW5lIGFkZHMgYSBcXG4sIGJyZWFrcyBjYW4ndCBiZSBmb2xsb3dlZCBieSBhIHNwYWNlLlxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG4gIHZhciBtYXRjaDtcbiAgLy8gc3RhcnQgaXMgYW4gaW5jbHVzaXZlIGluZGV4LiBlbmQsIGN1cnIsIGFuZCBuZXh0IGFyZSBleGNsdXNpdmUuXG4gIHZhciBzdGFydCA9IDAsIGVuZCwgY3VyciA9IDAsIG5leHQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgLy8gSW52YXJpYW50czogMCA8PSBzdGFydCA8PSBsZW5ndGgtMS5cbiAgLy8gICAwIDw9IGN1cnIgPD0gbmV4dCA8PSBtYXgoMCwgbGVuZ3RoLTIpLiBjdXJyIC0gc3RhcnQgPD0gd2lkdGguXG4gIC8vIEluc2lkZSB0aGUgbG9vcDpcbiAgLy8gICBBIG1hdGNoIGltcGxpZXMgbGVuZ3RoID49IDIsIHNvIGN1cnIgYW5kIG5leHQgYXJlIDw9IGxlbmd0aC0yLlxuICB3aGlsZSAoKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSkge1xuICAgIG5leHQgPSBtYXRjaC5pbmRleDtcbiAgICAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuICAgIGlmIChuZXh0IC0gc3RhcnQgPiB3aWR0aCkge1xuICAgICAgZW5kID0gKGN1cnIgPiBzdGFydCkgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbGluZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIC8vIHNraXAgdGhlIHNwYWNlIHRoYXQgd2FzIG91dHB1dCBhcyBcXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSBzdGFydCA8PSBsZW5ndGgtMVxuICAgIH1cbiAgICBjdXJyID0gbmV4dDtcbiAgfVxuXG4gIC8vIEJ5IHRoZSBpbnZhcmlhbnRzLCBzdGFydCA8PSBsZW5ndGgtMSwgc28gdGhlcmUgaXMgc29tZXRoaW5nIGxlZnQgb3Zlci5cbiAgLy8gSXQgaXMgZWl0aGVyIHRoZSB3aG9sZSBzdHJpbmcgb3IgYSBwYXJ0IHN0YXJ0aW5nIGZyb20gbm9uLXdoaXRlc3BhY2UuXG4gIHJlc3VsdCArPSAnXFxuJztcbiAgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG4gIGlmIChsaW5lLmxlbmd0aCAtIHN0YXJ0ID4gd2lkdGggJiYgY3VyciA+IHN0YXJ0KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQsIGN1cnIpICsgJ1xcbicgKyBsaW5lLnNsaWNlKGN1cnIgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpOyAvLyBkcm9wIGV4dHJhIFxcbiBqb2luZXJcbn1cblxuLy8gRXNjYXBlcyBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyLCBuZXh0Q2hhcjtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAvLyBDaGVjayBmb3Igc3Vycm9nYXRlIHBhaXJzIChyZWZlcmVuY2UgVW5pY29kZSAzLjAgc2VjdGlvbiBcIjMuNyBTdXJyb2dhdGVzXCIpLlxuICAgIGlmIChjaGFyID49IDB4RDgwMCAmJiBjaGFyIDw9IDB4REJGRi8qIGhpZ2ggc3Vycm9nYXRlICovKSB7XG4gICAgICBuZXh0Q2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGlmIChuZXh0Q2hhciA+PSAweERDMDAgJiYgbmV4dENoYXIgPD0gMHhERkZGLyogbG93IHN1cnJvZ2F0ZSAqLykge1xuICAgICAgICAvLyBDb21iaW5lIHRoZSBzdXJyb2dhdGUgcGFpciBhbmQgc3RvcmUgaXQgZXNjYXBlZC5cbiAgICAgICAgcmVzdWx0ICs9IGVuY29kZUhleCgoY2hhciAtIDB4RDgwMCkgKiAweDQwMCArIG5leHRDaGFyIC0gMHhEQzAwICsgMHgxMDAwMCk7XG4gICAgICAgIC8vIEFkdmFuY2UgaW5kZXggb25lIGV4dHJhIHNpbmNlIHdlIGFscmVhZHkgdXNlZCB0aGF0IGNoYXIgaGVyZS5cbiAgICAgICAgaSsrOyBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlU2VxID0gRVNDQVBFX1NFUVVFTkNFU1tjaGFyXTtcbiAgICByZXN1bHQgKz0gIWVzY2FwZVNlcSAmJiBpc1ByaW50YWJsZShjaGFyKVxuICAgICAgPyBzdHJpbmdbaV1cbiAgICAgIDogZXNjYXBlU2VxIHx8IGVuY29kZUhleChjaGFyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0W2luZGV4XSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgaWYgKGluZGV4ICE9PSAwKSBfcmVzdWx0ICs9ICcsJyArICghc3RhdGUuY29uZGVuc2VGbG93ID8gJyAnIDogJycpO1xuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBfcmVzdWx0ICs9ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJztcbiAgICAgIH1cblxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuICAgIGlmIChpbmRleCAhPT0gMCkgcGFpckJ1ZmZlciArPSAnLCAnO1xuXG4gICAgaWYgKHN0YXRlLmNvbmRlbnNlRmxvdykgcGFpckJ1ZmZlciArPSAnXCInO1xuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignc29ydEtleXMgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcblxuICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8XG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmR1bXAgJiYgc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KTtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICd7fSc7IC8vIEVtcHR5IG1hcHBpbmcgaWYgbm8gdmFsaWQgcGFpcnMuXG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZXhwbGljaXQpIHtcbiAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcblxuICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gc3RhdGUuZXhwbGljaXRUeXBlcyA6IHN0YXRlLmltcGxpY2l0VHlwZXM7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gdHlwZUxpc3RbaW5kZXhdO1xuXG4gICAgaWYgKCh0eXBlLmluc3RhbmNlT2YgIHx8IHR5cGUucHJlZGljYXRlKSAmJlxuICAgICAgICAoIXR5cGUuaW5zdGFuY2VPZiB8fCAoKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSAmJiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSkpICYmXG4gICAgICAgICghdHlwZS5wcmVkaWNhdGUgIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG5cbiAgICAgIHN0YXRlLnRhZyA9IGV4cGxpY2l0ID8gdHlwZS50YWcgOiAnPyc7XG5cbiAgICAgIGlmICh0eXBlLnJlcHJlc2VudCkge1xuICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlTWFwW3R5cGUudGFnXSB8fCB0eXBlLmRlZmF1bHRTdHlsZTtcblxuICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwodHlwZS5yZXByZXNlbnQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50KG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUucmVwcmVzZW50LCBzdHlsZSkpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnRbc3R5bGVdKG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5mdW5jdGlvbiB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3QsIGJsb2NrLCBjb21wYWN0LCBpc2tleSkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IChzdGF0ZS5mbG93TGV2ZWwgPCAwIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIHZhciBvYmplY3RPckFycmF5ID0gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGR1cGxpY2F0ZUluZGV4LFxuICAgICAgZHVwbGljYXRlO1xuXG4gIGlmIChvYmplY3RPckFycmF5KSB7XG4gICAgZHVwbGljYXRlSW5kZXggPSBzdGF0ZS5kdXBsaWNhdGVzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBkdXBsaWNhdGUgPSBkdXBsaWNhdGVJbmRleCAhPT0gLTE7XG4gIH1cblxuICBpZiAoKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHwgZHVwbGljYXRlIHx8IChzdGF0ZS5pbmRlbnQgIT09IDIgJiYgbGV2ZWwgPiAwKSkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgdmFyIGFycmF5TGV2ZWwgPSAoc3RhdGUubm9BcnJheUluZGVudCAmJiAobGV2ZWwgPiAwKSkgPyBsZXZlbCAtIDEgOiBsZXZlbDtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYXJyYXlMZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGFycmF5TGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICBpZiAoc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgICAgd3JpdGVTY2FsYXIoc3RhdGUsIHN0YXRlLmR1bXAsIGxldmVsLCBpc2tleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5za2lwSW52YWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3VuYWNjZXB0YWJsZSBraW5kIG9mIGFuIG9iamVjdCB0byBkdW1wICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICBzdGF0ZS5kdW1wID0gJyE8JyArIHN0YXRlLnRhZyArICc+ICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUob3B0aW9ucyk7XG5cbiAgaWYgKCFzdGF0ZS5ub1JlZnMpIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMoaW5wdXQsIHN0YXRlKTtcblxuICBpZiAod3JpdGVOb2RlKHN0YXRlLCAwLCBpbnB1dCwgdHJ1ZSwgdHJ1ZSkpIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBzYWZlRHVtcChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gZHVtcChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgID0gZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wID0gc2FmZUR1bXA7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBsb2FkZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvbG9hZGVyJyk7XG52YXIgZHVtcGVyID0gcmVxdWlyZSgnLi9qcy15YW1sL2R1bXBlcicpO1xuXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gJyArIG5hbWUgKyAnIGlzIGRlcHJlY2F0ZWQgYW5kIGNhbm5vdCBiZSB1c2VkLicpO1xuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlR5cGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvdHlwZScpO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEnKTtcbm1vZHVsZS5leHBvcnRzLkZBSUxTQUZFX1NDSEVNQSAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5KU09OX1NDSEVNQSAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9qc29uJyk7XG5tb2R1bGUuZXhwb3J0cy5DT1JFX1NDSEVNQSAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9jb3JlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgICAgICAgICA9IGxvYWRlci5sb2FkO1xubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgICAgICAgICA9IGxvYWRlci5sb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWQgICAgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkQWxsICAgICAgICAgPSBsb2FkZXIuc2FmZUxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5kdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XG5tb2R1bGUuZXhwb3J0cy5zYWZlRHVtcCAgICAgICAgICAgID0gZHVtcGVyLnNhZmVEdW1wO1xubW9kdWxlLmV4cG9ydHMuWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9leGNlcHRpb24nKTtcblxuLy8gRGVwcmVjYXRlZCBzY2hlbWEgbmFtZXMgZnJvbSBKUy1ZQU1MIDIuMC54XG5tb2R1bGUuZXhwb3J0cy5NSU5JTUFMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLlNBRkVfU0NIRU1BICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcblxuLy8gRGVwcmVjYXRlZCBmdW5jdGlvbnMgZnJvbSBKUy1ZQU1MIDEueC54XG5tb2R1bGUuZXhwb3J0cy5zY2FuICAgICAgICAgICA9IGRlcHJlY2F0ZWQoJ3NjYW4nKTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlICAgICAgICAgID0gZGVwcmVjYXRlZCgncGFyc2UnKTtcbm1vZHVsZS5leHBvcnRzLmNvbXBvc2UgICAgICAgID0gZGVwcmVjYXRlZCgnY29tcG9zZScpO1xubW9kdWxlLmV4cG9ydHMuYWRkQ29uc3RydWN0b3IgPSBkZXByZWNhdGVkKCdhZGRDb25zdHJ1Y3RvcicpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4vbGliL2pzLXlhbWwuanMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG4iLCAidmFyIHBhcnNlciA9IHJlcXVpcmUoJ2pzLXlhbWwnKVxudmFyIG9wdGlvbmFsQnl0ZU9yZGVyTWFyayA9ICdcXFxcdWZlZmY/J1xudmFyIHBsYXRmb3JtID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2Vzcy5wbGF0Zm9ybSA6ICcnXG52YXIgcGF0dGVybiA9ICdeKCcgK1xuICBvcHRpb25hbEJ5dGVPcmRlck1hcmsgK1xuICAnKD0geWFtbCA9fC0tLSknICtcbiAgJyQoW1xcXFxzXFxcXFNdKj8pJyArXG4gICdeKD86XFxcXDJ8XFxcXC5cXFxcLlxcXFwuKVxcXFxzKicgK1xuICAnJCcgK1xuICAocGxhdGZvcm0gPT09ICd3aW4zMicgPyAnXFxcXHI/JyA6ICcnKSArXG4gICcoPzpcXFxcbik/KSdcbi8vIE5PVEU6IElmIHRoaXMgcGF0dGVybiB1c2VzIHRoZSAnZycgZmxhZyB0aGUgYHJlZ2V4YCB2YXJpYWJsZSBkZWZpbml0aW9uIHdpbGxcbi8vIG5lZWQgdG8gYmUgbW92ZWQgZG93biBpbnRvIHRoZSBmdW5jdGlvbnMgdGhhdCB1c2UgaXQuXG52YXIgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sICdtJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHRyYWN0b3Jcbm1vZHVsZS5leHBvcnRzLnRlc3QgPSB0ZXN0XG5cbmZ1bmN0aW9uIGV4dHJhY3RvciAoc3RyaW5nLCBvcHRpb25zKSB7XG4gIHN0cmluZyA9IHN0cmluZyB8fCAnJ1xuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7IGFsbG93VW5zYWZlOiBmYWxzZSB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIGluc3RhbmNlb2YgT2JqZWN0ID8geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9IDogZGVmYXVsdE9wdGlvbnNcbiAgb3B0aW9ucy5hbGxvd1Vuc2FmZSA9IEJvb2xlYW4ob3B0aW9ucy5hbGxvd1Vuc2FmZSlcbiAgdmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KC8oXFxyP1xcbikvKVxuICBpZiAobGluZXNbMF0gJiYgLz0geWFtbCA9fC0tLS8udGVzdChsaW5lc1swXSkpIHtcbiAgICByZXR1cm4gcGFyc2Uoc3RyaW5nLCBvcHRpb25zLmFsbG93VW5zYWZlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJvZHk6IHN0cmluZyxcbiAgICAgIGJvZHlCZWdpbjogMVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTG9jYXRpb24gKG1hdGNoLCBib2R5KSB7XG4gIHZhciBsaW5lID0gMVxuICB2YXIgcG9zID0gYm9keS5pbmRleE9mKCdcXG4nKVxuICB2YXIgb2Zmc2V0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcblxuICB3aGlsZSAocG9zICE9PSAtMSkge1xuICAgIGlmIChwb3MgPj0gb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbGluZVxuICAgIH1cbiAgICBsaW5lKytcbiAgICBwb3MgPSBib2R5LmluZGV4T2YoJ1xcbicsIHBvcyArIDEpXG4gIH1cblxuICByZXR1cm4gbGluZVxufVxuXG5mdW5jdGlvbiBwYXJzZSAoc3RyaW5nLCBhbGxvd1Vuc2FmZSkge1xuICB2YXIgbWF0Y2ggPSByZWdleC5leGVjKHN0cmluZylcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJvZHk6IHN0cmluZyxcbiAgICAgIGJvZHlCZWdpbjogMVxuICAgIH1cbiAgfVxuXG4gIHZhciBsb2FkZXIgPSBhbGxvd1Vuc2FmZSA/IHBhcnNlci5sb2FkIDogcGFyc2VyLnNhZmVMb2FkXG4gIHZhciB5YW1sID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0ucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG4gIHZhciBhdHRyaWJ1dGVzID0gbG9hZGVyKHlhbWwpIHx8IHt9XG4gIHZhciBib2R5ID0gc3RyaW5nLnJlcGxhY2UobWF0Y2hbMF0sICcnKVxuICB2YXIgbGluZSA9IGNvbXB1dGVMb2NhdGlvbihtYXRjaCwgc3RyaW5nKVxuXG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBib2R5OiBib2R5LFxuICAgIGJvZHlCZWdpbjogbGluZSxcbiAgICBmcm9udG1hdHRlcjogeWFtbFxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3QgKHN0cmluZykge1xuICBzdHJpbmcgPSBzdHJpbmcgfHwgJydcblxuICByZXR1cm4gcmVnZXgudGVzdChzdHJpbmcpXG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIgfSBmcm9tIFwiQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzXCJcbmltcG9ydCAqIGFzIGJ1aWxkIGZyb20gXCJAcmVtaXgtcnVuL2Rldi9zZXJ2ZXItYnVpbGRcIlxuXG5jb25zdCBoYW5kbGVSZXF1ZXN0ID0gY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIoe1xuXHRidWlsZCxcblx0bW9kZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXG5cdGdldExvYWRDb250ZXh0OiBjb250ZXh0ID0+IGNvbnRleHQuZW52XG59KVxuXG5leHBvcnQgZnVuY3Rpb24gb25SZXF1ZXN0KGNvbnRleHQpIHtcblx0cmV0dXJuIGhhbmRsZVJlcXVlc3QoY29udGV4dClcbn1cbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgaW5zdGFsbEdsb2JhbHMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuZXhwb3J0IHsgY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICcuL3Nlc3Npb25zL2Nsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyLCBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vd29ya2VyLmpzJztcblxuaW5zdGFsbEdsb2JhbHMoKTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgc2lnbiwgdW5zaWduIH0gZnJvbSAnLi9jb29raWVTaWduaW5nLmpzJztcblxuZnVuY3Rpb24gaW5zdGFsbEdsb2JhbHMoKSB7XG4gIHNlbGYuc2lnbiA9IHNpZ247XG4gIHNlbGYudW5zaWduID0gdW5zaWduO1xufVxuXG5leHBvcnQgeyBpbnN0YWxsR2xvYmFscyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5hc3luYyBmdW5jdGlvbiBzaWduKHZhbHVlLCBzZWNyZXQpIHtcbiAgbGV0IGtleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGVuY29kZXIuZW5jb2RlKHNlY3JldCksIHtcbiAgICBuYW1lOiBcIkhNQUNcIixcbiAgICBoYXNoOiBcIlNIQS0yNTZcIlxuICB9LCBmYWxzZSwgW1wic2lnblwiXSk7XG4gIGxldCBkYXRhID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQgc2lnbmF0dXJlID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKFwiSE1BQ1wiLCBrZXksIGRhdGEpO1xuICBsZXQgaGFzaCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSkucmVwbGFjZSgvPSskLywgXCJcIik7XG4gIHJldHVybiB2YWx1ZSArIFwiLlwiICsgaGFzaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVuc2lnbihjb29raWUsIHNlY3JldCkge1xuICBsZXQga2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSwge1xuICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgIGhhc2g6IFwiU0hBLTI1NlwiXG4gIH0sIGZhbHNlLCBbXCJ2ZXJpZnlcIl0pO1xuICBsZXQgdmFsdWUgPSBjb29raWUuc2xpY2UoMCwgY29va2llLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gIGxldCBoYXNoID0gY29va2llLnNsaWNlKGNvb2tpZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBzaWduYXR1cmUgPSBieXRlU3RyaW5nVG9VaW50OEFycmF5KGF0b2IoaGFzaCkpO1xuICBsZXQgdmFsaWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShcIkhNQUNcIiwga2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICByZXR1cm4gdmFsaWQgPyB2YWx1ZSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBieXRlU3RyaW5nVG9VaW50OEFycmF5KGJ5dGVTdHJpbmcpIHtcbiAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgeyBzaWduLCB1bnNpZ24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY3JlYXRlU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICdAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgU2Vzc2lvblN0b3JhZ2UgdGhhdCBzdG9yZXMgc2Vzc2lvbiBkYXRhIGluIHRoZSBDbG91bGRmbGFyZSBLViBTdG9yZS5cbiAqXG4gKiBUaGUgYWR2YW50YWdlIG9mIHVzaW5nIHRoaXMgaW5zdGVhZCBvZiBjb29raWUgc2Vzc2lvbiBzdG9yYWdlIGlzIHRoYXRcbiAqIEtWIFN0b3JlIG1heSBjb250YWluIG11Y2ggbW9yZSBkYXRhIHRoYW4gY29va2llcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNjcmVhdGVjbG91ZGZsYXJla3ZzZXNzaW9uc3RvcmFnZS1jbG91ZGZsYXJlLXdvcmtlcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2Uoe1xuICBjb29raWUsXG4gIGt2XG59KSB7XG4gIHJldHVybiBjcmVhdGVTZXNzaW9uU3RvcmFnZSh7XG4gICAgY29va2llLFxuXG4gICAgYXN5bmMgY3JlYXRlRGF0YShkYXRhLCBleHBpcmVzKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgcmFuZG9tQnl0ZXMgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CeXRlcyk7IC8vIFRoaXMgc3RvcmFnZSBtYW5hZ2VzIGFuIGlkIHNwYWNlIG9mIDJeNjQgaWRzLCB3aGljaCBpcyBmYXIgZ3JlYXRlclxuICAgICAgICAvLyB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBmaWxlcyBhbGxvd2VkIG9uIGFuIE5URlMgb3IgZXh0NCB2b2x1bWVcbiAgICAgICAgLy8gKDJeMzIpLiBIb3dldmVyLCB0aGUgbGFyZ2VyIGlkIHNwYWNlIHNob3VsZCBoZWxwIHRvIGF2b2lkIGNvbGxpc2lvbnNcbiAgICAgICAgLy8gd2l0aCBleGlzdGluZyBpZHMgd2hlbiBjcmVhdGluZyBuZXcgc2Vzc2lvbnMsIHdoaWNoIHNwZWVkcyB0aGluZ3MgdXAuXG5cbiAgICAgICAgbGV0IGlkID0gWy4uLnJhbmRvbUJ5dGVzXS5tYXAoeCA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG5cbiAgICAgICAgaWYgKGF3YWl0IGt2LmdldChpZCwgXCJqc29uXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBrdi5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgICAgICAgZXhwaXJhdGlvbjogZXhwaXJlcyA/IE1hdGgucm91bmQoZXhwaXJlcy5nZXRUaW1lKCkgLyAxMDAwKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyByZWFkRGF0YShpZCkge1xuICAgICAgbGV0IHNlc3Npb24gPSBhd2FpdCBrdi5nZXQoaWQpO1xuXG4gICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlc3Npb24pO1xuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGVEYXRhKGlkLCBkYXRhLCBleHBpcmVzKSB7XG4gICAgICBhd2FpdCBrdi5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgICAgIGV4cGlyYXRpb246IGV4cGlyZXMgPyBNYXRoLnJvdW5kKGV4cGlyZXMuZ2V0VGltZSgpIC8gMTAwMCkgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyBkZWxldGVEYXRhKGlkKSB7XG4gICAgICBhd2FpdCBrdi5kZWxldGUoaWQpO1xuICAgIH1cblxuICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IGNyZWF0ZUNvb2tpZSwgaXNDb29raWUgfSBmcm9tICcuL2Nvb2tpZXMuanMnO1xuZXhwb3J0IHsganNvbiwgcmVkaXJlY3QgfSBmcm9tICcuL3Jlc3BvbnNlcy5qcyc7XG5leHBvcnQgeyBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vc2VydmVyLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVNlc3Npb25TdG9yYWdlLCBpc1Nlc3Npb24gfSBmcm9tICcuL3Nlc3Npb25zLmpzJztcbmV4cG9ydCB7IGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlIH0gZnJvbSAnLi9zZXNzaW9ucy9jb29raWVTdG9yYWdlLmpzJztcbmV4cG9ydCB7IGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlIH0gZnJvbSAnLi9zZXNzaW9ucy9tZW1vcnlTdG9yYWdlLmpzJztcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBjcmVhdGluZyBgYXBwbGljYXRpb24vanNvbmAgcmVzcG9uc2VzLiBDb252ZXJ0cyBgZGF0YWBcbiAqIHRvIEpTT04gYW5kIHNldHMgdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNqc29uXG4gKi9cbmZ1bmN0aW9uIGpzb24oZGF0YSwgaW5pdCA9IHt9KSB7XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuXG4gIGlmICh0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgIHN0YXR1czogaW5pdFxuICAgIH07XG4gIH1cblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcblxuICBpZiAoIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwgeyAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZS4gU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjcmVkaXJlY3RcbiAqL1xuXG5mdW5jdGlvbiByZWRpcmVjdCh1cmwsIGluaXQgPSAzMDIpIHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7XG4gICAgICBzdGF0dXM6IHJlc3BvbnNlSW5pdFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuY29uc3QgcmVkaXJlY3RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3BvbnNlLnN0YXR1cyk7XG59XG5mdW5jdGlvbiBpc0NhdGNoUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1DYXRjaFwiKSAhPSBudWxsO1xufVxuXG5leHBvcnQgeyBpc0NhdGNoUmVzcG9uc2UsIGlzUmVkaXJlY3RSZXNwb25zZSwgaXNSZXNwb25zZSwganNvbiwgcmVkaXJlY3QgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGNhbGxSb3V0ZUFjdGlvbiwgY2FsbFJvdXRlTG9hZGVyLCBleHRyYWN0RGF0YSB9IGZyb20gJy4vZGF0YS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcywgY3JlYXRlRW50cnlNYXRjaGVzIH0gZnJvbSAnLi9lbnRyeS5qcyc7XG5pbXBvcnQgeyBzZXJpYWxpemVFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGdldERvY3VtZW50SGVhZGVycyB9IGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgeyBtYXRjaFNlcnZlclJvdXRlcyB9IGZyb20gJy4vcm91dGVNYXRjaGluZy5qcyc7XG5pbXBvcnQgeyBpc1NlcnZlck1vZGUsIFNlcnZlck1vZGUgfSBmcm9tICcuL21vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUm91dGVzIH0gZnJvbSAnLi9yb3V0ZXMuanMnO1xuaW1wb3J0IHsgaXNSZWRpcmVjdFJlc3BvbnNlLCBpc0NhdGNoUmVzcG9uc2UsIGpzb24gfSBmcm9tICcuL3Jlc3BvbnNlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nIH0gZnJvbSAnLi9zZXJ2ZXJIYW5kb2ZmLmpzJztcblxuLyoqXG4gKiBUaGUgbWFpbiByZXF1ZXN0IGhhbmRsZXIgZm9yIGEgUmVtaXggc2VydmVyLiBUaGlzIGhhbmRsZXIgcnVucyBpbiB0aGUgY29udGV4dFxuICogb2YgYSBjbG91ZCBwcm92aWRlcidzIHNlcnZlciAoZS5nLiBFeHByZXNzIG9uIEZpcmViYXNlKSBvciBsb2NhbGx5IHZpYSB0aGVpclxuICogZGV2IHRvb2xzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgc2VydmVzIEhUVFAgcmVxdWVzdHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RIYW5kbGVyKGJ1aWxkLCBwbGF0Zm9ybSwgbW9kZSkge1xuICBsZXQgcm91dGVzID0gY3JlYXRlUm91dGVzKGJ1aWxkLnJvdXRlcyk7XG4gIGxldCBzZXJ2ZXJNb2RlID0gaXNTZXJ2ZXJNb2RlKG1vZGUpID8gbW9kZSA6IFNlcnZlck1vZGUuUHJvZHVjdGlvbjtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RIYW5kbGVyKHJlcXVlc3QsIGxvYWRDb250ZXh0KSB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCB1cmwucGF0aG5hbWUpO1xuICAgIGxldCByZXF1ZXN0VHlwZSA9IGdldFJlcXVlc3RUeXBlKHVybCwgbWF0Y2hlcyk7XG4gICAgbGV0IHJlc3BvbnNlO1xuXG4gICAgc3dpdGNoIChyZXF1ZXN0VHlwZSkge1xuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVEYXRhUmVxdWVzdCh7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICAgIGhhbmRsZURhdGFSZXF1ZXN0OiBidWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRGF0YVJlcXVlc3QsXG4gICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJkb2N1bWVudFwiOlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlbmRlckRvY3VtZW50UmVxdWVzdCh7XG4gICAgICAgICAgYnVpbGQsXG4gICAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHJvdXRlcyxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInJlc291cmNlXCI6XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiaGVhZFwiKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRGF0YVJlcXVlc3Qoe1xuICBoYW5kbGVEYXRhUmVxdWVzdCxcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoZXMsXG4gIHJlcXVlc3QsXG4gIHNlcnZlck1vZGVcbn0pIHtcbiAgaWYgKCFpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSkge1xuICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHtyZXF1ZXN0Lm1ldGhvZH1cImApLCA0MDUpO1xuICB9XG5cbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7dXJsLnBhdGhuYW1lfVwiYCksIDQwNCk7XG4gIH1cblxuICBsZXQgcmVzcG9uc2U7XG4gIGxldCBtYXRjaDtcblxuICB0cnkge1xuICAgIGlmIChpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIG1hdGNoID0gZ2V0QWN0aW9uUmVxdWVzdE1hdGNoKHVybCwgbWF0Y2hlcyk7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxSb3V0ZUFjdGlvbih7XG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByb3V0ZUlkID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJfZGF0YVwiKTtcblxuICAgICAgaWYgKCFyb3V0ZUlkKSB7XG4gICAgICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKGBNaXNzaW5nIHJvdXRlIGlkIGluID9fZGF0YWApLCA0MDMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGVtcE1hdGNoID0gbWF0Y2hlcy5maW5kKG1hdGNoID0+IG1hdGNoLnJvdXRlLmlkID09PSByb3V0ZUlkKTtcblxuICAgICAgaWYgKCF0ZW1wTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IG1hdGNoIFVSTCBcIiR7dXJsLnBhdGhuYW1lfVwiYCksIDQwMyk7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjYWxsUm91dGVMb2FkZXIoe1xuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAvLyBXZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gcHJldmVudCBhIGZldGNoIHJlcXVlc3QgZnJvbSBmb2xsb3dpbmdcbiAgICAgIC8vIHJlZGlyZWN0cy4gU28gd2UgdXNlIHRoZSBgWC1SZW1peC1SZWRpcmVjdGAgaGVhZGVyIHRvIGluZGljYXRlIHRoZVxuICAgICAgLy8gbmV4dCBVUkwsIGFuZCB0aGVuIFwiZm9sbG93XCIgdGhlIHJlZGlyZWN0IG1hbnVhbGx5IG9uIHRoZSBjbGllbnQuXG4gICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlZGlyZWN0XCIsIGhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIikpO1xuICAgICAgaGVhZGVycy5kZWxldGUoXCJMb2NhdGlvblwiKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZURhdGFSZXF1ZXN0KSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZURhdGFSZXF1ZXN0KHJlc3BvbnNlLmNsb25lKCksIHtcbiAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LmNsb25lKClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyTW9kZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCkge1xuICAgICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihlcnJvciwgNTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpLCA1MDApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlckRvY3VtZW50UmVxdWVzdCh7XG4gIGJ1aWxkLFxuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgcm91dGVzLFxuICBzZXJ2ZXJNb2RlXG59KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgbGV0IGFwcFN0YXRlID0ge1xuICAgIHRyYWNrQm91bmRhcmllczogdHJ1ZSxcbiAgICB0cmFja0NhdGNoQm91bmRhcmllczogdHJ1ZSxcbiAgICBjYXRjaEJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICByZW5kZXJCb3VuZGFyeVJvdXRlSWQ6IG51bGwsXG4gICAgbG9hZGVyQm91bmRhcnlSb3V0ZUlkOiBudWxsLFxuICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgY2F0Y2g6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGlmICghaXNWYWxpZFJlcXVlc3RNZXRob2QocmVxdWVzdCkpIHtcbiAgICBtYXRjaGVzID0gbnVsbDtcbiAgICBhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcyA9IGZhbHNlO1xuICAgIGFwcFN0YXRlLmNhdGNoID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIHN0YXR1czogNDA1LFxuICAgICAgc3RhdHVzVGV4dDogXCJNZXRob2QgTm90IEFsbG93ZWRcIlxuICAgIH07XG4gIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICBhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcyA9IGZhbHNlO1xuICAgIGFwcFN0YXRlLmNhdGNoID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIHN0YXR1czogNDA0LFxuICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgIH07XG4gIH1cblxuICBsZXQgYWN0aW9uU3RhdHVzO1xuICBsZXQgYWN0aW9uRGF0YTtcbiAgbGV0IGFjdGlvbk1hdGNoO1xuICBsZXQgYWN0aW9uUmVzcG9uc2U7XG5cbiAgaWYgKG1hdGNoZXMgJiYgaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgYWN0aW9uTWF0Y2ggPSBnZXRBY3Rpb25SZXF1ZXN0TWF0Y2godXJsLCBtYXRjaGVzKTtcblxuICAgIHRyeSB7XG4gICAgICBhY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxSb3V0ZUFjdGlvbih7XG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBtYXRjaDogYWN0aW9uTWF0Y2gsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGFjdGlvblJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uUmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIGFjdGlvblN0YXR1cyA9IHtcbiAgICAgICAgc3RhdHVzOiBhY3Rpb25SZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IGFjdGlvblJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0NhdGNoUmVzcG9uc2UoYWN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gZ2V0RGVlcGVzdFJvdXRlSWRXaXRoQm91bmRhcnkobWF0Y2hlcywgXCJDYXRjaEJvdW5kYXJ5XCIpO1xuICAgICAgICBhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcyA9IGZhbHNlO1xuICAgICAgICBhcHBTdGF0ZS5jYXRjaCA9IHsgLi4uYWN0aW9uU3RhdHVzLFxuICAgICAgICAgIGRhdGE6IGF3YWl0IGV4dHJhY3REYXRhKGFjdGlvblJlc3BvbnNlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiBhd2FpdCBleHRyYWN0RGF0YShhY3Rpb25SZXNwb25zZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID0gZ2V0RGVlcGVzdFJvdXRlSWRXaXRoQm91bmRhcnkobWF0Y2hlcywgXCJFcnJvckJvdW5kYXJ5XCIpO1xuICAgICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICBhcHBTdGF0ZS5lcnJvciA9IGF3YWl0IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcblxuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3IgcnVubmluZyB0aGUgYWN0aW9uIGZvciByb3V0ZSAke2FjdGlvbk1hdGNoLnJvdXRlLmlkfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCByb3V0ZU1vZHVsZXMgPSBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcyhidWlsZC5yb3V0ZXMpO1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IG1hdGNoZXMgfHwgW107XG5cbiAgaWYgKGFwcFN0YXRlLmNhdGNoKSB7XG4gICAgbWF0Y2hlc1RvTG9hZCA9IGdldE1hdGNoZXNVcFRvRGVlcGVzdEJvdW5kYXJ5KCAvLyBnZXQgcmlkIG9mIHRoZSBhY3Rpb24sIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBpdCdzIGxvYWRlciBlaXRoZXJcbiAgICAvLyBiZWNhdXNlIHdlJ2xsIGJlIHJlbmRlcmluZyB0aGUgY2F0Y2ggYm91bmRhcnksIGlmIHlvdSBjYW4gZ2V0IGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBsb2FkZXIgZGF0YSBpbiB0aGUgY2F0Y2ggYm91bmRhcnkgdGhlbiBob3cgdGhlIGhlY2sgaXMgaXRcbiAgICAvLyBzdXBwb3NlZCB0byBkZWFsIHdpdGggdGhyb3duIHJlc3BvbnNlcz9cbiAgICBtYXRjaGVzVG9Mb2FkLnNsaWNlKDAsIC0xKSwgXCJDYXRjaEJvdW5kYXJ5XCIpO1xuICB9IGVsc2UgaWYgKGFwcFN0YXRlLmVycm9yKSB7XG4gICAgbWF0Y2hlc1RvTG9hZCA9IGdldE1hdGNoZXNVcFRvRGVlcGVzdEJvdW5kYXJ5KCAvLyBnZXQgcmlkIG9mIHRoZSBhY3Rpb24sIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBpdCdzIGxvYWRlciBlaXRoZXJcbiAgICAvLyBiZWNhdXNlIHdlJ2xsIGJlIHJlbmRlcmluZyB0aGUgZXJyb3IgYm91bmRhcnksIGlmIHlvdSBjYW4gZ2V0IGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBsb2FkZXIgZGF0YSBpbiB0aGUgZXJyb3IgYm91bmRhcnkgdGhlbiBob3cgdGhlIGhlY2sgaXMgaXRcbiAgICAvLyBzdXBwb3NlZCB0byBkZWFsIHdpdGggZXJyb3JzIGluIHRoZSBsb2FkZXIsIHRvbz9cbiAgICBtYXRjaGVzVG9Mb2FkLnNsaWNlKDAsIC0xKSwgXCJFcnJvckJvdW5kYXJ5XCIpO1xuICB9XG5cbiAgbGV0IHJvdXRlTG9hZGVyUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChtYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBtYXRjaC5yb3V0ZS5tb2R1bGUubG9hZGVyID8gY2FsbFJvdXRlTG9hZGVyKHtcbiAgICBsb2FkQ29udGV4dCxcbiAgICBtYXRjaCxcbiAgICByZXF1ZXN0XG4gIH0pIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCkpKTsgLy8gU3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBhY3Rpb24uIFdlIHdpbGwgdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGxhdGVyXG4gIC8vIHdoYXQgY2F0Y2ggb3IgZXJyb3IgYm91bmRhcnkgc2hvdWxkIGJlIHJlbmRlcmVkIHVuZGVyIGNhc2VzIHdoZXJlXG4gIC8vIGFjdGlvbnMgZG9uJ3QgdGhyb3cgYnV0IGxvYWRlcnMgZG8sIGFjdGlvbnMgdGhyb3cgYW5kIHBhcmVudCBsb2FkZXJzXG4gIC8vIGFsc28gdGhyb3csIGV0Yy5cblxuICBsZXQgYWN0aW9uQ2F0Y2ggPSBhcHBTdGF0ZS5jYXRjaDtcbiAgbGV0IGFjdGlvbkVycm9yID0gYXBwU3RhdGUuZXJyb3I7XG4gIGxldCBhY3Rpb25DYXRjaEJvdW5kYXJ5Um91dGVJZCA9IGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkO1xuICBsZXQgYWN0aW9uTG9hZGVyQm91bmRhcnlSb3V0ZUlkID0gYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkOyAvLyBSZXNldCB0aGUgYXBwIGVycm9yIGFuZCBjYXRjaCBzdGF0ZSB0byBwcm9wb2dhdGUgdGhlIGxvYWRlciBzdGF0ZXNcbiAgLy8gZnJvbSB0aGUgcmVzdWx0cyBpbnRvIHRoZSBhcHAgc3RhdGUuXG5cbiAgYXBwU3RhdGUuY2F0Y2ggPSB1bmRlZmluZWQ7XG4gIGFwcFN0YXRlLmVycm9yID0gdW5kZWZpbmVkO1xuICBsZXQgcm91dGVMb2FkZXJSZXNwb25zZXMgPSB7fTtcbiAgbGV0IGxvYWRlclN0YXR1c0NvZGVzID0gW107XG4gIGxldCByb3V0ZURhdGEgPSB7fTtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWF0Y2hlc1RvTG9hZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICBsZXQgcmVzdWx0ID0gcm91dGVMb2FkZXJSZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuc3RhdHVzID09PSBcInJlamVjdGVkXCIgPyByZXN1bHQucmVhc29uIDogdW5kZWZpbmVkO1xuICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgPyByZXN1bHQudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGlzUmVkaXJlY3QgPSByZXNwb25zZSA/IGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkgOiBmYWxzZTtcbiAgICBsZXQgaXNDYXRjaCA9IHJlc3BvbnNlID8gaXNDYXRjaFJlc3BvbnNlKHJlc3BvbnNlKSA6IGZhbHNlOyAvLyBJZiBhIHBhcmVudCBsb2FkZXIgaGFzIGFscmVhZHkgY2F1Z2h0IG9yIGVycm9yJ2QsIGJhaWwgYmVjYXVzZVxuICAgIC8vIHdlIGRvbid0IG5lZWQgYW55IG1vcmUgY2hpbGQgZGF0YS5cblxuICAgIGlmIChhcHBTdGF0ZS5jYXRjaCB8fCBhcHBTdGF0ZS5lcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiB0aGVyZSBpcyBhIHJlc3BvbnNlIGFuZCBpdCdzIGEgcmVkaXJlY3QsIGRvIGl0IHVubGVzcyB0aGVyZVxuICAgIC8vIGlzIGFuIGFjdGlvbiBlcnJvciBvciBjYXRjaCBzdGF0ZSwgdGhvc2UgYWN0aW9uIGJvdW5kYXJ5IHN0YXRlc1xuICAgIC8vIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzYXRlcywgdGhpcyBtZWFucyBpZiBhIGxvYWRlciByZWRpcmVjdHNcbiAgICAvLyBhZnRlciBhbiBhY3Rpb24gY2F0Y2hlcyBvciBlcnJvcnMgd2Ugd29uJ3QgZm9sbG93IGl0LCBhbmQgaW5zdGVhZFxuICAgIC8vIHJlbmRlciB0aGUgYm91bmRhcnkgY2F1c2VkIGJ5IHRoZSBhY3Rpb24uXG5cblxuICAgIGlmICghYWN0aW9uQ2F0Y2ggJiYgIWFjdGlvbkVycm9yICYmIHJlc3BvbnNlICYmIGlzUmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IC8vIFRyYWNrIHRoZSBib3VuZGFyeSBJRCdzIGZvciB0aGUgbG9hZGVyc1xuXG5cbiAgICBpZiAobWF0Y2gucm91dGUubW9kdWxlLkNhdGNoQm91bmRhcnkpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLnJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvYWRlclN0YXR1c0NvZGVzLnB1c2goNTAwKTtcbiAgICAgIGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcyA9IGZhbHNlO1xuICAgICAgYXBwU3RhdGUuZXJyb3IgPSBhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvcik7XG5cbiAgICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIHJ1bm5pbmcgdGhlIGRhdGEgbG9hZGVyIGZvciByb3V0ZSAke21hdGNoLnJvdXRlLmlkfWApO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICByb3V0ZUxvYWRlclJlc3BvbnNlc1ttYXRjaC5yb3V0ZS5pZF0gPSByZXNwb25zZTtcbiAgICAgIGxvYWRlclN0YXR1c0NvZGVzLnB1c2gocmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgaWYgKGlzQ2F0Y2gpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIGNhdGNoIHJlc3BvbnNlLCBzdG9yZSBpdCBpbiBhcHAgc3RhdGUsIGFuZCBiYWlsXG4gICAgICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICAgIGFwcFN0YXRlLmNhdGNoID0ge1xuICAgICAgICAgIGRhdGE6IGF3YWl0IGV4dHJhY3REYXRhKHJlc3BvbnNlKSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXh0cmFjdCBhbmQgc3RvcmUgdGhlIGxvYWRlciBkYXRhXG4gICAgICAgIHJvdXRlRGF0YVttYXRjaC5yb3V0ZS5pZF0gPSBhd2FpdCBleHRyYWN0RGF0YShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElmIHRoZXJlIHdhcyBub3QgYSBsb2FkZXIgY2F0Y2ggb3IgZXJyb3Igc3RhdGUgdHJpZ2dlcmVkIHJlc2V0IHRoZVxuICAvLyBib3VuZGFyaWVzIGFzIHRoZXkgYXJlIHByb2JhYmx5IGRlZXBlciBpbiB0aGUgdHJlZSBpZiB0aGUgYWN0aW9uXG4gIC8vIGluaXRpYWxseSB0cmlnZ2VyZWQgYSBib3VuZGFyeSBhcyB0aGF0IG1hdGNoIHdvdWxkIG5vdCBleGlzdCBpbiB0aGVcbiAgLy8gbWF0Y2hlcyB0byBsb2FkLlxuXG5cbiAgaWYgKCFhcHBTdGF0ZS5jYXRjaCkge1xuICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gYWN0aW9uQ2F0Y2hCb3VuZGFyeVJvdXRlSWQ7XG4gIH1cblxuICBpZiAoIWFwcFN0YXRlLmVycm9yKSB7XG4gICAgYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID0gYWN0aW9uTG9hZGVyQm91bmRhcnlSb3V0ZUlkO1xuICB9IC8vIElmIHRoZXJlIHdhcyBhbiBhY3Rpb24gZXJyb3Igb3IgY2F0Y2gsIHdlIHdpbGwgcmVzZXQgdGhlIHN0YXRlIHRvIHRoZVxuICAvLyBpbml0aWFsIHZhbHVlcywgb3RoZXJ3aXNlIHdlIHdpbGwgdXNlIHdoYXRldmVyIGNhbWUgb3V0IG9mIHRoZSBsb2FkZXJzLlxuXG5cbiAgYXBwU3RhdGUuY2F0Y2ggPSBhY3Rpb25DYXRjaCB8fCBhcHBTdGF0ZS5jYXRjaDtcbiAgYXBwU3RhdGUuZXJyb3IgPSBhY3Rpb25FcnJvciB8fCBhcHBTdGF0ZS5lcnJvcjtcbiAgbGV0IHJlbmRlcmFibGVNYXRjaGVzID0gZ2V0UmVuZGVyYWJsZU1hdGNoZXMobWF0Y2hlcywgYXBwU3RhdGUpO1xuXG4gIGlmICghcmVuZGVyYWJsZU1hdGNoZXMpIHtcbiAgICByZW5kZXJhYmxlTWF0Y2hlcyA9IFtdO1xuICAgIGxldCByb290ID0gcm91dGVzWzBdO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwgJiYgcm9vdCAhPT0gdm9pZCAwICYmIHJvb3QubW9kdWxlLkNhdGNoQm91bmRhcnkpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gXCJyb290XCI7XG4gICAgICByZW5kZXJhYmxlTWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgIHJvdXRlOiByb3V0ZXNbMF1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBIYW5kbGUgcmVzcG9uc2VzIHdpdGggYSBub24tMjAwIHN0YXR1cyBjb2RlLiBUaGUgZmlyc3QgbG9hZGVyIHdpdGggYVxuICAvLyBub24tMjAwIHN0YXR1cyBjb2RlIGRldGVybWluZXMgdGhlIHN0YXR1cyBjb2RlIGZvciB0aGUgd2hvbGUgcmVzcG9uc2UuXG5cblxuICBsZXQgbm90T2tSZXNwb25zZSA9IGFjdGlvblN0YXR1cyAmJiBhY3Rpb25TdGF0dXMuc3RhdHVzICE9PSAyMDAgPyBhY3Rpb25TdGF0dXMuc3RhdHVzIDogbG9hZGVyU3RhdHVzQ29kZXMuZmluZChzdGF0dXMgPT4gc3RhdHVzICE9PSAyMDApO1xuICBsZXQgcmVzcG9uc2VTdGF0dXNDb2RlID0gYXBwU3RhdGUuZXJyb3IgPyA1MDAgOiB0eXBlb2Ygbm90T2tSZXNwb25zZSA9PT0gXCJudW1iZXJcIiA/IG5vdE9rUmVzcG9uc2UgOiBhcHBTdGF0ZS5jYXRjaCA/IGFwcFN0YXRlLmNhdGNoLnN0YXR1cyA6IDIwMDtcbiAgbGV0IHJlc3BvbnNlSGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgcmVuZGVyYWJsZU1hdGNoZXMsIHJvdXRlTG9hZGVyUmVzcG9uc2VzLCBhY3Rpb25SZXNwb25zZSk7XG4gIGxldCBlbnRyeU1hdGNoZXMgPSBjcmVhdGVFbnRyeU1hdGNoZXMocmVuZGVyYWJsZU1hdGNoZXMsIGJ1aWxkLmFzc2V0cy5yb3V0ZXMpO1xuICBsZXQgc2VydmVySGFuZG9mZiA9IHtcbiAgICBhY3Rpb25EYXRhLFxuICAgIGFwcFN0YXRlOiBhcHBTdGF0ZSxcbiAgICBtYXRjaGVzOiBlbnRyeU1hdGNoZXMsXG4gICAgcm91dGVEYXRhXG4gIH07XG4gIGxldCBlbnRyeUNvbnRleHQgPSB7IC4uLnNlcnZlckhhbmRvZmYsXG4gICAgbWFuaWZlc3Q6IGJ1aWxkLmFzc2V0cyxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKVxuICB9O1xuICBsZXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0ID0gYnVpbGQuZW50cnkubW9kdWxlLmRlZmF1bHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KHJlcXVlc3QuY2xvbmUoKSwgcmVzcG9uc2VTdGF0dXNDb2RlLCByZXNwb25zZUhlYWRlcnMsIGVudHJ5Q29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVzcG9uc2VTdGF0dXNDb2RlID0gNTAwOyAvLyBHbyBhZ2FpbiwgdGhpcyB0aW1lIHdpdGggdGhlIGNvbXBvbmVudERpZENhdGNoIGVtdWxhdGlvbi4gQXMgaXQgcmVuZGVyZWRcbiAgICAvLyBsYXN0IHRpbWUgd2UgbXV0YXRlZCBgY29tcG9uZW50RGlkQ2F0Y2gucm91dGVJZGAgZm9yIHRoZSBsYXN0IHJlbmRlcmVkXG4gICAgLy8gcm91dGUsIG5vdyB3ZSBrbm93IHdoZXJlIHRvIHJlbmRlciB0aGUgZXJyb3IgYm91bmRhcnkgKGZlZWxzIGEgbGl0dGxlXG4gICAgLy8gaGFja3kgYnV0IHRoYXQncyBob3cgaG9va3Mgd29yaykuIFRoaXMgdGVsbHMgdGhlIGVtdWxhdG9yIHRvIHN0b3BcbiAgICAvLyB0cmFja2luZyB0aGUgYHJvdXRlSWRgIGFzIHdlIHJlbmRlciBiZWNhdXNlIHdlIGFscmVhZHkgaGF2ZSBhbiBlcnJvciB0b1xuICAgIC8vIHJlbmRlci5cblxuICAgIGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcyA9IGZhbHNlO1xuICAgIGFwcFN0YXRlLmVycm9yID0gYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuICAgIGVudHJ5Q29udGV4dC5zZXJ2ZXJIYW5kb2ZmU3RyaW5nID0gY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KHJlcXVlc3QuY2xvbmUoKSwgcmVzcG9uc2VTdGF0dXNDb2RlLCByZXNwb25zZUhlYWRlcnMsIGVudHJ5Q29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGxldCBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiO1xuXG4gICAgICBpZiAoc2VydmVyTW9kZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCkge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5cXG4ke1N0cmluZyhlcnJvcil9YDtcbiAgICAgIH0gLy8gR29vZCBncmllZiBmb2xrcywgZ2V0IHlvdXIgYWN0IHRvZ2V0aGVyIFx1RDgzRFx1REUwMiFcblxuXG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KHtcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoZXMsXG4gIHJlcXVlc3QsXG4gIHNlcnZlck1vZGVcbn0pIHtcbiAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IGNhbGxSb3V0ZUxvYWRlcih7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGxldCBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiO1xuXG4gICAgaWYgKHNlcnZlck1vZGUgPT09IFNlcnZlck1vZGUuRGV2ZWxvcG1lbnQpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7U3RyaW5nKGVycm9yKX1gO1xuICAgIH0gLy8gR29vZCBncmllZiBmb2xrcywgZ2V0IHlvdXIgYWN0IHRvZ2V0aGVyIFx1RDgzRFx1REUwMiFcblxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShtZXNzYWdlLCB7XG4gICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1ZXN0VHlwZSh1cmwsIG1hdGNoZXMpIHtcbiAgaWYgKHVybC5zZWFyY2hQYXJhbXMuaGFzKFwiX2RhdGFcIikpIHtcbiAgICByZXR1cm4gXCJkYXRhXCI7XG4gIH1cblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gXCJkb2N1bWVudFwiO1xuICB9XG5cbiAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG5cbiAgaWYgKCFtYXRjaC5yb3V0ZS5tb2R1bGUuZGVmYXVsdCkge1xuICAgIHJldHVybiBcInJlc291cmNlXCI7XG4gIH1cblxuICByZXR1cm4gXCJkb2N1bWVudFwiO1xufVxuXG5mdW5jdGlvbiBpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkge1xuICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG1ldGhvZCA9PT0gXCJwb3N0XCIgfHwgbWV0aG9kID09PSBcInB1dFwiIHx8IG1ldGhvZCA9PT0gXCJwYXRjaFwiIHx8IG1ldGhvZCA9PT0gXCJkZWxldGVcIjtcbn1cblxuZnVuY3Rpb24gaXNIZWFkUmVxdWVzdChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImhlYWRcIjtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFJlcXVlc3RNZXRob2QocmVxdWVzdCkge1xuICByZXR1cm4gcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiB8fCBpc0hlYWRSZXF1ZXN0KHJlcXVlc3QpIHx8IGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXJyb3JCb3VuZGFyeUVycm9yKGVycm9yLCBzdGF0dXMpIHtcbiAgcmV0dXJuIGpzb24oYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpLCB7XG4gICAgc3RhdHVzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiWC1SZW1peC1FcnJvclwiOiBcInllc1wiXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJbmRleFJlcXVlc3RVcmwodXJsKSB7XG4gIGxldCBpbmRleFJlcXVlc3QgPSBmYWxzZTtcblxuICBmb3IgKGxldCBwYXJhbSBvZiB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpKSB7XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgaW5kZXhSZXF1ZXN0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXhSZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25SZXF1ZXN0TWF0Y2godXJsLCBtYXRjaGVzKSB7XG4gIGxldCBtYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuXG4gIGlmICghaXNJbmRleFJlcXVlc3RVcmwodXJsKSAmJiBtYXRjaC5yb3V0ZS5pZC5lbmRzV2l0aChcIi9pbmRleFwiKSkge1xuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKC0yKVswXTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVlcGVzdFJvdXRlSWRXaXRoQm91bmRhcnkobWF0Y2hlcywga2V5KSB7XG4gIGxldCBtYXRjaGVkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkobWF0Y2hlcywga2V5KS5zbGljZSgtMSlbMF07XG4gIHJldHVybiBtYXRjaGVkID8gbWF0Y2hlZC5yb3V0ZS5pZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoZXNVcFRvRGVlcGVzdEJvdW5kYXJ5KG1hdGNoZXMsIGtleSkge1xuICBsZXQgZGVlcGVzdEJvdW5kYXJ5SW5kZXggPSAtMTtcbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAobWF0Y2gucm91dGUubW9kdWxlW2tleV0pIHtcbiAgICAgIGRlZXBlc3RCb3VuZGFyeUluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGVlcGVzdEJvdW5kYXJ5SW5kZXggPT09IC0xKSB7XG4gICAgLy8gbm8gcm91dGUgZXJyb3IgYm91bmRhcmllcywgZG9uJ3QgbmVlZCB0byBjYWxsIGFueSBsb2FkZXJzXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgZGVlcGVzdEJvdW5kYXJ5SW5kZXggKyAxKTtcbn0gLy8gVGhpcyBwcmV2ZW50cyBgPE91dGxldC8+YCBmcm9tIHJlbmRlcmluZyBhbnl0aGluZyBiZWxvdyB3aGVyZSB0aGUgZXJyb3IgdGhyZXdcbi8vIFRPRE86IG1heWJlIGRvIHRoaXMgaW4gPFJlbWl4RXJyb3JCb3VuZGFyeSArIGNvbnRleHQ+XG5cblxuZnVuY3Rpb24gZ2V0UmVuZGVyYWJsZU1hdGNoZXMobWF0Y2hlcywgYXBwU3RhdGUpIHtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gbm8gZXJyb3IsIG5vIHdvcnJpZXNcblxuXG4gIGlmICghYXBwU3RhdGUuY2F0Y2ggJiYgIWFwcFN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBsZXQgbGFzdFJlbmRlcmFibGVJbmRleCA9IC0xO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuXG4gICAgaWYgKGFwcFN0YXRlLnJlbmRlckJvdW5kYXJ5Um91dGVJZCA9PT0gaWQgfHwgYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZCA9PT0gaWQpIHtcbiAgICAgIGxhc3RSZW5kZXJhYmxlSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBsYXN0UmVuZGVyYWJsZUluZGV4ICsgMSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBpc1Jlc3BvbnNlLCBpc1JlZGlyZWN0UmVzcG9uc2UsIGpzb24gfSBmcm9tICcuL3Jlc3BvbnNlcy5qcyc7XG5cbi8qKlxuICogQW4gb2JqZWN0IG9mIGFyYml0cmFyeSBmb3Igcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyBwcm92aWRlZCBieSB0aGVcbiAqIHNlcnZlcidzIGBnZXRMb2FkQ29udGV4dCgpYCBmdW5jdGlvbi5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVBY3Rpb24oe1xuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2gsXG4gIHJlcXVlc3Rcbn0pIHtcbiAgbGV0IGFjdGlvbiA9IG1hdGNoLnJvdXRlLm1vZHVsZS5hY3Rpb247XG5cbiAgaWYgKCFhY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtYWRlIGEgJHtyZXF1ZXN0Lm1ldGhvZH0gcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBidXQgZGlkIG5vdCBwcm92aWRlIGAgKyBgYW4gXFxgYWN0aW9uXFxgIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIGAgKyBgcmVxdWVzdC5gKTtcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBhY3Rpb24oe1xuICAgICAgcmVxdWVzdDogc3RyaXBEYXRhUGFyYW0oc3RyaXBJbmRleFBhcmFtKHJlcXVlc3QpKSxcbiAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIWlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUmVkaXJlY3RSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIGVycm9yLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1DYXRjaFwiLCBcInllc1wiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBlcnJvcjtcbiAgfVxuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IGRlZmluZWQgYW4gYWN0aW9uIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIgYnV0IGRpZG4ndCByZXR1cm4gYCArIGBhbnl0aGluZyBmcm9tIHlvdXIgXFxgYWN0aW9uXFxgIGZ1bmN0aW9uLiBQbGVhc2UgcmV0dXJuIGEgdmFsdWUgb3IgXFxgbnVsbFxcYC5gKTtcbiAgfVxuXG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBqc29uKHJlc3VsdCk7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVMb2FkZXIoe1xuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2gsXG4gIHJlcXVlc3Rcbn0pIHtcbiAgbGV0IGxvYWRlciA9IG1hdGNoLnJvdXRlLm1vZHVsZS5sb2FkZXI7XG5cbiAgaWYgKCFsb2FkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtYWRlIGEgJHtyZXF1ZXN0Lm1ldGhvZH0gcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBidXQgZGlkIG5vdCBwcm92aWRlIGAgKyBgYSBcXGBsb2FkZXJcXGAgZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgYCArIGByZXF1ZXN0LmApO1xuICB9XG5cbiAgbGV0IHJlc3VsdDtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGxvYWRlcih7XG4gICAgICByZXF1ZXN0OiBzdHJpcERhdGFQYXJhbShzdHJpcEluZGV4UGFyYW0ocmVxdWVzdC5jbG9uZSgpKSksXG4gICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1JlZGlyZWN0UmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBlcnJvci5oZWFkZXJzLnNldChcIlgtUmVtaXgtQ2F0Y2hcIiwgXCJ5ZXNcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gZXJyb3I7XG4gIH1cblxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBkZWZpbmVkIGEgbG9hZGVyIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIgYnV0IGRpZG4ndCByZXR1cm4gYCArIGBhbnl0aGluZyBmcm9tIHlvdXIgXFxgbG9hZGVyXFxgIGZ1bmN0aW9uLiBQbGVhc2UgcmV0dXJuIGEgdmFsdWUgb3IgXFxgbnVsbFxcYC5gKTtcbiAgfVxuXG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBqc29uKHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5kZXhQYXJhbShyZXF1ZXN0KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgbGV0IGluZGV4VmFsdWVzID0gdXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgbGV0IGluZGV4VmFsdWVzVG9LZWVwID0gW107XG5cbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IHRvS2VlcCBvZiBpbmRleFZhbHVlc1RvS2VlcCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdG9LZWVwKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgcmVxdWVzdCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwRGF0YVBhcmFtKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcIl9kYXRhXCIpO1xuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLmhyZWYsIHJlcXVlc3QpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwb25zZSkge1xuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcblxuICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9IC8vIFdoYXQgb3RoZXIgZGF0YSB0eXBlcyBkbyB3ZSBuZWVkIHRvIGhhbmRsZSBoZXJlPyBXaGF0IG90aGVyIGtpbmRzIG9mXG4gIC8vIHJlc3BvbnNlcyBhcmUgcGVvcGxlIGdvaW5nIHRvIGJlIHJldHVybmluZyBmcm9tIHRoZWlyIGxvYWRlcnM/XG4gIC8vIC0gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkID9cbiAgLy8gLSBtdWx0aXBhcnQvZm9ybS1kYXRhID9cbiAgLy8gLSBiaW5hcnkgKGF1ZGlvL3ZpZGVvKSA/XG5cblxuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuXG5leHBvcnQgeyBjYWxsUm91dGVBY3Rpb24sIGNhbGxSb3V0ZUxvYWRlciwgZXh0cmFjdERhdGEgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudHJ5TWF0Y2hlcyhtYXRjaGVzLCByb3V0ZXMpIHtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKG1hdGNoID0+ICh7XG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoLnBhdGhuYW1lLFxuICAgIHJvdXRlOiByb3V0ZXNbbWF0Y2gucm91dGUuaWRdXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKG1hbmlmZXN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYW5pZmVzdCkucmVkdWNlKChtZW1vLCByb3V0ZUlkKSA9PiB7XG4gICAgbWVtb1tyb3V0ZUlkXSA9IG1hbmlmZXN0W3JvdXRlSWRdLm1vZHVsZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbnRyeU1hdGNoZXMsIGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKipcbiAqIFRoaXMgdGhpbmcgcHJvYmFibHkgd2FycmFudHMgc29tZSBleHBsYW5hdGlvbi5cbiAqXG4gKiBUaGUgd2hvbGUgcG9pbnQgaGVyZSBpcyB0byBlbXVsYXRlIGNvbXBvbmVudERpZENhdGNoIGZvciBzZXJ2ZXIgcmVuZGVyaW5nIGFuZFxuICogZGF0YSBsb2FkaW5nLiBJdCBjYW4gZ2V0IHRyaWNreS4gUmVhY3QgY2FuIGRvIHRoaXMgb24gY29tcG9uZW50IGJvdW5kYXJpZXNcbiAqIGJ1dCBkb2Vzbid0IHN1cHBvcnQgaXQgZm9yIHNlcnZlciByZW5kZXJpbmcgb3IgZGF0YSBsb2FkaW5nLiBXZSBrbm93IGVub3VnaFxuICogd2l0aCBuZXN0ZWQgcm91dGVzIHRvIGJlIGFibGUgdG8gZW11bGF0ZSB0aGUgYmVoYXZpb3IgKGJlY2F1c2Ugd2Uga25vdyB0aGVtXG4gKiBzdGF0aWNhbGx5IGJlZm9yZSByZW5kZXJpbmcuKVxuICpcbiAqIEVhY2ggcm91dGUgY2FuIGV4cG9ydCBhbiBgRXJyb3JCb3VuZGFyeWAuXG4gKlxuICogLSBXaGVuIHJlbmRlcmluZyB0aHJvd3MgYW4gZXJyb3IsIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IHdpbGwgcmVuZGVyXG4gKiAgIChub3JtYWwgcmVhY3QgY29tcG9uZW50RGlkQ2F0Y2gpLiBUaGlzIHdpbGwgYmUgdGhlIHJvdXRlJ3Mgb3duIGJvdW5kYXJ5LCBidXRcbiAqICAgaWYgbm9uZSBpcyBwcm92aWRlZCwgaXQgd2lsbCBidWJibGUgdXAgdG8gdGhlIHBhcmVudHMuXG4gKiAtIFdoZW4gZGF0YSBsb2FkaW5nIHRocm93cyBhbiBlcnJvciwgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgd2lsbCByZW5kZXJcbiAqIC0gV2hlbiBwZXJmb3JtaW5nIGFuIGFjdGlvbiwgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgZm9yIHRoZSBhY3Rpb24nc1xuICogICByb3V0ZSB0cmVlIHdpbGwgcmVuZGVyIChubyByZWRpcmVjdCBoYXBwZW5zKVxuICpcbiAqIER1cmluZyBub3JtYWwgcmVhY3QgcmVuZGVyaW5nLCB3ZSBkbyBub3RoaW5nIHNwZWNpYWwsIGp1c3Qgbm9ybWFsXG4gKiBjb21wb25lbnREaWRDYXRjaC5cbiAqXG4gKiBGb3Igc2VydmVyIHJlbmRlcmluZywgd2UgbXV0YXRlIGByZW5kZXJCb3VuZGFyeVJvdXRlSWRgIHRvIGtub3cgdGhlIGxhc3RcbiAqIGxheW91dCB0aGF0IGhhcyBhbiBlcnJvciBib3VuZGFyeSB0aGF0IHRyaWVkIHRvIHJlbmRlci4gVGhpcyBlbXVsYXRlcyB3aGljaFxuICogbGF5b3V0IHdvdWxkIGNhdGNoIGEgdGhyb3duIGVycm9yLiBJZiB0aGUgcmVuZGVyaW5nIGZhaWxzLCB3ZSBjYXRjaCB0aGUgZXJyb3JcbiAqIG9uIHRoZSBzZXJ2ZXIsIGFuZCBnbyBhZ2FpbiBhIHNlY29uZCB0aW1lIHdpdGggdGhlIGVtdWxhdG9yIGhvbGRpbmcgb24gdG8gdGhlXG4gKiBpbmZvcm1hdGlvbiBpdCBuZWVkcyB0byByZW5kZXIgdGhlIHNhbWUgZXJyb3IgYm91bmRhcnkgYXMgYSBkeW5hbWljYWxseVxuICogdGhyb3duIHJlbmRlciBlcnJvci5cbiAqXG4gKiBXaGVuIGRhdGEgbG9hZGluZywgc2VydmVyIG9yIGNsaWVudCBzaWRlLCB3ZSB1c2UgdGhlIGVtdWxhdG9yIHRvIGxpa2V3aXNlXG4gKiBoYW5nIG9uIHRvIHRoZSBlcnJvciBhbmQgcmUtcmVuZGVyIGF0IHRoZSBhcHByb3ByaWF0ZSBsYXlvdXQgKHdoZXJlIGEgdGhyb3duXG4gKiBlcnJvciB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0IGJ5IGNEQykuXG4gKlxuICogV2hlbiBhY3Rpb25zIHRocm93LCBpdCBhbGwgd29ya3MgdGhlIHNhbWUuIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHRvIGJlIGF3YXJlXG4gKiBvZiB0aG91Z2guIEFjdGlvbnMgbm9ybWFsbHkgYXJlIHJlcXVpcmVkIHRvIHJlZGlyZWN0LCBidXQgaW4gdGhlIGNhc2Ugb2ZcbiAqIGVycm9ycywgd2UgcmVuZGVyIHRoZSBhY3Rpb24ncyByb3V0ZSB3aXRoIHRoZSBlbXVsYXRvciBob2xkaW5nIG9uIHRvIHRoZVxuICogZXJyb3IuIElmIGR1cmluZyB0aGlzIHJlbmRlciBhIHBhcmVudCByb3V0ZS9sb2FkZXIgdGhyb3dzIHdlIGlnbm9yZSB0aGF0IG5ld1xuICogZXJyb3IgYW5kIHJlbmRlciB0aGUgYWN0aW9uJ3Mgb3JpZ2luYWwgZXJyb3IgYXMgZGVlcGx5IGFzIHBvc3NpYmxlLiBJbiBvdGhlclxuICogd29yZHMsIHdlIHNpbXBseSBpZ25vcmUgdGhlIG5ldyBlcnJvciBhbmQgdXNlIHRoZSBhY3Rpb24ncyBlcnJvciBpbiBwbGFjZVxuICogYmVjYXVzZSBpdCBjYW1lIGZpcnN0LCBhbmQgdGhhdCBqdXN0IHdvdWxkbid0IGJlIGZhaXIgdG8gbGV0IGVycm9ycyBjdXQgaW5cbiAqIGxpbmUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgfTtcbn1cblxuZXhwb3J0IHsgc2VyaWFsaXplRXJyb3IgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IHNwbGl0Q29va2llc1N0cmluZyB9IGZyb20gJ3NldC1jb29raWUtcGFyc2VyJztcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBtYXRjaGVzLCByb3V0ZUxvYWRlclJlc3BvbnNlcywgYWN0aW9uUmVzcG9uc2UpIHtcbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlKChwYXJlbnRIZWFkZXJzLCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSBidWlsZC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdLm1vZHVsZTtcbiAgICBsZXQgcm91dGVMb2FkZXJSZXNwb25zZSA9IHJvdXRlTG9hZGVyUmVzcG9uc2VzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBsZXQgbG9hZGVySGVhZGVycyA9IHJvdXRlTG9hZGVyUmVzcG9uc2UgPyByb3V0ZUxvYWRlclJlc3BvbnNlLmhlYWRlcnMgOiBuZXcgSGVhZGVycygpO1xuICAgIGxldCBhY3Rpb25IZWFkZXJzID0gYWN0aW9uUmVzcG9uc2UgPyBhY3Rpb25SZXNwb25zZS5oZWFkZXJzIDogbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJvdXRlTW9kdWxlLmhlYWRlcnMgPyB0eXBlb2Ygcm91dGVNb2R1bGUuaGVhZGVycyA9PT0gXCJmdW5jdGlvblwiID8gcm91dGVNb2R1bGUuaGVhZGVycyh7XG4gICAgICBsb2FkZXJIZWFkZXJzLFxuICAgICAgcGFyZW50SGVhZGVycyxcbiAgICAgIGFjdGlvbkhlYWRlcnNcbiAgICB9KSA6IHJvdXRlTW9kdWxlLmhlYWRlcnMgOiB1bmRlZmluZWQpOyAvLyBBdXRvbWF0aWNhbGx5IHByZXNlcnZlIFNldC1Db29raWUgaGVhZGVycyB0aGF0IHdlcmUgc2V0IGVpdGhlciBieSB0aGVcbiAgICAvLyBsb2FkZXIgb3IgYnkgYSBwYXJlbnQgcm91dGUuXG5cbiAgICBwcmVwZW5kQ29va2llcyhhY3Rpb25IZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhsb2FkZXJIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGNoaWxkSGVhZGVycykge1xuICBsZXQgcGFyZW50U2V0Q29va2llU3RyaW5nID0gcGFyZW50SGVhZGVycy5nZXQoXCJTZXQtQ29va2llXCIpO1xuXG4gIGlmIChwYXJlbnRTZXRDb29raWVTdHJpbmcpIHtcbiAgICBsZXQgY29va2llcyA9IHNwbGl0Q29va2llc1N0cmluZyhwYXJlbnRTZXRDb29raWVTdHJpbmcpO1xuICAgIGNvb2tpZXMuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgY2hpbGRIZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXREb2N1bWVudEhlYWRlcnMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IG1hdGNoUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbi8vIFRPRE86IGV4cG9ydC9pbXBvcnQgZnJvbSByZWFjdC1yb3V0ZXItZG9tXG5mdW5jdGlvbiBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCBwYXRobmFtZSk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBtYXRjaFNlcnZlclJvdXRlcyB9O1xuIiwgImltcG9ydCBfZXh0ZW5kcyBmcm9tJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO3ZhciByLEI9cnx8KHI9e30pO0IuUG9wPVwiUE9QXCI7Qi5QdXNoPVwiUFVTSFwiO0IuUmVwbGFjZT1cIlJFUExBQ0VcIjt2YXIgQz1cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP2Z1bmN0aW9uKGIpe3JldHVybiBPYmplY3QuZnJlZXplKGIpfTpmdW5jdGlvbihiKXtyZXR1cm4gYn07ZnVuY3Rpb24gRChiLGgpe2lmKCFiKXtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUud2FybihoKTt0cnl7dGhyb3cgRXJyb3IoaCk7fWNhdGNoKGUpe319fWZ1bmN0aW9uIEUoYil7Yi5wcmV2ZW50RGVmYXVsdCgpO2IucmV0dXJuVmFsdWU9XCJcIn1cbmZ1bmN0aW9uIEYoKXt2YXIgYj1bXTtyZXR1cm57Z2V0IGxlbmd0aCgpe3JldHVybiBiLmxlbmd0aH0scHVzaDpmdW5jdGlvbihoKXtiLnB1c2goaCk7cmV0dXJuIGZ1bmN0aW9uKCl7Yj1iLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSE9PWh9KX19LGNhbGw6ZnVuY3Rpb24oaCl7Yi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlKGgpfSl9fX1mdW5jdGlvbiBIKCl7cmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLDgpfWZ1bmN0aW9uIEkoYil7dmFyIGg9Yi5wYXRobmFtZTtoPXZvaWQgMD09PWg/XCIvXCI6aDt2YXIgZT1iLnNlYXJjaDtlPXZvaWQgMD09PWU/XCJcIjplO2I9Yi5oYXNoO2I9dm9pZCAwPT09Yj9cIlwiOmI7ZSYmXCI/XCIhPT1lJiYoaCs9XCI/XCI9PT1lLmNoYXJBdCgwKT9lOlwiP1wiK2UpO2ImJlwiI1wiIT09YiYmKGgrPVwiI1wiPT09Yi5jaGFyQXQoMCk/YjpcIiNcIitiKTtyZXR1cm4gaH1cbmZ1bmN0aW9uIEooYil7dmFyIGg9e307aWYoYil7dmFyIGU9Yi5pbmRleE9mKFwiI1wiKTswPD1lJiYoaC5oYXNoPWIuc3Vic3RyKGUpLGI9Yi5zdWJzdHIoMCxlKSk7ZT1iLmluZGV4T2YoXCI/XCIpOzA8PWUmJihoLnNlYXJjaD1iLnN1YnN0cihlKSxiPWIuc3Vic3RyKDAsZSkpO2ImJihoLnBhdGhuYW1lPWIpfXJldHVybiBofVxuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoYil7ZnVuY3Rpb24gaCgpe3ZhciBjPXAubG9jYXRpb24sYT1tLnN0YXRlfHx7fTtyZXR1cm5bYS5pZHgsQyh7cGF0aG5hbWU6Yy5wYXRobmFtZSxzZWFyY2g6Yy5zZWFyY2gsaGFzaDpjLmhhc2gsc3RhdGU6YS51c3J8fG51bGwsa2V5OmEua2V5fHxcImRlZmF1bHRcIn0pXX1mdW5jdGlvbiBlKGMpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYz9jOkkoYyl9ZnVuY3Rpb24geChjLGEpe3ZvaWQgMD09PWEmJihhPW51bGwpO3JldHVybiBDKF9leHRlbmRzKHtwYXRobmFtZTpxLnBhdGhuYW1lLGhhc2g6XCJcIixzZWFyY2g6XCJcIn0sXCJzdHJpbmdcIj09PXR5cGVvZiBjP0ooYyk6Yyx7c3RhdGU6YSxrZXk6SCgpfSkpfWZ1bmN0aW9uIHooYyl7dD1jO2M9aCgpO3Y9Y1swXTtxPWNbMV07ZC5jYWxsKHthY3Rpb246dCxsb2NhdGlvbjpxfSl9ZnVuY3Rpb24gQShjLGEpe2Z1bmN0aW9uIGYoKXtBKGMsYSl9dmFyIGw9ci5QdXNoLGs9eChjLFxuYSk7aWYoIWcubGVuZ3RofHwoZy5jYWxsKHthY3Rpb246bCxsb2NhdGlvbjprLHJldHJ5OmZ9KSwhMSkpe3ZhciBuPVt7dXNyOmsuc3RhdGUsa2V5Omsua2V5LGlkeDp2KzF9LGUoayldO2s9blswXTtuPW5bMV07dHJ5e20ucHVzaFN0YXRlKGssXCJcIixuKX1jYXRjaChHKXtwLmxvY2F0aW9uLmFzc2lnbihuKX16KGwpfX1mdW5jdGlvbiB5KGMsYSl7ZnVuY3Rpb24gZigpe3koYyxhKX12YXIgbD1yLlJlcGxhY2Usaz14KGMsYSk7Zy5sZW5ndGgmJihnLmNhbGwoe2FjdGlvbjpsLGxvY2F0aW9uOmsscmV0cnk6Zn0pLDEpfHwoaz1be3VzcjprLnN0YXRlLGtleTprLmtleSxpZHg6dn0sZShrKV0sbS5yZXBsYWNlU3RhdGUoa1swXSxcIlwiLGtbMV0pLHoobCkpfWZ1bmN0aW9uIHcoYyl7bS5nbyhjKX12b2lkIDA9PT1iJiYoYj17fSk7Yj1iLndpbmRvdzt2YXIgcD12b2lkIDA9PT1iP2RvY3VtZW50LmRlZmF1bHRWaWV3OmIsbT1wLmhpc3RvcnksdT1udWxsO3AuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsXG5mdW5jdGlvbigpe2lmKHUpZy5jYWxsKHUpLHU9bnVsbDtlbHNle3ZhciBjPXIuUG9wLGE9aCgpLGY9YVswXTthPWFbMV07aWYoZy5sZW5ndGgpaWYobnVsbCE9Zil7dmFyIGw9di1mO2wmJih1PXthY3Rpb246Yyxsb2NhdGlvbjphLHJldHJ5OmZ1bmN0aW9uKCl7dygtMSpsKX19LHcobCkpfWVsc2VcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoITEsXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLCBidXQgaW4gZ2VuZXJhbCB5b3Ugc2hvdWxkIGRvIGFsbCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIHRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKTpcbnZvaWQgMDtlbHNlIHooYyl9fSk7dmFyIHQ9ci5Qb3A7Yj1oKCk7dmFyIHY9YlswXSxxPWJbMV0sZD1GKCksZz1GKCk7bnVsbD09diYmKHY9MCxtLnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSxtLnN0YXRlLHtpZHg6dn0pLFwiXCIpKTtyZXR1cm57Z2V0IGFjdGlvbigpe3JldHVybiB0fSxnZXQgbG9jYXRpb24oKXtyZXR1cm4gcX0sY3JlYXRlSHJlZjplLHB1c2g6QSxyZXBsYWNlOnksZ286dyxiYWNrOmZ1bmN0aW9uKCl7dygtMSl9LGZvcndhcmQ6ZnVuY3Rpb24oKXt3KDEpfSxsaXN0ZW46ZnVuY3Rpb24oYyl7cmV0dXJuIGQucHVzaChjKX0sYmxvY2s6ZnVuY3Rpb24oYyl7dmFyIGE9Zy5wdXNoKGMpOzE9PT1nLmxlbmd0aCYmcC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsRSk7cmV0dXJuIGZ1bmN0aW9uKCl7YSgpO2cubGVuZ3RofHxwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIixFKX19fX07XG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShiKXtmdW5jdGlvbiBoKCl7dmFyIGE9SihtLmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKSxmPWEucGF0aG5hbWUsbD1hLnNlYXJjaDthPWEuaGFzaDt2YXIgaz11LnN0YXRlfHx7fTtyZXR1cm5bay5pZHgsQyh7cGF0aG5hbWU6dm9pZCAwPT09Zj9cIi9cIjpmLHNlYXJjaDp2b2lkIDA9PT1sP1wiXCI6bCxoYXNoOnZvaWQgMD09PWE/XCJcIjphLHN0YXRlOmsudXNyfHxudWxsLGtleTprLmtleXx8XCJkZWZhdWx0XCJ9KV19ZnVuY3Rpb24gZSgpe2lmKHQpYy5jYWxsKHQpLHQ9bnVsbDtlbHNle3ZhciBhPXIuUG9wLGY9aCgpLGw9ZlswXTtmPWZbMV07aWYoYy5sZW5ndGgpaWYobnVsbCE9bCl7dmFyIGs9cS1sO2smJih0PXthY3Rpb246YSxsb2NhdGlvbjpmLHJldHJ5OmZ1bmN0aW9uKCl7cCgtMSprKX19LHAoaykpfWVsc2VcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoITEsXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLCBidXQgaW4gZ2VuZXJhbCB5b3Ugc2hvdWxkIGRvIGFsbCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIHRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKTpcbnZvaWQgMDtlbHNlIEEoYSl9fWZ1bmN0aW9uIHgoYSl7dmFyIGY9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIiksbD1cIlwiO2YmJmYuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSYmKGY9bS5sb2NhdGlvbi5ocmVmLGw9Zi5pbmRleE9mKFwiI1wiKSxsPS0xPT09bD9mOmYuc2xpY2UoMCxsKSk7cmV0dXJuIGwrXCIjXCIrKFwic3RyaW5nXCI9PT10eXBlb2YgYT9hOkkoYSkpfWZ1bmN0aW9uIHooYSxmKXt2b2lkIDA9PT1mJiYoZj1udWxsKTtyZXR1cm4gQyhfZXh0ZW5kcyh7cGF0aG5hbWU6ZC5wYXRobmFtZSxoYXNoOlwiXCIsc2VhcmNoOlwiXCJ9LFwic3RyaW5nXCI9PT10eXBlb2YgYT9KKGEpOmEse3N0YXRlOmYsa2V5OkgoKX0pKX1mdW5jdGlvbiBBKGEpe3Y9YTthPWgoKTtxPWFbMF07ZD1hWzFdO2cuY2FsbCh7YWN0aW9uOnYsbG9jYXRpb246ZH0pfWZ1bmN0aW9uIHkoYSxmKXtmdW5jdGlvbiBsKCl7eShhLGYpfXZhciBrPXIuUHVzaCxuPXooYSxmKTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP1xuRChcIi9cIj09PW4ucGF0aG5hbWUuY2hhckF0KDApLFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKFwiK0pTT04uc3RyaW5naWZ5KGEpK1wiKVwiKTp2b2lkIDA7aWYoIWMubGVuZ3RofHwoYy5jYWxsKHthY3Rpb246ayxsb2NhdGlvbjpuLHJldHJ5Omx9KSwhMSkpe3ZhciBHPVt7dXNyOm4uc3RhdGUsa2V5Om4ua2V5LGlkeDpxKzF9LHgobildO249R1swXTtHPUdbMV07dHJ5e3UucHVzaFN0YXRlKG4sXCJcIixHKX1jYXRjaChLKXttLmxvY2F0aW9uLmFzc2lnbihHKX1BKGspfX1mdW5jdGlvbiB3KGEsZil7ZnVuY3Rpb24gbCgpe3coYSxmKX12YXIgaz1yLlJlcGxhY2Usbj16KGEsZik7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKFwiL1wiPT09bi5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnJlcGxhY2UoXCIrSlNPTi5zdHJpbmdpZnkoYSkrXG5cIilcIik6dm9pZCAwO2MubGVuZ3RoJiYoYy5jYWxsKHthY3Rpb246ayxsb2NhdGlvbjpuLHJldHJ5Omx9KSwxKXx8KG49W3t1c3I6bi5zdGF0ZSxrZXk6bi5rZXksaWR4OnF9LHgobildLHUucmVwbGFjZVN0YXRlKG5bMF0sXCJcIixuWzFdKSxBKGspKX1mdW5jdGlvbiBwKGEpe3UuZ28oYSl9dm9pZCAwPT09YiYmKGI9e30pO2I9Yi53aW5kb3c7dmFyIG09dm9pZCAwPT09Yj9kb2N1bWVudC5kZWZhdWx0VmlldzpiLHU9bS5oaXN0b3J5LHQ9bnVsbDttLmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLGUpO20uYWRkRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIixmdW5jdGlvbigpe3ZhciBhPWgoKVsxXTtJKGEpIT09SShkKSYmZSgpfSk7dmFyIHY9ci5Qb3A7Yj1oKCk7dmFyIHE9YlswXSxkPWJbMV0sZz1GKCksYz1GKCk7bnVsbD09cSYmKHE9MCx1LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSx1LnN0YXRlLHtpZHg6cX0pLFwiXCIpKTtyZXR1cm57Z2V0IGFjdGlvbigpe3JldHVybiB2fSxnZXQgbG9jYXRpb24oKXtyZXR1cm4gZH0sXG5jcmVhdGVIcmVmOngscHVzaDp5LHJlcGxhY2U6dyxnbzpwLGJhY2s6ZnVuY3Rpb24oKXtwKC0xKX0sZm9yd2FyZDpmdW5jdGlvbigpe3AoMSl9LGxpc3RlbjpmdW5jdGlvbihhKXtyZXR1cm4gZy5wdXNoKGEpfSxibG9jazpmdW5jdGlvbihhKXt2YXIgZj1jLnB1c2goYSk7MT09PWMubGVuZ3RoJiZtLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIixFKTtyZXR1cm4gZnVuY3Rpb24oKXtmKCk7Yy5sZW5ndGh8fG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLEUpfX19fTtcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoYil7ZnVuY3Rpb24gaChkLGcpe3ZvaWQgMD09PWcmJihnPW51bGwpO3JldHVybiBDKF9leHRlbmRzKHtwYXRobmFtZTp0LnBhdGhuYW1lLHNlYXJjaDpcIlwiLGhhc2g6XCJcIn0sXCJzdHJpbmdcIj09PXR5cGVvZiBkP0ooZCk6ZCx7c3RhdGU6ZyxrZXk6SCgpfSkpfWZ1bmN0aW9uIGUoZCxnLGMpe3JldHVybiFxLmxlbmd0aHx8KHEuY2FsbCh7YWN0aW9uOmQsbG9jYXRpb246ZyxyZXRyeTpjfSksITEpfWZ1bmN0aW9uIHgoZCxnKXt1PWQ7dD1nO3YuY2FsbCh7YWN0aW9uOnUsbG9jYXRpb246dH0pfWZ1bmN0aW9uIHooZCxnKXt2YXIgYz1yLlB1c2gsYT1oKGQsZyk7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKFwiL1wiPT09dC5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucHVzaChcIitKU09OLnN0cmluZ2lmeShkKStcIilcIik6XG52b2lkIDA7ZShjLGEsZnVuY3Rpb24oKXt6KGQsZyl9KSYmKG0rPTEscC5zcGxpY2UobSxwLmxlbmd0aCxhKSx4KGMsYSkpfWZ1bmN0aW9uIEEoZCxnKXt2YXIgYz1yLlJlcGxhY2UsYT1oKGQsZyk7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKFwiL1wiPT09dC5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucmVwbGFjZShcIitKU09OLnN0cmluZ2lmeShkKStcIilcIik6dm9pZCAwO2UoYyxhLGZ1bmN0aW9uKCl7QShkLGcpfSkmJihwW21dPWEseChjLGEpKX1mdW5jdGlvbiB5KGQpe3ZhciBnPU1hdGgubWluKE1hdGgubWF4KG0rZCwwKSxwLmxlbmd0aC0xKSxjPXIuUG9wLGE9cFtnXTtlKGMsYSxmdW5jdGlvbigpe3koZCl9KSYmKG09Zyx4KGMsYSkpfXZvaWQgMD09PWImJihiPXt9KTt2YXIgdz1iO2I9dy5pbml0aWFsRW50cmllczt3PXcuaW5pdGlhbEluZGV4O3ZhciBwPSh2b2lkIDA9PT1cbmI/W1wiL1wiXTpiKS5tYXAoZnVuY3Rpb24oZCl7dmFyIGc9QyhfZXh0ZW5kcyh7cGF0aG5hbWU6XCIvXCIsc2VhcmNoOlwiXCIsaGFzaDpcIlwiLHN0YXRlOm51bGwsa2V5OkgoKX0sXCJzdHJpbmdcIj09PXR5cGVvZiBkP0ooZCk6ZCkpO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/RChcIi9cIj09PWcucGF0aG5hbWUuY2hhckF0KDApLFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNyZWF0ZU1lbW9yeUhpc3RvcnkoeyBpbml0aWFsRW50cmllcyB9KSAoaW52YWxpZCBlbnRyeTogXCIrSlNPTi5zdHJpbmdpZnkoZCkrXCIpXCIpOnZvaWQgMDtyZXR1cm4gZ30pLG09TWF0aC5taW4oTWF0aC5tYXgobnVsbD09dz9wLmxlbmd0aC0xOncsMCkscC5sZW5ndGgtMSksdT1yLlBvcCx0PXBbbV0sdj1GKCkscT1GKCk7cmV0dXJue2dldCBpbmRleCgpe3JldHVybiBtfSxnZXQgYWN0aW9uKCl7cmV0dXJuIHV9LGdldCBsb2NhdGlvbigpe3JldHVybiB0fSxjcmVhdGVIcmVmOmZ1bmN0aW9uKGQpe3JldHVyblwic3RyaW5nXCI9PT1cbnR5cGVvZiBkP2Q6SShkKX0scHVzaDp6LHJlcGxhY2U6QSxnbzp5LGJhY2s6ZnVuY3Rpb24oKXt5KC0xKX0sZm9yd2FyZDpmdW5jdGlvbigpe3koMSl9LGxpc3RlbjpmdW5jdGlvbihkKXtyZXR1cm4gdi5wdXNoKGQpfSxibG9jazpmdW5jdGlvbihkKXtyZXR1cm4gcS5wdXNoKGQpfX19O2V4cG9ydHtyIGFzIEFjdGlvbixjcmVhdGVCcm93c2VySGlzdG9yeSxjcmVhdGVIYXNoSGlzdG9yeSxjcmVhdGVNZW1vcnlIaXN0b3J5LEkgYXMgY3JlYXRlUGF0aCxKIGFzIHBhcnNlUGF0aH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBIaXN0b3J5LFxuICBJbml0aWFsRW50cnksXG4gIExvY2F0aW9uLFxuICBNZW1vcnlIaXN0b3J5LFxuICBQYXRoLFxuICBUb1xufSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBjcmVhdGVNZW1vcnlIaXN0b3J5LFxuICBwYXJzZVBhdGhcbn0gZnJvbSBcImhpc3RvcnlcIjtcblxuZXhwb3J0IHR5cGUgeyBMb2NhdGlvbiwgUGF0aCwgVG8sIE5hdmlnYXRpb25UeXBlIH07XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZyk6IGFzc2VydHMgY29uZCB7XG4gIGlmICghY29uZCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbmNvbnN0IGFscmVhZHlXYXJuZWQ6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXk6IHN0cmluZywgY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCAmJiAhYWxyZWFkeVdhcm5lZFtrZXldKSB7XG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDT05URVhUXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIDxSb3V0ZXI+IEFQSVxuICogd2hlcmUgYm90aCB0aGUgbG9jYXRpb24gYW5kIGEgbmF2aWdhdG9yIG11c3QgYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBpbiBvcmRlclxuICogdG8gYXZvaWQgXCJ0ZWFyaW5nXCIgdGhhdCBtYXkgb2NjdXIgaW4gYSBzdXNwZW5zZS1lbmFibGVkIGFwcCBpZiB0aGUgYWN0aW9uXG4gKiBhbmQvb3IgbG9jYXRpb24gd2VyZSB0byBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGhpc3RvcnkgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRvciA9IFBpY2s8SGlzdG9yeSwgXCJnb1wiIHwgXCJwdXNoXCIgfCBcInJlcGxhY2VcIiB8IFwiY3JlYXRlSHJlZlwiPjtcblxuaW50ZXJmYWNlIE5hdmlnYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgYmFzZW5hbWU6IHN0cmluZztcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYzogYm9vbGVhbjtcbn1cblxuY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5hdmlnYXRpb25Db250ZXh0T2JqZWN0PihudWxsISk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIE5hdmlnYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJOYXZpZ2F0aW9uXCI7XG59XG5cbmludGVyZmFjZSBMb2NhdGlvbkNvbnRleHRPYmplY3Qge1xuICBsb2NhdGlvbjogTG9jYXRpb247XG4gIG5hdmlnYXRpb25UeXBlOiBOYXZpZ2F0aW9uVHlwZTtcbn1cblxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxMb2NhdGlvbkNvbnRleHRPYmplY3Q+KG51bGwhKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xufVxuXG5pbnRlcmZhY2UgUm91dGVDb250ZXh0T2JqZWN0IHtcbiAgb3V0bGV0OiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsO1xuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW107XG59XG5cbmNvbnN0IFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8Um91dGVDb250ZXh0T2JqZWN0Pih7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW11cbn0pO1xuXG5pZiAoX19ERVZfXykge1xuICBSb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENPTVBPTkVOVFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWVtb3J5cm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXhcbn06IE1lbW9yeVJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8TWVtb3J5SGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7IGluaXRpYWxFbnRyaWVzLCBpbml0aWFsSW5kZXggfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZVByb3BzIHtcbiAgdG86IFRvO1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBOb3RlOiBUaGlzIEFQSSBpcyBtb3N0bHkgdXNlZnVsIGluIFJlYWN0LkNvbXBvbmVudCBzdWJjbGFzc2VzIHRoYXQgYXJlIG5vdFxuICogYWJsZSB0byB1c2UgaG9va3MuIEluIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgdGhlXG4gKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI25hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBOYXZpZ2F0ZSh7IHRvLCByZXBsYWNlLCBzdGF0ZSB9OiBOYXZpZ2F0ZVByb3BzKTogbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYDxOYXZpZ2F0ZT4gbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgd2FybmluZyhcbiAgICAhUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljLFxuICAgIGA8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIGAgK1xuICAgICAgYFRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBgICtcbiAgICAgIGBvbmx5IGV2ZXIgcmVuZGVyZWQgaW4gcmVzcG9uc2UgdG8gc29tZSB1c2VyIGludGVyYWN0aW9uIG9yIHN0YXRlIGNoYW5nZS5gXG4gICk7XG5cbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0bGV0UHJvcHMge1xuICBjb250ZXh0PzogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI291dGxldFxuICovXG5leHBvcnQgZnVuY3Rpb24gT3V0bGV0KHByb3BzOiBPdXRsZXRQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlUHJvcHMge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBpbmRleD86IGJvb2xlYW47XG4gIHBhdGg/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFJvdXRlUHJvcHMge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBpbmRleD86IGZhbHNlO1xuICBwYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5b3V0Um91dGVQcm9wcyB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRleFJvdXRlUHJvcHMge1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgaW5kZXg6IHRydWU7XG59XG5cbi8qKlxuICogRGVjbGFyZXMgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBhdCBhIGNlcnRhaW4gVVJMIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGUoXG4gIF9wcm9wczogUGF0aFJvdXRlUHJvcHMgfCBMYXlvdXRSb3V0ZVByb3BzIHwgSW5kZXhSb3V0ZVByb3BzXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIGZhbHNlLFxuICAgIGBBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIGAgK1xuICAgICAgYG5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5gXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbiAgbmF2aWdhdGlvblR5cGU/OiBOYXZpZ2F0aW9uVHlwZTtcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAqXG4gKiBOb3RlOiBZb3UgdXN1YWxseSB3b24ndCByZW5kZXIgYSA8Um91dGVyPiBkaXJlY3RseS4gSW5zdGVhZCwgeW91J2xsIHJlbmRlciBhXG4gKiByb3V0ZXIgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQgc3VjaCBhcyBhIDxCcm93c2VyUm91dGVyPlxuICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgPFN0YXRpY1JvdXRlcj4gZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcih7XG4gIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICBuYXZpZ2F0aW9uVHlwZSA9IE5hdmlnYXRpb25UeXBlLlBvcCxcbiAgbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufTogUm91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5gICtcbiAgICAgIGAgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuXG4gIGxldCBiYXNlbmFtZSA9IG5vcm1hbGl6ZVBhdGhuYW1lKGJhc2VuYW1lUHJvcCk7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHsgYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljOiBzdGF0aWNQcm9wIH0pLFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXVxuICApO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cblxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCJcbiAgfSA9IGxvY2F0aW9uUHJvcDtcblxuICBsZXQgbG9jYXRpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleV0pO1xuXG4gIHdhcm5pbmcoXG4gICAgbG9jYXRpb24gIT0gbnVsbCxcbiAgICBgPFJvdXRlciBiYXNlbmFtZT1cIiR7YmFzZW5hbWV9XCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgYCArXG4gICAgICBgXCIke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1cIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIGAgK1xuICAgICAgYGJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLmBcbiAgKTtcblxuICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25hdmlnYXRpb25Db250ZXh0fT5cbiAgICAgIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgICB2YWx1ZT17eyBsb2NhdGlvbiwgbmF2aWdhdGlvblR5cGUgfX1cbiAgICAgIC8+XG4gICAgPC9OYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXNQcm9wcyB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBsb2NhdGlvbj86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhIG5lc3RlZCB0cmVlIG9mIDxSb3V0ZT4gZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXMoe1xuICBjaGlsZHJlbixcbiAgbG9jYXRpb25cbn06IFJvdXRlc1Byb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VSb3V0ZXMoY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKSwgbG9jYXRpb24pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIT09LU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGJ1aWxkaW5nXG4gKiBjdXN0b20gbGlua3MgdGhhdCBhcmUgYWxzbyBhY2Nlc3NpYmxlIGFuZCBwcmVzZXJ2ZSByaWdodC1jbGljayBiZWhhdmlvci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZWhyZWZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUhyZWYodG86IFRvKTogc3RyaW5nIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBnZXRUb1BhdGhuYW1lKHRvKTtcbiAgICBsZXQgZW5kc1dpdGhTbGFzaCA9IHRvUGF0aG5hbWUgIT0gbnVsbCAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBqb2luZWRQYXRobmFtZSA9XG4gICAgICBwYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBiYXNlbmFtZSArIChlbmRzV2l0aFNsYXNoID8gXCIvXCIgOiBcIlwiKVxuICAgICAgICA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLmNyZWF0ZUhyZWYoeyBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlcj4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VpbnJvdXRlcmNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IFVSTCBpbiB3ZWJcbiAqIGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6IElmIHlvdSdyZSB1c2luZyB0aGlzIGl0IG1heSBtZWFuIHlvdSdyZSBkb2luZyBzb21lIG9mIHlvdXIgb3duXG4gKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gKiBiZSBhYmxlIHRvIHByb3ZpZGUgc29tZXRoaW5nIGhpZ2hlci1sZXZlbCB0byBiZXR0ZXIgc3VpdCB5b3VyIG5lZWRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2F0aW9uKCk6IExvY2F0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuXG50eXBlIFBhcmFtUGFyc2VGYWlsZWQgPSB7IGZhaWxlZDogdHJ1ZSB9O1xuXG50eXBlIFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gQ2hlY2sgaGVyZSBpZiB0aGVyZSBleGlzdHMgYSBmb3J3YXJkIHNsYXNoIGluIHRoZSBzdHJpbmcuXG4gIFNlZ21lbnQgZXh0ZW5kcyBgJHtpbmZlciBMZWZ0U2VnbWVudH0vJHtpbmZlciBSaWdodFNlZ21lbnR9YFxuICAgID8gLy8gSWYgdGhlcmUgaXMgYSBmb3J3YXJkIHNsYXNoLCB0aGVuIGF0dGVtcHQgdG8gcGFyc2UgZWFjaCBzaWRlIG9mIHRoZVxuICAgICAgLy8gZm9yd2FyZCBzbGFzaC5cbiAgICAgIFBhcmFtUGFyc2VTZWdtZW50PExlZnRTZWdtZW50PiBleHRlbmRzIGluZmVyIExlZnRSZXN1bHRcbiAgICAgID8gUGFyYW1QYXJzZVNlZ21lbnQ8UmlnaHRTZWdtZW50PiBleHRlbmRzIGluZmVyIFJpZ2h0UmVzdWx0XG4gICAgICAgID8gTGVmdFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgID8gLy8gSWYgdGhlIGxlZnQgc2lkZSBpcyBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIGEgcGFyYW0sIHRoZW4gY2hlY2sgaWZcbiAgICAgICAgICAgIC8vIHRoZSByaWdodCBzaWRlIGNhbiBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIHdlbGwuIElmIGJvdGggc2lkZXNcbiAgICAgICAgICAgIC8vIGNhbiBiZSBwYXJzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBhIHVuaW9uIG9mIHRoZSB0d28gc2lkZXNcbiAgICAgICAgICAgIC8vIChyZWFkOiBcImZvb1wiIHwgXCJiYXJcIikuXG4gICAgICAgICAgICBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgICAgPyBMZWZ0UmVzdWx0IHwgUmlnaHRSZXN1bHRcbiAgICAgICAgICAgIDogTGVmdFJlc3VsdFxuICAgICAgICAgIDogLy8gSWYgdGhlIGxlZnQgc2lkZSBpcyBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBhcyBhIHBhcmFtLCB0aGVuIGNoZWNrXG4gICAgICAgICAgLy8gaWYgb25seSB0aGUgcmlnaHQgc2lkZSBjYW4gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFzIGEgcGFyYW0uIElmIGl0XG4gICAgICAgICAgLy8gY2FuLCB0aGVuIHRoZSByZXN1bHQgaXMganVzdCByaWdodCwgZWxzZSBpdCdzIGEgZmFpbHVyZS5cbiAgICAgICAgICBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgID8gUmlnaHRSZXN1bHRcbiAgICAgICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgICA6IC8vIElmIHRoZSBsZWZ0IHNpZGUgZGlkbid0IHBhcnNlIGludG8gYSBwYXJhbSwgdGhlbiBqdXN0IGNoZWNrIHRoZSByaWdodFxuICAgICAgLy8gc2lkZS5cbiAgICAgIFBhcmFtUGFyc2VTZWdtZW50PFJpZ2h0U2VnbWVudD4gZXh0ZW5kcyBpbmZlciBSaWdodFJlc3VsdFxuICAgICAgPyBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICA/IFJpZ2h0UmVzdWx0XG4gICAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgOiAvLyBJZiB0aGVyZSdzIG5vIGZvcndhcmQgc2xhc2gsIHRoZW4gY2hlY2sgaWYgdGhpcyBzZWdtZW50IHN0YXJ0cyB3aXRoIGFcbiAgICAvLyBjb2xvbi4gSWYgaXQgZG9lcywgdGhlbiB0aGlzIGlzIGEgZHluYW1pYyBzZWdtZW50LCBzbyB0aGUgcmVzdWx0IGlzXG4gICAgLy8ganVzdCB0aGUgcmVtYWluZGVyIG9mIHRoZSBzdHJpbmcuIE90aGVyd2lzZSwgaXQncyBhIGZhaWx1cmUuXG4gICAgU2VnbWVudCBleHRlbmRzIGA6JHtpbmZlciBSZW1haW5pbmd9YFxuICAgID8gUmVtYWluaW5nXG4gICAgOiBQYXJhbVBhcnNlRmFpbGVkO1xuXG4vLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgc2VnbWVudC4gSWYgaXQgZmFpbHMsIHRoZW4ganVzdCByZXR1cm4gdGhlXG4vLyBwbGFpbiBzdHJpbmcgdHlwZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2suIE90aGVyd2lzZSByZXR1cm4gdGhlIHVuaW9uIG9mIHRoZVxuLy8gcGFyc2VkIHN0cmluZyBsaXRlcmFscyB0aGF0IHdlcmUgcmVmZXJlbmNlZCBhcyBkeW5hbWljIHNlZ21lbnRzIGluIHRoZSByb3V0ZS5cbnR5cGUgUGFyYW1QYXJzZUtleTxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQ+IGV4dGVuZHMgc3RyaW5nXG4gICAgPyBQYXJhbVBhcnNlU2VnbWVudDxTZWdtZW50PlxuICAgIDogc3RyaW5nO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VuYXZpZ2F0aW9udHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKTogTmF2aWdhdGlvblR5cGUge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVVJMIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxuICogPE5hdkxpbms+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlbWF0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIFBhcmFtUGFyc2VLZXk8UGF0aD4sXG4gIFBhdGggZXh0ZW5kcyBzdHJpbmdcbj4ocGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoKTogUGF0aE1hdGNoPFBhcmFtS2V5PiB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IHBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFBhdGg8UGFyYW1LZXksIFBhdGg+KHBhdHRlcm4sIHBhdGhuYW1lKSxcbiAgICBbcGF0aG5hbWUsIHBhdHRlcm5dXG4gICk7XG59XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSBmb3IgdGhlIG5hdmlnYXRlKCkgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbSB1c2VOYXZpZ2F0ZSgpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlRnVuY3Rpb24ge1xuICAodG86IFRvLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbiAgKGRlbHRhOiBudW1iZXIpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlT3B0aW9ucyB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgPExpbms+cywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VuYXZpZ2F0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2aWdhdGUoKTogTmF2aWdhdGVGdW5jdGlvbiB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFxuICAgIG1hdGNoZXMubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuXG4gIGxldCBuYXZpZ2F0ZTogTmF2aWdhdGVGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh0bzogVG8gfCBudW1iZXIsIG9wdGlvbnM6IE5hdmlnYXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBhY3RpdmVSZWYuY3VycmVudCxcbiAgICAgICAgYFlvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIGAgK1xuICAgICAgICAgIGB5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5gXG4gICAgICApO1xuXG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICAgICAgdG8sXG4gICAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZVxuICAgICAgKTtcblxuICAgICAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID0gam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgICAgfVxuXG4gICAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb3B0aW9ucy5zdGF0ZVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdXG4gICk7XG5cbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuXG5jb25zdCBPdXRsZXRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDx1bmtub3duPihudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VvdXRsZXRjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0PENvbnRleHQgPSB1bmtub3duPigpOiBDb250ZXh0IHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCkgYXMgQ29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IDxPdXRsZXQ+IHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VvdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0PzogdW5rbm93bik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgaWYgKG91dGxldCkge1xuICAgIHJldHVybiAoXG4gICAgICA8T3V0bGV0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+e291dGxldH08L091dGxldENvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXJhbXM8XG4gIFBhcmFtc09yS2V5IGV4dGVuZHMgc3RyaW5nIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHN0cmluZ1xuPigpOiBSZWFkb25seTxcbiAgW1BhcmFtc09yS2V5XSBleHRlbmRzIFtzdHJpbmddID8gUGFyYW1zPFBhcmFtc09yS2V5PiA6IFBhcnRpYWw8UGFyYW1zT3JLZXk+XG4+IHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyAocm91dGVNYXRjaC5wYXJhbXMgYXMgYW55KSA6IHt9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlcmVzb2x2ZWRwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG86IFRvKTogUGF0aCB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFxuICAgIG1hdGNoZXMubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSksXG4gICAgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZz86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgbWF0Y2hlczogcGFyZW50TWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIFlvdSB3b24ndCBnZXQgYSB3YXJuaW5nIGFib3V0IDIgZGlmZmVyZW50IDxSb3V0ZXM+IHVuZGVyIGEgPFJvdXRlPlxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPFJvdXRlcz5cbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2dcIiBlbGVtZW50PXs8QmxvZyAvPn0gLz5cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgIC8vIDwvUm91dGVzPlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAvLyAgIHJldHVybiAoXG4gICAgLy8gICAgIDxSb3V0ZXM+XG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIGxldCBwYXJlbnRQYXRoID0gKHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGgpIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UoXG4gICAgICBwYXJlbnRQYXRobmFtZSxcbiAgICAgICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBgICtcbiAgICAgICAgYFwiJHtwYXJlbnRQYXRobmFtZX1cIiAodW5kZXIgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+KSBidXQgdGhlIGAgK1xuICAgICAgICBgcGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFwiKlwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBgICtcbiAgICAgICAgYGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIGAgK1xuICAgICAgICBgcm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxcblxcbmAgK1xuICAgICAgICBgUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgYCArXG4gICAgICAgIGBwYXRoPVwiJHtwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogYCR7cGFyZW50UGF0aH0vKmB9XCI+LmBcbiAgICApO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID1cbiAgICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHxcbiAgICAgICAgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgYCArXG4gICAgICAgIGB0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgYCArXG4gICAgICAgIGBtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFwiJHtwYXJlbnRQYXRobmFtZUJhc2V9XCIgYCArXG4gICAgICAgIGBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcblxuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG5cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgPyBwYXRobmFtZVxuICAgICAgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHsgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lIH0pO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCxcbiAgICAgIGBObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGBcbiAgICApO1xuXG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fFxuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGRvZXMgbm90IGhhdmUgYW4gZWxlbWVudC4gYCArXG4gICAgICAgIGBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXCJlbXB0eVwiIHBhZ2UuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJlxuICAgICAgbWF0Y2hlcy5tYXAobWF0Y2ggPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICAgICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICAgICAgICBwYXRobmFtZTogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICAgICAgcGF0aG5hbWVCYXNlOlxuICAgICAgICAgICAgbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgICAgICAgICA/IHBhcmVudFBhdGhuYW1lQmFzZVxuICAgICAgICAgICAgICA6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzXG4gICk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI2NyZWF0ZXJvdXRlc2Zyb21jaGlsZHJlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4pOiBSb3V0ZU9iamVjdFtdIHtcbiAgbGV0IHJvdXRlczogUm91dGVPYmplY3RbXSA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGVsZW1lbnQgPT4ge1xuICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgIC8vIFRyYW5zcGFyZW50bHkgc3VwcG9ydCBSZWFjdC5GcmFnbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgcm91dGVzLnB1c2guYXBwbHkoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudChcbiAgICAgIGVsZW1lbnQudHlwZSA9PT0gUm91dGUsXG4gICAgICBgWyR7XG4gICAgICAgIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZVxuICAgICAgfV0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PmBcbiAgICApO1xuXG4gICAgbGV0IHJvdXRlOiBSb3V0ZU9iamVjdCA9IHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoXG4gICAgfTtcblxuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogVGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhcnNlZCBmcm9tIHRoZSBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgUGFyYW1zPEtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtrZXkgaW4gS2V5XTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBIHJvdXRlIG9iamVjdCByZXByZXNlbnRzIGEgbG9naWNhbCByb3V0ZSwgd2l0aCAob3B0aW9uYWxseSkgaXRzIGNoaWxkXG4gKiByb3V0ZXMgb3JnYW5pemVkIGluIGEgdHJlZS1saWtlIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJvdXRlT2JqZWN0W107XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGluZGV4PzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNnZW5lcmF0ZXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aChwYXRoOiBzdHJpbmcsIHBhcmFtczogUGFyYW1zID0ge30pOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aFxuICAgIC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBrZXkpID0+IHtcbiAgICAgIGludmFyaWFudChwYXJhbXNba2V5XSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgcmV0dXJuIHBhcmFtc1trZXldITtcbiAgICB9KVxuICAgIC5yZXBsYWNlKC9cXC8qXFwqJC8sIF8gPT5cbiAgICAgIHBhcmFtc1tcIipcIl0gPT0gbnVsbCA/IFwiXCIgOiBwYXJhbXNbXCIqXCJdLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBBIFJvdXRlTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSByb3V0ZSBtYXRjaGVkIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcm91dGUgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICByb3V0ZTogUm91dGVPYmplY3Q7XG59XG5cbi8qKlxuICogTWF0Y2hlcyB0aGUgZ2l2ZW4gcm91dGVzIHRvIGEgbG9jYXRpb24gYW5kIHJldHVybnMgdGhlIG1hdGNoIGRhdGEuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHJvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgbG9jYXRpb25Bcmc6IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nLFxuICBiYXNlbmFtZSA9IFwiL1wiXG4pOiBSb3V0ZU1hdGNoW10gfCBudWxsIHtcbiAgbGV0IGxvY2F0aW9uID1cbiAgICB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG5cbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuXG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcblxuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2goYnJhbmNoZXNbaV0sIHBhdGhuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5pbnRlcmZhY2UgUm91dGVNZXRhIHtcbiAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIGNhc2VTZW5zaXRpdmU6IGJvb2xlYW47XG4gIGNoaWxkcmVuSW5kZXg6IG51bWJlcjtcbiAgcm91dGU6IFJvdXRlT2JqZWN0O1xufVxuXG5pbnRlcmZhY2UgUm91dGVCcmFuY2gge1xuICBwYXRoOiBzdHJpbmc7XG4gIHNjb3JlOiBudW1iZXI7XG4gIHJvdXRlc01ldGE6IFJvdXRlTWV0YVtdO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdID0gW10sXG4gIHBhcmVudHNNZXRhOiBSb3V0ZU1ldGFbXSA9IFtdLFxuICBwYXJlbnRQYXRoID0gXCJcIlxuKTogUm91dGVCcmFuY2hbXSB7XG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgbWV0YTogUm91dGVNZXRhID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOiByb3V0ZS5wYXRoIHx8IFwiXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxuICAgICAgY2hpbGRyZW5JbmRleDogaW5kZXgsXG4gICAgICByb3V0ZVxuICAgIH07XG5cbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSxcbiAgICAgICAgYEFic29sdXRlIHJvdXRlIHBhdGggXCIke21ldGEucmVsYXRpdmVQYXRofVwiIG5lc3RlZCB1bmRlciBwYXRoIGAgK1xuICAgICAgICAgIGBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggYCArXG4gICAgICAgICAgYG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcblxuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG5cbiAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIGJlZm9yZSBhZGRpbmcgdGhpcyByb3V0ZSB0byB0aGUgYXJyYXkgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYCArXG4gICAgICAgICAgYGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG5cbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJhbmNoZXMucHVzaCh7IHBhdGgsIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLCByb3V0ZXNNZXRhIH0pO1xuICB9KTtcblxuICByZXR1cm4gYnJhbmNoZXM7XG59XG5cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdKTogdm9pZCB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+XG4gICAgYS5zY29yZSAhPT0gYi5zY29yZVxuICAgICAgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICAgIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICAgICAgYS5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCksXG4gICAgICAgICAgYi5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleClcbiAgICAgICAgKVxuICApO1xufVxuXG5jb25zdCBwYXJhbVJlID0gL146XFx3KyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSAoczogc3RyaW5nKSA9PiBzID09PSBcIipcIjtcblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGg6IHN0cmluZywgaW5kZXg6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG5cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xuICAgIC5maWx0ZXIocyA9PiAhaXNTcGxhdChzKSlcbiAgICAucmVkdWNlKFxuICAgICAgKHNjb3JlLCBzZWdtZW50KSA9PlxuICAgICAgICBzY29yZSArXG4gICAgICAgIChwYXJhbVJlLnRlc3Qoc2VnbWVudClcbiAgICAgICAgICA/IGR5bmFtaWNTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHNlZ21lbnQgPT09IFwiXCJcbiAgICAgICAgICA/IGVtcHR5U2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgICAgaW5pdGlhbFNjb3JlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNpYmxpbmdzID1cbiAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuXG4gIHJldHVybiBzaWJsaW5nc1xuICAgID8gLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICAgIDogLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgYnJhbmNoOiBSb3V0ZUJyYW5jaCxcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogUm91dGVNYXRjaDxQYXJhbUtleT5bXSB8IG51bGwge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG5cbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlczogUm91dGVNYXRjaFtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gcGF0aG5hbWVcbiAgICAgICAgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG5cbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuXG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pLFxuICAgICAgcm91dGVcbiAgICB9KTtcblxuICAgIGlmIChtYXRjaC5wYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPSBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGxcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsLFxuICBwYXJlbnRNYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXVxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBtYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8Um91dGVDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgIGNoaWxkcmVuPXtcbiAgICAgICAgICBtYXRjaC5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQgPyBtYXRjaC5yb3V0ZS5lbGVtZW50IDogPE91dGxldCAvPlxuICAgICAgICB9XG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgIG1hdGNoZXM6IHBhcmVudE1hdGNoZXMuY29uY2F0KG1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSlcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgKTtcbiAgfSwgbnVsbCBhcyBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsKTtcbn1cblxuLyoqXG4gKiBBIFBhdGhQYXR0ZXJuIGlzIHVzZWQgdG8gbWF0Y2ggb24gc29tZSBwb3J0aW9uIG9mIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhQYXR0ZXJuPFBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3QgYSBVUkwgcGF0aG5hbWUuIE1heSBjb250YWluIGA6aWRgLXN0eWxlIHNlZ21lbnRzXG4gICAqIHRvIGluZGljYXRlIHBsYWNlaG9sZGVycyBmb3IgZHluYW1pYyBwYXJhbWV0ZXJzLiBNYXkgYWxzbyBlbmQgd2l0aCBgLypgIHRvXG4gICAqIGluZGljYXRlIG1hdGNoaW5nIHRoZSByZXN0IG9mIHRoZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBwYXRoOiBQYXRoO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGUgc3RhdGljIHBvcnRpb25zIG9mIHRoZSBgcGF0aGAgc2hvdWxkIGJlIG1hdGNoZWQgaW5cbiAgICogdGhlIHNhbWUgY2FzZS5cbiAgICovXG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGlzIHBhdHRlcm4gc2hvdWxkIG1hdGNoIHRoZSBlbnRpcmUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgZW5kPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIFBhdGhNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIFBhdGhQYXR0ZXJuIG1hdGNoZWQgb24gYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aE1hdGNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBhdHRlcm4gdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuO1xufVxuXG50eXBlIE11dGFibGU8VD4gPSB7XG4gIC1yZWFkb25seSBbUCBpbiBrZXlvZiBUXTogVFtQXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgcGF0dGVybiBtYXRjaGluZyBvbiBhIFVSTCBwYXRobmFtZSBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dFxuICogdGhlIG1hdGNoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWF0Y2hwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFBhdGg8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihcbiAgcGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuXG4gIGxldCBbbWF0Y2hlciwgcGFyYW1OYW1lc10gPSBjb21waWxlUGF0aChcbiAgICBwYXR0ZXJuLnBhdGgsXG4gICAgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLFxuICAgIHBhdHRlcm4uZW5kXG4gICk7XG5cbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXM6IFBhcmFtcyA9IHBhcmFtTmFtZXMucmVkdWNlPE11dGFibGU8UGFyYW1zPj4oXG4gICAgKG1lbW8sIHBhcmFtTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJhbXNbXCIqXCJdIGxhdGVyIGJlY2F1c2UgaXQgd2lsbCBiZSBkZWNvZGVkIHRoZW5cbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lXG4gICAgICAgICAgLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aClcbiAgICAgICAgICAucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuXG4gICAgICBtZW1vW3BhcmFtTmFtZV0gPSBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCIsXG4gICAgICAgIHBhcmFtTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgZW5kID0gdHJ1ZVxuKTogW1JlZ0V4cCwgc3RyaW5nW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9XG4gICAgXCJeXCIgK1xuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAgICAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgICAgIC5yZXBsYWNlKC9bXFxcXC4qK14kP3t9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC86KFxcdyspL2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gXCIoW15cXFxcL10rKVwiO1xuICAgICAgfSk7XG5cbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgcGFyYW1OYW1lcy5wdXNoKFwiKlwiKTtcbiAgICByZWdleHBTb3VyY2UgKz1cbiAgICAgIHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIlxuICAgICAgICA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgICAgICA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7IC8vIERvbid0IGluY2x1ZGUgdGhlIC8gaW4gcGFyYW1zW1wiKlwiXVxuICB9IGVsc2Uge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBlbmRcbiAgICAgID8gXCJcXFxcLyokXCIgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgOiAvLyBPdGhlcndpc2UsIG1hdGNoIGEgd29yZCBib3VuZGFyeSBvciBhIHByb2NlZWRpbmcgLy4gVGhlIHdvcmQgYm91bmRhcnkgcmVzdHJpY3RzXG4gICAgICAgIC8vIHBhcmVudCByb3V0ZXMgdG8gbWF0Y2hpbmcgb25seSB0aGVpciBvd24gd29yZHMgYW5kIG5vdGhpbmcgbW9yZSwgZS5nLiBwYXJlbnRcbiAgICAgICAgLy8gcm91dGUgXCIvaG9tZVwiIHNob3VsZCBub3QgbWF0Y2ggXCIvaG9tZTJcIi5cbiAgICAgICAgXCIoPzpcXFxcYnxcXFxcL3wkKVwiO1xuICB9XG5cbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcblxuICByZXR1cm4gW21hdGNoZXIsIHBhcmFtTmFtZXNdO1xufVxuXG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQodmFsdWU6IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgVGhlIHZhbHVlIGZvciB0aGUgVVJMIHBhcmFtIFwiJHtwYXJhbU5hbWV9XCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlYCArXG4gICAgICAgIGAgdGhlIHN0cmluZyBcIiR7dmFsdWV9XCIgaXMgYSBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHlgICtcbiAgICAgICAgYCBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3Jlc29sdmVwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGF0aCh0bzogVG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKTogUGF0aCB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuXG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWVcbiAgICA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgID8gdG9QYXRobmFtZVxuICAgICAgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKVxuICAgIDogZnJvbVBhdGhuYW1lO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGg6IHN0cmluZywgZnJvbVBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcblxuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goc2VnbWVudCA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgLy8gS2VlcCB0aGUgcm9vdCBcIlwiIHNlZ21lbnQgc28gdGhlIHBhdGhuYW1lIHN0YXJ0cyBhdCAvXG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRvKFxuICB0b0FyZzogVG8sXG4gIHJvdXRlUGF0aG5hbWVzOiBzdHJpbmdbXSxcbiAgbG9jYXRpb25QYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoIHtcbiAgbGV0IHRvID0gdHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvQXJnKSA6IHRvQXJnO1xuICBsZXQgdG9QYXRobmFtZSA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0by5wYXRobmFtZTtcblxuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGxldCBmcm9tOiBzdHJpbmc7XG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgLy8gRWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnMgXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lXG4gICAgICAvLyBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleSBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhXG4gICAgICAvLyBtYWpvciByZWFzb24gd2UgY2FsbCB0aGlzIGEgXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCB0byB2YWx1ZSBoYWQgb25lLlxuICBpZiAoXG4gICAgdG9QYXRobmFtZSAmJlxuICAgIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmXG4gICAgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIilcbiAgKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvOiBUbyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgLyBwYXRoc1xuICByZXR1cm4gdG8gPT09IFwiXCIgfHwgKHRvIGFzIFBhdGgpLnBhdGhuYW1lID09PSBcIlwiXG4gICAgPyBcIi9cIlxuICAgIDogdHlwZW9mIHRvID09PSBcInN0cmluZ1wiXG4gICAgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lXG4gICAgOiB0by5wYXRobmFtZTtcbn1cblxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRobmFtZTogc3RyaW5nLCBiYXNlbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KGJhc2VuYW1lLmxlbmd0aCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2VuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG59XG5cbmNvbnN0IGpvaW5QYXRocyA9IChwYXRoczogc3RyaW5nW10pOiBzdHJpbmcgPT5cbiAgcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG5cbmNvbnN0IG5vcm1hbGl6ZVBhdGhuYW1lID0gKHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcblxuY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIlxuICAgID8gXCJcIlxuICAgIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpXG4gICAgPyBzZWFyY2hcbiAgICA6IFwiP1wiICsgc2VhcmNoO1xuXG5jb25zdCBub3JtYWxpemVIYXNoID0gKGhhc2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0XG59O1xuIiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBCcm93c2VySGlzdG9yeSwgSGFzaEhpc3RvcnksIEhpc3RvcnkgfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVQYXRoIH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7XG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGdlbmVyYXRlUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIG1hdGNoUGF0aCxcbiAgcmVzb2x2ZVBhdGgsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJvdXRlcyxcbiAgdXNlT3V0bGV0Q29udGV4dFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5pbXBvcnQgdHlwZSB7IFRvIH0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IFJvdXRlciFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUkUtRVhQT1JUU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gTm90ZTogS2VlcCBpbiBzeW5jIHdpdGggcmVhY3Qtcm91dGVyIGV4cG9ydHMhXG5leHBvcnQge1xuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlcyxcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBnZW5lcmF0ZVBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBtYXRjaFBhdGgsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlc29sdmVQYXRoLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZU91dGxldENvbnRleHRcbn07XG5cbmV4cG9ydCB0eXBlIHtcbiAgTG9jYXRpb24sXG4gIFBhdGgsXG4gIFRvLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdG9yLFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXRoTWF0Y2gsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBQYXRoUm91dGVQcm9wcyxcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVzUHJvcHNcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUm91dGVDb250ZXh0XG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENPTVBPTkVOVFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3NlclJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBQcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIHdpbmRvd1xufTogQnJvd3NlclJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEJyb3dzZXJIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7IHdpbmRvdyB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBIYXNoUm91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCB3aW5kb3cgfTogSGFzaFJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEhhc2hIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdyB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaGlzdG9yeTogSGlzdG9yeTtcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBhY2NlcHRzIGEgcHJlLWluc3RhbnRpYXRlZCBoaXN0b3J5IG9iamVjdC4gSXQncyBpbXBvcnRhbnRcbiAqIHRvIG5vdGUgdGhhdCB1c2luZyB5b3VyIG93biBoaXN0b3J5IG9iamVjdCBpcyBoaWdobHkgZGlzY291cmFnZWQgYW5kIG1heSBhZGRcbiAqIHR3byB2ZXJzaW9ucyBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRvIHlvdXIgYnVuZGxlcyB1bmxlc3MgeW91IHVzZSB0aGUgc2FtZVxuICogdmVyc2lvbiBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRoYXQgUmVhY3QgUm91dGVyIHVzZXMgaW50ZXJuYWxseS5cbiAqL1xuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgaGlzdG9yeSB9OiBIaXN0b3J5Um91dGVyUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5pZiAoX19ERVZfXykge1xuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnlSb3V0ZXIgYXMgdW5zdGFibGVfSGlzdG9yeVJvdXRlciB9O1xuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8UmVhY3QuQW5jaG9ySFRNTEF0dHJpYnV0ZXM8SFRNTEFuY2hvckVsZW1lbnQ+LCBcImhyZWZcIj4ge1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgdG86IFRvO1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuZXhwb3J0IGNvbnN0IExpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBMaW5rV2l0aFJlZihcbiAgICB7IG9uQ2xpY2ssIHJlbG9hZERvY3VtZW50LCByZXBsYWNlID0gZmFsc2UsIHN0YXRlLCB0YXJnZXQsIHRvLCAuLi5yZXN0IH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBocmVmID0gdXNlSHJlZih0byk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHsgcmVwbGFjZSwgc3RhdGUsIHRhcmdldCB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhcbiAgICAgIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxBbmNob3JFbGVtZW50LCBNb3VzZUV2ZW50PlxuICAgICkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmICFyZWxvYWREb2N1bWVudCkge1xuICAgICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICA8YVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB0YXJnZXQ9e3RhcmdldH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdkxpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8TGlua1Byb3BzLCBcImNsYXNzTmFtZVwiIHwgXCJzdHlsZVwiIHwgXCJjaGlsZHJlblwiPiB7XG4gIGNoaWxkcmVuOlxuICAgIHwgUmVhY3QuUmVhY3ROb2RlXG4gICAgfCAoKHByb3BzOiB7IGlzQWN0aXZlOiBib29sZWFuIH0pID0+IFJlYWN0LlJlYWN0Tm9kZSk7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjbGFzc05hbWU/OiBzdHJpbmcgfCAoKHByb3BzOiB7IGlzQWN0aXZlOiBib29sZWFuIH0pID0+IHN0cmluZyk7XG4gIGVuZD86IGJvb2xlYW47XG4gIHN0eWxlPzpcbiAgICB8IFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gUmVhY3QuQ1NTUHJvcGVydGllcyk7XG59XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBOYXZMaW5rID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQW5jaG9yRWxlbWVudCwgTmF2TGlua1Byb3BzPihcbiAgZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoXG4gICAge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgICAgZW5kID0gZmFsc2UsXG4gICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgdG8sXG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvKTtcblxuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lO1xuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRvUGF0aG5hbWUgPSB0b1BhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzQWN0aXZlID1cbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHxcbiAgICAgICghZW5kICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJlxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKTtcblxuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGNsYXNzTmFtZTogc3RyaW5nO1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHsgaXNBY3RpdmUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjbGFzc05hbWUgcHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgd2UgdXNlIGEgZGVmYXVsdCBgYWN0aXZlYFxuICAgICAgLy8gY2xhc3MgZm9yIDxOYXZMaW5rIC8+cyB0aGF0IGFyZSBhY3RpdmUuIEluIHY1IGBhY3RpdmVgIHdhcyB0aGUgZGVmYXVsdFxuICAgICAgLy8gdmFsdWUgZm9yIGBhY3RpdmVDbGFzc05hbWVgLCBidXQgd2UgYXJlIHJlbW92aW5nIHRoYXQgQVBJIGFuZCBjYW4gc3RpbGxcbiAgICAgIC8vIHVzZSB0aGUgb2xkIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgY2xlYW5lciB1cGdyYWRlIHBhdGggYW5kIGtlZXAgdGhlXG4gICAgICAvLyBzaW1wbGUgc3R5bGluZyBydWxlcyB3b3JraW5nIGFzIHRoZXkgY3VycmVudGx5IGRvLlxuICAgICAgY2xhc3NOYW1lID0gW2NsYXNzTmFtZVByb3AsIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGxdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIGxldCBzdHlsZSA9XG4gICAgICB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AoeyBpc0FjdGl2ZSB9KSA6IHN0eWxlUHJvcDtcblxuICAgIHJldHVybiAoXG4gICAgICA8TGlua1xuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgYXJpYS1jdXJyZW50PXthcmlhQ3VycmVudH1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIHRvPXt0b31cbiAgICAgID5cbiAgICAgICAge3R5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oeyBpc0FjdGl2ZSB9KSA6IGNoaWxkcmVufVxuICAgICAgPC9MaW5rPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhPT0tTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcjxFIGV4dGVuZHMgRWxlbWVudCA9IEhUTUxBbmNob3JFbGVtZW50PihcbiAgdG86IFRvLFxuICB7XG4gICAgdGFyZ2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICAgIHN0YXRlXG4gIH06IHtcbiAgICB0YXJnZXQ/OiBSZWFjdC5IVE1MQXR0cmlidXRlQW5jaG9yVGFyZ2V0O1xuICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIHN0YXRlPzogYW55O1xuICB9ID0ge31cbik6IChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4gdm9pZCB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgICAgICAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYSBwdXNoLCBzbyBkbyB0aGUgc2FtZSBoZXJlLlxuICAgICAgICBsZXQgcmVwbGFjZSA9XG4gICAgICAgICAgISFyZXBsYWNlUHJvcCB8fCBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcblxuICAgICAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtsb2NhdGlvbiwgbmF2aWdhdGUsIHBhdGgsIHJlcGxhY2VQcm9wLCBzdGF0ZSwgdGFyZ2V0LCB0b11cbiAgKTtcbn1cblxuLyoqXG4gKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gKiBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0PzogVVJMU2VhcmNoUGFyYW1zSW5pdCkge1xuICB3YXJuaW5nKFxuICAgIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgYFlvdSBjYW5ub3QgdXNlIHRoZSBcXGB1c2VTZWFyY2hQYXJhbXNcXGAgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBgICtcbiAgICAgIGBzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IGAgK1xuICAgICAgYEV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIGAgK1xuICAgICAgYGh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtc1xcblxcbmAgK1xuICAgICAgYElmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBgICtcbiAgICAgIGBodHRwczovL3BvbHlmaWxsLmlvL3YzLyB3aGljaCBwcm92aWRlcyBzb21lIHJlY29tbWVuZGF0aW9ucyBhYm91dCBob3cgYCArXG4gICAgICBgdG8gbG9hZCBwb2x5ZmlsbHMgb25seSBmb3IgdXNlcnMgdGhhdCBuZWVkIHRoZW0sIGluc3RlYWQgb2YgZm9yIGV2ZXJ5IGAgK1xuICAgICAgYHVzZXIuYFxuICApO1xuXG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICBmb3IgKGxldCBrZXkgb2YgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50LmtleXMoKSkge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50LmdldEFsbChrZXkpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG4gIH0sIFtsb2NhdGlvbi5zZWFyY2hdKTtcblxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgbmV4dEluaXQ6IFVSTFNlYXJjaFBhcmFtc0luaXQsXG4gICAgICBuYXZpZ2F0ZU9wdGlvbnM/OiB7IHJlcGxhY2U/OiBib29sZWFuOyBzdGF0ZT86IGFueSB9XG4gICAgKSA9PiB7XG4gICAgICBuYXZpZ2F0ZShcIj9cIiArIGNyZWF0ZVNlYXJjaFBhcmFtcyhuZXh0SW5pdCksIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbmF2aWdhdGVdXG4gICk7XG5cbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc10gYXMgY29uc3Q7XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtS2V5VmFsdWVQYWlyID0gW3N0cmluZywgc3RyaW5nXTtcblxuZXhwb3J0IHR5cGUgVVJMU2VhcmNoUGFyYW1zSW5pdCA9XG4gIHwgc3RyaW5nXG4gIHwgUGFyYW1LZXlWYWx1ZVBhaXJbXVxuICB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPlxuICB8IFVSTFNlYXJjaFBhcmFtcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICBpbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0ID0gXCJcIlxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgdHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBBcnJheS5pc0FycmF5KGluaXQpIHx8XG4gICAgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgPyBpbml0XG4gICAgICA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgICAgIHJldHVybiBtZW1vLmNvbmNhdChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV1cbiAgICAgICAgICApO1xuICAgICAgICB9LCBbXSBhcyBQYXJhbUtleVZhbHVlUGFpcltdKVxuICApO1xufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLyoqXG4gKiBUaGUgbW9kZSB0byB1c2Ugd2hlbiBydW5uaW5nIHRoZSBzZXJ2ZXIuXG4gKi9cbmxldCBTZXJ2ZXJNb2RlO1xuXG4oZnVuY3Rpb24gKFNlcnZlck1vZGUpIHtcbiAgU2VydmVyTW9kZVtcIkRldmVsb3BtZW50XCJdID0gXCJkZXZlbG9wbWVudFwiO1xuICBTZXJ2ZXJNb2RlW1wiUHJvZHVjdGlvblwiXSA9IFwicHJvZHVjdGlvblwiO1xuICBTZXJ2ZXJNb2RlW1wiVGVzdFwiXSA9IFwidGVzdFwiO1xufSkoU2VydmVyTW9kZSB8fCAoU2VydmVyTW9kZSA9IHt9KSk7XG5cbmZ1bmN0aW9uIGlzU2VydmVyTW9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFNlcnZlck1vZGUuRGV2ZWxvcG1lbnQgfHwgdmFsdWUgPT09IFNlcnZlck1vZGUuUHJvZHVjdGlvbiB8fCB2YWx1ZSA9PT0gU2VydmVyTW9kZS5UZXN0O1xufVxuXG5leHBvcnQgeyBTZXJ2ZXJNb2RlLCBpc1NlcnZlck1vZGUgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8vIE5PVEU6IG1ha2Ugc3VyZSB0byBjaGFuZ2UgdGhlIFJvdXRlIGluIHJlbWl4LXJlYWN0IGlmIHlvdSBjaGFuZ2UgdGhpc1xuLy8gTk9URTogbWFrZSBzdXJlIHRvIGNoYW5nZSB0aGUgRW50cnlSb3V0ZSBpbiByZW1peC1yZWFjdCBpZiB5b3UgY2hhbmdlIHRoaXNcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcGFyZW50SWQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5maWx0ZXIoa2V5ID0+IG1hbmlmZXN0W2tleV0ucGFyZW50SWQgPT09IHBhcmVudElkKS5tYXAoaWQgPT4gKHsgLi4ubWFuaWZlc3RbaWRdLFxuICAgIGNoaWxkcmVuOiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIGlkKVxuICB9KSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJvdXRlcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IGpzZXNjIGZyb20gJ2pzZXNjJztcblxuZnVuY3Rpb24gY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKSB7XG4gIC8vIFVzZSBqc2VzYyB0byBlc2NhcGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBsb2FkZXJzLiBUaGlzIHN0cmluZyBpc1xuICAvLyBpbnNlcnRlZCBkaXJlY3RseSBpbnRvIHRoZSBIVE1MIGluIHRoZSBgPFNjcmlwdHM+YCBlbGVtZW50LlxuICByZXR1cm4ganNlc2Moc2VydmVySGFuZG9mZiwge1xuICAgIGlzU2NyaXB0Q29udGV4dDogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBjcmVhdGVSZXF1ZXN0SGFuZGxlciBhcyBjcmVhdGVSZXF1ZXN0SGFuZGxlciQxIH0gZnJvbSAnQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RIYW5kbGVyKHtcbiAgYnVpbGQsXG4gIGdldExvYWRDb250ZXh0LFxuICBtb2RlXG59KSB7XG4gIGxldCBwbGF0Zm9ybSA9IHt9O1xuICBsZXQgaGFuZGxlUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3RIYW5kbGVyJDEoYnVpbGQsIHBsYXRmb3JtLCBtb2RlKTtcbiAgcmV0dXJuIGNvbnRleHQgPT4ge1xuICAgIGxldCBsb2FkQ29udGV4dCA9IHR5cGVvZiBnZXRMb2FkQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiID8gZ2V0TG9hZENvbnRleHQoY29udGV4dCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGhhbmRsZVJlcXVlc3QoY29udGV4dC5yZXF1ZXN0LCBsb2FkQ29udGV4dCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlcih7XG4gIGJ1aWxkLFxuICBnZXRMb2FkQ29udGV4dCxcbiAgbW9kZVxufSkge1xuICBjb25zdCBoYW5kbGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdEhhbmRsZXIoe1xuICAgIGJ1aWxkLFxuICAgIGdldExvYWRDb250ZXh0LFxuICAgIG1vZGVcbiAgfSk7XG5cbiAgY29uc3QgaGFuZGxlRmV0Y2ggPSBhc3luYyBjb250ZXh0ID0+IHtcbiAgICBsZXQgcmVzcG9uc2U7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL3dyYW5nbGVyMi9pc3N1ZXMvMTE3XG5cbiAgICBjb250ZXh0LnJlcXVlc3QuaGVhZGVycy5kZWxldGUoXCJpZi1ub25lLW1hdGNoXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgY29udGV4dC5lbnYuQVNTRVRTLmZldGNoKGNvbnRleHQucmVxdWVzdC51cmwsIGNvbnRleHQucmVxdWVzdC5jbG9uZSgpKTtcbiAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA0MDAgPyBuZXcgUmVzcG9uc2UocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpIDogdW5kZWZpbmVkO1xuICAgIH0gY2F0Y2gge31cblxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVxdWVzdChjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG5cbiAgcmV0dXJuIGFzeW5jIGNvbnRleHQgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRmV0Y2goY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiYgZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoZS5tZXNzYWdlIHx8IGUudG9TdHJpbmcoKSwge1xuICAgICAgICAgIHN0YXR1czogNTAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiSW50ZXJuYWwgRXJyb3JcIiwge1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlciwgY3JlYXRlUmVxdWVzdEhhbmRsZXIgfTtcbiIsICJcbmltcG9ydCAqIGFzIGVudHJ5U2VydmVyIGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxlbnRyeS5zZXJ2ZXIudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTAgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXHJvb3QudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTEgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXHJvdXRlc1xcXFxkb3dubG9hZC50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlMiBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXHN1cHBvcnQudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTMgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXHJvdXRlc1xcXFxzb3VyY2UudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTQgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXHJvdXRlc1xcXFxhYm91dC50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlNSBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXGFwcGxlLnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGU2IGZyb20gXCJEOlxcXFxwcm9qZWN0c1xcXFx1bmlrZXkub3JnXFxcXGFwcFxcXFxyb3V0ZXNcXFxcaW5kZXgudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTcgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXHJvdXRlc1xcXFxsaW51eC50c3hcIjtcbmltcG9ydCAqIGFzIHJvdXRlOCBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXGJsb2cudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTkgZnJvbSBcIkQ6XFxcXHByb2plY3RzXFxcXHVuaWtleS5vcmdcXFxcYXBwXFxcXHJvdXRlc1xcXFxibG9nXFxcXCRzbHVnLnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUxMCBmcm9tIFwiRDpcXFxccHJvamVjdHNcXFxcdW5pa2V5Lm9yZ1xcXFxhcHBcXFxccm91dGVzXFxcXGJsb2dcXFxcaW5kZXgudHN4XCI7XG4gIGV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzZXRzIH0gZnJvbSBcIkByZW1peC1ydW4vZGV2L2Fzc2V0cy1tYW5pZmVzdFwiO1xuICBleHBvcnQgY29uc3QgZW50cnkgPSB7IG1vZHVsZTogZW50cnlTZXJ2ZXIgfTtcbiAgZXhwb3J0IGNvbnN0IHJvdXRlcyA9IHtcbiAgICBcInJvb3RcIjoge1xuICAgICAgaWQ6IFwicm9vdFwiLFxuICAgICAgcGFyZW50SWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBhdGg6IFwiXCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTBcbiAgICB9LFxuICBcInJvdXRlcy9kb3dubG9hZFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvZG93bmxvYWRcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IFwiZG93bmxvYWRcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlMVxuICAgIH0sXG4gIFwicm91dGVzL3N1cHBvcnRcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL3N1cHBvcnRcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IFwic3VwcG9ydFwiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGUyXG4gICAgfSxcbiAgXCJyb3V0ZXMvc291cmNlXCI6IHtcbiAgICAgIGlkOiBcInJvdXRlcy9zb3VyY2VcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IFwic291cmNlXCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTNcbiAgICB9LFxuICBcInJvdXRlcy9hYm91dFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvYWJvdXRcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IFwiYWJvdXRcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlNFxuICAgIH0sXG4gIFwicm91dGVzL2FwcGxlXCI6IHtcbiAgICAgIGlkOiBcInJvdXRlcy9hcHBsZVwiLFxuICAgICAgcGFyZW50SWQ6IFwicm9vdFwiLFxuICAgICAgcGF0aDogXCJhcHBsZVwiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGU1XG4gICAgfSxcbiAgXCJyb3V0ZXMvaW5kZXhcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL2luZGV4XCIsXG4gICAgICBwYXJlbnRJZDogXCJyb290XCIsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBpbmRleDogdHJ1ZSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGU2XG4gICAgfSxcbiAgXCJyb3V0ZXMvbGludXhcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL2xpbnV4XCIsXG4gICAgICBwYXJlbnRJZDogXCJyb290XCIsXG4gICAgICBwYXRoOiBcImxpbnV4XCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTdcbiAgICB9LFxuICBcInJvdXRlcy9ibG9nXCI6IHtcbiAgICAgIGlkOiBcInJvdXRlcy9ibG9nXCIsXG4gICAgICBwYXJlbnRJZDogXCJyb290XCIsXG4gICAgICBwYXRoOiBcImJsb2dcIixcbiAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlOFxuICAgIH0sXG4gIFwicm91dGVzL2Jsb2cvJHNsdWdcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL2Jsb2cvJHNsdWdcIixcbiAgICAgIHBhcmVudElkOiBcInJvdXRlcy9ibG9nXCIsXG4gICAgICBwYXRoOiBcIjpzbHVnXCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTlcbiAgICB9LFxuICBcInJvdXRlcy9ibG9nL2luZGV4XCI6IHtcbiAgICAgIGlkOiBcInJvdXRlcy9ibG9nL2luZGV4XCIsXG4gICAgICBwYXJlbnRJZDogXCJyb3V0ZXMvYmxvZ1wiLFxuICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgaW5kZXg6IHRydWUsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiB1bmRlZmluZWQsXG4gICAgICBtb2R1bGU6IHJvdXRlMTBcbiAgICB9XG4gIH07IiwgImltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIlxuaW1wb3J0IHsgUmVtaXhTZXJ2ZXIgfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IHR5cGUgeyBFbnRyeUNvbnRleHQgfSBmcm9tICdyZW1peCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgcmVzcG9uc2VTdGF0dXNDb2RlOiBudW1iZXIsXG4gIHJlc3BvbnNlSGVhZGVyczogSGVhZGVycyxcbiAgcmVtaXhDb250ZXh0OiBFbnRyeUNvbnRleHRcbikge1xuICBjb25zdCBtYXJrdXAgPSByZW5kZXJUb1N0cmluZyhcbiAgICA8UmVtaXhTZXJ2ZXIgY29udGV4dD17cmVtaXhDb250ZXh0fSB1cmw9e3JlcXVlc3QudXJsfSAvPlxuICApXG5cbiAgcmVzcG9uc2VIZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvaHRtbFwiKVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXCI8IURPQ1RZUEUgaHRtbD5cIiArIG1hcmt1cCwge1xuICAgIHN0YXR1czogcmVzcG9uc2VTdGF0dXNDb2RlLFxuICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVyc1xuICB9KVxufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9IGZyb20gJ0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyc7XG5cbi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgY3JlYXRlQ29va2llLCBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSwgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsIGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVNlc3Npb25TdG9yYWdlLCBpc0Nvb2tpZSwgaXNTZXNzaW9uLCBqc29uLCByZWRpcmVjdCB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG4vKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IEZvcm0sIExpbmssIExpbmtzLCBMaXZlUmVsb2FkLCBNZXRhLCBOYXZMaW5rLCBPdXRsZXQsIFByZWZldGNoUGFnZUxpbmtzLCBSZW1peEJyb3dzZXIsIFJlbWl4U2VydmVyLCBTY3JpcHRzLCBTY3JvbGxSZXN0b3JhdGlvbiwgdXNlQWN0aW9uRGF0YSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VDYXRjaCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUhyZWYsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0LCB1c2VUcmFuc2l0aW9uIH0gZnJvbSAnQHJlbWl4LXJ1bi9yZWFjdCc7XG5cbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IFJlbWl4QnJvd3NlciB9IGZyb20gJy4vYnJvd3Nlci5qcyc7XG5leHBvcnQgeyBPdXRsZXQsIHVzZUhyZWYsIHVzZUxvY2F0aW9uLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuZXhwb3J0IHsgRm9ybSwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIFByZWZldGNoUGFnZUxpbmtzLCBTY3JpcHRzLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMb2FkZXJEYXRhLCB1c2VNYXRjaGVzLCB1c2VTdWJtaXQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuZXhwb3J0IHsgdXNlQ2F0Y2ggfSBmcm9tICcuL2Vycm9yQm91bmRhcmllcy5qcyc7XG5leHBvcnQgeyBTY3JvbGxSZXN0b3JhdGlvbiB9IGZyb20gJy4vc2Nyb2xsLXJlc3RvcmF0aW9uLmpzJztcbmV4cG9ydCB7IFJlbWl4U2VydmVyIH0gZnJvbSAnLi9zZXJ2ZXIuanMnO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VIcmVmLCBOYXZMaW5rIGFzIE5hdkxpbmskMSwgTGluayBhcyBMaW5rJDEsIHVzZUxvY2F0aW9uLCB1c2VSZXNvbHZlZFBhdGgsIHVzZU5hdmlnYXRlLCBSb3V0ZXIsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgUmVtaXhFcnJvckJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSB9IGZyb20gJy4vZXJyb3JCb3VuZGFyaWVzLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuaW1wb3J0IHsgZ2V0TGlua3NGb3JNYXRjaGVzLCBpc1BhZ2VMaW5rRGVzY3JpcHRvciwgZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzLCBnZXREYXRhTGlua0hyZWZzLCBnZXRNb2R1bGVMaW5rSHJlZnMsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzIH0gZnJvbSAnLi9saW5rcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sIH0gZnJvbSAnLi9tYXJrdXAuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZXMuanMnO1xuaW1wb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcuL3RyYW5zaXRpb24uanMnO1xuXG5jb25zdCBSZW1peEVudHJ5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHVzZVJlbWl4RW50cnlDb250ZXh0KCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVtaXhFbnRyeUNvbnRleHQpO1xuICBpbnZhcmlhbnQoY29udGV4dCwgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxSZW1peD4gZWxlbWVudFwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIFJlbWl4RW50cnkoe1xuICBjb250ZXh0OiBlbnRyeUNvbnRleHQsXG4gIGFjdGlvbixcbiAgbG9jYXRpb246IGhpc3RvcnlMb2NhdGlvbixcbiAgbmF2aWdhdG9yOiBfbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBsZXQge1xuICAgIG1hbmlmZXN0LFxuICAgIHJvdXRlRGF0YTogZG9jdW1lbnRMb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZyxcbiAgICBhcHBTdGF0ZTogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yXG4gIH0gPSBlbnRyeUNvbnRleHQ7XG4gIGxldCBjbGllbnRSb3V0ZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdC5yb3V0ZXMsIHJvdXRlTW9kdWxlcywgUmVtaXhSb3V0ZSksIFttYW5pZmVzdCwgcm91dGVNb2R1bGVzXSk7XG4gIGxldCBbY2xpZW50U3RhdGUsIHNldENsaWVudFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGVudHJ5Q29tcG9uZW50RGlkQ2F0Y2hFbXVsYXRvcik7XG4gIGxldCBbdHJhbnNpdGlvbk1hbmFnZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcih7XG4gICAgICByb3V0ZXM6IGNsaWVudFJvdXRlcyxcbiAgICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGE6IGRvY3VtZW50TG9hZGVyRGF0YSxcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBjYXRjaDogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yLmNhdGNoLFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkOiBlbnRyeUNvbXBvbmVudERpZENhdGNoRW11bGF0b3IuY2F0Y2hCb3VuZGFyeVJvdXRlSWQsXG4gICAgICBvblJlZGlyZWN0OiBfbmF2aWdhdG9yLnJlcGxhY2UsXG4gICAgICBvbkNoYW5nZTogc3RhdGUgPT4ge1xuICAgICAgICBzZXRDbGllbnRTdGF0ZSh7XG4gICAgICAgICAgY2F0Y2g6IHN0YXRlLmNhdGNoLFxuICAgICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgICAgICBjYXRjaEJvdW5kYXJ5Um91dGVJZDogc3RhdGUuY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgICAgIGxvYWRlckJvdW5kYXJ5Um91dGVJZDogc3RhdGUuZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICAgICAgICB0cmFja0JvdW5kYXJpZXM6IGZhbHNlLFxuICAgICAgICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIEVuc3VyZXMgcHVzaGVzIGludGVycnVwdGluZyBwZW5kaW5nIG5hdmlnYXRpb25zIHVzZSByZXBsYWNlXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBSZWFjdCBSb3V0ZXJcblxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHB1c2ggPSAodG8sIHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKS50cmFuc2l0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IF9uYXZpZ2F0b3IucmVwbGFjZSh0bywgc3RhdGUpIDogX25hdmlnYXRvci5wdXNoKHRvLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7IC4uLl9uYXZpZ2F0b3IsXG4gICAgICBwdXNoXG4gICAgfTtcbiAgfSwgW19uYXZpZ2F0b3IsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG4gIGxldCB7XG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGFcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7IC8vIFNlbmQgbmV3IGxvY2F0aW9uIHRvIHRoZSB0cmFuc2l0aW9uIG1hbmFnZXJcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBsb2NhdGlvblxuICAgIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChoaXN0b3J5TG9jYXRpb24gPT09IGxvY2F0aW9uKSByZXR1cm47XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiBcIm5hdmlnYXRpb25cIixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBzdWJtaXNzaW9uOiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCksXG4gICAgICBhY3Rpb25cbiAgICB9KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBoaXN0b3J5TG9jYXRpb24sIGFjdGlvbl0pOyAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoZSBhcHAgdGhyZXcgYmVmb3JlIHJlbmRlcmluZyBhbnlcbiAgLy8gcm91dGVzLCBnZXQgdGhlIGVycm9yIGFuZCBwYXNzIGl0IHRvIHRoZSBFcnJvckJvdW5kYXJ5IHRvIGVtdWxhdGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYFxuXG4gIGxldCBzc3JFcnJvckJlZm9yZVJvdXRlc1JlbmRlcmVkID0gY2xpZW50U3RhdGUuZXJyb3IgJiYgY2xpZW50U3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBudWxsICYmIGNsaWVudFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9PT0gbnVsbCA/IGRlc2VyaWFsaXplRXJyb3IoY2xpZW50U3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkO1xuICBsZXQgc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZCA9IGNsaWVudFN0YXRlLmNhdGNoICYmIGNsaWVudFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBudWxsID8gY2xpZW50U3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBhcHBTdGF0ZTogY2xpZW50U3RhdGUsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgY2xpZW50Um91dGVzLFxuICAgICAgcm91dGVEYXRhOiBsb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSxcbiAgICBlcnJvcjogc3NyRXJyb3JCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peENhdGNoQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSxcbiAgICBjYXRjaDogc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVzLCBudWxsKSkpKSk7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3IoZGF0YSkge1xuICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBkYXRhLnN0YWNrO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIFJvdXRlcygpIHtcbiAgLy8gVE9ETzogQWRkIGByZW5kZXJNYXRjaGVzYCBmdW5jdGlvbiB0byBSUiB0aGF0IHdlIGNhbiB1c2UgYW5kIHRoZW4gd2UgZG9uJ3RcbiAgLy8gbmVlZCB0aGlzIGNvbXBvbmVudCwgd2UgY2FuIGp1c3QgYHJlbmRlck1hdGNoZXNgIGZyb20gUmVtaXhFbnRyeVxuICBsZXQge1xuICAgIGNsaWVudFJvdXRlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTsgLy8gZmFsbGJhY2sgdG8gdGhlIHJvb3QgaWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoXG5cbiAgbGV0IGVsZW1lbnQgPSB1c2VSb3V0ZXMoY2xpZW50Um91dGVzKSB8fCBjbGllbnRSb3V0ZXNbMF0uZWxlbWVudDtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSZW1peFJvdXRlXG5cblxuY29uc3QgUmVtaXhSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VSZW1peFJvdXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlbWl4Um91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KGNvbnRleHQsIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbiBhIHJlbWl4IHJvdXRlIGVsZW1lbnRcIik7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Um91dGVDb21wb25lbnQoe1xuICBpZFxufSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHtpZH1cIiBoYXMgbm8gY29tcG9uZW50ISBQbGVhc2UgZ28gYWRkIGEgXFxgZGVmYXVsdFxcYCBleHBvcnQgaW4gdGhlIHJvdXRlIG1vZHVsZSBmaWxlLlxcbmAgKyBcIklmIHlvdSB3ZXJlIHRyeWluZyB0byBuYXZpZ2F0ZSBvciBzdWJtaXQgdG8gYSByZXNvdXJjZSByb3V0ZSwgdXNlIGA8YT5gIGluc3RlYWQgb2YgYDxMaW5rPmAgb3IgYDxGb3JtIHJlbG9hZERvY3VtZW50PmAuXCIpO1xufVxuXG5mdW5jdGlvbiBSZW1peFJvdXRlKHtcbiAgaWRcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHtcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGFwcFN0YXRlXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtpZF07XG4gIGxldCB7XG4gICAgZGVmYXVsdDogQ29tcG9uZW50LFxuICAgIENhdGNoQm91bmRhcnksXG4gICAgRXJyb3JCb3VuZGFyeVxuICB9ID0gcm91dGVNb2R1bGVzW2lkXTtcbiAgbGV0IGVsZW1lbnQgPSBDb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFJvdXRlQ29tcG9uZW50LCB7XG4gICAgaWQ6IGlkXG4gIH0pO1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBkYXRhLFxuICAgIGlkXG4gIH07XG5cbiAgaWYgKENhdGNoQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyQ2F1Z2h0ID0gYXBwU3RhdGUuY2F0Y2ggJiYgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPT09IGlkID8gYXBwU3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7IC8vIFRoaXMgbmVlZHMgdG8gcnVuIGFmdGVyIHdlIGNoZWNrIGZvciB0aGUgZXJyb3IgZnJvbSBhIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBpbmNvcnJlY3RseSByZW5kZXIgdGhpcyBib3VuZGFyeSBmb3IgYSBsb2FkZXIgZXJyb3JcbiAgICAvLyBkZWVwZXIgaW4gdGhlIHRyZWUuXG5cbiAgICBpZiAoYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyQ2F1Z2h0ID8ge1xuICAgICAgaWQsXG5cbiAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYSBjYXRjaCBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhDYXRjaEJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IENhdGNoQm91bmRhcnksXG4gICAgICBjYXRjaDogbWF5YmVTZXJ2ZXJDYXVnaHRcbiAgICB9LCBlbGVtZW50KTtcbiAgfSAvLyBPbmx5IHdyYXAgaW4gZXJyb3IgYm91bmRhcnkgaWYgdGhlIHJvdXRlIGRlZmluZWQgb25lLCBvdGhlcndpc2UgbGV0IHRoZVxuICAvLyBlcnJvciBidWJibGUgdG8gdGhlIHBhcmVudCBib3VuZGFyeS4gV2UgY291bGQgZGVmYXVsdCB0byB1c2luZyBlcnJvclxuICAvLyBib3VuZGFyaWVzIGFyb3VuZCBldmVyeSByb3V0ZSwgYnV0IG5vdyBpZiB0aGUgYXBwIGRvZXNuJ3Qgd2FudCB1c2Vyc1xuICAvLyBzZWVpbmcgdGhlIGRlZmF1bHQgUmVtaXggRXJyb3JCb3VuZGFyeSBjb21wb25lbnQsIHRoZXkgKm11c3QqIGRlZmluZSBhblxuICAvLyBlcnJvciBib3VuZGFyeSBmb3IgKmV2ZXJ5KiByb3V0ZSBhbmQgdGhhdCB3b3VsZCBiZSBhbm5veWluZy4gTWlnaHQgYXNcbiAgLy8gd2VsbCBtYWtlIGl0IHJlcXVpcmVkIGF0IHRoYXQgcG9pbnQuXG4gIC8vXG4gIC8vIEJ5IGNvbmRpdGlvbmFsbHkgd3JhcHBpbmcgbGlrZSB0aGlzLCB3ZSBhbGxvdyBhcHBzIHRvIGRlZmluZSBhIHRvcCBsZXZlbFxuICAvLyBFcnJvckJvdW5kYXJ5IGNvbXBvbmVudCBhbmQgYmUgZG9uZSB3aXRoIGl0LiBUaGVuLCBpZiB0aGV5IHdhbnQgdG8sIHRoZXlcbiAgLy8gY2FuIGFkZCBtb3JlIHNwZWNpZmljIGJvdW5kYXJpZXMgYnkgZXhwb3J0aW5nIEVycm9yQm91bmRhcnkgY29tcG9uZW50c1xuICAvLyBmb3Igd2hpY2hldmVyIHJvdXRlcyB0aGV5IHBsZWFzZS5cbiAgLy9cbiAgLy8gTk9URTogdGhpcyBraW5kIG9mIGxvZ2ljIHdpbGwgbW92ZSBpbnRvIFJlYWN0IFJvdXRlclxuXG5cbiAgaWYgKEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPSBhcHBTdGF0ZS5lcnJvciAmJiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkKSA/IGRlc2VyaWFsaXplRXJyb3IoYXBwU3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkOyAvLyBUaGlzIG5lZWRzIHRvIHJ1biBhZnRlciB3ZSBjaGVjayBmb3IgdGhlIGVycm9yIGZyb20gYSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgaW5jb3JyZWN0bHkgcmVuZGVyIHRoaXMgYm91bmRhcnkgZm9yIGEgbG9hZGVyIGVycm9yXG4gICAgLy8gZGVlcGVyIGluIHRoZSB0cmVlLlxuXG4gICAgaWYgKGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcykge1xuICAgICAgYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPyB7XG4gICAgICBpZCxcblxuICAgICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvciBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhFcnJvckJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IEVycm9yQm91bmRhcnksXG4gICAgICBlcnJvcjogbWF5YmVTZXJ2ZXJSZW5kZXJFcnJvclxuICAgIH0sIGVsZW1lbnQpO1xuICB9IC8vIEl0J3MgaW1wb3J0YW50IGZvciB0aGUgcm91dGUgY29udGV4dCB0byBiZSBhYm92ZSB0aGUgZXJyb3IgYm91bmRhcnkgc28gdGhhdFxuICAvLyBhIGNhbGwgdG8gYHVzZUxvYWRlckRhdGFgIGRvZXNuJ3QgYWNjaWRlbnRhbGx5IGdldCB0aGUgcGFyZW50cyByb3V0ZSdzIGRhdGEuXG5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCBlbGVtZW50KTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFB1YmxpYyBBUElcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwcmVmZXRjaGluZyBiZWhhdmlvciBvZiB0aGUgbGluazpcbiAqXG4gKiAtIFwiaW50ZW50XCI6IEZldGNoZWQgd2hlbiB0aGUgdXNlciBmb2N1c2VzIG9yIGhvdmVycyB0aGUgbGlua1xuICogLSBcInJlbmRlclwiOiBGZXRjaGVkIHdoZW4gdGhlIGxpbmsgaXMgcmVuZGVyZWRcbiAqIC0gXCJub25lXCI6IE5ldmVyIGZldGNoZWRcbiAqL1xuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGxldCB7XG4gICAgb25Gb2N1cyxcbiAgICBvbkJsdXIsXG4gICAgb25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnRcbiAgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICB9LCBbcHJlZmV0Y2hdKTtcblxuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJpbnRlbnRcIikge1xuICAgICAgc2V0TWF5YmVQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGNhbmNlbEludGVudCA9ICgpID0+IHtcbiAgICBpZiAocHJlZmV0Y2ggPT09IFwiaW50ZW50XCIpIHtcbiAgICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCB7XG4gICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQmx1ciwgY2FuY2VsSW50ZW50KSxcbiAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICBvblRvdWNoU3RhcnQ6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uVG91Y2hTdGFydCwgc2V0SW50ZW50KVxuICB9XTtcbn1cbi8qKlxuICogQSBzcGVjaWFsIGtpbmQgb2YgYDxMaW5rPmAgdGhhdCBrbm93cyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBcImFjdGl2ZVwiLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I25hdmxpbmtcbiAqL1xuXG5cbmxldCBOYXZMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgdG8sXG4gIHByZWZldGNoID0gXCJub25lXCIsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgbGV0IFtzaG91bGRQcmVmZXRjaCwgcHJlZmV0Y2hIYW5kbGVyc10gPSB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCBwcm9wcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2TGluayQxLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdG86IHRvXG4gIH0sIHByb3BzLCBwcmVmZXRjaEhhbmRsZXJzKSksIHNob3VsZFByZWZldGNoID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIHtcbiAgICBwYWdlOiBocmVmXG4gIH0pIDogbnVsbCk7XG59KTtcbi8qKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBhbiBhbmNob3IgdGFnIGFuZCBpcyB0aGUgcHJpbWFyeSB3YXkgdGhlIHVzZXIgd2lsbFxuICogbmF2aWdhdGUgYXJvdW5kIHlvdXIgd2Vic2l0ZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNsaW5rXG4gKi9cblxubGV0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0byxcbiAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rJDEsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB0bzogdG9cbiAgfSwgcHJvcHMsIHByZWZldGNoSGFuZGxlcnMpKSwgc2hvdWxkUHJlZmV0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywge1xuICAgIHBhZ2U6IGhyZWZcbiAgfSkgOiBudWxsKTtcbn0pO1xuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgdGhlaXJIYW5kbGVyICYmIHRoZWlySGFuZGxlcihldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgYDxsaW5rPmAgdGFncyBmb3IgdGhlIGN1cnJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbmZ1bmN0aW9uIExpbmtzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIG1hbmlmZXN0XG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbGlua3MgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSwgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsaW5rcy5tYXAobGluayA9PiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihsaW5rKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBsaW5rLnBhZ2VcbiAgfSwgbGluaykpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGxpbmsucmVsICsgbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGFsbCBvZiB0aGUgYDxsaW5rIHJlbD1cInByZWZldGNoXCI+YCBhbmRcbiAqIGA8bGluayByZWw9XCJtb2R1bGVwcmVsb2FkXCIvPmAgdGFncyBmb3IgYWxsIHRoZSBhc3NldHMgKGRhdGEsIG1vZHVsZXMsIGNzcykgb2ZcbiAqIGEgZ2l2ZW4gcGFnZS5cbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBwcm9wcy5wYWdlXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNwcmVmZXRjaHBhZ2VsaW5rcy1cbiAqL1xuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHtcbiAgICBjbGllbnRSb3V0ZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaENsaWVudFJvdXRlcyhjbGllbnRSb3V0ZXMsIHBhZ2UpLCBbY2xpZW50Um91dGVzLCBwYWdlXSk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgY29uc29sZS53YXJuKGBUcmllZCB0byBwcmVmZXRjaCAke3BhZ2V9IGJ1dCBubyByb3V0ZXMgbWF0Y2hlZC5gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rc0ltcGwsIF9leHRlbmRzKHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIG1hdGNoZXM6IG1hdGNoZXNcbiAgfSwgZGF0YUxpbmtQcm9wcykpO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaGVkU3R5bGVzaGVldHMobWF0Y2hlcykge1xuICBsZXQge1xuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IFtzdHlsZUxpbmtzLCBzZXRTdHlsZUxpbmtzXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMpLnRoZW4obGlua3MgPT4ge1xuICAgICAgaWYgKCFpbnRlcnJ1cHRlZCkgc2V0U3R5bGVMaW5rcyhsaW5rcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgcm91dGVNb2R1bGVzXSk7XG4gIHJldHVybiBzdHlsZUxpbmtzO1xufVxuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwoe1xuICBwYWdlLFxuICBtYXRjaGVzOiBuZXh0TWF0Y2hlcyxcbiAgLi4ubGlua1Byb3BzXG59KSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICBtYW5pZmVzdFxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JEYXRhID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uLCBcImRhdGFcIiksIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb25dKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JBc3NldHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb24sIFwiYXNzZXRzXCIpLCBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uXSk7XG4gIGxldCBkYXRhSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldERhdGFMaW5rSHJlZnMocGFnZSwgbmV3TWF0Y2hlc0ZvckRhdGEsIG1hbmlmZXN0KSwgW25ld01hdGNoZXNGb3JEYXRhLCBwYWdlLCBtYW5pZmVzdF0pO1xuICBsZXQgbW9kdWxlSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE1vZHVsZUxpbmtIcmVmcyhuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdCksIFtuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdF0pOyAvLyBuZWVkcyB0byBiZSBhIGhvb2sgd2l0aCBhc3luYyBiZWhhdmlvciBiZWNhdXNlIHdlIG5lZWQgdGhlIG1vZHVsZXMsIG5vdFxuICAvLyBqdXN0IHRoZSBtYW5pZmVzdCBsaWtlIHRoZSBvdGhlciBsaW5rcyBpbiBoZXJlLlxuXG4gIGxldCBzdHlsZUxpbmtzID0gdXNlUHJlZmV0Y2hlZFN0eWxlc2hlZXRzKG5ld01hdGNoZXNGb3JBc3NldHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGRhdGFIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICBhczogXCJmZXRjaFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBtb2R1bGVIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBzdHlsZUxpbmtzLm1hcChsaW5rID0+XG4gIC8qI19fUFVSRV9fKi9cbiAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gIC8vIGFscmVhZHkgd2l0aCB0aGVpciBvd24gcHJvcHNcbiAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgPHRpdGxlPmAgYW5kIGA8bWV0YT5gIHRhZ3MgZm9yIHRoZSBjdXJyZW50IHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNtZXRhLWxpbmtzLXNjcmlwdHNcbiAqL1xuXG5cbmZ1bmN0aW9uIE1ldGEoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWV0YSA9IHt9O1xuICBsZXQgcGFyZW50c0RhdGEgPSB7fTtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gbWF0Y2gucGFyYW1zO1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZUlkXTtcblxuICAgIGlmIChyb3V0ZU1vZHVsZS5tZXRhKSB7XG4gICAgICBsZXQgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYXJlbnRzRGF0YSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvblxuICAgICAgfSkgOiByb3V0ZU1vZHVsZS5tZXRhO1xuICAgICAgT2JqZWN0LmFzc2lnbihtZXRhLCByb3V0ZU1ldGEpO1xuICAgIH1cblxuICAgIHBhcmVudHNEYXRhW3JvdXRlSWRdID0gZGF0YTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgT2JqZWN0LmVudHJpZXMobWV0YSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgLy8gT3BlbiBHcmFwaCB0YWdzIHVzZSB0aGUgYHByb3BlcnR5YCBhdHRyaWJ1dGUsIHdoaWxlIG90aGVyIG1ldGEgdGFnc1xuICAgIC8vIHVzZSBgbmFtZWAuIFNlZSBodHRwczovL29ncC5tZS9cbiAgICBsZXQgaXNPcGVuR3JhcGhUYWcgPSBuYW1lLnN0YXJ0c1dpdGgoXCJvZzpcIik7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwidGl0bGVcIiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwge1xuICAgICAga2V5OiBcInRpdGxlXCJcbiAgICB9LCB2YWx1ZSkgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChjb250ZW50ID0+IGlzT3BlbkdyYXBoVGFnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogbmFtZSArIGNvbnRlbnQsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUgKyBjb250ZW50LFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSkgOiBpc09wZW5HcmFwaFRhZyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBuYW1lLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSk7XG4gIH0pKTtcbn1cbi8qKlxuICogVHJhY2tzIHdoZXRoZXIgUmVtaXggaGFzIGZpbmlzaGVkIGh5ZHJhdGluZyBvciBub3QsIHNvIHNjcmlwdHMgY2FuIGJlIHNraXBwZWRcbiAqIGR1cmluZyBjbGllbnQtc2lkZSB1cGRhdGVzLlxuICovXG5cbmxldCBpc0h5ZHJhdGVkID0gZmFsc2U7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgYDxzY3JpcHQ+YCB0YWdzIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLiBCdW5kbGVzIGZvclxuICogYWRkaXRpb25hbCByb3V0ZXMgYXJlIGxvYWRlZCBsYXRlciBhcyBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHByb3BzIEFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBhZGQgdG8gZWFjaCBzY3JpcHQgdGFnIHRoYXQgaXMgcmVuZGVyZWQuXG4gKiBJbiBhZGRpdGlvbiB0byBzY3JpcHRzLCBcXDxsaW5rIHJlbD1cIm1vZHVsZXByZWxvYWRcIj4gdGFncyByZWNlaXZlIHRoZSBjcm9zc09yaWdpblxuICogcHJvcGVydHkgaWYgcHJvdmlkZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHtcbiAgICBtYW5pZmVzdCxcbiAgICBtYXRjaGVzLFxuICAgIHBlbmRpbmdMb2NhdGlvbixcbiAgICBjbGllbnRSb3V0ZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZ1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBsZXQgaW5pdGlhbFNjcmlwdHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHNlcnZlckhhbmRvZmZTdHJpbmcgPyBgd2luZG93Ll9fcmVtaXhDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTtgIDogXCJcIjtcbiAgICBsZXQgcm91dGVNb2R1bGVzU2NyaXB0ID0gYCR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYGltcG9ydCAqIGFzIHJvdXRlJHtpbmRleH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlKX07YCkuam9pbihcIlxcblwiKX1cbndpbmRvdy5fX3JlbWl4Um91dGVNb2R1bGVzID0geyR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYCR7SlNPTi5zdHJpbmdpZnkobWF0Y2gucm91dGUuaWQpfTpyb3V0ZSR7aW5kZXh9YCkuam9pbihcIixcIil9fTtgO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChjb250ZXh0U2NyaXB0KVxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LnVybFxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChyb3V0ZU1vZHVsZXNTY3JpcHQpLFxuICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSxcbiAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICB9KSkpOyAvLyBkaXNhYmxlZCBkZXBzIGFycmF5IGJlY2F1c2Ugd2UgYXJlIHB1cnBvc2VmdWxseSBvbmx5IHJlbmRlcmluZyB0aGlzIG9uY2VcbiAgICAvLyBmb3IgaHlkcmF0aW9uLCBhZnRlciB0aGF0IHdlIHdhbnQgdG8ganVzdCBjb250aW51ZSByZW5kZXJpbmcgdGhlIGluaXRpYWxcbiAgICAvLyBzY3JpcHRzIGFzIHRoZXkgd2VyZSB3aGVuIHRoZSBwYWdlIGZpcnN0IGxvYWRlZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICB9LCBbXSk7IC8vIGF2b2lkIHdhdGVyZmFsbCB3aGVuIGltcG9ydGluZyB0aGUgbmV4dCByb3V0ZSBtb2R1bGVcblxuICBsZXQgbmV4dE1hdGNoZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uKSB7XG4gICAgICAvLyBGSVhNRTogY2FuIHByb2JhYmx5IHVzZSB0cmFuc2l0aW9uTWFuYWdlciBgbmV4dE1hdGNoZXNgXG4gICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKGNsaWVudFJvdXRlcywgcGVuZGluZ0xvY2F0aW9uKTtcbiAgICAgIGludmFyaWFudChtYXRjaGVzLCBgTm8gcm91dGVzIG1hdGNoIHBhdGggXCIke3BlbmRpbmdMb2NhdGlvbi5wYXRobmFtZX1cImApO1xuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LCBbcGVuZGluZ0xvY2F0aW9uLCBjbGllbnRSb3V0ZXNdKTtcbiAgbGV0IHJvdXRlUHJlbG9hZHMgPSBtYXRjaGVzLmNvbmNhdChuZXh0TWF0Y2hlcykubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiAocm91dGUuaW1wb3J0cyB8fCBbXSkuY29uY2F0KFtyb3V0ZS5tb2R1bGVdKTtcbiAgfSkuZmxhdCgxKTtcbiAgbGV0IHByZWxvYWRzID0gbWFuaWZlc3QuZW50cnkuaW1wb3J0cy5jb25jYXQocm91dGVQcmVsb2Fkcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZGVkdXBlKHByZWxvYWRzKS5tYXAocGF0aCA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgIGtleTogcGF0aCxcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IHBhdGgsXG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gIH0pKSwgaXNIeWRyYXRlZCA/IG51bGwgOiBpbml0aWFsU2NyaXB0cyk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cblxuLyoqXG4gKiBBIFJlbWl4LWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHQgdGhhdCB0aGVcbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNmb3JtXG4gKi9cbmxldCBGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSk7XG59KTtcbmxldCBGb3JtSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHJlbG9hZERvY3VtZW50ID0gZmFsc2UsXG4gIHJlcGxhY2UgPSBmYWxzZSxcbiAgbWV0aG9kID0gXCJnZXRcIixcbiAgYWN0aW9uID0gXCIuXCIsXG4gIGVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBmZXRjaEtleSxcbiAgb25TdWJtaXQsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoZmV0Y2hLZXkpO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCBmb3JtTWV0aG9kKTtcbiAgbGV0IGZvcm1SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgbGV0IHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGZvcm1SZWYpOyAvLyBXaGVuIGNhbGxpbmcgYHN1Ym1pdGAgb24gdGhlIGZvcm0gZWxlbWVudCBpdHNlbGYsIHdlIGRvbid0IGdldCBkYXRhIGZyb21cbiAgLy8gdGhlIGJ1dHRvbiB0aGF0IHN1Ym1pdHRlZCB0aGUgZXZlbnQuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAgIDxGb3JtPlxuICAvLyAgICAgPGJ1dHRvbiBuYW1lPVwic29tZXRoaW5nXCIgdmFsdWU9XCJ3aGF0ZXZlclwiPlN1Ym1pdDwvYnV0dG9uPlxuICAvLyAgIDwvRm9ybT5cbiAgLy9cbiAgLy8gZm9ybURhdGEuZ2V0KFwic29tZXRoaW5nXCIpIHNob3VsZCBiZSBcIndoYXRldmVyXCIsIGJ1dCB3ZSBkb24ndCBnZXQgdGhhdFxuICAvLyB1bmxlc3Mgd2UgY2FsbCBzdWJtaXQgb24gdGhlIGNsaWNrZWQgYnV0dG9uIGl0c2VsZi5cbiAgLy9cbiAgLy8gVG8gZmlndXJlIG91dCB3aGljaCBidXR0b24gdHJpZ2dlcmVkIHRoZSBzdWJtaXQsIHdlJ2xsIGF0dGFjaCBhIGNsaWNrXG4gIC8vIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBmb3JtLiBUaGUgY2xpY2sgZXZlbnQgaXMgYWx3YXlzIHRyaWdnZXJlZCBiZWZvcmVcbiAgLy8gdGhlIHN1Ym1pdCBldmVudCAoZXZlbiB3aGVuIHN1Ym1pdHRpbmcgdmlhIGtleWJvYXJkIHdoZW4gZm9jdXNlZCBvblxuICAvLyBhbm90aGVyIGZvcm0gZmllbGQsIHllZWVlZXQpIHNvIHdlIHNob3VsZCBoYXZlIGFjY2VzcyB0byB0aGF0IGJ1dHRvbidzXG4gIC8vIGRhdGEgZm9yIHVzZSBpbiB0aGUgc3VibWl0IGhhbmRsZXIuXG5cbiAgbGV0IGNsaWNrZWRCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZm9ybSA9IGZvcm1SZWYuY3VycmVudDtcbiAgICBpZiAoIWZvcm0pIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgbGV0IHN1Ym1pdEJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFwiYnV0dG9uLGlucHV0W3R5cGU9c3VibWl0XVwiKTtcblxuICAgICAgaWYgKHN1Ym1pdEJ1dHRvbiAmJiBzdWJtaXRCdXR0b24uZm9ybSA9PT0gZm9ybSAmJiBzdWJtaXRCdXR0b24udHlwZSA9PT0gXCJzdWJtaXRcIikge1xuICAgICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBzdWJtaXRCdXR0b247XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICBlbmNUeXBlOiBlbmNUeXBlLFxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IHVuZGVmaW5lZCA6IGV2ZW50ID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3VibWl0KGNsaWNrZWRCdXR0b25SZWYuY3VycmVudCB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVwbGFjZVxuICAgICAgfSk7XG4gICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgcHJvcHMpKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0FjdGlvblJlcXVlc3RNZXRob2QobWV0aG9kKSB7XG4gIG1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbWV0aG9kID09PSBcInBvc3RcIiB8fCBtZXRob2QgPT09IFwicHV0XCIgfHwgbWV0aG9kID09PSBcInBhdGNoXCIgfHwgbWV0aG9kID09PSBcImRlbGV0ZVwiO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBhIGA8Zm9ybSBhY3Rpb24+YCBwYXRoIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHJvdXRlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWZvcm1hY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uID0gXCIuXCIsIG1ldGhvZCA9IFwiZ2V0XCIpIHtcbiAgbGV0IHtcbiAgICBpZFxuICB9ID0gdXNlUmVtaXhSb3V0ZUNvbnRleHQoKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgoYWN0aW9uKTtcbiAgbGV0IHNlYXJjaCA9IHBhdGguc2VhcmNoO1xuICBsZXQgaXNJbmRleFJvdXRlID0gaWQuZW5kc1dpdGgoXCIvaW5kZXhcIik7XG5cbiAgaWYgKGFjdGlvbiA9PT0gXCIuXCIgJiYgaXNJbmRleFJvdXRlICYmIGlzQWN0aW9uUmVxdWVzdE1ldGhvZChtZXRob2QpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoID8gc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGgucGF0aG5hbWUgKyBzZWFyY2g7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VzdWJtaXRcbiAqL1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICByZXR1cm4gdXNlU3VibWl0SW1wbCgpO1xufVxuZnVuY3Rpb24gdXNlU3VibWl0SW1wbChrZXkpIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGRlZmF1bHRBY3Rpb24gPSB1c2VGb3JtQWN0aW9uKCk7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IGVuY1R5cGU7XG4gICAgbGV0IGZvcm1EYXRhO1xuXG4gICAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgbGV0IHN1Ym1pc3Npb25UcmlnZ2VyID0gb3B0aW9ucy5zdWJtaXNzaW9uVHJpZ2dlcjtcbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5tZXRob2Q7XG4gICAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCB0YXJnZXQuYWN0aW9uO1xuICAgICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCB0YXJnZXQuZW5jdHlwZTtcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG5cbiAgICAgIGlmIChzdWJtaXNzaW9uVHJpZ2dlciAmJiBzdWJtaXNzaW9uVHJpZ2dlci5uYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChzdWJtaXNzaW9uVHJpZ2dlci5uYW1lLCBzdWJtaXNzaW9uVHJpZ2dlci52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmICh0YXJnZXQudHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgICAgbGV0IGZvcm0gPSB0YXJnZXQuZm9ybTtcblxuICAgICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiB3aXRob3V0IGEgPGZvcm0+YCk7XG4gICAgICB9IC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG5cbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0ubWV0aG9kO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5hY3Rpb247XG4gICAgICBlbmNUeXBlID0gb3B0aW9ucy5lbmNUeXBlIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSB8fCBmb3JtLmVuY3R5cGU7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTsgLy8gSW5jbHVkZSBuYW1lICsgdmFsdWUgZnJvbSBhIDxidXR0b24+XG5cbiAgICAgIGlmICh0YXJnZXQubmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5zZXQodGFyZ2V0Lm5hbWUsIHRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgYCArIGA8aW5wdXQgdHlwZT1cInN1Ym1pdHxpbWFnZVwiPmApO1xuICAgICAgfVxuXG4gICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcImdldFwiO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgZGVmYXVsdEFjdGlvbjtcbiAgICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgIGZvcm1EYXRhID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSBjYWxsaW5nIHN1Ym1pdCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIuIFwiICsgXCJUcnkgY2FsbGluZyBzdWJtaXQgd2l0aGluIGEgYHVzZUVmZmVjdGAgb3IgY2FsbGJhY2sgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgbGV0IHVybCA9IG5ldyBVUkwoYWN0aW9uLCBgJHtwcm90b2NvbH0vLyR7aG9zdH1gKTtcblxuICAgIGlmIChtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIikge1xuICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBmb3JtRGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN1Ym1pdCBiaW5hcnkgZm9ybSBkYXRhIHVzaW5nIEdFVGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGFjdGlvbjogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBlbmNUeXBlLFxuICAgICAga2V5OiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOClcbiAgICB9O1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiZmV0Y2hlclwiLFxuICAgICAgICBocmVmOiBzdWJtaXNzaW9uLmFjdGlvbixcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0TmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pO1xuICAgICAgbmF2aWdhdGUodXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCwge1xuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2RlZmF1bHRBY3Rpb24sIGtleSwgbmF2aWdhdGUsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG59XG5sZXQgbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uO1xuXG5mdW5jdGlvbiBzZXROZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikge1xuICBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCkge1xuICBsZXQgc3VibWlzc2lvbiA9IG5leHROYXZpZ2F0aW9uU3VibWlzc2lvbjtcbiAgbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uID0gdW5kZWZpbmVkO1xuICByZXR1cm4gc3VibWlzc2lvbjtcbn1cblxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYGJlZm9yZXVubG9hZGAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcywgd2hpY2ggYXV0b21hdGljYWxseSBoYXBwZW5zIG9uIHRoZSBuZXh0IGA8TGluaz5gIGNsaWNrIHdoZW4gUmVtaXhcbiAqIGRldGVjdHMgYSBuZXcgdmVyc2lvbiBvZiB0aGUgYXBwIGlzIGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWJlZm9yZXVubG9hZFxuICovXG5cblxuZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNhbGxiYWNrKSB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrXSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm91dGUgbWF0Y2hlcyBvbiB0aGUgcGFnZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nXG4gKiBsYXlvdXQgYWJzdHJhY3Rpb25zIHdpdGggeW91ciBjdXJyZW50IHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VtYXRjaGVzXG4gKi9cblxuZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzLFxuICAgIHJvdXRlRGF0YSxcbiAgICByb3V0ZU1vZHVsZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICB2YXIgX3JvdXRlTW9kdWxlcyRtYXRjaCRyO1xuXG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IG1hdGNoO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogbWF0Y2gucm91dGUuaWQsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGRhdGE6IHJvdXRlRGF0YVttYXRjaC5yb3V0ZS5pZF0sXG4gICAgICAvLyBpZiB0aGUgbW9kdWxlIGZhaWxzIHRvIGxvYWQgb3IgYW4gZXJyb3IvcmVzcG9uc2UgaXMgdGhyb3duLCB0aGUgbW9kdWxlXG4gICAgICAvLyB3b24ndCBiZSBkZWZpbmVkLlxuICAgICAgaGFuZGxlOiAoX3JvdXRlTW9kdWxlcyRtYXRjaCRyID0gcm91dGVNb2R1bGVzW21hdGNoLnJvdXRlLmlkXSkgPT09IG51bGwgfHwgX3JvdXRlTW9kdWxlcyRtYXRjaCRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcm91dGVNb2R1bGVzJG1hdGNoJHIuaGFuZGxlXG4gICAgfTtcbiAgfSksIFttYXRjaGVzLCByb3V0ZURhdGEsIHJvdXRlTW9kdWxlc10pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIHBhcnNlZCBkYXRhIGZyb20gdGhlIGN1cnJlbnQgcm91dGUncyBgbG9hZGVyYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2Vsb2FkZXJkYXRhXG4gKi9cblxuZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgcmV0dXJuIHVzZVJlbWl4Um91dGVDb250ZXh0KCkuZGF0YTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgSlNPTiBwYXJzZWQgZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJvdXRlJ3MgYGFjdGlvbmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlYWN0aW9uZGF0YVxuICovXG5cbmZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKSB7XG4gIGxldCB7XG4gICAgaWQ6IHJvdXRlSWRcbiAgfSA9IHVzZVJlbWl4Um91dGVDb250ZXh0KCk7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCB7XG4gICAgYWN0aW9uRGF0YVxuICB9ID0gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgcmV0dXJuIGFjdGlvbkRhdGEgPyBhY3Rpb25EYXRhW3JvdXRlSWRdIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8ga25vdyBhYm91dCBhIHBhZ2UgdHJhbnNpdGlvbiB0byBidWlsZCBwZW5kaW5nXG4gKiBuYXZpZ2F0aW9uIGluZGljYXRvcnMgYW5kIG9wdGltaXN0aWMgVUkgb24gZGF0YSBtdXRhdGlvbnMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNldHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpLnRyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoS2V5KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIC8vIFRPRE86IG1ha2UgQU5PVEhFUiBmb3JtIHcvbyBhIGZldGNoS2V5IHByb3BcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcmVmOiByZWYsXG4gICAgICBmZXRjaEtleTogZmV0Y2hLZXlcbiAgICB9KSk7XG4gIH0pO1xufVxuXG5sZXQgZmV0Y2hlcklkID0gMDtcblxuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2VmZXRjaGVyXG4gKi9cbmZ1bmN0aW9uIHVzZUZldGNoZXIoKSB7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBba2V5XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFN0cmluZygrK2ZldGNoZXJJZCkpO1xuICBsZXQgW0Zvcm1dID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlRmV0Y2hlckZvcm0oa2V5KSk7XG4gIGxldCBbbG9hZF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBocmVmID0+IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiZmV0Y2hlclwiLFxuICAgICAgaHJlZixcbiAgICAgIGtleVxuICAgIH0pO1xuICB9KTtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoa2V5KTtcbiAgbGV0IGZldGNoZXIgPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRGZXRjaGVyKGtleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgRm9ybSxcbiAgICBzdWJtaXQsXG4gICAgbG9hZCxcbiAgICAuLi5mZXRjaGVyXG4gIH0pLCBbZmV0Y2hlciwgRm9ybSwgc3VibWl0LCBsb2FkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBidXN0ZWQgd2hlbiB0aGUgUmVhY3QgdGVhbSBnZXRzIHJlYWwgd2VpcmQgYW5kIGNhbGxzIGVmZmVjdHNcbiAgICAvLyB0d2ljZSBvbiBtb3VudD8gIFdlIHJlYWxseSBqdXN0IG5lZWQgdG8gZ2FyYmFnZSBjb2xsZWN0IGhlcmUgd2hlbiB0aGlzXG4gICAgLy8gZmV0Y2hlciBpcyBubyBsb25nZXIgYXJvdW5kLlxuICAgIHJldHVybiAoKSA9PiB0cmFuc2l0aW9uTWFuYWdlci5kZWxldGVGZXRjaGVyKGtleSk7XG4gIH0sIFt0cmFuc2l0aW9uTWFuYWdlciwga2V5XSk7XG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG4vKipcbiAqIFByb3ZpZGVzIGFsbCBmZXRjaGVycyBjdXJyZW50bHkgb24gdGhlIHBhZ2UuIFVzZWZ1bCBmb3IgbGF5b3V0cyBhbmQgcGFyZW50XG4gKiByb3V0ZXMgdGhhdCBuZWVkIHRvIHByb3ZpZGUgcGVuZGluZy9vcHRpbWlzdGljIFVJIHJlZ2FyZGluZyB0aGUgZmV0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlZmV0Y2hlcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBmZXRjaGVyc1xuICB9ID0gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgcmV0dXJuIFsuLi5mZXRjaGVycy52YWx1ZXMoKV07XG59IC8vIERlYWQgQ29kZSBFbGltaW5hdGlvbiBtYWdpYyBmb3IgcHJvZHVjdGlvbiBidWlsZHMuXG4vLyBUaGlzIHdheSBkZXZzIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgZG9pbmcgdGhlIE5PREVfRU5WIGNoZWNrIHRoZW1zZWx2ZXMuXG5cbmNvbnN0IExpdmVSZWxvYWQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiID8gKCkgPT4gbnVsbCA6IGZ1bmN0aW9uIExpdmVSZWxvYWQoe1xuICBwb3J0ID0gTnVtYmVyKHByb2Nlc3MuZW52LlJFTUlYX0RFVl9TRVJWRVJfV1NfUE9SVCB8fCA4MDAyKVxufSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbmxldCBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICd3c3M6JyA6ICd3czonO1xubGV0IGhvc3QgPSBsb2NhdGlvbi5ob3N0bmFtZTtcbmxldCBzb2NrZXRQYXRoID0gcHJvdG9jb2wgKyAnLy8nICsgaG9zdCArICc6JHtwb3J0fS9zb2NrZXQnO1xuXG5sZXQgd3MgPSBuZXcgV2ViU29ja2V0KHNvY2tldFBhdGgpO1xud3Mub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gIGxldCBldmVudCA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTtcbiAgaWYgKGV2ZW50LnR5cGUgPT09IFwiTE9HXCIpIHtcbiAgICBjb25zb2xlLmxvZyhldmVudC5tZXNzYWdlKTtcbiAgfVxuICBpZiAoZXZlbnQudHlwZSA9PT0gXCJSRUxPQURcIikge1xuICAgIGNvbnNvbGUubG9nKFwiXHVEODNEXHVEQ0JGIFJlbG9hZGluZyB3aW5kb3cgLi4uXCIpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufTtcbndzLm9uZXJyb3IgPSBlcnJvciA9PiB7XG4gIGNvbnNvbGUubG9nKFwiUmVtaXggZGV2IGFzc2V0IHNlcnZlciB3ZWIgc29ja2V0IGVycm9yOlwiKTtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59O1xuICAgICAgICAgICAgICBgLnRyaW0oKVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB1c2VDb21wb3NlZFJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgZm9yIChsZXQgcmVmIG9mIHJlZnMpIHtcbiAgICAgIGlmIChyZWYgPT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG5cbiAgfSwgcmVmcyk7XG59XG5cbmV4cG9ydCB7IEZvcm0sIEZvcm1JbXBsLCBMaW5rLCBMaW5rcywgTGl2ZVJlbG9hZCwgTWV0YSwgTmF2TGluaywgUHJlZmV0Y2hQYWdlTGlua3MsIFJlbWl4RW50cnksIFJlbWl4RW50cnlDb250ZXh0LCBSZW1peFJvdXRlLCBTY3JpcHRzLCBjb21wb3NlRXZlbnRIYW5kbGVycywgdXNlQWN0aW9uRGF0YSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VGZXRjaGVyLCB1c2VGZXRjaGVycywgdXNlRm9ybUFjdGlvbiwgdXNlTG9hZGVyRGF0YSwgdXNlTWF0Y2hlcywgdXNlU3VibWl0LCB1c2VTdWJtaXRJbXBsLCB1c2VUcmFuc2l0aW9uIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBleHRlbmRzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbmNsYXNzIFJlbWl4RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCxcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvblxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgLy8gcHJldmlvdXMgcGFnZSB0aGF0IGRpZG4ndCBoYXZlIGFuIGVycm9yLiBCZWNhdXNlIHRoaXMgd3JhcHMgdGhlIGVudGlyZVxuICAgIC8vIGFwcGxpY2F0aW9uIChldmVuIHRoZSBIVE1MISkgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZVxuICAgIC8vIGNvbnRpbnVlcyB0byBkaXNwbGF5LiBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3JcbiAgICAvLyB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAvLyBjb21lcyBpbiBhbmQgdGhlIHVzZXIgcmVjb3ZlcnMgZnJvbSB0aGUgZXJyb3IuXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvblxuICAgICAgfTtcbiAgICB9IC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XG4gICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY29tcG9uZW50LCB7XG4gICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmVycm9yXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9XG5cbn1cbi8qKlxuICogV2hlbiBhcHAncyBkb24ndCBwcm92aWRlIGEgcm9vdCBsZXZlbCBFcnJvckJvdW5kYXJ5LCB3ZSBkZWZhdWx0IHRvIHRoaXMuXG4gKi9cblxuZnVuY3Rpb24gUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnkoe1xuICBlcnJvclxufSkge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCB7XG4gICAgbGFuZzogXCJlblwiXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgIGNoYXJTZXQ6IFwidXRmLThcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLHZpZXdwb3J0LWZpdD1jb3ZlclwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIFwiQXBwbGljYXRpb24gRXJyb3IhXCIpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWFpblwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRGYW1pbHk6IFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIsXG4gICAgICBwYWRkaW5nOiBcIjJyZW1cIlxuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiBcIjI0cHhcIlxuICAgIH1cbiAgfSwgXCJBcHBsaWNhdGlvbiBFcnJvclwiKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nOiBcIjJyZW1cIixcbiAgICAgIGJhY2tncm91bmQ6IFwiaHNsYSgxMCwgNTAlLCA1MCUsIDAuMSlcIixcbiAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgb3ZlcmZsb3c6IFwiYXV0b1wiXG4gICAgfVxuICB9LCBlcnJvci5zdGFjaykpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlx1RDgzRFx1RENCRiBIZXkgZGV2ZWxvcGVyXHVEODNEXHVEQzRCLiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMuIENoZWNrIG91dCBodHRwczovL3JlbWl4LnJ1bi9ndWlkZXMvZXJyb3JzIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBgXG4gICAgfVxuICB9KSkpO1xufVxubGV0IFJlbWl4Q2F0Y2hDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRocm93biByZXNwb25zZSBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL2NvbnZlbnRpb25zI2NhdGNoYm91bmRhcnlcbiAqL1xuXG5mdW5jdGlvbiB1c2VDYXRjaCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUmVtaXhDYXRjaENvbnRleHQpO1xufVxuZnVuY3Rpb24gUmVtaXhDYXRjaEJvdW5kYXJ5KHtcbiAgY2F0Y2g6IGNhdGNoVmFsLFxuICBjb21wb25lbnQ6IENvbXBvbmVudCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgaWYgKGNhdGNoVmFsKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlbWl4Q2F0Y2hDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY2F0Y2hWYWxcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBXaGVuIGFwcCdzIGRvbid0IHByb3ZpZGUgYSByb290IGxldmVsIENhdGNoQm91bmRhcnksIHdlIGRlZmF1bHQgdG8gdGhpcy5cbiAqL1xuXG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSgpIHtcbiAgbGV0IGNhdWdodCA9IHVzZUNhdGNoKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwge1xuICAgIGxhbmc6IFwiZW5cIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBcIlVuaGFuZGxlZCBUaHJvd24gUmVzcG9uc2UhXCIpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLFxuICAgICAgcGFkZGluZzogXCIycmVtXCJcbiAgICB9XG4gIH0sIGNhdWdodC5zdGF0dXMsIFwiIFwiLCBjYXVnaHQuc3RhdHVzVGV4dCksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiXHVEODNEXHVEQ0JGIEhleSBkZXZlbG9wZXJcdUQ4M0RcdURDNEIuIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIDQwNHMgKGFuZCBvdGhlciByZXNwb25zZXMpLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vZ3VpZGVzL25vdC1mb3VuZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYFxuICAgIH1cbiAgfSkpKTtcbn1cblxuZXhwb3J0IHsgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peEVycm9yQm91bmRhcnksIFJlbWl4Um9vdERlZmF1bHRDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgdXNlQ2F0Y2ggfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBpbnZhcmlhbnQgYXMgZGVmYXVsdCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfSBmcm9tICcuL3JvdXRlTW9kdWxlcy5qcyc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdldHMgYWxsIHRoZSBsaW5rcyBmb3IgYSBzZXQgb2YgbWF0Y2hlcy4gVGhlIG1vZHVsZXMgYXJlIGFzc3VtZWQgdG8gaGF2ZSBiZWVuXG4gKiBsb2FkZWQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpIHtcbiAgbGV0IGRlc2NyaXB0b3JzID0gbWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIHZhciBfbW9kdWxlJGxpbmtzO1xuXG4gICAgbGV0IG1vZHVsZSA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgcmV0dXJuICgoX21vZHVsZSRsaW5rcyA9IG1vZHVsZS5saW5rcykgPT09IG51bGwgfHwgX21vZHVsZSRsaW5rcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21vZHVsZSRsaW5rcy5jYWxsKG1vZHVsZSkpIHx8IFtdO1xuICB9KS5mbGF0KDEpO1xuICBsZXQgcHJlbG9hZHMgPSBnZXRDdXJyZW50UGFnZU1vZHVsZVByZWxvYWRIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCk7XG4gIHJldHVybiBkZWR1cGUoZGVzY3JpcHRvcnMsIHByZWxvYWRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZU1vZHVsZSkge1xuICBpZiAoIXJvdXRlTW9kdWxlLmxpbmtzKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IHJvdXRlTW9kdWxlLmxpbmtzKCk7XG4gIGlmICghZGVzY3JpcHRvcnMpIHJldHVybjtcbiAgbGV0IHN0eWxlTGlua3MgPSBbXTtcblxuICBmb3IgKGxldCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKCFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIpIHtcbiAgICAgIHN0eWxlTGlua3MucHVzaCh7IC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBkb24ndCBibG9jayBmb3Igbm9uLW1hdGNoaW5nIG1lZGlhIHF1ZXJpZXNcblxuXG4gIGxldCBtYXRjaGluZ0xpbmtzID0gc3R5bGVMaW5rcy5maWx0ZXIobGluayA9PiAhbGluay5tZWRpYSB8fCB3aW5kb3cubWF0Y2hNZWRpYShsaW5rLm1lZGlhKS5tYXRjaGVzKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hpbmdMaW5rcy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmsoZGVzY3JpcHRvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBPYmplY3QuYXNzaWduKGxpbmssIGRlc2NyaXB0b3IpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGluaygpIHtcbiAgICAgIC8vIGlmIGEgbmF2aWdhdGlvbiBpbnRlcnJ1cHRzIHRoaXMgcHJlZmV0Y2ggUmVhY3Qgd2lsbCB1cGRhdGUgdGhlIDxoZWFkPlxuICAgICAgLy8gYW5kIHJlbW92ZSB0aGUgbGluayB3ZSBwdXQgaW4gdGhlcmUgbWFudWFsbHksIHNvIHdlIGNoZWNrIGlmIGl0J3Mgc3RpbGxcbiAgICAgIC8vIHRoZXJlIGJlZm9yZSB0cnlpbmcgdG8gcmVtb3ZlIGl0XG4gICAgICBpZiAoZG9jdW1lbnQuaGVhZC5jb250YWlucyhsaW5rKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpbmsub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICBsaW5rLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gIH0pO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbmZ1bmN0aW9uIGlzUGFnZUxpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5wYWdlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNIdG1sTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmhyZWYgPT09IFwic3RyaW5nXCI7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IGxpbmtzID0gYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlcy5tYXAoYXN5bmMgbWF0Y2ggPT4ge1xuICAgIGxldCBtb2QgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGUobWF0Y2gucm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgcmV0dXJuIG1vZC5saW5rcyA/IG1vZC5saW5rcygpIDogW107XG4gIH0pKTtcbiAgcmV0dXJuIGxpbmtzLmZsYXQoMSkuZmlsdGVyKGlzSHRtbExpbmtEZXNjcmlwdG9yKS5maWx0ZXIobGluayA9PiBsaW5rLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgbGluay5yZWwgPT09IFwicHJlbG9hZFwiKS5tYXAoKHtcbiAgICByZWwsXG4gICAgLi4uYXR0cnNcbiAgfSkgPT4gcmVsID09PSBcInByZWxvYWRcIiA/IHtcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICAuLi5hdHRyc1xuICB9IDoge1xuICAgIHJlbDogXCJwcmVmZXRjaFwiLFxuICAgIGFzOiBcInN0eWxlXCIsXG4gICAgLi4uYXR0cnNcbiAgfSk7XG59IC8vIFRoaXMgaXMgcmlkaWN1bG91c2x5IGlkZW50aWNhbCB0byB0cmFuc2l0aW9uLnRzIGBmaWx0ZXJNYXRjaGVzVG9Mb2FkYFxuXG5mdW5jdGlvbiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIGN1cnJlbnRNYXRjaGVzLCBsb2NhdGlvbiwgbW9kZSkge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aFBhdGNoKHBhZ2UpO1xuXG4gIGxldCBpc05ldyA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRNYXRjaGVzW2luZGV4XSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUuaWQ7XG4gIH07XG5cbiAgbGV0IG1hdGNoUGF0aENoYW5nZWQgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgdmFyIF9jdXJyZW50TWF0Y2hlcyRpbmRleDtcblxuICAgIHJldHVybiAoLy8gcGFyYW0gY2hhbmdlLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgKChfY3VycmVudE1hdGNoZXMkaW5kZXggPSBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUucGF0aCkgPT09IG51bGwgfHwgX2N1cnJlbnRNYXRjaGVzJGluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY3VycmVudE1hdGNoZXMkaW5kZXguZW5kc1dpdGgoXCIqXCIpKSAmJiBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICAgICk7XG4gIH07IC8vIE5PVEU6IGtlZXAgdGhpcyBtb3N0bHkgdXAtdG8tZGF0ZSB3LyB0aGUgdHJhbnNpdGlvbiBkYXRhIGRpZmYsIGJ1dCB0aGlzXG4gIC8vIHZlcnNpb24gZG9lc24ndCBjYXJlIGFib3V0IHN1Ym1pc3Npb25zXG5cblxuICBsZXQgbmV3TWF0Y2hlcyA9IG1vZGUgPT09IFwiZGF0YVwiICYmIGxvY2F0aW9uLnNlYXJjaCAhPT0gcGF0aC5zZWFyY2ggPyAvLyB0aGlzIGlzIHJlYWxseSBzaW1pbGFyIHRvIHN0dWZmIGluIHRyYW5zaXRpb24udHMsIG1heWJlIHNvbWVib2R5IHNtYXJ0ZXJcbiAgLy8gdGhhbiBtZSAob3IgaW4gbGVzcyBvZiBhIGh1cnJ5KSBjYW4gc2hhcmUgc29tZSBvZiBpdC4gWW91J3JlIHRoZSBiZXN0LlxuICBuZXh0TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghbWF0Y2gucm91dGUuaGFzTG9hZGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKSB7XG4gICAgICByZXR1cm4gbWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKHtcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIHByZXZVcmw6IG5ldyBVUkwobG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoLCB3aW5kb3cub3JpZ2luKSxcbiAgICAgICAgdXJsOiBuZXcgVVJMKHBhZ2UsIHdpbmRvdy5vcmlnaW4pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgOiBuZXh0TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBtYXRjaC5yb3V0ZS5oYXNMb2FkZXIgJiYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKTtcbiAgfSk7XG4gIHJldHVybiBuZXdNYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2V0RGF0YUxpbmtIcmVmcyhwYWdlLCBtYXRjaGVzLCBtYW5pZmVzdCkge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aFBhdGNoKHBhZ2UpO1xuICByZXR1cm4gZGVkdXBlSHJlZnMobWF0Y2hlcy5maWx0ZXIobWF0Y2ggPT4gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXS5oYXNMb2FkZXIpLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoXG4gICAgfSA9IHBhdGg7XG4gICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiX2RhdGFcIiwgbWF0Y2gucm91dGUuaWQpO1xuICAgIHJldHVybiBgJHtwYXRobmFtZX0/JHtzZWFyY2hQYXJhbXN9YDtcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0UGF0Y2gpIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFBhdGNoLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG5cbiAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaW1wb3J0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWZzO1xuICB9KS5mbGF0KDEpKTtcbn0gLy8gVGhlIGA8U2NyaXB0PmAgd2lsbCByZW5kZXIgcmVsPW1vZHVsZXByZWxvYWQgZm9yIHRoZSBjdXJyZW50IHBhZ2UsIHdlIGRvbid0XG4vLyBuZWVkIHRvIGluY2x1ZGUgdGhlbSBpbiBhIHBhZ2UgcHJlZmV0Y2gsIHRoaXMgZ2l2ZXMgdXMgdGhlIGxpc3QgdG8gcmVtb3ZlXG4vLyB3aGlsZSBkZWR1cGluZy5cblxuZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2VNb2R1bGVQcmVsb2FkSHJlZnMobWF0Y2hlcywgbWFuaWZlc3QpIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCBocmVmcyA9IFtyb3V0ZS5tb2R1bGVdO1xuXG4gICAgaWYgKHJvdXRlLmltcG9ydHMpIHtcbiAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmcztcbiAgfSkuZmxhdCgxKSk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhyZWZzKGhyZWZzKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChocmVmcyldO1xufVxuXG5mdW5jdGlvbiBkZWR1cGUoZGVzY3JpcHRvcnMsIHByZWxvYWRzKSB7XG4gIGxldCBzZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwcmVsb2Fkc1NldCA9IG5ldyBTZXQocHJlbG9hZHMpO1xuICByZXR1cm4gZGVzY3JpcHRvcnMucmVkdWNlKChkZWR1cGVkLCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgbGV0IGFscmVhZHlNb2R1bGVQcmVsb2FkID0gIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IuYXMgPT09IFwic2NyaXB0XCIgJiYgZGVzY3JpcHRvci5ocmVmICYmIHByZWxvYWRzU2V0LmhhcyhkZXNjcmlwdG9yLmhyZWYpO1xuXG4gICAgaWYgKGFscmVhZHlNb2R1bGVQcmVsb2FkKSB7XG4gICAgICByZXR1cm4gZGVkdXBlZDtcbiAgICB9XG5cbiAgICBsZXQgc3RyID0gSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcik7XG5cbiAgICBpZiAoIXNldC5oYXMoc3RyKSkge1xuICAgICAgc2V0LmFkZChzdHIpO1xuICAgICAgZGVkdXBlZC5wdXNoKGRlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWR1cGVkO1xuICB9LCBbXSk7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS9pc3N1ZXMvODk3XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aFBhdGNoKGhyZWYpIHtcbiAgbGV0IHBhdGggPSBwYXJzZVBhdGgoaHJlZik7XG4gIGlmIChwYXRoLnNlYXJjaCA9PT0gdW5kZWZpbmVkKSBwYXRoLnNlYXJjaCA9IFwiXCI7XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgeyBkZWR1cGUsIGdldERhdGFMaW5rSHJlZnMsIGdldExpbmtzRm9yTWF0Y2hlcywgZ2V0TW9kdWxlTGlua0hyZWZzLCBnZXROZXdNYXRjaGVzRm9yTGlua3MsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzLCBpc0h0bWxMaW5rRGVzY3JpcHRvciwgaXNQYWdlTGlua0Rlc2NyaXB0b3IsIHByZWZldGNoU3R5bGVMaW5rcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbi8vIGFuZCBsZXZlcmFnZSBgcmVhY3Qtcm91dGVyYCBoZXJlIGluc3RlYWRcbi8vIFRPRE86IGltcG9ydC9leHBvcnQgZnJvbSByZWFjdC1yb3V0ZXItZG9tXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCB3aGVuIHRoZSBzZXJ2ZXIgdGhyb3dzIGEgUmVzcG9uc2UuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjY2F0Y2hib3VuZGFyeVxuICovXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIG9uIGEgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjZXJyb3Jib3VuZGFyeVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYDxsaW5rPmAgdGFncyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBgPGhlYWQ+YCBvZlxuICogdGhlIGRvY3VtZW50IG9uIHJvdXRlIHRyYW5zaXRpb25zLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9mIG5hbWUgKyBjb250ZW50IHBhaXJzIHRvIHVzZSBmb3JcbiAqIGA8bWV0YT5gIHRhZ3MgZm9yIGEgcm91dGUuIFRoZXNlIHRhZ3Mgd2lsbCBiZSBtZXJnZWQgd2l0aCAoYW5kIHRha2VcbiAqIHByZWNlZGVuY2Ugb3ZlcikgdGFncyBmcm9tIHBhcmVudCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cblxuLyoqXG4gKiBBIG5hbWUvY29udGVudCBwYWlyIHVzZWQgdG8gcmVuZGVyIGA8bWV0YT5gIHRhZ3MgaW4gYSBtZXRhIGZ1bmN0aW9uIGZvciBhXG4gKiByb3V0ZS4gVGhlIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcsIHdoaWNoIHdpbGwgcmVuZGVyIGEgc2luZ2xlIGA8bWV0YT5gXG4gKiB0YWcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHJlbmRlciBtdWx0aXBsZSB0YWdzIHdpdGggdGhlIHNhbWVcbiAqIGBuYW1lYCBhdHRyaWJ1dGUuXG4gKi9cblxuLyoqXG4gKiBEdXJpbmcgY2xpZW50IHNpZGUgdHJhbnNpdGlvbnMgUmVtaXggd2lsbCBvcHRpbWl6ZSByZWxvYWRpbmcgb2Ygcm91dGVzIHRoYXRcbiAqIGFyZSBjdXJyZW50bHkgb24gdGhlIHBhZ2UgYnkgYXZvaWRpbmcgbG9hZGluZyByb3V0ZXMgdGhhdCBhcmVuJ3QgY2hhbmdpbmcuXG4gKiBIb3dldmVyLCBpbiBzb21lIGNhc2VzLCBsaWtlIGZvcm0gc3VibWlzc2lvbnMgb3Igc2VhcmNoIHBhcmFtcyBSZW1peCBkb2Vzbid0XG4gKiBrbm93IHdoaWNoIHJvdXRlcyBuZWVkIHRvIGJlIHJlbG9hZGVkIHNvIGl0IHJlbG9hZHMgdGhlbSBhbGwgdG8gYmUgc2FmZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGxldHMgYXBwcyBmdXJ0aGVyIG9wdGltaXplIGJ5IHJldHVybmluZyBgZmFsc2VgIHdoZW4gUmVtaXggaXNcbiAqIGFib3V0IHRvIHJlbG9hZCB0aGUgcm91dGUuIEEgY29tbW9uIGNhc2UgaXMgYSByb290IGxvYWRlciB3aXRoIG5vdGhpbmcgYnV0XG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZXM6IGFmdGVyIGZvcm0gc3VibWlzc2lvbnMgdGhlIHJvb3QgcHJvYmFibHkgZG9lc24ndCBuZWVkXG4gKiB0byBiZSByZWxvYWRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9jb252ZW50aW9ucyN1bnN0YWJsZV9zaG91bGRyZWxvYWRcbiAqL1xuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgcmVuZGVyZWQgZm9yIGEgcm91dGUuXG4gKi9cblxuLyoqXG4gKiBBbiBhcmJpdHJhcnkgb2JqZWN0IHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjaGFuZGxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgaWYgKHJvdXRlLmlkIGluIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgaW1wb3J0KHJvdXRlLm1vZHVsZSk7XG4gICAgcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdID0gcm91dGVNb2R1bGU7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFVzZXIgZ290IGNhdWdodCBpbiB0aGUgbWlkZGxlIG9mIGEgZGVwbG95IGFuZCB0aGUgQ0ROIG5vIGxvbmdlciBoYXMgdGhlXG4gICAgLy8gYXNzZXQgd2UncmUgdHJ5aW5nIHRvIGltcG9ydCEgUmVsb2FkIGZyb20gdGhlIHNlcnZlciBhbmQgdGhlIHVzZXJcbiAgICAvLyAoc2hvdWxkKSBnZXQgdGhlIG5ldyBtYW5pZmVzdC0tdW5sZXNzIHRoZSBkZXZlbG9wZXIgcHVyZ2VkIHRoZSBzdGF0aWNcbiAgICAvLyBhc3NldHMsIHRoZSBtYW5pZmVzdCBwYXRoLCBidXQgbm90IHRoZSBkb2N1bWVudHMgXHVEODNEXHVERTJDXG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7Ly8gY2hlY2sgb3V0IG9mIHRoaXMgaG9vayBjYXVzZSB0aGUgREpzIG5ldmVyIGdvbm5hIHJlW3Ndb2x2ZSB0aGlzXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgbG9hZFJvdXRlTW9kdWxlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBjcmVhdGVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIHtcbiAgICBfX2h0bWw6IGh0bWxcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlSHRtbCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbG9hZFJvdXRlTW9kdWxlIH0gZnJvbSAnLi9yb3V0ZU1vZHVsZXMuanMnO1xuaW1wb3J0IHsgZmV0Y2hEYXRhLCBpc0NhdGNoUmVzcG9uc2UsIGV4dHJhY3REYXRhLCBpc1JlZGlyZWN0UmVzcG9uc2UgfSBmcm9tICcuL2RhdGEuanMnO1xuaW1wb3J0IHsgQ2F0Y2hWYWx1ZSwgVHJhbnNpdGlvblJlZGlyZWN0IH0gZnJvbSAnLi90cmFuc2l0aW9uLmpzJztcbmltcG9ydCB7IHByZWZldGNoU3R5bGVMaW5rcyB9IGZyb20gJy4vbGlua3MuanMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuL2ludmFyaWFudC5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlKGVudHJ5Um91dGUsIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXNlU2Vuc2l0aXZlOiAhIWVudHJ5Um91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICBlbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIGlkOiBlbnRyeVJvdXRlLmlkXG4gICAgfSksXG4gICAgaWQ6IGVudHJ5Um91dGUuaWQsXG4gICAgcGF0aDogZW50cnlSb3V0ZS5wYXRoLFxuICAgIGluZGV4OiBlbnRyeVJvdXRlLmluZGV4LFxuICAgIG1vZHVsZTogZW50cnlSb3V0ZS5tb2R1bGUsXG4gICAgbG9hZGVyOiBjcmVhdGVMb2FkZXIoZW50cnlSb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpLFxuICAgIGFjdGlvbjogY3JlYXRlQWN0aW9uKGVudHJ5Um91dGUpLFxuICAgIHNob3VsZFJlbG9hZDogY3JlYXRlU2hvdWxkUmVsb2FkKGVudHJ5Um91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSxcbiAgICBFcnJvckJvdW5kYXJ5OiBlbnRyeVJvdXRlLmhhc0Vycm9yQm91bmRhcnksXG4gICAgQ2F0Y2hCb3VuZGFyeTogZW50cnlSb3V0ZS5oYXNDYXRjaEJvdW5kYXJ5LFxuICAgIGhhc0xvYWRlcjogZW50cnlSb3V0ZS5oYXNMb2FkZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlcyhyb3V0ZU1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50LCBwYXJlbnRJZCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocm91dGVNYW5pZmVzdCkuZmlsdGVyKGtleSA9PiByb3V0ZU1hbmlmZXN0W2tleV0ucGFyZW50SWQgPT09IHBhcmVudElkKS5tYXAoa2V5ID0+IHtcbiAgICBsZXQgcm91dGUgPSBjcmVhdGVDbGllbnRSb3V0ZShyb3V0ZU1hbmlmZXN0W2tleV0sIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQpO1xuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNsaWVudFJvdXRlcyhyb3V0ZU1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50LCByb3V0ZS5pZCk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIHJvdXRlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hvdWxkUmVsb2FkKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IHNob3VsZFJlbG9hZCA9IGFyZyA9PiB7XG4gICAgbGV0IG1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZS5pZF07XG4gICAgaW52YXJpYW50KG1vZHVsZSwgYEV4cGVjdGVkIHJvdXRlIG1vZHVsZSB0byBiZSBsb2FkZWQgZm9yICR7cm91dGUuaWR9YCk7XG5cbiAgICBpZiAobW9kdWxlLnVuc3RhYmxlX3Nob3VsZFJlbG9hZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZS51bnN0YWJsZV9zaG91bGRSZWxvYWQoYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gc2hvdWxkUmVsb2FkO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgYXdhaXQgcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlTW9kdWxlKTtcbiAgcmV0dXJuIHJvdXRlTW9kdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2FkZXIocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgbG9hZGVyID0gYXN5bmMgKHtcbiAgICB1cmwsXG4gICAgc2lnbmFsLFxuICAgIHN1Ym1pc3Npb25cbiAgfSkgPT4ge1xuICAgIGlmIChyb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgIGxldCBbcmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaERhdGEodXJsLCByb3V0ZS5pZCwgc2lnbmFsLCBzdWJtaXNzaW9uKSwgbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcyldKTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmVzdWx0O1xuICAgICAgbGV0IHJlZGlyZWN0ID0gYXdhaXQgY2hlY2tSZWRpcmVjdChyZXN1bHQpO1xuICAgICAgaWYgKHJlZGlyZWN0KSByZXR1cm4gcmVkaXJlY3Q7XG5cbiAgICAgIGlmIChpc0NhdGNoUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2F0Y2hWYWx1ZShyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgYXdhaXQgZXh0cmFjdERhdGEocmVzdWx0LmNsb25lKCkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4dHJhY3REYXRhKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbG9hZGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24ocm91dGUpIHtcbiAgaWYgKCFyb3V0ZS5oYXNBY3Rpb24pIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgbGV0IGFjdGlvbiA9IGFzeW5jICh7XG4gICAgdXJsLFxuICAgIHNpZ25hbCxcbiAgICBzdWJtaXNzaW9uXG4gIH0pID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgcm91dGUuaWQsIHNpZ25hbCwgc3VibWlzc2lvbik7XG5cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBhd2FpdCBjaGVja1JlZGlyZWN0KHJlc3VsdCk7XG4gICAgaWYgKHJlZGlyZWN0KSByZXR1cm4gcmVkaXJlY3Q7XG5cbiAgICBpZiAoaXNDYXRjaFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBDYXRjaFZhbHVlKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBhd2FpdCBleHRyYWN0RGF0YShyZXN1bHQuY2xvbmUoKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBleHRyYWN0RGF0YShyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiBhY3Rpb247XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrUmVkaXJlY3QocmVzcG9uc2UpIHtcbiAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXNwb25zZS5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVkaXJlY3RcIiksIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuXG4gICAgaWYgKHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodXJsLmhyZWYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvblJlZGlyZWN0KHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBjcmVhdGVDbGllbnRSb3V0ZSwgY3JlYXRlQ2xpZW50Um91dGVzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJy4vaW52YXJpYW50LmpzJztcblxuZnVuY3Rpb24gaXNDYXRjaFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1DYXRjaFwiKSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1FcnJvclwiKSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSAhPSBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgcm91dGVJZCwgc2lnbmFsLCBzdWJtaXNzaW9uKSB7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX2RhdGFcIiwgcm91dGVJZCk7XG4gIGxldCBpbml0ID0gc3VibWlzc2lvbiA/IGdldEFjdGlvbkluaXQoc3VibWlzc2lvbiwgc2lnbmFsKSA6IHtcbiAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgIHNpZ25hbFxuICB9O1xuICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwuaHJlZiwgaW5pdCk7XG5cbiAgaWYgKGlzRXJyb3JSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICBlcnJvci5zdGFjayA9IGRhdGEuc3RhY2s7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcG9uc2UpIHtcbiAgLy8gVGhpcyBzYW1lIGFsZ29yaXRobSBpcyB1c2VkIG9uIHRoZSBzZXJ2ZXIgdG8gaW50ZXJwcmV0IGxvYWRcbiAgLy8gcmVzdWx0cyB3aGVuIHdlIHJlbmRlciB0aGUgSFRNTCBwYWdlLlxuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcblxuICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uSW5pdChzdWJtaXNzaW9uLCBzaWduYWwpIHtcbiAgbGV0IHtcbiAgICBlbmNUeXBlLFxuICAgIG1ldGhvZCxcbiAgICBmb3JtRGF0YVxuICB9ID0gc3VibWlzc2lvbjtcbiAgbGV0IGhlYWRlcnMgPSB1bmRlZmluZWQ7XG4gIGxldCBib2R5ID0gZm9ybURhdGE7XG5cbiAgaWYgKGVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpIHtcbiAgICBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhKSB7XG4gICAgICBpbnZhcmlhbnQodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLCBgRmlsZSBpbnB1dHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBlbmNUeXBlIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIHBsZWFzZSB1c2UgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgaW5zdGVhZC5gKTtcbiAgICAgIGJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBlbmNUeXBlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgaGVhZGVyc1xuICB9O1xufVxuXG5leHBvcnQgeyBleHRyYWN0RGF0YSwgZmV0Y2hEYXRhLCBpc0NhdGNoUmVzcG9uc2UsIGlzRXJyb3JSZXNwb25zZSwgaXNSZWRpcmVjdFJlc3BvbnNlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCB7IG1hdGNoQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZU1hdGNoaW5nLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuY2xhc3MgQ2F0Y2hWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikge1xuICByZXR1cm4gW1wiUE9TVFwiLCBcIlBVVFwiLCBcIlBBVENIXCIsIFwiREVMRVRFXCJdLmluY2x1ZGVzKHN1Ym1pc3Npb24ubWV0aG9kKTtcbn1cblxuZnVuY3Rpb24gaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pIHtcbiAgcmV0dXJuIHN1Ym1pc3Npb24ubWV0aG9kID09PSBcIkdFVFwiO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIEJvb2xlYW4obG9jYXRpb24uc3RhdGUpICYmIGxvY2F0aW9uLnN0YXRlLmlzUmVkaXJlY3Q7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImxvYWRlclwiO1xufVxuXG5mdW5jdGlvbiBpc0FjdGlvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJhY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pICYmIGxvY2F0aW9uLnN0YXRlLnR5cGUgPT09IFwiZmV0Y2hBY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImxvYWRlclN1Ym1pc3Npb25cIjtcbn1cblxuY2xhc3MgVHJhbnNpdGlvblJlZGlyZWN0IHtcbiAgY29uc3RydWN0b3IobG9jYXRpb24pIHtcbiAgICB0aGlzLmxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gbG9jYXRpb24gOiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbiAgfVxuXG59XG5jb25zdCBJRExFX1RSQU5TSVRJT04gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICB0eXBlOiBcImlkbGVcIlxufTtcbmNvbnN0IElETEVfRkVUQ0hFUiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICB0eXBlOiBcImluaXRcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbn07XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihpbml0KSB7XG4gIGxldCB7XG4gICAgcm91dGVzXG4gIH0gPSBpbml0O1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG4gIGxldCBuYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IG5ldyBNYXAoKTtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGluaXQubG9jYXRpb24pO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBDYXRjaEJvdW5kYXJ5IHRvIHRha2Ugb3ZlclxuICAgIG1hdGNoZXMgPSBbe1xuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgcm91dGU6IHJvdXRlc1swXVxuICAgIH1dO1xuICB9XG5cbiAgbGV0IHN0YXRlID0ge1xuICAgIGxvY2F0aW9uOiBpbml0LmxvY2F0aW9uLFxuICAgIGxvYWRlckRhdGE6IGluaXQubG9hZGVyRGF0YSB8fCB7fSxcbiAgICBhY3Rpb25EYXRhOiBpbml0LmFjdGlvbkRhdGEsXG4gICAgY2F0Y2g6IGluaXQuY2F0Y2gsXG4gICAgZXJyb3I6IGluaXQuZXJyb3IsXG4gICAgY2F0Y2hCb3VuZGFyeUlkOiBpbml0LmNhdGNoQm91bmRhcnlJZCB8fCBudWxsLFxuICAgIGVycm9yQm91bmRhcnlJZDogaW5pdC5lcnJvckJvdW5kYXJ5SWQgfHwgbnVsbCxcbiAgICBtYXRjaGVzLFxuICAgIG5leHRNYXRjaGVzOiB1bmRlZmluZWQsXG4gICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgIGZldGNoZXJzOiBuZXcgTWFwKClcbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGUodXBkYXRlcykge1xuICAgIHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHVwZGF0ZXMpO1xuICAgIGluaXQub25DaGFuZ2Uoc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXkpIHtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZW5kKGV2ZW50KSB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwibmF2aWdhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgc3VibWlzc2lvblxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKHJvdXRlcywgbG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICBtYXRjaGVzID0gW3tcbiAgICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgIHJvdXRlOiByb3V0ZXNbMF1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTm90Rm91bmROYXZpZ2F0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdWJtaXNzaW9uICYmIGlzSGFzaENoYW5nZU9ubHkobG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVIYXNoQ2hhbmdlKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIGJhY2svZm9yd2FyZCBidXR0b24sIHRyZWF0IGFsbCBhcyBub3JtYWwgbmF2aWdhdGlvblxuICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gQWN0aW9uLlBvcCkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyA8Rm9ybSBtZXRob2Q9XCJwb3N0IHwgcHV0IHwgZGVsZXRlIHwgcGF0Y2hcIj5cbiAgICAgICAgICBlbHNlIGlmIChzdWJtaXNzaW9uICYmIGlzQWN0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQWN0aW9uU3VibWlzc2lvbk5hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwiZ2V0XCIvPlxuICAgICAgICAgIGVsc2UgaWYgKHN1Ym1pc3Npb24gJiYgaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBhY3Rpb249PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNBY3Rpb25SZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwiZ2V0XCI+IC0tPiBsb2FkZXI9PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBsb2FkZXI9PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb2FkZXJSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gdXNlU3VibWlzc2lvbigpPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzRmV0Y2hBY3Rpb25SZWRpcmVjdChsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPExpbms+LCBuYXZpZ2F0ZSgpXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImZldGNoZXJcIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICAgICAgaHJlZlxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKHJvdXRlcywgaHJlZik7XG4gICAgICAgICAgaW52YXJpYW50KG1hdGNoZXMsIFwiTm8gbWF0Y2hlcyBmb3VuZFwiKTtcbiAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG5cbiAgICAgICAgICBpZiAoc3VibWlzc2lvbiAmJiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUFjdGlvbkZldGNoU3VibWlzc2lvbihrZXksIHN1Ym1pc3Npb24sIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN1Ym1pc3Npb24gJiYgaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJGZXRjaFN1Ym1pc3Npb24oaHJlZiwga2V5LCBzdWJtaXNzaW9uLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlckZldGNoKGhyZWYsIGtleSwgbWF0Y2gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgZXZlbnQgdHlwZTogJHtldmVudC50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcblxuICAgIGZvciAobGV0IFssIGNvbnRyb2xsZXJdIG9mIGZldGNoQ29udHJvbGxlcnMpIHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb25GZXRjaFN1Ym1pc3Npb24oa2V5LCBzdWJtaXNzaW9uLCBtYXRjaCkge1xuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25TdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZGF0YTogKGN1cnJlbnRGZXRjaGVyID09PSBudWxsIHx8IGN1cnJlbnRGZXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmV0Y2hlci5kYXRhKSB8fCB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGNvbnRyb2xsZXIpO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIG1hdGNoLCBjb250cm9sbGVyLnNpZ25hbCk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImZldGNoQWN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxvYWRGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWxvYWRcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IG1heWJlQWN0aW9uRXJyb3JSZXN1bHQgPSBpc0Vycm9yUmVzdWx0KHJlc3VsdCkgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQgPSBpc0NhdGNoUmVzdWx0KHJlc3VsdCkgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSBzdGF0ZS5uZXh0TWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzO1xuICAgIGxldCBocmVmVG9Mb2FkID0gY3JlYXRlSHJlZihzdGF0ZS50cmFuc2l0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uKTtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxMb2FkZXJzKHN0YXRlLCBjcmVhdGVVcmwoaHJlZlRvTG9hZCksIG1hdGNoZXNUb0xvYWQsIGNvbnRyb2xsZXIuc2lnbmFsLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0LCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBtYXRjaC5yb3V0ZS5pZCwgbG9hZEZldGNoZXIpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcblxuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBbZXJyb3IsIGVycm9yQm91bmRhcnlJZF0gPSBmaW5kRXJyb3JBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIHN0YXRlLm1hdGNoZXMsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQpO1xuICAgIGxldCBbY2F0Y2hWYWwsIGNhdGNoQm91bmRhcnlJZF0gPSBhd2FpdCBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIHN0YXRlLm1hdGNoZXMsIG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQpO1xuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgbGV0IGFib3J0ZWRLZXlzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcblxuICAgIGlmIChhYm9ydGVkS2V5cykge1xuICAgICAgbWFya0ZldGNoZXJzRG9uZShhYm9ydGVkS2V5cyk7XG4gICAgfVxuXG4gICAgbGV0IHllZXRlZE5hdmlnYXRpb24gPSB5ZWV0U3RhbGVOYXZpZ2F0aW9uTG9hZChsb2FkSWQpOyAvLyBuZWVkIHRvIGRvIHdoYXQgd2Ugd291bGQgaGF2ZSBkb25lIHdoZW4gdGhlIG5hdmlnYXRpb24gbG9hZCBjb21wbGV0ZWRcblxuICAgIGlmICh5ZWV0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICBsZXQge1xuICAgICAgICB0cmFuc2l0aW9uXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBpbnZhcmlhbnQodHJhbnNpdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIsIFwiRXhwZWN0ZWQgbG9hZGluZyB0cmFuc2l0aW9uXCIpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgbG9jYXRpb246IHRyYW5zaXRpb24ubG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IHN0YXRlLm5leHRNYXRjaGVzLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICBjYXRjaDogY2F0Y2hWYWwsXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZCxcbiAgICAgICAgbG9hZGVyRGF0YTogbWFrZUxvYWRlckRhdGEoc3RhdGUsIHJlc3VsdHMsIG1hdGNoZXNUb0xvYWQpLFxuICAgICAgICBhY3Rpb25EYXRhOiB0cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIgPyBzdGF0ZS5hY3Rpb25EYXRhIDogdW5kZWZpbmVkLFxuICAgICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgdGhlIGluZm8gZm9yIHRoZSBkYXRhXG4gICAgZWxzZSB7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5SWQsXG4gICAgICAgIGxvYWRlckRhdGE6IG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzVG9Mb2FkKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24geWVldFN0YWxlTmF2aWdhdGlvbkxvYWQobGFuZGVkSWQpIHtcbiAgICBsZXQgaXNMb2FkaW5nTmF2aWdhdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiO1xuXG4gICAgaWYgKGlzTG9hZGluZ05hdmlnYXRpb24gJiYgbmF2aWdhdGlvbkxvYWRJZCA8IGxhbmRlZElkKSB7XG4gICAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgICAgZGF0YTogZmV0Y2hlci5kYXRhLFxuICAgICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQpIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuXG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID8geWVldGVkS2V5cyA6IGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyRmV0Y2hTdWJtaXNzaW9uKGhyZWYsIGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpIHtcbiAgICBsZXQgY3VycmVudEZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIHR5cGU6IFwibG9hZGVyU3VibWlzc2lvblwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGRhdGE6IChjdXJyZW50RmV0Y2hlciA9PT0gbnVsbCB8fCBjdXJyZW50RmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZldGNoZXIuZGF0YSkgfHwgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBjb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlcihtYXRjaCwgY3JlYXRlVXJsKGhyZWYpLCBjb250cm9sbGVyLnNpZ25hbCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcblxuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyRmV0Y2goaHJlZiwga2V5LCBtYXRjaCkge1xuICAgIGlmICh0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVMb2FkZXJGZXRjaCB3YXMgY2FsbGVkIGR1cmluZyB0aGUgc2VydmVyIHJlbmRlciwgYnV0IGl0IHNob3VsZG4ndCBiZS4gXCIgKyBcIllvdSBhcmUgbGlrZWx5IGNhbGxpbmcgdXNlRmV0Y2hlci5sb2FkKCkgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICsgXCJUcnkgbW92aW5nIGl0IHRvIGEgdXNlRWZmZWN0IG9yIGEgY2FsbGJhY2suXCIpO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBkYXRhOiAoY3VycmVudEZldGNoZXIgPT09IG51bGwgfHwgY3VycmVudEZldGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGZXRjaGVyLmRhdGEpIHx8IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgY29udHJvbGxlcik7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXIobWF0Y2gsIGNyZWF0ZVVybChocmVmKSwgY29udHJvbGxlci5zaWduYWwpO1xuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSByZXR1cm47XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImxvYWRlclwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1heWJlQmFpbE9uRXJyb3IobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBtYXliZUJhaWxPbkNhdGNoKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZG9uZUZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSB7XG4gICAgaWYgKGlzQ2F0Y2hSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGNhdGNoQm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShtYXRjaCwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBjYXRjaDoge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZS5kYXRhLFxuICAgICAgICAgIHN0YXR1czogcmVzdWx0LnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXN1bHQudmFsdWUuc3RhdHVzVGV4dFxuICAgICAgICB9LFxuICAgICAgICBjYXRjaEJvdW5kYXJ5SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpIHtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3JCb3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaCwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgICAgZXJyb3I6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZU5vdEZvdW5kTmF2aWdhdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pOyAvLyBGb3JjZSBhc3luYyBzbyBVSSBjb2RlIGRvZXNuJ3QgaGF2ZSB0byBzcGVjaWFsIG5vdCBmb3VuZCByb3V0ZSBjaGFuZ2VzIG5vdFxuICAgIC8vIHNraXBwaW5nIHRoZSBwZW5kaW5nIHN0YXRlIChsaWtlIHNjcm9sbCByZXN0b3JhdGlvbiBnZXRzIHJlYWxseVxuICAgIC8vIGNvbXBsaWNhdGVkIHdpdGhvdXQgdGhlIHBlbmRpbmcgc3RhdGUsIG1heWJlIHdlIGNhbiBmaWd1cmUgc29tZXRoaW5nIGVsc2VcbiAgICAvLyBvdXQgbGF0ZXIsIGJ1dCB0aGlzIHdvcmtzIGdyZWF0LilcblxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGxldCBjYXRjaEJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobWF0Y2hlc1swXSwgbWF0Y2hlcyk7XG4gICAgdXBkYXRlKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGNhdGNoOiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICB9LFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb25TdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25TdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gICAgaWYgKCFpc0luZGV4UmVxdWVzdEFjdGlvbihzdWJtaXNzaW9uLmFjdGlvbikgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmlkLmVuZHNXaXRoKFwiL2luZGV4XCIpKSB7XG4gICAgICBtYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgbGV0IGxlYWZNYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIGxlYWZNYXRjaCwgY29udHJvbGxlci5zaWduYWwpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJhY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZXN1bHQudmFsdWUubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0NhdGNoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBbY2F0Y2hWYWwsIGNhdGNoQm91bmRhcnlJZF0gPSBhd2FpdCBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKFtyZXN1bHRdLCBtYXRjaGVzLCByZXN1bHQpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgICAgICBjYXRjaDogY2F0Y2hWYWwsXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxvYWRUcmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWxvYWRcIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb246IGxvYWRUcmFuc2l0aW9uLFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbbGVhZk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LnZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsZWFmTWF0Y2gucm91dGUuaWQsIHJlc3VsdCk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZShsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pOyAvLyBGb3JjZSBhc3luYyBzbyBVSSBjb2RlIGRvZXNuJ3QgaGF2ZSB0byBzcGVjaWFsIGNhc2UgaGFzaCBjaGFuZ2VzIG5vdFxuICAgIC8vIHNraXBwaW5nIHRoZSBwZW5kaW5nIHN0YXRlIChsaWtlIHNjcm9sbCByZXN0b3JhdGlvbiBnZXRzIHJlYWxseVxuICAgIC8vIGNvbXBsaWNhdGVkIHdpdGhvdXQgdGhlIHBlbmRpbmcgc3RhdGUsIG1heWJlIHdlIGNhbiBmaWd1cmUgc29tZXRoaW5nIGVsc2VcbiAgICAvLyBvdXQgbGF0ZXIsIGJ1dCB0aGlzIHdvcmtzIGdyZWF0LilcblxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWQobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsTG9hZFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGludmFyaWFudChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwibG9hZGVyU3VibWlzc2lvblwiLCBgVW5leHBlY3RlZCB0cmFuc2l0aW9uOiAke0pTT04uc3RyaW5naWZ5KHN0YXRlLnRyYW5zaXRpb24pfWApO1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uXG4gICAgfSA9IHN0YXRlLnRyYW5zaXRpb247XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImZldGNoQWN0aW9uUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgaW52YXJpYW50KHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25TdWJtaXNzaW9uXCIgfHwgLy8gbG9hZGVyIHJlZGlyZWN0ZWQgZHVyaW5nIGFjdGlvbiByZWxvYWRcbiAgICBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIsIGBVbmV4cGVjdGVkIHRyYW5zaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoc3RhdGUudHJhbnNpdGlvbil9YCk7XG4gICAgbGV0IHtcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9ID0gc3RhdGUudHJhbnNpdGlvbjtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhyZWYoc3RhdGUubG9jYXRpb24pID09PSBjcmVhdGVIcmVmKGxvY2F0aW9uKSAmJiBzdGF0ZS5sb2NhdGlvbi5oYXNoICE9PSBsb2NhdGlvbi5oYXNoO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgYWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IG1heWJlQWN0aW9uRXJyb3JSZXN1bHQgPSBhY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpID8gYWN0aW9uUmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIGxldCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0ID0gYWN0aW9uUmVzdWx0ICYmIGlzQ2F0Y2hSZXN1bHQoYWN0aW9uUmVzdWx0KSA/IGFjdGlvblJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIG5hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxMb2FkZXJzKHN0YXRlLCBjcmVhdGVVcmwoY3JlYXRlSHJlZihsb2NhdGlvbikpLCBtYXRjaGVzLCBjb250cm9sbGVyLnNpZ25hbCwgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCwgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG5cbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIC8vIGxvYWRlciByZWRpcmVjdGVkIGR1cmluZyBhbiBhY3Rpb24gcmVsb2FkLCB0cmVhdCBpdCBsaWtlIGFuXG4gICAgICAvLyBhY3Rpb25SZWRpcmVjdCBpbnN0ZWFkIHNvIHRoYXQgYWxsIHRoZSBsb2FkZXJzIGdldCBjYWxsZWQgYWdhaW4gYW5kIHRoZVxuICAgICAgLy8gc3VibWlzc2lvbiBzdGlja3MgYXJvdW5kIGZvciBvcHRpbWlzdGljL3BlbmRpbmcgVUkuXG4gICAgICBpZiAoc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiKSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJhY3Rpb25cIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwibG9hZGVyU3VibWlzc2lvblwiKSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCJcbiAgICAgICAgfTtcbiAgICAgICAgaW5pdC5vblJlZGlyZWN0KHJlZGlyZWN0LmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IFtlcnJvciwgZXJyb3JCb3VuZGFyeUlkXSA9IGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IFtjYXRjaFZhbCwgY2F0Y2hCb3VuZGFyeUlkXSA9IGF3YWl0IGZpbmRDYXRjaEFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IGFib3J0ZWRJZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhuYXZpZ2F0aW9uTG9hZElkKTtcblxuICAgIGlmIChhYm9ydGVkSWRzKSB7XG4gICAgICBtYXJrRmV0Y2hlcnNEb25lKGFib3J0ZWRJZHMpO1xuICAgIH1cblxuICAgIHVwZGF0ZSh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9yQm91bmRhcnlJZCxcbiAgICAgIGNhdGNoOiBjYXRjaFZhbCxcbiAgICAgIGNhdGNoQm91bmRhcnlJZCxcbiAgICAgIGxvYWRlckRhdGE6IG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzKSxcbiAgICAgIGFjdGlvbkRhdGE6IHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiA/IHN0YXRlLmFjdGlvbkRhdGEgOiB1bmRlZmluZWQsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICBmZXRjaGVyczogYWJvcnRlZElkcyA/IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIDogc3RhdGUuZmV0Y2hlcnNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpIHtcbiAgICB2YXIgX3BlbmRpbmdOYXZpZ2F0aW9uQ29uO1xuXG4gICAgKF9wZW5kaW5nTmF2aWdhdGlvbkNvbiA9IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikgPT09IG51bGwgfHwgX3BlbmRpbmdOYXZpZ2F0aW9uQ29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ05hdmlnYXRpb25Db24uYWJvcnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIGBFeHBlY3RlZCBmZXRjaCBjb250cm9sbGVyOiAke2tleX1gKTtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBnZXRTdGF0ZSxcbiAgICBnZXRGZXRjaGVyLFxuICAgIGRlbGV0ZUZldGNoZXIsXG4gICAgZGlzcG9zZSxcblxuICAgIGdldCBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzKCkge1xuICAgICAgcmV0dXJuIGZldGNoQ29udHJvbGxlcnM7XG4gICAgfVxuXG4gIH07XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzSW5kZXhSZXF1ZXN0QWN0aW9uKGFjdGlvbikge1xuICBsZXQgaW5kZXhSZXF1ZXN0ID0gZmFsc2U7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGFjdGlvbi5zcGxpdChcIj9cIiwgMilbMV0gfHwgXCJcIik7XG5cbiAgZm9yIChsZXQgcGFyYW0gb2Ygc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpKSB7XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgaW5kZXhSZXF1ZXN0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXhSZXF1ZXN0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVycyhzdGF0ZSwgdXJsLCBtYXRjaGVzLCBzaWduYWwsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpIHtcbiAgbGV0IG1hdGNoZXNUb0xvYWQgPSBmaWx0ZXJNYXRjaGVzVG9Mb2FkKHN0YXRlLCB1cmwsIG1hdGNoZXMsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwobWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlcihtYXRjaCwgdXJsLCBzaWduYWwpKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXIobWF0Y2gsIHVybCwgc2lnbmFsKSB7XG4gIGludmFyaWFudChtYXRjaC5yb3V0ZS5sb2FkZXIsIGBFeHBlY3RlZCBsb2FkZXIgZm9yICR7bWF0Y2gucm91dGUuaWR9YCk7XG5cbiAgdHJ5IHtcbiAgICBsZXQge1xuICAgICAgcGFyYW1zXG4gICAgfSA9IG1hdGNoO1xuICAgIGxldCB2YWx1ZSA9IGF3YWl0IG1hdGNoLnJvdXRlLmxvYWRlcih7XG4gICAgICBwYXJhbXMsXG4gICAgICB1cmwsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWU6IGVycm9yXG4gICAgfTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIG1hdGNoLCBzaWduYWwpIHtcbiAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBkb2VzIG5vdCBoYXZlIGFuIGFjdGlvbiwgYnV0IHlvdSBhcmUgdHJ5aW5nIGAgKyBgdG8gc3VibWl0IHRvIGl0LiBUbyBmaXggdGhpcywgcGxlYXNlIGFkZCBhbiBcXGBhY3Rpb25cXGAgZnVuY3Rpb24gdG8gdGhlIHJvdXRlYCk7XG4gIH1cblxuICB0cnkge1xuICAgIGxldCB2YWx1ZSA9IGF3YWl0IG1hdGNoLnJvdXRlLmFjdGlvbih7XG4gICAgICB1cmw6IGNyZWF0ZVVybChzdWJtaXNzaW9uLmFjdGlvbiksXG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWU6IGVycm9yXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJNYXRjaGVzVG9Mb2FkKHN0YXRlLCB1cmwsIG1hdGNoZXMsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpIHtcbiAgLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IHRoZSBwcm9ibGVtYXRpYyByb3V0ZSBhcyB0aGV5IGFyZW4ndCBnb2luZ1xuICAvLyB0byByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW0uXG4gIGlmIChzdWJtaXNzaW9uUm91dGVJZCAmJiAoYWN0aW9uQ2F0Y2hSZXN1bHQgfHwgYWN0aW9uRXJyb3JSZXN1bHQpKSB7XG4gICAgbGV0IGZvdW5kUHJvYmxlbWF0aWNSb3V0ZSA9IGZhbHNlO1xuICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiB7XG4gICAgICBpZiAoZm91bmRQcm9ibGVtYXRpY1JvdXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkID09PSBzdWJtaXNzaW9uUm91dGVJZCkge1xuICAgICAgICBmb3VuZFByb2JsZW1hdGljUm91dGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IGlzTmV3ID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICBpZiAoIXN0YXRlLm1hdGNoZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTsgLy8gW2EsIGJdIC0+IFthLCBjXVxuXG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBzdGF0ZS5tYXRjaGVzW2luZGV4XS5yb3V0ZS5pZDtcbiAgfTtcblxuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX3N0YXRlJG1hdGNoZXMkaW5kZXgkO1xuXG4gICAgcmV0dXJuICgvLyBwYXJhbSBjaGFuZ2UsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgICAgc3RhdGUubWF0Y2hlc1tpbmRleF0ucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8ICgoX3N0YXRlJG1hdGNoZXMkaW5kZXgkID0gc3RhdGUubWF0Y2hlc1tpbmRleF0ucm91dGUucGF0aCkgPT09IG51bGwgfHwgX3N0YXRlJG1hdGNoZXMkaW5kZXgkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkbWF0Y2hlcyRpbmRleCQuZW5kc1dpdGgoXCIqXCIpKSAmJiBzdGF0ZS5tYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTtcblxuICBsZXQgZmlsdGVyQnlSb3V0ZVByb3BzID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghbWF0Y2gucm91dGUubG9hZGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKSB7XG4gICAgICBsZXQgcHJldlVybCA9IGNyZWF0ZVVybChjcmVhdGVIcmVmKHN0YXRlLmxvY2F0aW9uKSk7XG4gICAgICByZXR1cm4gbWF0Y2gucm91dGUuc2hvdWxkUmVsb2FkKHtcbiAgICAgICAgcHJldlVybCxcbiAgICAgICAgdXJsLFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgbGV0IGlzSW5Sb290Q2F0Y2hCb3VuZGFyeSA9IHN0YXRlLm1hdGNoZXMubGVuZ3RoID09PSAxO1xuXG4gIGlmIChpc0luUm9vdENhdGNoQm91bmRhcnkpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIobWF0Y2ggPT4gISFtYXRjaC5yb3V0ZS5sb2FkZXIpO1xuICB9XG5cbiAgaWYgKChmZXRjaGVyID09PSBudWxsIHx8IGZldGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoZXIudHlwZSkgPT09IFwiYWN0aW9uUmVsb2FkXCIpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoZmlsdGVyQnlSb3V0ZVByb3BzKTtcbiAgfSBlbHNlIGlmICggLy8gbXV0YXRpb24sIHJlbG9hZCBmb3IgZnJlc2ggZGF0YVxuICBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIgfHwgc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlZGlyZWN0XCIgfHwgLy8gY2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gIGNyZWF0ZUhyZWYodXJsKSA9PT0gY3JlYXRlSHJlZihzdGF0ZS5sb2NhdGlvbikgfHwgLy8gc2VhcmNoIGFmZmVjdHMgYWxsIGxvYWRlcnNcbiAgdXJsLnNlYXJjaFBhcmFtcy50b1N0cmluZygpICE9PSBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoZmlsdGVyQnlSb3V0ZVByb3BzKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4LCBhcnIpID0+IHtcbiAgICAvLyBkb24ndCBsb2FkIGVycm9yZWQgYWN0aW9uIHJvdXRlXG4gICAgaWYgKChhY3Rpb25FcnJvclJlc3VsdCB8fCBhY3Rpb25DYXRjaFJlc3VsdCkgJiYgYXJyLmxlbmd0aCAtIDEgPT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmxvYWRlciAmJiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIFRyYW5zaXRpb25SZWRpcmVjdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICByZXR1cm4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZENhdGNoQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBhY3Rpb25DYXRjaFJlc3VsdCkge1xuICBsZXQgbG9hZGVyQ2F0Y2hSZXN1bHQ7XG5cbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNDYXRjaFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsb2FkZXJDYXRjaFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGxldCBleHRyYWN0Q2F0Y2hEYXRhID0gYXN5bmMgcmVzID0+ICh7XG4gICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNUZXh0LFxuICAgIGRhdGE6IHJlcy5kYXRhXG4gIH0pOyAvLyBXZWlyZCBjYXNlIHdoZXJlIGFjdGlvbiB0aHJldywgYW5kIHRoZW4gYSBwYXJlbnQgbG9hZGVyIEFMU08gdGhyZXcsIHdlXG4gIC8vIHVzZSB0aGUgYWN0aW9uIGNhdGNoIGJ1dCB0aGUgbG9hZGVyJ3MgbmVhcmVzdCBib3VuZGFyeSAoY2F1c2Ugd2UgY2FuJ3RcbiAgLy8gcmVuZGVyIGRvd24gdG8gdGhlIGJvdW5kYXJ5IHRoZSBhY3Rpb24gd291bGQgcHJlZmVyKVxuXG5cbiAgaWYgKGFjdGlvbkNhdGNoUmVzdWx0ICYmIGxvYWRlckNhdGNoUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobG9hZGVyQ2F0Y2hSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYXdhaXQgZXh0cmFjdENhdGNoRGF0YShhY3Rpb25DYXRjaFJlc3VsdC52YWx1ZSksIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGxvYWRlckNhdGNoUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobG9hZGVyQ2F0Y2hSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYXdhaXQgZXh0cmFjdENhdGNoRGF0YShsb2FkZXJDYXRjaFJlc3VsdC52YWx1ZSksIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5cbmZ1bmN0aW9uIGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgYWN0aW9uRXJyb3JSZXN1bHQpIHtcbiAgbGV0IGxvYWRlckVycm9yUmVzdWx0O1xuXG4gIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbG9hZGVyRXJyb3JSZXN1bHQgPSByZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gV2VpcmQgY2FzZSB3aGVyZSBhY3Rpb24gZXJyb3JlZCwgYW5kIHRoZW4gYSBwYXJlbnQgbG9hZGVyIEFMU08gZXJyb3JlZCwgd2VcbiAgLy8gdXNlIHRoZSBhY3Rpb24gZXJyb3IgYnV0IHRoZSBsb2FkZXIncyBuZWFyZXN0IGJvdW5kYXJ5IChjYXVzZSB3ZSBjYW4ndFxuICAvLyByZW5kZXIgZG93biB0byB0aGUgYm91bmRhcnkgdGhlIGFjdGlvbiB3b3VsZCBwcmVmZXIpXG5cblxuICBpZiAoYWN0aW9uRXJyb3JSZXN1bHQgJiYgbG9hZGVyRXJyb3JSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobG9hZGVyRXJyb3JSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYWN0aW9uRXJyb3JSZXN1bHQudmFsdWUsIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGFjdGlvbkVycm9yUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGFjdGlvbkVycm9yUmVzdWx0Lm1hdGNoLCBtYXRjaGVzKTtcbiAgICByZXR1cm4gW2FjdGlvbkVycm9yUmVzdWx0LnZhbHVlLCBib3VuZGFyeUlkXTtcbiAgfVxuXG4gIGlmIChsb2FkZXJFcnJvclJlc3VsdCkge1xuICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShsb2FkZXJFcnJvclJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFtsb2FkZXJFcnJvclJlc3VsdC52YWx1ZSwgYm91bmRhcnlJZF07XG4gIH1cblxuICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cblxuZnVuY3Rpb24gZmluZE5lYXJlc3RDYXRjaEJvdW5kYXJ5KG1hdGNoV2l0aEVycm9yLCBtYXRjaGVzKSB7XG4gIGxldCBuZWFyZXN0Qm91bmRhcnlJZCA9IG51bGw7XG5cbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5DYXRjaEJvdW5kYXJ5KSB7XG4gICAgICBuZWFyZXN0Qm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH0gLy8gb25seSBzZWFyY2ggcGFyZW50cyAoc3RvcCBhdCB0aHJvd2luZyBtYXRjaClcblxuXG4gICAgaWYgKG1hdGNoID09PSBtYXRjaFdpdGhFcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXJlc3RCb3VuZGFyeUlkO1xufVxuXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoV2l0aEVycm9yLCBtYXRjaGVzKSB7XG4gIGxldCBuZWFyZXN0Qm91bmRhcnlJZCA9IG51bGw7XG5cbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgICBuZWFyZXN0Qm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH0gLy8gb25seSBzZWFyY2ggcGFyZW50cyAoc3RvcCBhdCB0aHJvd2luZyBtYXRjaClcblxuXG4gICAgaWYgKG1hdGNoID09PSBtYXRjaFdpdGhFcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXJlc3RCb3VuZGFyeUlkO1xufVxuXG5mdW5jdGlvbiBtYWtlTG9hZGVyRGF0YShzdGF0ZSwgcmVzdWx0cywgbWF0Y2hlcykge1xuICBsZXQgbmV3RGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IHtcbiAgICBtYXRjaCxcbiAgICB2YWx1ZVxuICB9IG9mIHJlc3VsdHMpIHtcbiAgICBuZXdEYXRhW21hdGNoLnJvdXRlLmlkXSA9IHZhbHVlO1xuICB9XG5cbiAgbGV0IGxvYWRlckRhdGEgPSB7fTtcblxuICBmb3IgKGxldCB7XG4gICAgcm91dGVcbiAgfSBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IHZhbHVlID0gbmV3RGF0YVtyb3V0ZS5pZF0gIT09IHVuZGVmaW5lZCA/IG5ld0RhdGFbcm91dGUuaWRdIDogc3RhdGUubG9hZGVyRGF0YVtyb3V0ZS5pZF07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9hZGVyRGF0YVtyb3V0ZS5pZF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9hZGVyRGF0YTtcbn1cblxuZnVuY3Rpb24gaXNDYXRjaFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIENhdGNoVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXJsKGhyZWYpIHtcbiAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG59XG5cbmV4cG9ydCB7IENhdGNoVmFsdWUsIElETEVfRkVUQ0hFUiwgSURMRV9UUkFOU0lUSU9OLCBUcmFuc2l0aW9uUmVkaXJlY3QsIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBtYXRjaFJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuZnVuY3Rpb24gbWF0Y2hDbGllbnRSb3V0ZXMocm91dGVzLCBsb2NhdGlvbikge1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24pO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxvY2F0aW9uIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyB1c2VCZWZvcmVVbmxvYWQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuXG5sZXQgU1RPUkFHRV9LRVkgPSBcInBvc2l0aW9uc1wiO1xubGV0IHBvc2l0aW9ucyA9IHt9O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSk7XG5cbiAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICBwb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNzY3JvbGxyZXN0b3JhdGlvblxuICovXG5cblxuZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKCk7IC8vIHdhaXQgZm9yIHRoZSBicm93c2VyIHRvIHJlc3RvcmUgaXQgb24gaXRzIG93blxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICB9LCBbXSk7IC8vIGxldCB0aGUgYnJvd3NlciByZXN0b3JlIG9uIGl0J3Mgb3duIGZvciByZWZyZXNoXG5cbiAgdXNlQmVmb3JlVW5sb2FkKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICB9LCBbXSkpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbiAgICAgICAgICBsZXQgU1RPUkFHRV9LRVkgPSAke0pTT04uc3RyaW5naWZ5KFNUT1JBR0VfS0VZKX07XG4gICAgICAgICAgaWYgKCF3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCAhd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5KSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKDIpIH0sIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSkgfHwgJ3t9JylcbiAgICAgICAgICAgIGxldCBzdG9yZWRZID0gcG9zaXRpb25zW3dpbmRvdy5oaXN0b3J5LnN0YXRlLmtleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzdG9yZWRZKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKVxuICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIH1cbiAgfSk7XG59XG5sZXQgaHlkcmF0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB0cmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbigpO1xuICBsZXQgd2FzU3VibWlzc2lvblJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24uc3VibWlzc2lvbikge1xuICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24ubG9jYXRpb24pIHtcbiAgICAgIHBvc2l0aW9uc1tsb2NhdGlvbi5rZXldID0gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuICB9LCBbdHJhbnNpdGlvbiwgbG9jYXRpb25dKTtcbiAgdXNlQmVmb3JlVW5sb2FkKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShwb3NpdGlvbnMpKTtcbiAgfSwgW10pKTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIG9uIGh5ZHJhdGlvbiwgdGhlIGNvbXBvbmVudCBhbHJlYWR5IGRpZCB0aGlzIHdpdGggYW5cbiAgICAgIC8vIGlubGluZSBzY3JpcHQuXG4gICAgICBpZiAoIWh5ZHJhdGVkKSB7XG4gICAgICAgIGh5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgeSA9IHBvc2l0aW9uc1tsb2NhdGlvbi5rZXldOyAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcblxuICAgICAgaWYgKHkpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcblxuXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKTtcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBkb24ndCBkbyBhbnl0aGluZyBvbiBzdWJtaXNzaW9uc1xuXG5cbiAgICAgIGlmICh3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPT09IHRydWUpIHtcbiAgICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuXG5cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb25dKTtcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24uc3VibWlzc2lvbikge1xuICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uXSk7XG59XG5cbmV4cG9ydCB7IFNjcm9sbFJlc3RvcmF0aW9uIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBBY3Rpb24sIGNyZWF0ZVBhdGggfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlbWl4RW50cnkgfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuXG4vKipcbiAqIFRoZSBlbnRyeSBwb2ludCBmb3IgYSBSZW1peCBhcHAgd2hlbiBpdCBpcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyIChpblxuICogYGFwcC9lbnRyeS5zZXJ2ZXIuanNgKS4gVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgSFRNTCBpbiB0aGVcbiAqIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gUmVtaXhTZXJ2ZXIoe1xuICBjb250ZXh0LFxuICB1cmxcbn0pIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybCk7XG4gIH1cblxuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgaGFzaDogXCJcIixcbiAgICBzdGF0ZTogbnVsbCxcbiAgICBrZXk6IFwiZGVmYXVsdFwiXG4gIH07XG4gIGxldCBzdGF0aWNOYXZpZ2F0b3IgPSB7XG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgfSxcblxuICAgIHB1c2godG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIHJlcGxhY2UodG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9LCB7IHJlcGxhY2U6IHRydWUgfSlcXGAgc29tZXdoZXJlIGAgKyBgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5nbygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG5cbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuYmFjaygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH0sXG5cbiAgICBmb3J3YXJkKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH0sXG5cbiAgICBibG9jaygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJsb2NrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfVxuXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5LCB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBhY3Rpb246IEFjdGlvbi5Qb3AsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIG5hdmlnYXRvcjogc3RhdGljTmF2aWdhdG9yLFxuICAgIHN0YXRpYzogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHsgUmVtaXhTZXJ2ZXIgfTtcbiIsICJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIlxuaW1wb3J0IE5Qcm9ncmVzcyBmcm9tIFwibnByb2dyZXNzXCJcbmltcG9ydCBuUHJvZ3Jlc3NTdHlsZXMgZnJvbSBcIm5wcm9ncmVzcy9ucHJvZ3Jlc3MuY3NzXCJcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4vc3R5bGVzL2FwcC5jc3NcIlxuaW1wb3J0IHsgTWV0YUZ1bmN0aW9uLCBOYXZMaW5rIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB7XG5cdExpbmssXG5cdExpbmtzLFxuXHRMaXZlUmVsb2FkLFxuXHRNZXRhLFxuXHRPdXRsZXQsXG5cdFNjcmlwdHMsXG5cdFNjcm9sbFJlc3RvcmF0aW9uLFxuXHR1c2VDYXRjaCxcblx0dXNlVHJhbnNpdGlvbixcbn0gZnJvbSBcInJlbWl4XCJcblxuZXhwb3J0IGNvbnN0IGxpbmtzID0gKCkgPT4ge1xuXHRyZXR1cm4gW1xuXHRcdHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogc3R5bGVzIH0sXG5cdFx0eyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBuUHJvZ3Jlc3NTdHlsZXMgfSxcblx0XVxufVxuXG5leHBvcnQgY29uc3QgbWV0YTogTWV0YUZ1bmN0aW9uID0gKCkgPT4ge1xuXHRyZXR1cm4geyB0aXRsZTogXCJVbmlrZXkgLSBCXHUwMEUwbiBwaFx1MDBFRG0gdGlcdTFFQkZuZyBWaVx1MUVDN3RcIiB9XG59XG5cbmludGVyZmFjZSBEb2N1bWVudFByb3BzIHtcblx0Y2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuXHR0aXRsZT86IHN0cmluZ1xufVxuXG5jb25zdCBtZW51SXRlbXMgPSBbXG5cdHsgdG86IFwiL2Fib3V0XCIsIHRleHQ6IFwiR2lcdTFFREJpIHRoaVx1MUVDN3VcIiB9LFxuXHR7IHRvOiBcIi9ibG9nXCIsIHRleHQ6IFwiQmxvZ1wiIH0sXG5cdHsgdG86IFwiL2xpbnV4XCIsIHRleHQ6IFwiTGludXhcIiB9LFxuXHR7IHRvOiBcIi9hcHBsZVwiLCB0ZXh0OiBcIkFwcGxlXCIgfSxcblx0eyB0bzogXCIvc3VwcG9ydFwiLCB0ZXh0OiBcIlRyXHUxRUUzIGdpXHUwMEZBcFwiIH0sXG5cdHsgdG86IFwiL3NvdXJjZVwiLCB0ZXh0OiBcIk1cdTAwRTMgbmd1XHUxRUQzblwiIH1cbl1cblxuZnVuY3Rpb24gRG9jdW1lbnQoeyBjaGlsZHJlbiwgdGl0bGUgfTogRG9jdW1lbnRQcm9wcykge1xuXHRjb25zdCB0cmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbigpXG5cblx0UmVhY3QudXNlRWZmZWN0KCgpID0+IHtcblx0XHQvLyB3aGVuIHRoZSBzdGF0ZSBpcyBpZGxlIHRoZW4gd2UgY2FuIHRvIGNvbXBsZXRlIHRoZSBwcm9ncmVzcyBiYXJcblx0XHRpZiAodHJhbnNpdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIE5Qcm9ncmVzcy5kb25lKClcblx0XHQvLyBhbmQgd2hlbiBpdCdzIHNvbWV0aGluZyBlbHNlIGl0IG1lYW5zIGl0J3MgZWl0aGVyIHN1Ym1pdHRpbmcgYSBmb3JtIG9yXG5cdFx0Ly8gd2FpdGluZyBmb3IgdGhlIGxvYWRlcnMgb2YgdGhlIG5leHQgbG9jYXRpb24gc28gd2Ugc3RhcnQgaXRcblx0XHRlbHNlIE5Qcm9ncmVzcy5zdGFydCgpXG5cdH0sIFt0cmFuc2l0aW9uLnN0YXRlXSlcblxuXHRyZXR1cm4gKFxuXHRcdDxodG1sIGxhbmc9XCJlblwiPlxuXHRcdFx0PGhlYWQ+XG5cdFx0XHRcdDxtZXRhIGNoYXJTZXQ9XCJ1dGYtOFwiIC8+XG5cdFx0XHRcdDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xXCIgLz5cblx0XHRcdFx0PE1ldGEgLz5cblx0XHRcdFx0e3RpdGxlID8gPHRpdGxlPnt0aXRsZX08L3RpdGxlPiA6IG51bGx9XG5cdFx0XHRcdDxMaW5rcyAvPlxuXHRcdFx0PC9oZWFkPlxuXHRcdFx0PGJvZHk+XG5cdFx0XHRcdDxuYXYgY2xhc3NOYW1lPVwiYmctemluYy0xMDAgcHktMTBcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBtYXgtdy1zY3JlZW4tbGcgZmxleCBqdXN0aWZ5LWJldHdlZW4gbXgtYXV0b1wiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJcIj5cblx0XHRcdFx0XHRcdFx0PGEgaHJlZj1cIi9cIj48c3Ryb25nPlVuaUtleTwvc3Ryb25nPjwvYT5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PHVsIGNsYXNzTmFtZT1cImZsZXggc3BhY2UteC04XCI+XG5cdFx0XHRcdFx0XHRcdHttZW51SXRlbXMubWFwKG1lbnVJdGVtID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0PGxpIGtleT17bWVudUl0ZW0udG99PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8TmF2TGluayB0bz17bWVudUl0ZW0udG99PnttZW51SXRlbS50ZXh0fTwvTmF2TGluaz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvbmF2PlxuXG5cdFx0XHRcdDxtYWluIGNsYXNzTmFtZT1cIm1iLTIwXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbWF4LXctc2NyZWVuLW1kIG14LWF1dG9cIj5cblxuXHRcdFx0XHRcdFx0e2NoaWxkcmVufVxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDwvbWFpbj5cblxuXHRcdFx0XHQ8Zm9vdGVyIGNsYXNzTmFtZT1cIm10LWF1dG8gcC02IGJnLXNsYXRlLTUwMFwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIG1heC13LXNjcmVlbi1sZyBteC1hdXRvIHRleHQtd2hpdGVcIj5cdTAwQTkgMjAyMSBQaGFtIEtpbSBMb25nLjwvZGl2PlxuXHRcdFx0XHQ8L2Zvb3Rlcj5cblxuXHRcdFx0XHQ8U2Nyb2xsUmVzdG9yYXRpb24gLz5cblx0XHRcdFx0PFNjcmlwdHMgLz5cblx0XHRcdFx0PExpdmVSZWxvYWQgLz5cblx0XHRcdDwvYm9keSA+XG5cdFx0PC9odG1sID5cblx0KVxufVxuXG5Eb2N1bWVudC5wcm9wVHlwZXMgPSB7XG5cdGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblx0dGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwKCkge1xuXHRyZXR1cm4gKFxuXHRcdDxEb2N1bWVudD5cblx0XHRcdDxPdXRsZXQgLz5cblx0XHQ8L0RvY3VtZW50PlxuXHQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXRjaEJvdW5kYXJ5KCkge1xuXHRjb25zdCBjYXVnaHQgPSB1c2VDYXRjaCgpXG5cblx0cmV0dXJuIChcblx0XHQ8RG9jdW1lbnQgdGl0bGU9e2Ake2NhdWdodC5zdGF0dXN9ICR7Y2F1Z2h0LnN0YXR1c1RleHR9YH0+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImVycm9yLWNvbnRhaW5lclwiPlxuXHRcdFx0XHQ8aDE+XG5cdFx0XHRcdFx0e2NhdWdodC5zdGF0dXN9IHtjYXVnaHQuc3RhdHVzVGV4dH1cblx0XHRcdFx0PC9oMT5cblx0XHRcdDwvZGl2PlxuXHRcdDwvRG9jdW1lbnQ+XG5cdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEVycm9yQm91bmRhcnkoeyBlcnJvciB9OiB7IGVycm9yOiBFcnJvciB9KSB7XG5cdGNvbnNvbGUuZXJyb3IoZXJyb3IpXG5cblx0cmV0dXJuIChcblx0XHQ8RG9jdW1lbnQgdGl0bGU9XCJVaC1vaCFcIj5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZXJyb3ItY29udGFpbmVyXCI+XG5cdFx0XHRcdDxoMT5BcHAgRXJyb3I8L2gxPlxuXHRcdFx0XHQ8cHJlPntlcnJvci5tZXNzYWdlfTwvcHJlPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9Eb2N1bWVudD5cblx0KVxufVxuXG5FcnJvckJvdW5kYXJ5LnByb3BUeXBlcyA9IHtcblx0ZXJyb3I6IFByb3BUeXBlcy5vYmplY3QsXG59XG4iLCAiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBMaW5rLCB1c2VMb2FkZXJEYXRhIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB0eXBlIHsgTG9hZGVyRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IGdldFBhZ2VEYXRhIGZyb20gXCJ+L3V0aWxzL2dldFBhZ2VEYXRhXCJcbmltcG9ydCB7IGRvd25sb2FkX21keCB9IGZyb20gXCJ+L2NvbnRlbnQvZG93bmxvYWQubWQuanNcIlxuXG5leHBvcnQgY29uc3QgaGFuZGxlID0ge1xuXHRtYWluUGFnZXM6ICgpID0+IDxMaW5rIHRvPVwiL2Rvd25sb2FkXCI+RG93bmxvYWQ8L0xpbms+XG59XG5cbmV4cG9ydCBjb25zdCBsb2FkZXI6IExvYWRlckZ1bmN0aW9uID0gKCkgPT4ge1xuXHRyZXR1cm4gZ2V0UGFnZURhdGEoZG93bmxvYWRfbWR4KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEb3dubG9hZFBhZ2UoKSB7XG5cdGNvbnN0IHsgYXR0cmlidXRlcywgaHRtbCB9ID0gdXNlTG9hZGVyRGF0YSgpXG5cdHJldHVybiAoXG5cdFx0PGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGh0bWwgfX0gLz5cblx0KVxufVxuIiwgImltcG9ydCB7IG1hcmtlZCB9IGZyb20gXCJtYXJrZWRcIlxuaW1wb3J0IHBhcnNlRnJvbnRNYXR0ZXIgZnJvbSBcImZyb250LW1hdHRlclwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhZ2VEYXRhKHNvdXJjZTogc3RyaW5nKSB7XG5cdC8vZXh0cmFjdCB0aGUgZGF0YVxuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGJvZHkgfSA9IHBhcnNlRnJvbnRNYXR0ZXIoc291cmNlKVxuXHQvL2NvbnZlcnQgbWFya2Rvd24gdG8gaHRtbFxuXHRjb25zdCBodG1sID0gbWFya2VkLnBhcnNlKGJvZHkpXG5cblx0cmV0dXJuIHsgYXR0cmlidXRlcywgaHRtbCB9XG59IiwgIi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIyLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZVVybDogbnVsbCxcbiAgICBicmVha3M6IGZhbHNlLFxuICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgZ2ZtOiB0cnVlLFxuICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICBtYW5nbGU6IHRydWUsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICBzYW5pdGl6ZXI6IG51bGwsXG4gICAgc2lsZW50OiBmYWxzZSxcbiAgICBzbWFydExpc3RzOiBmYWxzZSxcbiAgICBzbWFydHlwYW50czogZmFsc2UsXG4gICAgdG9rZW5pemVyOiBudWxsLFxuICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgeGh0bWw6IGZhbHNlXG4gIH07XG59XG5cbmxldCBkZWZhdWx0cyA9IGdldERlZmF1bHRzKCk7XG5cbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGRlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG59XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbmNvbnN0IGVzY2FwZVJlcGxhY2UgPSAvWyY8PlwiJ10vZztcbmNvbnN0IGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS87XG5jb25zdCBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvZztcbmNvbnN0IGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICBpZiAoZW5jb2RlKSB7XG4gICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn1cblxuY29uc3QgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIChfLCBuKSA9PiB7XG4gICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcbiAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpXG4gICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxuXG5jb25zdCBjYXJldCA9IC8oXnxbXlxcW10pXFxeL2c7XG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2UgfHwgcmVnZXg7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgY29uc3Qgb2JqID0ge1xuICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZ2V0UmVnZXg6ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3Qgbm9uV29yZEFuZENvbG9uVGVzdCA9IC9bXlxcdzpdL2c7XG5jb25zdCBvcmlnaW5JbmRlcGVuZGVudFVybCA9IC9eJHxeW2Etel1bYS16MC05Ky4tXSo6fF5bPyNdL2k7XG5mdW5jdGlvbiBjbGVhblVybChzYW5pdGl6ZSwgYmFzZSwgaHJlZikge1xuICBpZiAoc2FuaXRpemUpIHtcbiAgICBsZXQgcHJvdDtcbiAgICB0cnkge1xuICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2Uobm9uV29yZEFuZENvbG9uVGVzdCwgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICBocmVmID0gcmVzb2x2ZVVybChiYXNlLCBocmVmKTtcbiAgfVxuICB0cnkge1xuICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaHJlZjtcbn1cblxuY29uc3QgYmFzZVVybHMgPSB7fTtcbmNvbnN0IGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuY29uc3QgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG5jb25zdCBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0oYmFzZSwgJy8nLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuICBjb25zdCByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG5cbiAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UoZG9tYWluLCAnJDEnKSArIGhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICB9XG59XG5cbmNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiBmdW5jdGlvbiBub29wVGVzdCgpIHt9IH07XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICBsZXQgaSA9IDEsXG4gICAgdGFyZ2V0LFxuICAgIGtleTtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gIGNvbnN0IHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCAobWF0Y2gsIG9mZnNldCwgc3RyKSA9PiB7XG4gICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICBjdXJyID0gb2Zmc2V0O1xuICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKSBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgIHJldHVybiAnfCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gIGxldCBpID0gMDtcblxuICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgaWYgKCFjZWxsc1swXS50cmltKCkpIHsgY2VsbHMuc2hpZnQoKTsgfVxuICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7IGNlbGxzLnBvcCgpOyB9XG5cbiAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpIGNlbGxzLnB1c2goJycpO1xuICB9XG5cbiAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufVxuXG4vLyBSZW1vdmUgdHJhaWxpbmcgJ2Mncy4gRXF1aXZhbGVudCB0byBzdHIucmVwbGFjZSgvYyokLywgJycpLlxuLy8gL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbi8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gIGNvbnN0IGwgPSBzdHIubGVuZ3RoO1xuICBpZiAobCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG4gIGxldCBzdWZmTGVuID0gMDtcblxuICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgd2hpbGUgKHN1ZmZMZW4gPCBsKSB7XG4gICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgIHN1ZmZMZW4rKztcbiAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgc3VmZkxlbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cigwLCBsIC0gc3VmZkxlbik7XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgbGV0IGxldmVsID0gMCxcbiAgICBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgbGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCkge1xuICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHNhbml0aXplIGFuZCBzYW5pdGl6ZXIgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuNy4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9tYXJrZWQuanMub3JnLyMvVVNJTkdfQURWQU5DRUQubWQjb3B0aW9ucycpO1xuICB9XG59XG5cbi8vIGNvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzLzgwNjc3N1xuZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHBhdHRlcm4sIGNvdW50KSB7XG4gIGlmIChjb3VudCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgaWYgKGNvdW50ICYgMSkge1xuICAgICAgcmVzdWx0ICs9IHBhdHRlcm47XG4gICAgfVxuICAgIGNvdW50ID4+PSAxO1xuICAgIHBhdHRlcm4gKz0gcGF0dGVybjtcbiAgfVxuICByZXR1cm4gcmVzdWx0ICsgcGF0dGVybjtcbn1cblxuZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdywgbGV4ZXIpIHtcbiAgY29uc3QgaHJlZiA9IGxpbmsuaHJlZjtcbiAgY29uc3QgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgY29uc3QgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcblxuICBpZiAoY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnKSB7XG4gICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIHJhdyxcbiAgICAgIGhyZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRleHQsXG4gICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyh0ZXh0LCBbXSlcbiAgICB9O1xuICAgIGxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgIHJldHVybiB0b2tlbjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgIHJhdyxcbiAgICAgIGhyZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRleHQ6IGVzY2FwZSh0ZXh0KVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIHRleHQpIHtcbiAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG5cbiAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcblxuICByZXR1cm4gdGV4dFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAubWFwKG5vZGUgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hJbmRlbnRJbk5vZGUgPSBub2RlLm1hdGNoKC9eXFxzKy8pO1xuICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBUb2tlbml6ZXJcbiAqL1xuY2xhc3MgVG9rZW5pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHM7XG4gIH1cblxuICBzcGFjZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5ld2xpbmUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGNvZGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICA6IHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZmVuY2VzKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCByYXcgPSBjYXBbMF07XG4gICAgICBjb25zdCB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgcmF3LFxuICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpIDogY2FwWzJdLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGhlYWRpbmcoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBsZXQgdGV4dCA9IGNhcFsyXS50cmltKCk7XG5cbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuICAgICAgaWYgKC8jJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gcnRyaW0odGV4dCwgJyMnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgfSBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH07XG4gICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfVxuXG4gIGhyKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHIuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5ibG9ja3F1b3RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnModGV4dCwgW10pLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGxpc3Qoc3JjKSB7XG4gICAgbGV0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGlzdC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHJhdywgaXN0YXNrLCBpc2NoZWNrZWQsIGluZGVudCwgaSwgYmxhbmtMaW5lLCBlbmRzV2l0aEJsYW5rTGluZSxcbiAgICAgICAgbGluZSwgbmV4dExpbmUsIHJhd0xpbmUsIGl0ZW1Db250ZW50cywgZW5kRWFybHk7XG5cbiAgICAgIGxldCBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgIGNvbnN0IGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcblxuICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICByYXc6ICcnLFxuICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICBpdGVtczogW11cbiAgICAgIH07XG5cbiAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBgXFxcXGR7MSw5fVxcXFwke2J1bGwuc2xpY2UoLTEpfWAgOiBgXFxcXCR7YnVsbH1gO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICBjb25zdCBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKGBeKCB7MCwzfSR7YnVsbH0pKCg/OiBbXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgIGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF07XG4gICAgICAgIG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnRyaW1MZWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50ID0gY2FwWzJdLnNlYXJjaCgvW14gXS8pOyAvLyBGaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICBpbmRlbnQgKz0gY2FwWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJsYW5rTGluZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghbGluZSAmJiAvXiAqJC8udGVzdChuZXh0TGluZSkpIHsgLy8gSXRlbXMgYmVnaW4gd2l0aCBhdCBtb3N0IG9uZSBibGFuayBsaW5lXG4gICAgICAgICAgcmF3ICs9IG5leHRMaW5lICsgJ1xcbic7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICBlbmRFYXJseSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgY29uc3QgbmV4dEJ1bGxldFJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpbKistXXxcXFxcZHsxLDl9Wy4pXSlgKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgcmF3TGluZSA9IHNyYy5zcGxpdCgnXFxuJywgMSlbMF07XG4gICAgICAgICAgICBsaW5lID0gcmF3TGluZTtcblxuICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csICcgICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcbiAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0UmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmUuc2VhcmNoKC9bXiBdLykgPj0gaW5kZW50IHx8ICFsaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYmxhbmtMaW5lKSB7IC8vIFVudGlsIGJsYW5rIGxpbmUsIGl0ZW0gZG9lc24ndCBuZWVkIGluZGVudGF0aW9uXG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIGxpbmU7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBPdGhlcndpc2UsIGltcHJvcGVyIGluZGVudGF0aW9uIGVuZHMgdGhpcyBpdGVtXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSAmJiAhbGluZS50cmltKCkpIHsgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGJsYW5rXG4gICAgICAgICAgICAgIGJsYW5rTGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhdyArPSByYXdMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhd0xpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGl0ZW0gZW5kZWQgd2l0aCBhIGJsYW5rIGxpbmUsIHRoZSBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9cXG4gKlxcbiAqJC8udGVzdChyYXcpKSB7XG4gICAgICAgICAgICBlbmRzV2l0aEJsYW5rTGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgaXNjaGVja2VkID0gaXN0YXNrWzBdICE9PSAnWyBdICc7XG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBpdGVtQ29udGVudHMucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50c1xuICAgICAgICB9KTtcblxuICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG4gICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gcmF3LnRyaW1SaWdodCgpO1xuICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnRleHQgPSBpdGVtQ29udGVudHMudHJpbVJpZ2h0KCk7XG4gICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnRyaW1SaWdodCgpO1xuXG4gICAgICBjb25zdCBsID0gbGlzdC5pdGVtcy5sZW5ndGg7XG5cbiAgICAgIC8vIEl0ZW0gY2hpbGQgdG9rZW5zIGhhbmRsZWQgaGVyZSBhdCBlbmQgYmVjYXVzZSB3ZSBuZWVkZWQgdG8gaGF2ZSB0aGUgZmluYWwgaXRlbSB0byB0cmltIGl0IGZpcnN0XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gZmFsc2U7XG4gICAgICAgIGxpc3QuaXRlbXNbaV0udG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2VucyhsaXN0Lml0ZW1zW2ldLnRleHQsIFtdKTtcbiAgICAgICAgY29uc3Qgc3BhY2VycyA9IGxpc3QuaXRlbXNbaV0udG9rZW5zLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ3NwYWNlJyk7XG4gICAgICAgIGNvbnN0IGhhc011bHRpcGxlTGluZUJyZWFrcyA9IHNwYWNlcnMuZXZlcnkodCA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhcnMgPSB0LnJhdy5zcGxpdCgnJyk7XG4gICAgICAgICAgbGV0IGxpbmVCcmVha3MgPSAwO1xuICAgICAgICAgIGZvciAoY29uc3QgY2hhciBvZiBjaGFycykge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGxpbmVCcmVha3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lQnJlYWtzID4gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbGlzdC5sb29zZSAmJiBzcGFjZXJzLmxlbmd0aCAmJiBoYXNNdWx0aXBsZUxpbmVCcmVha3MpIHtcbiAgICAgICAgICAvLyBIYXZpbmcgYSBzaW5nbGUgbGluZSBicmVhayBkb2Vzbid0IG1lYW4gYSBsaXN0IGlzIGxvb3NlLiBBIHNpbmdsZSBsaW5lIGJyZWFrIGlzIHRlcm1pbmF0aW5nIHRoZSBsYXN0IGxpc3QgaXRlbVxuICAgICAgICAgIGxpc3QubG9vc2UgPSB0cnVlO1xuICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIGh0bWwoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgICAgICB0b2tlbi50eXBlID0gJ3BhcmFncmFwaCc7XG4gICAgICAgIHRva2VuLnRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSk7XG4gICAgICAgIHRva2VuLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfVxuXG4gIGRlZihzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmRlZi5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgaWYgKGNhcFszXSkgY2FwWzNdID0gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgdGFnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHRhYmxlKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyhjYXBbMV0pLm1hcChjID0+IHsgcmV0dXJuIHsgdGV4dDogYyB9OyB9KSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICByb3dzOiBjYXBbM10gJiYgY2FwWzNdLnRyaW0oKSA/IGNhcFszXS5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgfTtcblxuICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgaXRlbS5yYXcgPSBjYXBbMF07XG5cbiAgICAgICAgbGV0IGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgbGV0IGksIGosIGssIHJvdztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGl0ZW0ucm93c1tpXSA9IHNwbGl0Q2VsbHMoaXRlbS5yb3dzW2ldLCBpdGVtLmhlYWRlci5sZW5ndGgpLm1hcChjID0+IHsgcmV0dXJuIHsgdGV4dDogYyB9OyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIGNoaWxkIHRva2VucyBpbnNpZGUgaGVhZGVycyBhbmQgY2VsbHNcblxuICAgICAgICAvLyBoZWFkZXIgY2hpbGQgdG9rZW5zXG4gICAgICAgIGwgPSBpdGVtLmhlYWRlci5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICBpdGVtLmhlYWRlcltqXS50b2tlbnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmxleGVyLmlubGluZVRva2VucyhpdGVtLmhlYWRlcltqXS50ZXh0LCBpdGVtLmhlYWRlcltqXS50b2tlbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2VsbCBjaGlsZCB0b2tlbnNcbiAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICByb3cgPSBpdGVtLnJvd3Nbal07XG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgcm93W2tdLnRva2VucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMocm93W2tdLnRleHQsIHJvd1trXS50b2tlbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxoZWFkaW5nKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcbiAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcGFyYWdyYXBoKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICA6IGNhcFsxXSxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcbiAgICAgIHRoaXMubGV4ZXIuaW5saW5lKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgdGV4dChzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH07XG4gICAgICB0aGlzLmxleGVyLmlubGluZSh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfVxuXG4gIGVzY2FwZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogZXNjYXBlKGNhcFsxXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdGFnKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICd0ZXh0J1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICh0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKSlcbiAgICAgICAgICA6IGNhcFswXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBsaW5rKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmxpbmsuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRyaW1tZWRVcmwgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgIC8vIGNvbW1vbm1hcmsgcmVxdWlyZXMgbWF0Y2hpbmcgYW5nbGUgYnJhY2tldHNcbiAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgIGNvbnN0IHJ0cmltU2xhc2ggPSBydHJpbSh0cmltbWVkVXJsLnNsaWNlKDAsIC0xKSwgJ1xcXFwnKTtcbiAgICAgICAgaWYgKCh0cmltbWVkVXJsLmxlbmd0aCAtIHJ0cmltU2xhc2gubGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbmQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgIGNvbnN0IGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgLy8gc3BsaXQgcGVkYW50aWMgaHJlZiBhbmQgdGl0bGVcbiAgICAgICAgY29uc3QgbGluayA9IC9eKFteJ1wiXSpbXlxcc10pXFxzKyhbJ1wiXSkoLiopXFwyLy5leGVjKGhyZWYpO1xuXG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgIH1cblxuICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogdGl0bGVcbiAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgfVxuICB9XG5cbiAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgbGV0IGNhcDtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgIGxldCBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgfVxuICB9XG5cbiAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgIGlmIChtYXRjaFszXSAmJiBwcmV2Q2hhci5tYXRjaCgvW1xccHtMfVxccHtOfV0vdSkpIHJldHVybjtcblxuICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG5cbiAgICBpZiAoIW5leHRDaGFyIHx8IChuZXh0Q2hhciAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkpIHtcbiAgICAgIGNvbnN0IGxMZW5ndGggPSBtYXRjaFswXS5sZW5ndGggLSAxO1xuICAgICAgbGV0IHJEZWxpbSwgckxlbmd0aCwgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsIG1pZERlbGltVG90YWwgPSAwO1xuXG4gICAgICBjb25zdCBlbmRSZWcgPSBtYXRjaFswXVswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kO1xuICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG5cbiAgICAgICAgaWYgKCFyRGVsaW0pIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG5cbiAgICAgICAgckxlbmd0aCA9IHJEZWxpbS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7IC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkgeyAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcblxuICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcblxuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBgZW1gIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgb2RkIGNoYXIgY291bnQuICphKioqXG4gICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gc3JjLnNsaWNlKDEsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCArIDEpLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCwgW10pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSAnc3Ryb25nJyBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIGV2ZW4gY2hhciBjb3VudC4gKiphKioqXG4gICAgICAgIGNvbnN0IHRleHQgPSBzcmMuc2xpY2UoMiwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgckxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgIHJhdzogc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGggKyAxKSxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCwgW10pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29kZXNwYW4oc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHRleHQgPSBlc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBicihzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ici5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZGVsKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdLCBbXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFsxXSkgOiBjYXBbMV0pO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRva2VuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgbGV0IGNhcDtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICBsZXQgcHJldkNhcFplcm87XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBwcmV2Q2FwWmVybyA9IGNhcFswXTtcbiAgICAgICAgICBjYXBbMF0gPSB0aGlzLnJ1bGVzLmlubGluZS5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKVswXTtcbiAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgaHJlZiA9ICdodHRwOi8vJyArIHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRva2VuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaW5saW5lVGV4dChzcmMsIHNtYXJ0eXBhbnRzKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQ7XG4gICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAodGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pKSA6IGNhcFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICBmZW5jZXM6IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSpcXG4pfH57Myx9KShbXlxcbl0qKVxcbig/OnwoW1xcc1xcU10qPylcXG4pKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS8sXG4gIGhyOiAvXiB7MCwzfSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXCogKil7Myx9KSg/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICBsaXN0OiAvXiggezAsM31idWxsKSggW15cXG5dKz8pPyg/OlxcbnwkKS8sXG4gIGh0bWw6ICdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg2KVxuICAgICsgJ3w8KD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgICArICd8PC8oPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVthLXpdW1xcXFx3LV0qXFxcXHMqPig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLFxuICBkZWY6IC9eIHswLDN9XFxbKGxhYmVsKVxcXTogKig/OlxcbiAqKT88PyhbXlxccz5dKyk+Pyg/Oig/OiArKD86XFxuICopP3wgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wVGVzdCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHx0YWJsZXwgK1xcbilbXlxcbl0rKSopLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmJsb2NrLl90aXRsZSA9IC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS87XG5ibG9jay5kZWYgPSBlZGl0KGJsb2NrLmRlZilcbiAgLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKVxuICAucmVwbGFjZSgndGl0bGUnLCBibG9jay5fdGl0bGUpXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5ibG9jay5saXN0SXRlbVN0YXJ0ID0gZWRpdCgvXiggKikoYnVsbCkgKi8pXG4gIC5yZXBsYWNlKCdidWxsJywgYmxvY2suYnVsbGV0KVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2subGlzdCA9IGVkaXQoYmxvY2subGlzdClcbiAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKVxuICAucmVwbGFjZSgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbidcbiAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nXG4gICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInXG4gICsgJ3x0cmFja3x1bCc7XG5ibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuYmxvY2suaHRtbCA9IGVkaXQoYmxvY2suaHRtbCwgJ2knKVxuICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZylcbiAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IGVkaXQoYmxvY2suYmxvY2txdW90ZSlcbiAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaClcbiAgLmdldFJlZ2V4KCk7XG5cbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5ub3JtYWwgPSBtZXJnZSh7fSwgYmxvY2spO1xuXG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2suZ2ZtID0gbWVyZ2Uoe30sIGJsb2NrLm5vcm1hbCwge1xuICB0YWJsZTogJ14gKihbXlxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSg/OlxcXFx8ICopPyg6Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKSg/OlxcXFx8ICopPycgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcbn0pO1xuXG5ibG9jay5nZm0udGFibGUgPSBlZGl0KGJsb2NrLmdmbS50YWJsZSlcbiAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKVxuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCd0YWJsZScsIGJsb2NrLmdmbS50YWJsZSkgLy8gaW50ZXJydXB0IHBhcmFncmFwaHMgd2l0aCB0YWJsZVxuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gKi9cblxuYmxvY2sucGVkYW50aWMgPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGh0bWw6IGVkaXQoXG4gICAgJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJ1xuICAgICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKVxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpXG4gICAgLnJlcGxhY2UoL3RhZy9nLCAnKD8hKD86J1xuICAgICAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YidcbiAgICAgICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJ1xuICAgICAgKyAnXFxcXGIpXFxcXHcrKD8hOnxbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJylcbiAgICAuZ2V0UmVnZXgoKSxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gIGZlbmNlczogbm9vcFRlc3QsIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gIHBhcmFncmFwaDogZWRpdChibG9jay5ub3JtYWwuX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJylcbiAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnfGZlbmNlcycsICcnKVxuICAgIC5yZXBsYWNlKCd8bGlzdCcsICcnKVxuICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgIC5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICB1cmw6IG5vb3BUZXN0LFxuICB0YWc6ICdeY29tbWVudCdcbiAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JywgLy8gQ0RBVEEgc2VjdGlvblxuICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LyxcbiAgcmVmbGlua1NlYXJjaDogJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJyxcbiAgZW1TdHJvbmc6IHtcbiAgICBsRGVsaW06IC9eKD86XFwqKyg/OihbcHVuY3RfXSl8W15cXHMqXSkpfF5fKyg/OihbcHVuY3QqXSl8KFteXFxzX10pKS8sXG4gICAgLy8gICAgICAgICgxKSBhbmQgKDIpIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyLiAoMykgYW5kICg0KSBjYW4gb25seSBiZSBMZWZ0LiAgKDUpIGFuZCAoNikgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0LlxuICAgIC8vICAgICAgICAoKSBTa2lwIG9ycGhhbiBkZWxpbSBpbnNpZGUgc3Ryb25nICAgICgxKSAjKioqICAgICAgICAgICAgICAgICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICg0KSAqKiojICAgICAgICAgICAgICAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICg2KSBhKioqYVxuICAgIHJEZWxpbUFzdDogL15bXl8qXSo/XFxfXFxfW15fKl0qP1xcKlteXypdKj8oPz1cXF9cXF8pfFtwdW5jdF9dKFxcKispKD89W1xcc118JCl8W15wdW5jdCpfXFxzXShcXCorKSg/PVtwdW5jdF9cXHNdfCQpfFtwdW5jdF9cXHNdKFxcKispKD89W15wdW5jdCpfXFxzXSl8W1xcc10oXFwqKykoPz1bcHVuY3RfXSl8W3B1bmN0X10oXFwqKykoPz1bcHVuY3RfXSl8W15wdW5jdCpfXFxzXShcXCorKSg/PVtecHVuY3QqX1xcc10pLyxcbiAgICByRGVsaW1VbmQ6IC9eW15fKl0qP1xcKlxcKlteXypdKj9cXF9bXl8qXSo/KD89XFwqXFwqKXxbcHVuY3QqXShcXF8rKSg/PVtcXHNdfCQpfFtecHVuY3QqX1xcc10oXFxfKykoPz1bcHVuY3QqXFxzXXwkKXxbcHVuY3QqXFxzXShcXF8rKSg/PVtecHVuY3QqX1xcc10pfFtcXHNdKFxcXyspKD89W3B1bmN0Kl0pfFtwdW5jdCpdKFxcXyspKD89W3B1bmN0Kl0pLyAvLyBeLSBOb3QgYWxsb3dlZCBmb3IgX1xuICB9LFxuICBjb2RlOiAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvLFxuICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3BUZXN0LFxuICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvLFxuICBwdW5jdHVhdGlvbjogL14oW1xcc3B1bmN0dWF0aW9uXSkvXG59O1xuXG4vLyBsaXN0IG9mIHB1bmN0dWF0aW9uIG1hcmtzIGZyb20gQ29tbW9uTWFyayBzcGVjXG4vLyB3aXRob3V0ICogYW5kIF8gdG8gaGFuZGxlIHRoZSBkaWZmZXJlbnQgZW1waGFzaXMgbWFya2VycyAqIGFuZCBfXG5pbmxpbmUuX3B1bmN0dWF0aW9uID0gJyFcIiMkJSZcXCcoKStcXFxcLS4sLzo7PD0+P0BcXFxcW1xcXFxdYF57fH1+JztcbmlubGluZS5wdW5jdHVhdGlvbiA9IGVkaXQoaW5saW5lLnB1bmN0dWF0aW9uKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuXG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuaW5saW5lLmJsb2NrU2tpcCA9IC9cXFtbXlxcXV0qP1xcXVxcKFteXFwpXSo/XFwpfGBbXmBdKj9gfDxbXj5dKj8+L2c7XG5pbmxpbmUuZXNjYXBlZEVtU3QgPSAvXFxcXFxcKnxcXFxcXy9nO1xuXG5pbmxpbmUuX2NvbW1lbnQgPSBlZGl0KGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcblxuaW5saW5lLmVtU3Ryb25nLmxEZWxpbSA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLmxEZWxpbSlcbiAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0ID0gZWRpdChpbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0LCAnZycpXG4gIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAuZ2V0UmVnZXgoKTtcblxuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCwgJ2cnKVxuICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS9nO1xuXG5pbmxpbmUuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbmlubGluZS5fZW1haWwgPSAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLztcbmlubGluZS5hdXRvbGluayA9IGVkaXQoaW5saW5lLmF1dG9saW5rKVxuICAucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lLl9zY2hlbWUpXG4gIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcblxuaW5saW5lLnRhZyA9IGVkaXQoaW5saW5lLnRhZylcbiAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpXG4gIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCBpbmxpbmUuX2F0dHJpYnV0ZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5fbGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuaW5saW5lLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbmlubGluZS5fdGl0bGUgPSAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLztcblxuaW5saW5lLmxpbmsgPSBlZGl0KGlubGluZS5saW5rKVxuICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZilcbiAgLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgLnJlcGxhY2UoJ3JlZicsIGJsb2NrLl9sYWJlbClcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5ub2xpbmsgPSBlZGl0KGlubGluZS5ub2xpbmspXG4gIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJylcbiAgLnJlcGxhY2UoJ3JlZmxpbmsnLCBpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ25vbGluaycsIGlubGluZS5ub2xpbmspXG4gIC5nZXRSZWdleCgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzoge1xuICAgIHN0YXJ0OiAvXl9ffFxcKlxcKi8sXG4gICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICBlbmRBc3Q6IC9cXCpcXCooPyFcXCopL2csXG4gICAgZW5kVW5kOiAvX18oPyFfKS9nXG4gIH0sXG4gIGVtOiB7XG4gICAgc3RhcnQ6IC9eX3xcXCovLFxuICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgZW5kQXN0OiAvXFwqKD8hXFwqKS9nLFxuICAgIGVuZFVuZDogL18oPyFfKS9nXG4gIH0sXG4gIGxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXCgoLio/KVxcKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAuZ2V0UmVnZXgoKSxcbiAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KClcbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IGVkaXQoaW5saW5lLmVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypffigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypffildKyg/ISQpKSsvLFxuICBkZWw6IC9eKH5+PykoPz1bXlxcc35dKShbXFxzXFxTXSo/W15cXHN+XSlcXDEoPz1bXn5dfCQpLyxcbiAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn0pO1xuXG5pbmxpbmUuZ2ZtLnVybCA9IGVkaXQoaW5saW5lLmdmbS51cmwsICdpJylcbiAgLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLmdmbS5fZXh0ZW5kZWRfZW1haWwpXG4gIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogZWRpdChpbmxpbmUuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gIHRleHQ6IGVkaXQoaW5saW5lLmdmbS50ZXh0KVxuICAgIC5yZXBsYWNlKCdcXFxcYl8nLCAnXFxcXGJffCB7Mix9XFxcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgLmdldFJlZ2V4KClcbn0pO1xuXG4vKipcbiAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufVxuXG4vKipcbiAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAqL1xuZnVuY3Rpb24gbWFuZ2xlKHRleHQpIHtcbiAgbGV0IG91dCA9ICcnLFxuICAgIGksXG4gICAgY2g7XG5cbiAgY29uc3QgbCA9IHRleHQubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5jbGFzcyBMZXhlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBUb2tlbml6ZXIoKTtcbiAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnRva2VuaXplci5sZXhlciA9IHRoaXM7XG4gICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpbkxpbms6IGZhbHNlLFxuICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICB0b3A6IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICBibG9jazogYmxvY2subm9ybWFsLFxuICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBSdWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBydWxlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2ssXG4gICAgICBpbmxpbmVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBMZXggTWV0aG9kXG4gICAqL1xuICBzdGF0aWMgbGV4KHNyYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBsZXhJbmxpbmUoc3JjLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIGxleGVyLmlubGluZVRva2VucyhzcmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXByb2Nlc3NpbmdcbiAgICovXG4gIGxleChzcmMpIHtcbiAgICBzcmMgPSBzcmNcbiAgICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpO1xuXG4gICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zKTtcblxuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChuZXh0ID0gdGhpcy5pbmxpbmVRdWV1ZS5zaGlmdCgpKSB7XG4gICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXhpbmdcbiAgICovXG4gIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuICAgIH1cbiAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZDtcblxuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9jay5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXdsaW5lXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGlmICh0b2tlbi5yYXcubGVuZ3RoID09PSAxICYmIHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAvLyBzbyBtb3ZlIGl0IHRoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IHVuZWNlc3NhcnkgcGFyYWdyYXBoIHRhZ3NcbiAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvZGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZlbmNlc1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaGVhZGluZ1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGhyXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGJsb2NrcXVvdGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBsaXN0XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaHRtbFxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZlxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10pIHtcbiAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRhYmxlIChnZm0pXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGxoZWFkaW5nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saGVhZGluZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jay5mb3JFYWNoKGZ1bmN0aW9uKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHsgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RQYXJhZ3JhcGhDbGlwcGVkICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IChjdXRTcmMubGVuZ3RoICE9PSBzcmMubGVuZ3RoKTtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRleHRcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgaW5saW5lKHNyYywgdG9rZW5zKSB7XG4gICAgdGhpcy5pbmxpbmVRdWV1ZS5wdXNoKHsgc3JjLCB0b2tlbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGV4aW5nL0NvbXBpbGluZ1xuICAgKi9cbiAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjO1xuXG4gICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICBsZXQgbWFza2VkU3JjID0gc3JjO1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcblxuICAgIC8vIE1hc2sgb3V0IHJlZmxpbmtzXG4gICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcbiAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmcoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gTWFzayBvdXQgZXNjYXBlZCBlbSAmIHN0cm9uZyBkZWxpbWl0ZXJzXG4gICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnKysnICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5sYXN0SW5kZXgpO1xuICAgIH1cblxuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgIGlmICgha2VlcFByZXZDaGFyKSB7XG4gICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICB9XG4gICAgICBrZWVwUHJldkNoYXIgPSBmYWxzZTtcblxuICAgICAgLy8gZXh0ZW5zaW9uc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zXG4gICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZVxuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUuc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNjYXBlXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lc2NhcGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0YWdcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvZGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGVzcGFuKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYnJcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVsIChnZm0pXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhdXRvbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYXV0b2xpbmsoc3JjLCBtYW5nbGUpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXh0XG4gICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUuZm9yRWFjaChmdW5jdGlvbihnZXRTdGFydEluZGV4KSB7XG4gICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7IHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpOyB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYywgc21hcnR5cGFudHMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHsgLy8gVHJhY2sgcHJldkNoYXIgYmVmb3JlIHN0cmluZyBvZiBfX19fIHN0YXJ0ZWRcbiAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgIH1cbiAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5jbGFzcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICB9XG5cbiAgY29kZShjb2RlLCBpbmZvc3RyaW5nLCBlc2NhcGVkKSB7XG4gICAgY29uc3QgbGFuZyA9IChpbmZvc3RyaW5nIHx8ICcnKS5tYXRjaCgvXFxTKi8pWzBdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICBjb25zdCBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgY29kZSA9IG91dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXG4kLywgJycpICsgJ1xcbic7XG5cbiAgICBpZiAoIWxhbmcpIHtcbiAgICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICAgKyAnXCI+J1xuICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgfVxuXG4gIGJsb2NrcXVvdGUocXVvdGUpIHtcbiAgICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbiAgfVxuXG4gIGh0bWwoaHRtbCkge1xuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3LCBzbHVnZ2VyKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJJZHMpIHtcbiAgICAgIHJldHVybiAnPGgnXG4gICAgICAgICsgbGV2ZWxcbiAgICAgICAgKyAnIGlkPVwiJ1xuICAgICAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICAgICAgKyBzbHVnZ2VyLnNsdWcocmF3KVxuICAgICAgICArICdcIj4nXG4gICAgICAgICsgdGV4dFxuICAgICAgICArICc8L2gnXG4gICAgICAgICsgbGV2ZWxcbiAgICAgICAgKyAnPlxcbic7XG4gICAgfVxuICAgIC8vIGlnbm9yZSBJRHNcbiAgICByZXR1cm4gJzxoJyArIGxldmVsICsgJz4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG4gIH1cblxuICBocigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgfVxuXG4gIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgc3RhcnRhdHQgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgfVxuXG4gIGxpc3RpdGVtKHRleHQpIHtcbiAgICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG4gIH1cblxuICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgcmV0dXJuICc8aW5wdXQgJ1xuICAgICAgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKVxuICAgICAgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIidcbiAgICAgICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJylcbiAgICAgICsgJz4gJztcbiAgfVxuXG4gIHBhcmFncmFwaCh0ZXh0KSB7XG4gICAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbiAgfVxuXG4gIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgIGlmIChib2R5KSBib2R5ID0gJzx0Ym9keT4nICsgYm9keSArICc8L3Rib2R5Pic7XG5cbiAgICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgICArICc8dGhlYWQ+XFxuJ1xuICAgICAgKyBoZWFkZXJcbiAgICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICAgKyBib2R5XG4gICAgICArICc8L3RhYmxlPlxcbic7XG4gIH1cblxuICB0YWJsZXJvdyhjb250ZW50KSB7XG4gICAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xuICB9XG5cbiAgdGFibGVjZWxsKGNvbnRlbnQsIGZsYWdzKSB7XG4gICAgY29uc3QgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgIGNvbnN0IHRhZyA9IGZsYWdzLmFsaWduXG4gICAgICA/ICc8JyArIHR5cGUgKyAnIGFsaWduPVwiJyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICAgIDogJzwnICsgdHlwZSArICc+JztcbiAgICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICB9XG5cbiAgLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuICBzdHJvbmcodGV4dCkge1xuICAgIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xuICB9XG5cbiAgZW0odGV4dCkge1xuICAgIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+JztcbiAgfVxuXG4gIGNvZGVzcGFuKHRleHQpIHtcbiAgICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xuICB9XG5cbiAgYnIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG4gIH1cblxuICBkZWwodGV4dCkge1xuICAgIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xuICB9XG5cbiAgbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBlc2NhcGUoaHJlZikgKyAnXCInO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICAgIH1cbiAgICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICBocmVmID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG4gICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGxldCBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgfVxuICAgIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICB0ZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIFRleHRSZW5kZXJlciB7XG4gIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICBzdHJvbmcodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgZW0odGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgY29kZXNwYW4odGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgZGVsKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGh0bWwodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgdGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBsaW5rKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIGJyKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICovXG5jbGFzcyBTbHVnZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZWVuID0ge307XG4gIH1cblxuICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAudHJpbSgpXG4gICAgICAvLyByZW1vdmUgaHRtbCB0YWdzXG4gICAgICAucmVwbGFjZSgvPFshXFwvYS16XS4qPz4vaWcsICcnKVxuICAgICAgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpXG4gICAgICAucmVwbGFjZSgvXFxzL2csICctJyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIG5leHQgc2FmZSAodW5pcXVlKSBzbHVnIHRvIHVzZVxuICAgKi9cbiAgZ2V0TmV4dFNhZmVTbHVnKG9yaWdpbmFsU2x1ZywgaXNEcnlSdW4pIHtcbiAgICBsZXQgc2x1ZyA9IG9yaWdpbmFsU2x1ZztcbiAgICBsZXQgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSAwO1xuICAgIGlmICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcbiAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gdGhpcy5zZWVuW29yaWdpbmFsU2x1Z107XG4gICAgICBkbyB7XG4gICAgICAgIG9jY3VyZW5jZUFjY3VtdWxhdG9yKys7XG4gICAgICAgIHNsdWcgPSBvcmlnaW5hbFNsdWcgKyAnLScgKyBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gICAgfVxuICAgIGlmICghaXNEcnlSdW4pIHtcbiAgICAgIHRoaXMuc2VlbltvcmlnaW5hbFNsdWddID0gb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICB0aGlzLnNlZW5bc2x1Z10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc2x1ZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHN0cmluZyB0byB1bmlxdWUgaWRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmRyeXJ1biBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dCB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAqL1xuICBzbHVnKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldE5leHRTYWZlU2x1ZyhzbHVnLCBvcHRpb25zLmRyeXJ1bik7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnRleHRSZW5kZXJlciA9IG5ldyBUZXh0UmVuZGVyZXIoKTtcbiAgICB0aGlzLnNsdWdnZXIgPSBuZXcgU2x1Z2dlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIExvb3BcbiAgICovXG4gIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgIGxldCBvdXQgPSAnJyxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIGwyLFxuICAgICAgbDMsXG4gICAgICByb3csXG4gICAgICBjZWxsLFxuICAgICAgaGVhZGVyLFxuICAgICAgYm9keSxcbiAgICAgIHRva2VuLFxuICAgICAgb3JkZXJlZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgbG9vc2UsXG4gICAgICBpdGVtQm9keSxcbiAgICAgIGl0ZW0sXG4gICAgICBjaGVja2VkLFxuICAgICAgdGFzayxcbiAgICAgIGNoZWNrYm94LFxuICAgICAgcmV0O1xuXG4gICAgY29uc3QgbCA9IHRva2Vucy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgdG9rZW4pO1xuICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyh0b2tlbi50eXBlKSkge1xuICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hyJzoge1xuICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKFxuICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpLFxuICAgICAgICAgICAgdG9rZW4uZGVwdGgsXG4gICAgICAgICAgICB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSxcbiAgICAgICAgICAgIHRoaXMuc2x1Z2dlcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsXG4gICAgICAgICAgICB0b2tlbi5sYW5nLFxuICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgaGVhZGVyID0gJyc7XG5cbiAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgICB0aGlzLnBhcnNlSW5saW5lKHRva2VuLmhlYWRlcltqXS50b2tlbnMpLFxuICAgICAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgIGwyID0gdG9rZW4ucm93cy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgIHJvdyA9IHRva2VuLnJvd3Nbal07XG5cbiAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgIGwzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsMzsgaysrKSB7XG4gICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSxcbiAgICAgICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0b2tlbi5hbGlnbltrXSB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgIHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgY2hlY2tlZCA9IGl0ZW0uY2hlY2tlZDtcbiAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcbiAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAvLyBUT0RPIHBhcnNlIGlubGluZSBjb250ZW50IGlmIHBhcmFtZXRlciBtYXJrZG93bj0xXG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcbiAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgKi9cbiAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgb3V0ID0gJycsXG4gICAgICBpLFxuICAgICAgdG9rZW4sXG4gICAgICByZXQ7XG5cbiAgICBjb25zdCBsID0gdG9rZW5zLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCB0b2tlbik7XG4gICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdlc2NhcGUnOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaW5rJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRva2VuLnRleHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VtJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4odG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYnInOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdDtcbiAgICBvcHQgPSBudWxsO1xuICB9XG5cbiAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCk7XG5cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodDtcbiAgICBsZXQgdG9rZW5zO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGxldCBvdXQ7XG5cbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuICAgICAgcmV0dXJuIGVyclxuICAgICAgICA/IGNhbGxiYWNrKGVycilcbiAgICAgICAgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgIH07XG5cbiAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuIGRvbmUoKTtcblxuICAgIGxldCBwZW5kaW5nID0gMDtcbiAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgIHBlbmRpbmcrKztcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCAmJiBjb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpO1xuICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmdldERlZmF1bHRzID0gZ2V0RGVmYXVsdHM7XG5cbm1hcmtlZC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG4vKipcbiAqIFVzZSBFeHRlbnNpb25cbiAqL1xuXG5tYXJrZWQudXNlID0gZnVuY3Rpb24oLi4uYXJncykge1xuICBjb25zdCBvcHRzID0gbWVyZ2Uoe30sIC4uLmFyZ3MpO1xuICBjb25zdCBleHRlbnNpb25zID0gbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwgeyByZW5kZXJlcnM6IHt9LCBjaGlsZFRva2Vuczoge30gfTtcbiAgbGV0IGhhc0V4dGVuc2lvbnM7XG5cbiAgYXJncy5mb3JFYWNoKChwYWNrKSA9PiB7XG4gICAgLy8gPT0tLSBQYXJzZSBcImFkZG9uXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgaWYgKHBhY2suZXh0ZW5zaW9ucykge1xuICAgICAgaGFzRXh0ZW5zaW9ucyA9IHRydWU7XG4gICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgIGlmICghZXh0Lm5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dC5yZW5kZXJlcikgeyAvLyBSZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnMgPyBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gOiBudWxsO1xuICAgICAgICAgIGlmIChwcmV2UmVuZGVyZXIpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgZXh0ZW5zaW9uIHdpdGggZnVuYyB0byBydW4gbmV3IGV4dGVuc2lvbiBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIGxldCByZXQgPSBleHQucmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHQudG9rZW5pemVyKSB7IC8vIFRva2VuaXplciBFeHRlbnNpb25zXG4gICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgKGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5zaW9uIGxldmVsIG11c3QgYmUgJ2Jsb2NrJyBvciAnaW5saW5lJ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbnNbZXh0LmxldmVsXSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXSA9IFtleHQudG9rZW5pemVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dC5zdGFydCkgeyAvLyBGdW5jdGlvbiB0byBjaGVjayBmb3Igc3RhcnQgb2YgdG9rZW5cbiAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jay5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0LmNoaWxkVG9rZW5zKSB7IC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICBleHRlbnNpb25zLmNoaWxkVG9rZW5zW2V4dC5uYW1lXSA9IGV4dC5jaGlsZFRva2VucztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBcIm92ZXJ3cml0ZVwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICBjb25zdCByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3Byb3BdO1xuICAgICAgICAvLyBSZXBsYWNlIHJlbmRlcmVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgIHJlbmRlcmVyW3Byb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBsZXQgcmV0ID0gcGFjay5yZW5kZXJlcltwcm9wXS5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIGlmIChwYWNrLnRva2VuaXplcikge1xuICAgICAgY29uc3QgdG9rZW5pemVyID0gbWFya2VkLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyKCk7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgY29uc3QgcHJldlRva2VuaXplciA9IHRva2VuaXplcltwcm9wXTtcbiAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgdG9rZW5pemVyW3Byb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBsZXQgcmV0ID0gcGFjay50b2tlbml6ZXJbcHJvcF0uYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLndhbGtUb2tlbnMpIHtcbiAgICAgIGNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgIG9wdHMud2Fsa1Rva2VucyA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIHBhY2sud2Fsa1Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICAgICAgaWYgKHdhbGtUb2tlbnMpIHtcbiAgICAgICAgICB3YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChoYXNFeHRlbnNpb25zKSB7XG4gICAgICBvcHRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIG1hcmtlZC5zZXRPcHRpb25zKG9wdHMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5cbm1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24odG9rZW5zLCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgIGNhbGxiYWNrLmNhbGwobWFya2VkLCB0b2tlbik7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRva2VuLmhlYWRlcikge1xuICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdG9rZW4ucm93cykge1xuICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW4uaXRlbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmIChtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucyAmJiBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2VucyAmJiBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1t0b2tlbi50eXBlXSkgeyAvLyBXYWxrIGFueSBleHRlbnNpb25zXG4gICAgICAgICAgbWFya2VkLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbdG9rZW4udHlwZV0uZm9yRWFjaChmdW5jdGlvbihjaGlsZFRva2Vucykge1xuICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5bY2hpbGRUb2tlbnNdLCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW4udG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2UgSW5saW5lXG4gKi9cbm1hcmtlZC5wYXJzZUlubGluZSA9IGZ1bmN0aW9uKHNyYywgb3B0KSB7XG4gIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICB9XG5cbiAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbnMgPSBMZXhlci5sZXhJbmxpbmUoc3JjLCBvcHQpO1xuICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5tYXJrZWQuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5tYXJrZWQuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuXG5jb25zdCBvcHRpb25zID0gbWFya2VkLm9wdGlvbnM7XG5jb25zdCBzZXRPcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnM7XG5jb25zdCB1c2UgPSBtYXJrZWQudXNlO1xuY29uc3Qgd2Fsa1Rva2VucyA9IG1hcmtlZC53YWxrVG9rZW5zO1xuY29uc3QgcGFyc2VJbmxpbmUgPSBtYXJrZWQucGFyc2VJbmxpbmU7XG5jb25zdCBwYXJzZSA9IG1hcmtlZDtcbmNvbnN0IHBhcnNlciA9IFBhcnNlci5wYXJzZTtcbmNvbnN0IGxleGVyID0gTGV4ZXIubGV4O1xuXG5leHBvcnQgeyBMZXhlciwgUGFyc2VyLCBSZW5kZXJlciwgU2x1Z2dlciwgVGV4dFJlbmRlcmVyLCBUb2tlbml6ZXIsIGRlZmF1bHRzLCBnZXREZWZhdWx0cywgbGV4ZXIsIG1hcmtlZCwgb3B0aW9ucywgcGFyc2UsIHBhcnNlSW5saW5lLCBwYXJzZXIsIHNldE9wdGlvbnMsIHVzZSwgd2Fsa1Rva2VucyB9O1xuIiwgImV4cG9ydCBjb25zdCBkb3dubG9hZF9tZHggPSBgLS0tXG50aXRsZTogRG93bmxvYWQgVW5pS2V5XG4tLS1cbiMgRG93bmxvYWQgVW5pS2V5XG5cblRyXHUwMUIwXHUxRURCYyBraGkgY2hcdTFFQTF5IFVuaUtleSBsXHUxRUE3biBcdTAxMTFcdTFFQTd1IHRpXHUwMEVBbiwgYlx1MUVBMW4gaFx1MDBFM3kgeGVtIGhcdTAxQjBcdTFFREJuZyBkXHUxRUFCbiB2XHUxRUMxIHZpXHUxRUM3YyAqKmNoXHUxRUU5bmcgdGhcdTFFRjFjIFVuaUtleSB2XHUxRURCaSBjaFx1MUVFRiBrXHUwMEZEIFx1MDExMWlcdTFFQzduIHRcdTFFRUQqKiBcdTAxMTFcdTFFQzMgY2hcdTFFQUZjIGNoXHUxRUFGbiBiXHUxRUExbiBcdTAxMTFhbmcgZFx1MDBGOW5nIGJcdTFFQTNuIFVuaUtleSBzXHUxRUExY2gsIHh1XHUxRUE1dCBwaFx1MDBFMXQgdFx1MUVFQiB0XHUwMEUxYyBnaVx1MUVBMy5cblxuIyMjIFVuaUtleSA0LjMgUkM1XG5cblx1MDExMFx1MDBFMnkgbFx1MDBFMCBwaGlcdTAwRUFuIGJcdTFFQTNuIFVuaUtleSBtXHUxRURCaSBuaFx1MUVBNXQuXG5cbiogQ1x1MDBFMWMgdGhheSBcdTAxMTFcdTFFRDVpIGNcdTFFQTNpIHRpXHUxRUJGbiBjXHUxRUU3YSBwaGlcdTAwRUFuIGJcdTFFQTNuIG5cdTAwRTB5OiBbWGVtIHRcdTFFQTFpIFx1MDExMVx1MDBFMnldKC8pXG4qIFtVbmlLZXkgNC4zIFJDNSwgNjQgYml0LCBaSVAgZmlsZV0oLyk6IEJ1aWxkIDIwMDkyOS4gSFx1MUVENyB0clx1MUVFMyBXaW5kb3dzIDY0LWJpdC5cbiogW1VuaUtleSA0LjMgUkM1LCAzMiBiaXQsIFpJUCBmaWxlXSgvKTogQnVpbGQgMjAwOTI5LiBIXHUxRUQ3IHRyXHUxRUUzIFdpbmRvd3MgMzItYml0IHZcdTAwRTAgNjQtYml0LlxuKiBOXHUxRUJGdSBiXHUxRUExbiB0XHUwMEVDbSB0aFx1MUVBNXkgbFx1MUVEN2kgdHJvbmcgVW5pS2V5LCBbeGluIGhcdTAwRTN5IGJcdTAwRTFvIGxcdTFFRDdpIHRcdTFFQTFpIFx1MDExMVx1MDBFMnldKC8pLlxuXG4jIyMgVW5pS2V5IDQuMyBSQzRcblxuXHUwMTEwXHUwMEUyeSBsXHUwMEUwIHBoaVx1MDBFQW4gYlx1MUVBM24gY1x1MDE2OSwgXHUxRUQ1biBcdTAxMTFcdTFFQ0JuaCwgXHUwMTExXHUwMUIwXHUxRUUzYyBwaFx1MDBFMXQgaFx1MDBFMG5oIHRcdTFFRUIgdGhcdTAwRTFuZyA3LCBuXHUwMTAzbSAyMDE4LlxuXG4qIFtVbmlLZXkgNC4zIFJDNCwgNjQgYml0LCBaSVAgZmlsZV0oLyk6IEJ1aWxkIDE4MDcxNC4gSFx1MUVENyB0clx1MUVFMyBXaW5kb3dzIDY0LWJpdC5cbiogW1VuaUtleSA0LjMgUkM0LCAzMiBiaXQsIFpJUCBmaWxlXSgvKTogQnVpbGQgMTgwNzE0LiBIXHUxRUQ3IHRyXHUxRUUzIFdpbmRvd3MgMzItYml0LlxuXG4jIyMgVVZDb252ZXJ0ZXJcblxuVVZDb252ZXJ0ZXIgbFx1MDBFMCBtXHUxRUQ5dCBjaFx1MDFCMFx1MDFBMW5nIHRyXHUwMEVDbmggZFx1MDBGMm5nIGxcdTFFQzduaCBcdTAxMTFhIG5cdTAxMDNuZyBkXHUwMEY5bmcgXHUwMTExXHUxRUMzIGNodXlcdTFFQzNuIFx1MDExMVx1MUVENWkgZ2lcdTFFRUZhIGNcdTAwRTFjIGJcdTFFQTNuZyBtXHUwMEUzIHRpXHUxRUJGbmcgVmlcdTFFQzd0IGtoXHUwMEUxYyBuaGF1LihVbmljb2RlLCBVVEY4LCBUQ1ZOMywgVk5JXHUyMDI2KVxuXG5VVkNvbnZlcnRlciBjXHUwMEYzIGNcdTAwRTFjIHBoaVx1MDBFQW4gYlx1MUVBM24gZFx1MDBFMG5oIGNobyBXaW5kb3dzIHZcdTAwRTAgTGludXguXG5cbltVVkNvbnZlcnRlciAxLjEuM2IgZm9yIFdpbmRvd3MgKDEyIEtCKV0oLykuXG5bVVZDb252ZXJ0ZXIgZm9yIExpbnV4XSgvKVxuXG5gIiwgIlxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBMaW5rLCB1c2VMb2FkZXJEYXRhIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB0eXBlIHsgTG9hZGVyRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IGdldFBhZ2VEYXRhIGZyb20gXCJ+L3V0aWxzL2dldFBhZ2VEYXRhXCJcbmltcG9ydCB7IHN1cHBvcnRfbWR4IH0gZnJvbSBcIn4vY29udGVudC9zdXBwb3J0Lm1kLmpzXCJcblxuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHtcblx0bWFpblBhZ2VzOiAoKSA9PiA8TGluayB0bz1cIi9hYm91dFwiPkdpXHUxRURCaSB0aGlcdTFFQzd1PC9MaW5rPlxufVxuXG5leHBvcnQgY29uc3QgbG9hZGVyOiBMb2FkZXJGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIGdldFBhZ2VEYXRhKHN1cHBvcnRfbWR4KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdXBwb3J0UGFnZSgpIHtcblx0Y29uc3QgeyBhdHRyaWJ1dGVzLCBodG1sIH0gPSB1c2VMb2FkZXJEYXRhKClcblx0cmV0dXJuIChcblx0XHQ8ZGl2IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaHRtbCB9fSAvPlxuXHQpXG59XG4iLCAiZXhwb3J0IGNvbnN0IHN1cHBvcnRfbWR4ID0gYC0tLVxudGl0bGU6IFRyXHUxRUUzIGdpXHUwMEZBcFxuLS0tXG4jIFRyXHUxRUUzIGdpXHUwMEZBcFxuXG4jIyMgRFx1MUVGMSBcdTAwRTFuIFVuaUtleVxuXG5DXHUwMEUxYyB0aFx1MUVBM28gbHVcdTFFQURuLCBjXHUwMEUxYyBwaGlcdTAwRUFuIGJcdTFFQTNuIFVuaUtleSB2XHUwMEUwIG1cdTAwRTMgbmd1XHUxRUQzbiBcdTAxMTFcdTAxQjBcdTFFRTNjIFx1MDExMVx1MUVCN3QgdFx1MUVBMWkgd2Vic2l0ZSBkXHUxRUYxIFx1MDBFMW46IFtVbmlLZXkgUHJvamVjdF0oLylcblxuTlx1MUVCRnUgZ1x1MUVCN3AgbFx1MUVEN2kgdlx1MUVEQmkgVW5pS2V5IGJcdTFFQTFuIGNcdTAwRjMgdGhcdTFFQzMsIFtiXHUwMEUxbyBsXHUxRUQ3aSB0XHUxRUExaSBcdTAxMTFcdTAwRTJ5XSgvKS5cblxuIyMjIENcdTAwRTFjIGNoXHUwMEZBIFx1MDBGRFxuXG4xLiBYXHUwMEUxYyB0aFx1MUVGMWMgVW5pS2V5XG5cblx0XHUwMTEwXHUxRUMzIHhcdTAwRTFjIFx1MDExMVx1MUVDQm5oIFVuaUtleSBiXHUxRUExbiBcdTAxMTFhbmcgZFx1MDBGOW5nIGNcdTAwRjMgbmd1XHUxRUQzbiBnXHUxRUQxYyBzXHUxRUExY2gsIGtoXHUwMEY0bmcgYlx1MUVDQiBzXHUxRUVEYSBcdTAxMTFcdTFFRDVpLCBoXHUwMEUzeSBba2lcdTFFQzNtIHRyYSBjaFx1MUVFRiBrXHUxRUY5IHNcdTFFRDEgY1x1MUVFN2EgVW5pa2V5XSgvKVxuXG4yLiBUXHUxRUYxIFx1MDExMVx1MUVEOW5nIGNoXHUxRUExeSBVbmlLZXkgdlx1MUVEQmkgcXV5XHUxRUMxbiBhZG1pbnN0cmF0b3JcblxuXHRUXHUwMEY5eSBjaFx1MUVDRG4gS2hcdTFFREZpIFx1MDExMVx1MUVEOW5nIGNcdTAwRjluZyBXaW5kb3dzIHRyb25nIFVuaUtleSBraFx1MDBGNG5nIGNcdTAwRjMgdFx1MDBFMWMgZFx1MUVFNW5nIFx1MDExMVx1MUVDMyBjaFx1MUVBMXkgdlx1MUVEQmkgcXV5XHUxRUMxbiBhZG1pbmlzdHJhdG9yLiBCXHUxRUExbiBjXHUxRUE3biBwaFx1MUVBM2kgZFx1MDBGOW5nIFRhc2sgU2NoZWR1bGVyLiBYZW0gaFx1MDFCMFx1MUVEQm5nIGRcdTFFQUJuOiBbQ2hcdTFFQTF5IFVuaUtleSB2XHUxRURCaSBxdXlcdTFFQzFuIGFkbWluaXN0cmF0b3JdKC8pXG5cbiMjIyBIXHUwMUIwXHUxRURCbmcgZFx1MUVBQm4gc1x1MUVFRCBkXHUxRUU1bmdcblxuW0hcdTAxQjBcdTFFREJuZyBkXHUxRUFCbiBzXHUxRUVEIGRcdTFFRTVuZyBVbmlLZXldKC8pOiBUXHUwMEUwaSBsaVx1MUVDN3Ugblx1MDBFMHkgXHUwMTExXHUwMEUzIGNcdTAwRjMgbmhpXHUxRUMxdSBwaFx1MUVBN24gXHUwMTExXHUwMEUzIGxcdTFFQTFjIGhcdTFFQUR1LiBSXHUxRUE1dCB0aVx1MUVCRmMgdFx1MDBGNGkgY2hcdTAxQjBhIGNcdTAwRjMgdGhcdTFFRERpIGdpYW4gY1x1MUVBRHAgbmhcdTFFQUR0IHRcdTAwRTBpIGxpXHUxRUM3dSBuXHUwMEUweS5cblxuW0ZBUTogQ1x1MDBFMWMgY1x1MDBFMnUgaFx1MUVDRmkgdGhcdTAxQjBcdTFFRERuZyBnXHUxRUI3cCB2XHUxRUMxIFVuaUtleV0oLykuXG5cbiMjIyBDXHUwMEUxYyBiXHUxRUQ5IGZvbnQgY2hcdTFFRUYgdGlcdTFFQkZuZyBWaVx1MUVDN3RcblxuRFx1MDFCMFx1MUVEQmkgXHUwMTExXHUwMEUyeSBsXHUwMEUwIGNcdTAwRTFjIGJcdTFFRDkgZm9udCBjaFx1MUVFRiBjXHUwMTY5LCByYSBcdTAxMTFcdTFFRERpIHRcdTFFRUIgdHJcdTAxQjBcdTFFREJjIGtoaSBjXHUwMEYzIGNcdTAwRTFjIGJcdTFFRDkgZm9udCB1bmljb2RlIGNcdTAwRjMgaFx1MUVENyB0clx1MUVFMyB0aVx1MUVCRm5nIFZpXHUxRUM3dC4gQlx1MUVBMW4gY2hcdTFFQzkgblx1MDBFQW4gZFx1MDBGOW5nIGNcdTAwRTFjIGZvbnQgblx1MDBFMHkga2hpIGNcdTAwRjMgbFx1MDBGRCBkbyB0aFx1MUVGMWMgc1x1MUVGMSBjXHUxRUE3biB0aGlcdTFFQkZ0LiBUcm9uZyBcdTAxMTFhIHNcdTFFRDEgdHJcdTAxQjBcdTFFRERuZyBoXHUxRUUzcCwgaFx1MDBFM3kgZFx1MDBGOW5nIGNcdTAwRTFjIGJcdTFFRDkgZm9udCB1bmljb2RlLlxuXG5bVENWTi1BQkMgZm9udHMgKDIuNSBNQildKC8pXG5cbltWTkkgZm9udHMgKDMwMCBLQildKC8pXG5gIiwgIlxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBMaW5rLCB1c2VMb2FkZXJEYXRhIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB0eXBlIHsgTG9hZGVyRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IGdldFBhZ2VEYXRhIGZyb20gXCJ+L3V0aWxzL2dldFBhZ2VEYXRhXCJcbmltcG9ydCB7IHNvdXJjZV9tZHggfSBmcm9tIFwifi9jb250ZW50L3NvdXJjZS5tZC5qc1wiXG5cbmV4cG9ydCBjb25zdCBoYW5kbGUgPSB7XG5cdG1haW5QYWdlczogKCkgPT4gPExpbmsgdG89XCIvYWJvdXRcIj5HaVx1MUVEQmkgdGhpXHUxRUM3dTwvTGluaz5cbn1cblxuZXhwb3J0IGNvbnN0IGxvYWRlcjogTG9hZGVyRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiBnZXRQYWdlRGF0YShzb3VyY2VfbWR4KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTb3VyY2VQYWdlKCkge1xuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGh0bWwgfSA9IHVzZUxvYWRlckRhdGEoKVxuXHRyZXR1cm4gKFxuXHRcdDxkaXYgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBodG1sIH19IC8+XG5cdClcbn1cbiIsICJleHBvcnQgY29uc3Qgc291cmNlX21keCA9IGAtLS1cbnRpdGxlOiBVbmlLZXkgU291cmNlIENvZGVcbi0tLVxuIyBVbmlLZXkgU291cmNlIENvZGVcblxuQWxsIHNvdXJjZSBjb2RlIGluIHRoaXMgcGFnZSBpcyByZWxlYXNlZCB1bmRlciB0aGUgdGVybXMgb2YgW3RoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZV0oLykuIEJ5IGRvd25sb2FkaW5nIFVuaUtleSBzb3VyY2UgY29kZSwgeW91IGFncmVlIHdpdGggYWxsIHRoZSB0ZXJtcyBvZiB0aGlzIGxpY2Vuc2UuXG5cbiMjIyBVbmlLZXkgVmlldG5hbWVzZSBJbnB1dCBNZXRob2RcblxuKiBJbiAyMDAxLCBJIHJlbGVhc2VkIHRoZSBzb3VyY2UgY29kZSBvZiB0aGUgY29yZSBlbmdpbmUgVW5pS2V5IFZpZXRuYW1lc2UgSW5wdXQgTWV0aG9kIHRvZ2V0aGVyIHdpdGggdGhlIHgtdW5pa2V5IGxpbnV4IHBhY2thZ2UuIFNpbmNlIHRoZW4sIHRoZSBVbmlLZXkgZW5naW5lIGhhcyBiZWVuIGludGVncmF0ZWQgdG8gZGlmZmVyZW50IGtleWJvYXJkIGlucHV0IHByb2dyYW1zIGluIHZhcmlvdXMgcGxhdGZvcm1zOiBMaW51eCwgW21hY09TIGFuZCBpT1NdKC8pLCBGcmVlQlNELiBUaGUgY29yZSBlbmdpbmUgaXMgc3RpbGwgcHJldHR5IG11Y2ggdW5jaGFuZ2VkIGluIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBVbmlLZXkgZm9yIFdpbmRvd3MuIFlvdSBjYW4gZ2V0IHRoZSBlbmdpbmUgc291cmNlIGNvZGUgaW4gdGhlIG9yaWdpbmFsIHgtdW5pa2V5IGxpbnV4IHBhY2thZ2UuXG5cblx0W3gtdW5pa2V5IHNvdXJjZSBjb2RlXSgvKVxuXG4qIEZvciBlZHVjYXRpb25hbCBwdXJwb3NlcywgSSBoYXZlIGFsc28gcmVsZWFzZWQgdGhlIGZ1bGwgVW5pS2V5IDMuNiAoZm9yIFdpbmRvd3MpIHNvdXJjZSBjb2RlLiBQbGVhc2Ugbm90ZSB0aGF0LCBVbmlLZXkgMy42d2FzIGJ1aWx0IHdpdGggYW4gb2xkIHZlcnNpb24gb2YgdGhlIFVuaUtleSBJbnB1dCBFbmdpbmUuIFlvdSBjYW5kIGZpbmQgdGhlIGxhdGVzdCBlbmdpbmUgc291cmNlIGNvZGUgaW4gdGhlIHgtdW5pa2V5IHBhY2thZ2UgYWJvdmUuXG5cblx0W1VuaUtleSAzLjYyIDA1MDcxMSAtIHNvdXJjZSBjb2RlXSgvKVxuXG4jIyMgVVZDb252ZXJ0ZXJcblxuVVZDb252ZXJ0ZXIgaXMgYSB1bml2ZXJzYWwgY29tbWFuZC1saW5lIFZpZXRuYW1lc2UgZW5jb2RpbmcgY29udmVydGVyIHRoYXQgc3VwcG9ydHMgMTMgZGlmZmVyZW50IGNoYXJzZXRzL2VuY29kaW5ncyAoVW5pY29kZSwgVVRGOCwgVENWTjMsIFZOSVx1MjAyNikuIFVWQ29udmVydGVyIGNhbiBiZSBidWlsdCBpbiBXaW5kb3dzLCBMaW51eCwgTWFjIE9TIFguXG5cbiogVGFyLmd6IGZvcm1hdCAoZm9yIExpbnV4LCBNYWMgT1MgWCk6IFtVVkNvbnZlcnRlciAxLjEuM2JdKC8pXG4qIFppcCBmb3JtYXQgKGZvciBXaW5kb3dzKTogW1VWQ29udmVydGVyIDEuMS4zYl0oLylcblxuYCIsICJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGluaywgdXNlTG9hZGVyRGF0YSB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgdHlwZSB7IExvYWRlckZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCBnZXRQYWdlRGF0YSBmcm9tIFwifi91dGlscy9nZXRQYWdlRGF0YVwiXG5pbXBvcnQgeyBhYm91dF9tZHggfSBmcm9tIFwifi9jb250ZW50L2Fib3V0Lm1kLmpzXCJcblxuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHtcblx0bWFpblBhZ2VzOiAoKSA9PiA8TGluayB0bz1cIi9hYm91dFwiPkdpXHUxRURCaSB0aGlcdTFFQzd1PC9MaW5rPlxufVxuXG5leHBvcnQgY29uc3QgbG9hZGVyOiBMb2FkZXJGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIGdldFBhZ2VEYXRhKGFib3V0X21keClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWJvdXRQYWdlKCkge1xuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGh0bWwgfSA9IHVzZUxvYWRlckRhdGEoKVxuXHRyZXR1cm4gKFxuXHRcdDxkaXYgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBodG1sIH19IC8+XG5cdClcbn1cbiIsICJleHBvcnQgY29uc3QgYWJvdXRfbWR4ID0gYC0tLVxudGl0bGU6IEdpXHUxRURCaSB0aGlcdTFFQzd1IFVuaUtleVxuLS0tXG4jIEdpXHUxRURCaSB0aGlcdTFFQzd1IFVuaUtleVxuXG5VbmlLZXkgXHUwMTExXHUwMUIwXHUxRUUzYyBjXHUwMEY0bmcgYlx1MUVEMSBsXHUxRUE3biBcdTAxMTFcdTFFQTd1IHRpXHUwMEVBbiB2XHUwMEUwbyBuXHUwMTAzbSAxOTk5LiBOZ2F5IHRcdTFFRUIga2hpIHJhIFx1MDExMVx1MUVERGksIFVuaUtleSBcdTAxMTFcdTAwRTMgXHUwMTExXHUwMUIwXHUxRUUzYyBuZ1x1MDFCMFx1MUVERGkgZFx1MDBGOW5nIFx1MDExMVx1MDBGM24gbmhcdTFFQURuIHJcdTFFQTV0IHRcdTAwRURjaCBjXHUxRUYxYyBuaFx1MUVERCB0XHUwMEVEbmggXHUwMTExXHUwMUExbiBnaVx1MUVBM24sIHRpXHUxRUM3biBkXHUxRUU1bmcsIHRcdTFFRDFjIFx1MDExMVx1MUVEOSwgdGluIGNcdTFFQUR5LiBVbmlLZXkgbmhhbmggY2hcdTAwRjNuZyB0clx1MUVERiB0aFx1MDBFMG5oIGNoXHUwMUIwXHUwMUExbmcgdHJcdTAwRUNuaCBnXHUwMEY1IHRpXHUxRUJGbmcgVmlcdTFFQzd0IHRcdTFFRDF0IG5oXHUxRUE1dCwgcGhcdTFFRDUgYmlcdTFFQkZuIG5oXHUxRUE1dCB0clx1MDBFQW4gV2luZG93cy4gSGlcdTFFQzduIG5heSBVbmlLZXkgY1x1MDBGMyBtXHUxRUI3dCBoXHUxRUE3dSBuaFx1MDFCMCB0clx1MDBFQW4gdFx1MUVBNXQgY1x1MUVBMyBjXHUwMEUxYyBtXHUwMEUxeSB0XHUwMEVEbmggY2hcdTFFQTF5IFdpbmRvd3MgY1x1MUVFN2EgbmdcdTAxQjBcdTFFRERpIFZpXHUxRUM3dC5cblxuKipVbmlLZXkgVmlldG5hbWVzZSBJbnB1dCBNZXRob2QqKiwgbW9kdWxlIGNoXHUwMEVEbmggeFx1MUVFRCBsXHUwMEZEIHRpXHUxRUJGbmcgVmlcdTFFQzd0IChnXHUxRUQzbSBjXHUwMEUxYyBwaFx1MDFCMFx1MDFBMW5nIHBoXHUwMEUxcCBnXHUwMEY1LCB0aHVcdTFFQUR0IHRvXHUwMEUxbiBjaHV5XHUxRUMzbiBcdTAxMTFcdTFFRDVpIHRpXHUxRUJGbmcgVmlcdTFFQzd0KSB0cm9uZyBVbmlLZXksIFx1MDExMVx1MDFCMFx1MUVFM2Mgb3Blbi1zb3VyY2UgdFx1MUVFQiBuXHUwMTAzbSAyMDAxLiBCXHUxRUEzbiBvcGVuLXNvdXJjZSBjXHUxRUU3YSBVbmlLZXkgY2hcdTFFQTF5IHRyXHUwMEVBbiBYLVdpbmRvdyAoTGludXgpIFx1MDExMVx1MDFCMFx1MUVFM2MgY1x1MDBGNG5nIGJcdTFFRDEgdFx1MUVFQiBuXHUwMTAzbSAyMDAxLCBkXHUwMUIwXHUxRURCaSB0XHUwMEVBbiAqKngtdW5pa2V5KiouICoqeC11bmlrZXkqKiBsXHUwMEUwIG1cdTFFRDl0IHRyb25nIG5oXHUxRUVGbmcgY2hcdTAxQjBcdTAxQTFuZyB0clx1MDBFQ25oIGdcdTAwRjUgdGlcdTFFQkZuZyBWaVx1MUVDN3QgXHUwMTExXHUxRUE3dSB0aVx1MDBFQW4gdHJcdTAwRUFuIExpbnV4LiBUXHUxRUVCIHNvdXJjZSBjb2RlIHgtdW5pa2V5LCBVbmlLZXkgSW5wdXQgRW5naW5lIFx1MDExMVx1MDBFMyBcdTAxMTFcdTAxQjBcdTFFRTNjIHNcdTFFRUQgZFx1MUVFNW5nIHZcdTAwRTAgdFx1MDBFRGNoIGhcdTFFRTNwIHZcdTAwRTBvIGNcdTAwRTFjIGJcdTFFRDkgZ1x1MDBGNSB0aVx1MUVCRm5nIFZpXHUxRUM3dCB0clx1MDBFQW4gTGludXggc2F1IG5cdTAwRTB5LiBCXHUxRUQ5IGdcdTAwRjUgcGhcdTFFRDUgYmlcdTFFQkZuIG5oXHUxRUE1dCBkXHUwMEY5bmcgbFx1MDBGNWkgVW5pS2V5IHRyXHUwMEVBbiBMaW51eCBoaVx1MUVDN24gbmF5IGxcdTAwRTAgaWJ1cy11bmlrZXkgKGRvIExcdTAwRUEgUXVcdTFFRDFjIFR1XHUxRUE1biBwaFx1MDBFMXQgdHJpXHUxRUMzbikuXG5cblRcdTFFRUIgblx1MDEwM20gMjAwNiwgdFx1MDBFMWMgZ2lcdTFFQTMgVW5pS2V5IFx1MDExMVx1MDBFMyBjaG8gcGhcdTAwRTlwIEFwcGxlIGRcdTAwRjluZyBzb3VyY2UgY29kZSB4LXVuaWtleSB0cm9uZyBjXHUwMEUxYyBzXHUxRUEzbiBwaFx1MUVBOW0gY1x1MUVFN2EgQXBwbGUgdGhlbyBjXHUwMEUxYyBcdTAxMTFpXHUxRUMxdSBraG9cdTFFQTNuIGNcdTFFRTdhIGdpXHUxRUE1eSBwaFx1MDBFOXAgVGhlIE1JVCBsaWNlbnNlLiBUXHUxRUVCIHBoaVx1MDBFQW4gYlx1MUVBM24gVGlnZXIsIGJcdTFFRDkgZ1x1MDBGNSB0aVx1MUVCRm5nIFZpXHUxRUM3dCBjXHUwMEYzIHNcdTFFQjVuIHRyXHUwMEVBbiBNYWMgT1MgWCBcdTAxMTFcdTAwRTMgYlx1MUVBRnQgXHUwMTExXHUxRUE3dSBkXHUwMEY5bmcgbFx1MDBGNWkgVW5pS2V5LiBcdTAxMTBcdTFFQkZuIG5cdTAxMDNtIDIwMTAsIHBoaVx1MDBFQW4gYlx1MUVBM24gaU9TIDQuMCBjXHUwMTY5bmcgdFx1MDBFRGNoIGhcdTFFRTNwIGxcdTAwRjVpIFVuaUtleS4gXHUwMTEwXHUxRUJGbiBuYXkgdFx1MUVBNXQgY1x1MUVBMyBjXHUwMEUxYyB0aGlcdTFFQkZ0IGJcdTFFQ0IgaVBob25lLCBpUGFkIFx1MDExMVx1MUVDMXUgXHUwMTExYW5nIHNcdTFFRUQgZFx1MUVFNW5nIFVuaUtleSBjaG8gYlx1MUVEOSBnXHUwMEY1IHRpXHUxRUJGbmcgVmlcdTFFQzd0IGNcdTAwRjMgc1x1MUVCNW4uXG5cblVuaUtleSBcdTAxMTFcdTAxQjBcdTFFRTNjIHBoXHUwMEUxdCB0cmlcdTFFQzNuIGJcdTFFREZpICpQaFx1MUVBMW0gS2ltIExvbmcqLiBXZWJzaXRlIGNoXHUwMEVEbmggdGhcdTFFRTljIGR1eSBuaFx1MUVBNXQgY1x1MUVFN2EgVW5pS2V5IGxcdTAwRTAgW2h0dHA6Ly91bmlrZXkub3JnXShodHRwOi8vdW5pa2V5Lm9yZykuIFRcdTAwRTFjIGdpXHUxRUEzIGtoXHUwMEY0bmcgY2hcdTFFQ0J1IHRyXHUwMEUxY2ggbmhpXHUxRUM3bSB2XHUxRUMxIGJcdTFFQTV0IGNcdTFFRTkgd2Vic2l0ZSBuXHUwMEUwbyBraFx1MDBFMWMgY3VuZyBjXHUxRUE1cCBjXHUwMEUxYyBwaFx1MUVBN24gbVx1MUVDMW0gVW5pS2V5LlxuYCIsICJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGluaywgdXNlTG9hZGVyRGF0YSB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgdHlwZSB7IExvYWRlckZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCBnZXRQYWdlRGF0YSBmcm9tIFwifi91dGlscy9nZXRQYWdlRGF0YVwiXG5pbXBvcnQgeyBhcHBsZV9tZHggfSBmcm9tIFwifi9jb250ZW50L2FwcGxlLm1kLmpzXCJcblxuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHtcblx0bWFpblBhZ2VzOiAoKSA9PiA8TGluayB0bz1cIi9hYm91dFwiPkdpXHUxRURCaSB0aGlcdTFFQzd1PC9MaW5rPlxufVxuXG5leHBvcnQgY29uc3QgbG9hZGVyOiBMb2FkZXJGdW5jdGlvbiA9ICgpID0+IHtcblx0cmV0dXJuIGdldFBhZ2VEYXRhKGFwcGxlX21keClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwbGVQYWdlKCkge1xuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGh0bWwgfSA9IHVzZUxvYWRlckRhdGEoKVxuXHRyZXR1cm4gKFxuXHRcdDxkaXYgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBodG1sIH19IC8+XG5cdClcbn1cbiIsICJleHBvcnQgY29uc3QgYXBwbGVfbWR4ID0gYC0tLVxudGl0bGU6IFVuaUtleSBjaG8gbWFjT1Mgdlx1MDBFMCBpT1Ncbi0tLVxuIyBVbmlLZXkgY2hvIG1hY09TIHZcdTAwRTAgaU9TXG5cblRcdTFFRUIgblx1MDEwM20gMjAwNiwgdFx1MDBGNGkgXHUwMTExXHUwMEUzIGNobyBwaFx1MDBFOXAgQXBwbGUgZFx1MDBGOW5nIHNvdXJjZSBjb2RlICoqeC11bmlrZXkqKiAocGhpXHUwMEVBbiBiXHUxRUEzbiBVbmlLZXkgY2hvIExpbnV4LCBjXHUwMEYzIGNoXHUxRUU5YSBtb2R1bGUgbFx1MDBGNWkgKipVbmlrZXkgVmlldG5hbWVzZSBJbnB1dCBNZXRob2QqKikgdHJvbmcgY1x1MDBFMWMgc1x1MUVBM24gcGhcdTFFQTltIGNcdTFFRTdhIEFwcGxlIHRoZW8gY1x1MDBFMWMgXHUwMTExaVx1MUVDMXUga2hvXHUxRUEzbiBjXHUxRUU3YSBnaVx1MUVBNXkgcGhcdTAwRTlwIFRoZSBNSVQgbGljZW5zZS4gVFx1MUVFQiBwaGlcdTAwRUFuIGJcdTFFQTNuIE1hY09TIFggTGVvcGFyZCwgYlx1MUVEOSBnXHUwMEY1IHRpXHUxRUJGbmcgVmlcdTFFQzd0IGNcdTAwRjMgc1x1MUVCNW4gdHJcdTAwRUFuIE1hYyBPUyBYIFx1MDExMVx1MDBFMyBiXHUxRUFGdCBcdTAxMTFcdTFFQTd1IGRcdTAwRjluZyBsXHUwMEY1aSBVbmlLZXkuIFx1MDExMFx1MUVCRm4gblx1MDEwM20gMjAxMCwgcGhpXHUwMEVBbiBiXHUxRUEzbiBpT1MgNC4wIGNcdTAxNjluZyB0XHUwMEVEY2ggaFx1MUVFM3AgbFx1MDBGNWkgVW5pS2V5LiBcdTAxMTBcdTFFQkZuIG5heSB0XHUxRUE1dCBjXHUxRUEzIGNcdTAwRTFjIHRoaVx1MUVCRnQgYlx1MUVDQiBpUGhvbmUsIGlQYWQgXHUwMTExXHUxRUMxdSBcdTAxMTFhbmcgc1x1MUVFRCBkXHUxRUU1bmcgVW5pS2V5IGNobyBiXHUxRUQ5IGdcdTAwRjUgdGlcdTFFQkZuZyBWaVx1MUVDN3QgY1x1MDBGMyBzXHUxRUI1biB0clx1MDBFQW4gbVx1MDBFMXkuXG5cbkJcdTAwRTBuIHBoXHUwMEVEbSB0aVx1MUVCRm5nIFZpXHUxRUM3dCB0cm9uZyBtYWNPUyBjXHUwMEYzIHRcdTAwRUFuIFNpbXBsZSBUZWxleCBzXHUxRUVEIGRcdTFFRTVuZyBsXHUwMEY1aSAqKlVuaWtleSBWaWV0bmFtZXNlIElucHV0IE1ldGhvZCoqXG5cbiFbVGVsZXggaW4gTWFjT1NdKC9pbWcvbWFjb3MtdGVsZXgucG5nKVxuXG5Ucm9uZyBpT1MsIHhcdTAwRTFjIG5oXHUxRUFEbiBjXHUxRUU3YSBBcHBsZSB2XHUxRUMxIHZpXHUxRUM3YyBkXHUwMEY5bmcgVW5pS2V5IGNcdTAwRjMgdGhcdTFFQzMgdFx1MDBFQ20gdGhcdTFFQTV5IHRyb25nICpDXHUwMEUwaSBcdTAxMTFcdTFFQjd0IC0gQ1x1MDBFMGkgXHUwMTExXHUxRUI3dCBjaHVuZyAtIEdpXHUxRURCaSB0aGlcdTFFQzd1IC0gUGhcdTAwRTFwIGxcdTAwRkQgLSBUaFx1MDBGNG5nIGJcdTAwRTFvIHBoXHUwMEUxcCBsXHUwMEZEKlxuXG4hW2lPUyBMZWdhbCBOb3RpY2VdKC9pbWcvaW9zLWxlZ2FsLmpwZylcblxuYCIsICJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGluaywgdXNlTG9hZGVyRGF0YSB9IGZyb20gXCJyZW1peFwiXG5pbXBvcnQgdHlwZSB7IExvYWRlckZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCBnZXRQYWdlRGF0YSBmcm9tIFwifi91dGlscy9nZXRQYWdlRGF0YVwiXG5pbXBvcnQgeyBpbmRleF9tZHggfSBmcm9tIFwifi9jb250ZW50L2luZGV4Lm1kLmpzXCJcblxuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHtcblx0bWFpblBhZ2VzOiAoKSA9PiA8TGluayB0bz1cIi9cIj5UcmFuZyBjaFx1MUVFNzwvTGluaz5cbn1cblxuZXhwb3J0IGNvbnN0IGxvYWRlcjogTG9hZGVyRnVuY3Rpb24gPSAoKSA9PiB7XG5cdHJldHVybiBnZXRQYWdlRGF0YShpbmRleF9tZHgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEluZGV4KCkge1xuXHRjb25zdCB7IGF0dHJpYnV0ZXMsIGh0bWwgfSA9IHVzZUxvYWRlckRhdGEoKVxuXHRyZXR1cm4gKFxuXHRcdDxkaXYgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBodG1sIH19IC8+XG5cdClcbn1cbiIsICJleHBvcnQgY29uc3QgaW5kZXhfbWR4ID0gYC0tLVxudGl0bGU6IFVuaUtleSAtIEJcdTAwRTBuIHBoXHUwMEVEbSB0aVx1MUVCRm5nIFZpXHUxRUM3dFxuLS0tXG4jIFVuaUtleSAtIEJcdTAwRTBuIHBoXHUwMEVEbSB0aVx1MUVCRm5nIFZpXHUxRUM3dFxuXG5VbmlrZXkgbFx1MDBFMCBjaFx1MDFCMFx1MDFBMW5nIHRyXHUwMEVDbmggYlx1MDBFMG4gcGhcdTAwRURtIHRpXHUxRUJGbmcgVmlcdTFFQzd0IHBoXHUxRUQ1IGJpXHUxRUJGbiBuaFx1MUVBNXQgdHJcdTAwRUFuIFdpbmRvd3MuIFBoXHUxRUE3biBsXHUwMEY1aSB4XHUxRUVEIGxcdTAwRkQgdGlcdTFFQkZuZyBWaVx1MUVDN3QgVW5pS2V5IElucHV0IEVuZ2luZSBjXHUwMTY5bmcgXHUwMTExXHUwMUIwXHUxRUUzYyBzXHUxRUVEIGRcdTFFRTVuZyB0cm9uZyBjXHUwMEUxYyBjaFx1MDFCMFx1MDFBMW5nIHRyXHUwMEVDbmggYlx1MDBFMG4gcGhcdTAwRURtIG1cdTFFQjdjIFx1MDExMVx1MUVDQm5oIGNcdTFFRTdhIGNcdTAwRTFjIGhcdTFFQzcgXHUwMTExaVx1MUVDMXUgaFx1MDBFMG5oIExpbnV4LCBNYWMgT1MgWCB2XHUwMEUwIFx1MDExMVx1MUVCN2MgYmlcdTFFQzd0IGxcdTAwRTAgdFx1MUVBNXQgY1x1MUVBMyBjXHUwMEUxYyB0aGlcdTFFQkZ0IGJcdTFFQ0IgZFx1MDBGOW5nIGlPUyAoaVBob25lLCBpUGFkKS4gVW5pS2V5IElucHV0IEVuZ2luZSBjXHUwMEYzIG1cdTAwRTMgbmd1XHUxRUQzbiBtXHUxRURGIHRoZW8gZ2lcdTFFQTV5IHBoXHUwMEU5cCBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZS5cblxuVW5pa2V5Lm9yZyBsXHUwMEUwIHdlYnNpdGUgY2hcdTAwRURuaCB0aFx1MUVFOWMgZHV5IG5oXHUxRUE1dCBjXHUxRUU3YSBwaFx1MUVBN24gbVx1MUVDMW0gVW5pS2V5LiBUXHUwMEUxYyBnaVx1MUVBMyBraFx1MDBGNG5nIGNoXHUxRUNCdSB0clx1MDBFMWNoIG5oaVx1MUVDN20gdlx1MUVDMSB0XHUxRUE1dCBjXHUxRUEzIGNcdTAwRTFjIHdlYnNpdGUga2hcdTAwRTFjIGxcdTFFQTV5IHRcdTAwRUFuIGhvXHUxRUI3YyBwaFx1MDBFMm4gcGhcdTFFRDFpIHNcdTFFQTNuIHBoXHUxRUE5bSBVbmlLZXkuXG5cbiMjIFRpbiB0XHUxRUU5Y1xuXG4tLS1cblxuKiBOZ1x1MDBFMHkgMTUvMTAvMjAyMDpcblxuXHQqIFBoXHUwMEUxdCBoXHUwMEUwbmggW1VuaUtleSA0LjMgUkM1XSgvKSBoXHUxRUQ3IHRyXHUxRUUzIHRyXHUwMEVDbmggZHV5XHUxRUM3dCBFZGdlIG1cdTFFREJpIHRcdTFFRDF0IGhcdTAxQTFuLlxuXG4qIE5nXHUwMEUweSAxNC83LzIwMTg6XG5cblx0KiBQaFx1MDBFMXQgaFx1MDBFMG5oIFtVbmlLZXkgNC4zIFJDNF0oLykgc1x1MUVFRGEgbVx1MUVEOXQgbFx1MUVEN2kga2hcdTAwRjRuZyBnXHUwMEY1IFx1MDExMVx1MDFCMFx1MUVFM2MgdHJvbmcgbVx1MUVEOXQgc1x1MUVEMSBhcHAgKGNvbnNvbGUsIGdhbWUsIFVXUCBhcHBzKS5cblxuKiBOZ1x1MDBFMHkgMi83LzIwMTg6XG5cblx0KiBQaFx1MDBFMXQgaFx1MDBFMG5oIFtVbmlLZXkgNC4zIFJDM10oLykgc1x1MUVFRGEgXHUwMTExXHUwMUIwXHUxRUUzYyBsXHUxRUQ3aSB2XHUxRURCaSBFeGNlbCB2XHUwMEUwIGNcdTAwRTFjIHRyXHUwMEVDbmggZHV5XHUxRUM3dCAoQ2hyb21lLCBFZGdlLCBGaXJlZm94LCBJbnRlcm5ldCBFeHBsb3JlcikuXG5cblx0KiBDaFx1MDBGQSBcdTAwRkQ6IEJcdTFFQTNuIDQuMiBSQzIgcGhcdTAwRTF0IGhcdTAwRTBuaCBuZ1x1MDBFMHkgMS83LzIwMTggY1x1MDBGMyBsXHUxRUQ3aSB2XHUxRURCaSBFZGdlLiBMXHUxRUQ3aSBuXHUwMEUweSBcdTAxMTFcdTAwRTMgXHUwMTExXHUwMUIwXHUxRUUzYyBzXHUxRUVEYSBuZ2F5IHRyb25nIGJcdTFFQTNuIDQuMyBSQzMuXG5cbiogTmdcdTAwRTB5IDIzLzYvMjAxODpcblxuXHQqIFBoXHUwMEUxdCBoXHUwMEUwbmggVW5pS2V5IDQuMyBSQzFcblx0XG5cdCogS1x1MUVDMyB0XHUxRUVCIHBoaVx1MDBFQW4gYlx1MUVBM24gNC4zLCBjXHUwMEUxYyBiXHUxRUEzbiBVbmlLZXkgXHUwMTExXHUwMUIwXHUxRUUzYyBwaFx1MDBFMXQgaFx1MDBFMG5oIFx1MDExMWkga1x1MDBFOG0gdlx1MUVEQmkgY2hcdTFFRUYga1x1MDBGRCBzXHUxRUQxIGNcdTAwRjMgY2hcdTFFRTluZyB0aFx1MUVGMWMgXHUwMTExXHUxRUMzIGNoXHUxRUQxbmcgcGhcdTFFQTduIG1cdTFFQzFtIGdpXHUxRUEzIG1cdTFFQTFvLiBYZW0gdGhcdTAwRUFtIHRoXHUwMEY0bmcgdGluIHRcdTFFQTFpIFtDaFx1MUVFOW5nIHRoXHUxRUYxYyBVbmlLZXldKC8pLlxuXG4jIyBDXHUwMEUxYyB0XHUwMEVEbmggblx1MDEwM25nXG5cbi0tLVxuXG5VbmlLZXkgaFx1MUVENyB0clx1MUVFMzpcblxuKiBUXHUxRUE1dCBjXHUxRUEzIGNcdTAwRTFjIGJcdTFFQTNuZyBtXHUwMEUzIHBoXHUxRUQ1IGJpXHUxRUJGbjpcblxuXHQqIFVuaWNvZGUsIFRDVk4gKEFCQylcblxuXHQqIFZJUVIsIFZOSSwgVlBTLCBWSVNDSUksIEJLIEhDTTEsIEJLIEhDTTIsXHUyMDI2XG5cblx0KiBVbmljb2RlIFVURi04LCBVbmljb2RlIE5DUiAtIGZvciBXZWIgZWRpdG9ycy5cblxuKiAyIHBoXHUwMUIwXHUwMUExbmcgcGhcdTAwRTFwIGdcdTAwRjUgdGhcdTAwRjRuZyBkXHUxRUU1bmc6IFRFTEVYLCBWTklcblxuKiBDaG8gcGhcdTAwRTlwIHRcdTFFRjEgXHUwMTExXHUxRUNCbmggbmdoXHUwMTI5YSBraVx1MUVDM3UgZ1x1MDBGNVxuXG4qIENobyBwaFx1MDBFOXAgZ1x1MDBGNSB0XHUxRUFGdCB2XHUwMEUwIFx1MDExMVx1MUVDQm5oIG5naFx1MDEyOWEgYlx1MUVBM25nIGdcdTAwRjUgdFx1MUVBRnQuXG5cbiogQ2hcdTFFQTF5IHRyXHUwMEVBbiB0XHUxRUE1dCBjXHUxRUEzIGNcdTAwRTFjIHBoaVx1MDBFQW4gYlx1MUVBM24gV2luZG93czogMTAsIDgsIDcsIFZpc3RhLCAyMDAwLCBYUCwgOXguXG5cblVuaUtleSByXHUxRUE1dCBnXHUxRUNEbiBuaFx1MUVCOSwga2hcdTAwRjRuZyBjXHUxRUE3biBjXHUwMEUwaSBcdTAxMTFcdTFFQjd0LlxuXG5gIiwgIlxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBMaW5rLCB1c2VMb2FkZXJEYXRhIH0gZnJvbSBcInJlbWl4XCJcbmltcG9ydCB0eXBlIHsgTG9hZGVyRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIlxuaW1wb3J0IGdldFBhZ2VEYXRhIGZyb20gXCJ+L3V0aWxzL2dldFBhZ2VEYXRhXCJcbmltcG9ydCB7IGxpbnV4X21keCB9IGZyb20gXCJ+L2NvbnRlbnQvbGludXgubWQuanNcIlxuXG5leHBvcnQgY29uc3QgaGFuZGxlID0ge1xuXHRtYWluUGFnZXM6ICgpID0+IDxMaW5rIHRvPVwiL2Fib3V0XCI+R2lcdTFFREJpIHRoaVx1MUVDN3U8L0xpbms+XG59XG5cbmV4cG9ydCBjb25zdCBsb2FkZXI6IExvYWRlckZ1bmN0aW9uID0gKCkgPT4ge1xuXHRyZXR1cm4gZ2V0UGFnZURhdGEobGludXhfbWR4KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMaW51eFBhZ2UoKSB7XG5cdGNvbnN0IHsgYXR0cmlidXRlcywgaHRtbCB9ID0gdXNlTG9hZGVyRGF0YSgpXG5cdHJldHVybiAoXG5cdFx0PGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGh0bWwgfX0gLz5cblx0KVxufVxuIiwgImV4cG9ydCBjb25zdCBsaW51eF9tZHggPSBgLS0tXG50aXRsZTogVW5pS2V5IFNvZnR3YXJlIGZvciBMaW51eFxuLS0tXG4jIFVuaUtleSBTb2Z0d2FyZSBmb3IgTGludXhcblxuIyMgWC1VbmlrZXlcblxuWC1VbmlrZXkgaXMgVW5pa2V5IHBvcnRlZCB0byBMaW51eCBhbmQgRnJlZUJTRC4gWC1VbmlrZXkgbGV0cyB5b3UgdHlwZSBWaWV0bmFtZXNlIGluIFggV2luZG93IGVudmlyb25tZW50LiBJdCBoYXMgYmVlbiB0ZXN0ZWQgd2l0aCBtYW55IHBvcHVsYXIgcHJvZ3JhbXMsIHN1Y2ggYXMgT3Blbk9mZmljZSwgZW1hY3MsIHZpbSwgUVQgYXBwbGljYXRpb25zLCBHVEsgYXBwbGljYXRpb25zXHUyMDI2IFgtVW5pa2V5IGhhcyBhbGwgdGhlIGZlYXR1cmVzIG9mIHRoZSBXaW5kb3dzIHZlcnNpb24sIGV4Y2VwdCB0aGF0IGl0cyBHVUkgaXMgc3RpbGwgdG9vIHNpbXBsaWZpZWQuIEFsbCBvcHRpb25zIGFyZSBzZXQgdGhyb3VnaCBjb25maWd1cmF0aW9uIGZpbGUgb3Iga2V5Ym9hcmQgc2hvcnRjdXRzLlxuXG4jIyMgRG93bmxvYWQgWC1VbmlrZXlcblxuKiBTb3VyY2UgY29kZTogW3gtdW5pa2V5IDEuMC40XSgvKVxuXG4jIyMgWC1VbmlrZXkgVXNlciBNYW51YWwgaW4gVmlldG5hbWVzZVxuXG4oVXNlciBNYW51YWwgaW4gRW5nbGlzaCBpcyBwcm92aWRlZCBpbiB0aGUgYWJvdmUgcGFja2FnZXMpXG5cbiogW1gtVW5pa2V5IE1hbnVhbCwgSFRNTF0oLyksIGVkaXRlZCBieSBQaGFtIFRoYW5oIExvbmcuXG4qIFtYLVVuaWtleSBNYW51YWwsIFBERl0oLyksIExhVGVYIHR5cGVzZXR0aW5nIGJ5IFBoYW4gVmluaCBUaGluaC5cblxuIyMgVVZDb252ZXJ0ZXJcblxuVVZDb252ZXJ0ZXIgaXMgYSB1bml2ZXJzYWwgY29tbWFuZC1saW5lIFZpZXRuYW1lc2UgZW5jb2RpbmcgY29udmVydGVyIHdoaWNoIHN1cHBvcnRzIGFsbCBwb3B1bGFyIGNoYXJzZXRzL2VuY29kaW5ncyAoVW5pY29kZSwgVVRGOCwgVENWTjMsIFZOSVx1MjAyNikuIFVWQ29udmVydGVyIGlzIGF2YWlsYWJsZSBpbiBXaW5kb3dzLCBMaW51eCwgYW5kIE1hYyBPUyBYLlxuXG4qIFtVVkNvbnZlcnRlciAxLjEuM2IgZm9yIFdpbmRvd3MgKDEyIEtCKV0oLykuXG4qIFtVVkNvbnZlcnRlciAxLjEuM2IgLSBTb3VyY2UgY29kZV0oLykuXG5cbiMjIFgtQ2hhdCBBdXRvdm4gUGx1Z2luXG5cbkF1dG92biBpcyBhIHBsdWdpbiBmb3IgWC1DaGF0IHRoYXQgYXV0b21hdGljYWxseSBjb252ZXJ0cyBhbGwgbWVzc2FnZXMgZnJvbSBWSVFSIGVuY29kaW5nIHRvIFVURi04IGVuY29kaW5nLlxuXG4qIFtBdXRvdm4gMC4yYiAoMS8zLzIwMDQpLSBzb3VyY2UgY29kZV0oLylcblxuIyMgUGluZSBWaWV0bmFtZXNlIEhPV1RPXG5cblRoaXMgSE9XVE8gc2hvd3MgaG93IFBpbmUgY2FuIGJlIHNldHVwIHRvIHJlYWQgYW5kIHdyaXRlIFZpZXRuYW1lc2UgZW1haWxzLiBPbmUgc3BlY2lhbCBmZWF0dXJlIGlzIHRoZSBhYmlsaXR5IHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIFZJUVIgYW5kIFVuaWNvZGUgY2hhcnNldHMgYXMgeW91IHJlYWQgb3Igc2VuZCBlbWFpbHMuIEVtYWlscyByZWNlaXZlZCBpbiBWSVFSIGNoYXJzZXQgY2FuIGJlIHZpZXdlZCBhcyBpZiB0aGV5IHdlcmUgd3JpdHRlbiBpbiB1bmljb2RlIVxuXG4qIFtDbGljayBoZXJlIHRvIHJlYWRdKC8pXG5cbkFsbCBzb2Z0d2FyZSBpbiB0aGlzIHBhZ2UgYXJlIHJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UuXG5gIiwgImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgTGluaywgT3V0bGV0IH0gZnJvbSBcInJlbWl4XCJcblxuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHtcblx0bWFpblBhZ2VzOiAoKSA9PiA8TGluayB0bz1cIi9ibG9nXCI+QmxvZzwvTGluaz5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmxvZ1BhZ2UoKSB7XG5cdHJldHVybiAoXG5cdFx0PD5cblx0XHRcdDxoMT5CbG9nPC9oMT5cblx0XHRcdDxPdXRsZXQgLz5cblx0XHQ8Lz5cblx0KVxufVxuIiwgImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCbG9nMygpIHtcblx0cmV0dXJuIChcblx0XHQ8PlxuXHRcdFx0PGgyPkJsb2cgMzwvaDI+XG5cdFx0PC8+XG5cdClcbn1cbiIsICJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IExpbmsgfSBmcm9tIFwicmVtaXhcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBYm91dFBhZ2VJbmRleCgpIHtcblx0cmV0dXJuIChcblx0XHQ8PlxuXHRcdFx0PHVsPlxuXHRcdFx0XHQ8bGk+PExpbmsgdG89XCIvYmxvZy9ibG9nMVwiPkJsb2cxPC9MaW5rPjwvbGk+XG5cdFx0XHRcdDxsaT48TGluayB0bz1cIi9ibG9nL2Jsb2cyXCI+QmxvZzI8L0xpbms+PC9saT5cblx0XHRcdFx0PGxpPjxMaW5rIHRvPVwiL2Jsb2cvYmxvZzNcIj5CbG9nMzwvTGluaz48L2xpPlxuXHRcdFx0PC91bD5cblx0XHQ8Lz5cblx0KVxufVxuIiwgImV4cG9ydCBkZWZhdWx0IHsndmVyc2lvbic6J2RmNzlhNmQxJywnZW50cnknOnsnbW9kdWxlJzonL2J1aWxkL2VudHJ5LmNsaWVudC1VTVFXRzVKVy5qcycsJ2ltcG9ydHMnOlsnL2J1aWxkL19zaGFyZWQvY2h1bmstS0ZKSlZYR0MuanMnLCcvYnVpbGQvX3NoYXJlZC9jaHVuay1FN1ZNT1VZTC5qcyddfSwncm91dGVzJzp7J3Jvb3QnOnsnaWQnOidyb290JywncGFyZW50SWQnOnVuZGVmaW5lZCwncGF0aCc6JycsJ2luZGV4Jzp1bmRlZmluZWQsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3Jvb3QtSFdaNFNWTlkuanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6ZmFsc2UsJ2hhc0NhdGNoQm91bmRhcnknOnRydWUsJ2hhc0Vycm9yQm91bmRhcnknOnRydWV9LCdyb3V0ZXMvYWJvdXQnOnsnaWQnOidyb3V0ZXMvYWJvdXQnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzonYWJvdXQnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvYWJvdXQtUk9QTE9IMkQuanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6dHJ1ZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6ZmFsc2UsJ2hhc0Vycm9yQm91bmRhcnknOmZhbHNlfSwncm91dGVzL2FwcGxlJzp7J2lkJzoncm91dGVzL2FwcGxlJywncGFyZW50SWQnOidyb290JywncGF0aCc6J2FwcGxlJywnaW5kZXgnOnVuZGVmaW5lZCwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm91dGVzL2FwcGxlLVBNV1hUN1kyLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOnRydWUsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX0sJ3JvdXRlcy9ibG9nJzp7J2lkJzoncm91dGVzL2Jsb2cnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzonYmxvZycsJ2luZGV4Jzp1bmRlZmluZWQsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9ibG9nLVJTQTdPRlVILmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvYmxvZy8kc2x1Zyc6eydpZCc6J3JvdXRlcy9ibG9nLyRzbHVnJywncGFyZW50SWQnOidyb3V0ZXMvYmxvZycsJ3BhdGgnOic6c2x1ZycsJ2luZGV4Jzp1bmRlZmluZWQsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9ibG9nLyRzbHVnLTRMTVgyTVZSLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvYmxvZy9pbmRleCc6eydpZCc6J3JvdXRlcy9ibG9nL2luZGV4JywncGFyZW50SWQnOidyb3V0ZXMvYmxvZycsJ3BhdGgnOnVuZGVmaW5lZCwnaW5kZXgnOnRydWUsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9ibG9nL2luZGV4LVJEWTYzVkZNLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvZG93bmxvYWQnOnsnaWQnOidyb3V0ZXMvZG93bmxvYWQnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzonZG93bmxvYWQnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvZG93bmxvYWQtWk9FUUJSUk0uanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6dHJ1ZSwnaGFzQ2F0Y2hCb3VuZGFyeSc6ZmFsc2UsJ2hhc0Vycm9yQm91bmRhcnknOmZhbHNlfSwncm91dGVzL2luZGV4Jzp7J2lkJzoncm91dGVzL2luZGV4JywncGFyZW50SWQnOidyb290JywncGF0aCc6dW5kZWZpbmVkLCdpbmRleCc6dHJ1ZSwnY2FzZVNlbnNpdGl2ZSc6dW5kZWZpbmVkLCdtb2R1bGUnOicvYnVpbGQvcm91dGVzL2luZGV4LUlFWE00QlFZLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOnRydWUsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX0sJ3JvdXRlcy9saW51eCc6eydpZCc6J3JvdXRlcy9saW51eCcsJ3BhcmVudElkJzoncm9vdCcsJ3BhdGgnOidsaW51eCcsJ2luZGV4Jzp1bmRlZmluZWQsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9saW51eC1QMllQVENBTi5qcycsJ2ltcG9ydHMnOnVuZGVmaW5lZCwnaGFzQWN0aW9uJzpmYWxzZSwnaGFzTG9hZGVyJzp0cnVlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvc291cmNlJzp7J2lkJzoncm91dGVzL3NvdXJjZScsJ3BhcmVudElkJzoncm9vdCcsJ3BhdGgnOidzb3VyY2UnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvc291cmNlLVlJTVVDNFdYLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOnRydWUsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX0sJ3JvdXRlcy9zdXBwb3J0Jzp7J2lkJzoncm91dGVzL3N1cHBvcnQnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzonc3VwcG9ydCcsJ2luZGV4Jzp1bmRlZmluZWQsJ2Nhc2VTZW5zaXRpdmUnOnVuZGVmaW5lZCwnbW9kdWxlJzonL2J1aWxkL3JvdXRlcy9zdXBwb3J0LTRVU0pJUVNWLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOnRydWUsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX19LCd1cmwnOicvYnVpbGQvbWFuaWZlc3QtREY3OUE2RDEuanMnfTsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFFQSxRQUFJLHdCQUF3QixPQUFPO0FBQ25DLFFBQUksa0JBQWlCLE9BQU8sVUFBVTtBQUN0QyxRQUFJLG1CQUFtQixPQUFPLFVBQVU7QUFFeEMsc0JBQWtCLEtBQUs7QUFDdEIsVUFBSSxRQUFRLFFBQVEsUUFBUSxRQUFXO0FBQ3RDLGNBQU0sSUFBSSxVQUFVO0FBQUE7QUFHckIsYUFBTyxPQUFPO0FBQUE7QUFHZiwrQkFBMkI7QUFDMUIsVUFBSTtBQUNILFlBQUksQ0FBQyxPQUFPLFFBQVE7QUFDbkIsaUJBQU87QUFBQTtBQU1SLFlBQUksUUFBUSxJQUFJLE9BQU87QUFDdkIsY0FBTSxLQUFLO0FBQ1gsWUFBSSxPQUFPLG9CQUFvQixPQUFPLE9BQU8sS0FBSztBQUNqRCxpQkFBTztBQUFBO0FBSVIsWUFBSSxRQUFRO0FBQ1osaUJBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBQzVCLGdCQUFNLE1BQU0sT0FBTyxhQUFhLE1BQU07QUFBQTtBQUV2QyxZQUFJLFNBQVMsT0FBTyxvQkFBb0IsT0FBTyxJQUFJLFNBQVUsR0FBRztBQUMvRCxpQkFBTyxNQUFNO0FBQUE7QUFFZCxZQUFJLE9BQU8sS0FBSyxRQUFRLGNBQWM7QUFDckMsaUJBQU87QUFBQTtBQUlSLFlBQUksUUFBUTtBQUNaLCtCQUF1QixNQUFNLElBQUksUUFBUSxTQUFVLFFBQVE7QUFDMUQsZ0JBQU0sVUFBVTtBQUFBO0FBRWpCLFlBQUksT0FBTyxLQUFLLE9BQU8sT0FBTyxJQUFJLFFBQVEsS0FBSyxRQUM3Qyx3QkFBd0I7QUFDekIsaUJBQU87QUFBQTtBQUdSLGVBQU87QUFBQSxlQUNDLEtBQVA7QUFFRCxlQUFPO0FBQUE7QUFBQTtBQUlULFdBQU8sVUFBVSxvQkFBb0IsT0FBTyxTQUFTLFNBQVUsUUFBUSxRQUFRO0FBQzlFLFVBQUk7QUFDSixVQUFJLEtBQUssU0FBUztBQUNsQixVQUFJO0FBRUosZUFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLFFBQVEsS0FBSztBQUMxQyxnQkFBTyxPQUFPLFVBQVU7QUFFeEIsaUJBQVMsT0FBTyxPQUFNO0FBQ3JCLGNBQUksZ0JBQWUsS0FBSyxPQUFNLE1BQU07QUFDbkMsZUFBRyxPQUFPLE1BQUs7QUFBQTtBQUFBO0FBSWpCLFlBQUksdUJBQXVCO0FBQzFCLG9CQUFVLHNCQUFzQjtBQUNoQyxtQkFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFFBQVEsS0FBSztBQUN4QyxnQkFBSSxpQkFBaUIsS0FBSyxPQUFNLFFBQVEsS0FBSztBQUM1QyxpQkFBRyxRQUFRLE1BQU0sTUFBSyxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNbEMsYUFBTztBQUFBO0FBQUE7QUFBQTs7O0FDeEZSO0FBQUE7QUFBQTtBQVNBO0FBRUEsUUFBSSxNQUF1QztBQUN6QyxNQUFDLFlBQVc7QUFDZDtBQUVBLFlBQUksVUFBVTtBQUdkLFlBQUksZUFBZTtBQU9uQixZQUFJLHFCQUFxQjtBQUN6QixZQUFJLG9CQUFvQjtBQUN4QixnQkFBUSxXQUFXO0FBQ25CLGdCQUFRLGFBQWE7QUFDckIsZ0JBQVEsV0FBVztBQUNuQixZQUFJLHNCQUFzQjtBQUMxQixZQUFJLHFCQUFxQjtBQUN6QixZQUFJLHlCQUF5QjtBQUM3QixnQkFBUSxXQUFXO0FBQ25CLFlBQUksMkJBQTJCO0FBQy9CLFlBQUksa0JBQWtCO0FBQ3RCLFlBQUksa0JBQWtCO0FBQ3RCLFlBQUksbUJBQW1CO0FBQ3ZCLFlBQUksMEJBQTBCO0FBQzlCLFlBQUkseUJBQXlCO0FBQzdCLFlBQUksbUJBQW1CO0FBQ3ZCLFlBQUksdUJBQXVCO0FBQzNCLFlBQUksZ0NBQWdDO0FBQ3BDLFlBQUksdUJBQXVCO0FBQzNCLFlBQUksMkJBQTJCO0FBRS9CLFlBQUksT0FBTyxXQUFXLGNBQWMsT0FBTyxLQUFLO0FBQzlDLGNBQUksWUFBWSxPQUFPO0FBQ3ZCLCtCQUFxQixVQUFVO0FBQy9CLDhCQUFvQixVQUFVO0FBQzlCLGtCQUFRLFdBQVcsVUFBVTtBQUM3QixrQkFBUSxhQUFhLFVBQVU7QUFDL0Isa0JBQVEsV0FBVyxVQUFVO0FBQzdCLGdDQUFzQixVQUFVO0FBQ2hDLCtCQUFxQixVQUFVO0FBQy9CLG1DQUF5QixVQUFVO0FBQ25DLGtCQUFRLFdBQVcsVUFBVTtBQUM3QixxQ0FBMkIsVUFBVTtBQUNyQyw0QkFBa0IsVUFBVTtBQUM1Qiw0QkFBa0IsVUFBVTtBQUM1Qiw2QkFBbUIsVUFBVTtBQUM3QixvQ0FBMEIsVUFBVTtBQUNwQyxtQ0FBeUIsVUFBVTtBQUNuQyw2QkFBbUIsVUFBVTtBQUM3QixpQ0FBdUIsVUFBVTtBQUNqQywwQ0FBZ0MsVUFBVTtBQUMxQyxpQ0FBdUIsVUFBVTtBQUNqQyxxQ0FBMkIsVUFBVTtBQUFBO0FBR3ZDLFlBQUksd0JBQXdCLE9BQU8sV0FBVyxjQUFjLE9BQU87QUFDbkUsWUFBSSx1QkFBdUI7QUFDM0IsK0JBQXVCLGVBQWU7QUFDcEMsY0FBSSxrQkFBa0IsUUFBUSxPQUFPLGtCQUFrQixVQUFVO0FBQy9ELG1CQUFPO0FBQUE7QUFHVCxjQUFJLGdCQUFnQix5QkFBeUIsY0FBYywwQkFBMEIsY0FBYztBQUVuRyxjQUFJLE9BQU8sa0JBQWtCLFlBQVk7QUFDdkMsbUJBQU87QUFBQTtBQUdULGlCQUFPO0FBQUE7QUFNVCxZQUFJLHlCQUF5QjtBQUFBLFVBSzNCLFNBQVM7QUFBQTtBQU9YLFlBQUksMEJBQTBCO0FBQUEsVUFDNUIsWUFBWTtBQUFBO0FBU2QsWUFBSSxvQkFBb0I7QUFBQSxVQUt0QixTQUFTO0FBQUE7QUFHWCxZQUFJLHlCQUF5QjtBQUM3QixZQUFJLHlCQUF5QjtBQUM3QixvQ0FBNEIsT0FBTztBQUNqQztBQUNFLHFDQUF5QjtBQUFBO0FBQUE7QUFJN0I7QUFDRSxpQ0FBdUIscUJBQXFCLFNBQVUsT0FBTztBQUMzRDtBQUNFLHVDQUF5QjtBQUFBO0FBQUE7QUFLN0IsaUNBQXVCLGtCQUFrQjtBQUV6QyxpQ0FBdUIsbUJBQW1CLFdBQVk7QUFDcEQsZ0JBQUksUUFBUTtBQUVaLGdCQUFJLHdCQUF3QjtBQUMxQix1QkFBUztBQUFBO0FBSVgsZ0JBQUksT0FBTyx1QkFBdUI7QUFFbEMsZ0JBQUksTUFBTTtBQUNSLHVCQUFTLFVBQVU7QUFBQTtBQUdyQixtQkFBTztBQUFBO0FBQUE7QUFPWCxZQUFJLHVCQUF1QjtBQUFBLFVBQ3pCLFNBQVM7QUFBQTtBQUdYLFlBQUksdUJBQXVCO0FBQUEsVUFDekI7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUVBLFFBQVE7QUFBQTtBQUdWO0FBQ0UsK0JBQXFCLHlCQUF5QjtBQUFBO0FBUWhELHNCQUFjLFNBQVE7QUFDcEI7QUFDRSxxQkFBUyxPQUFPLFVBQVUsUUFBUSxPQUFPLElBQUksTUFBTSxPQUFPLElBQUksT0FBTyxJQUFJLElBQUksT0FBTyxHQUFHLE9BQU8sTUFBTSxRQUFRO0FBQzFHLG1CQUFLLE9BQU8sS0FBSyxVQUFVO0FBQUE7QUFHN0IseUJBQWEsUUFBUSxTQUFRO0FBQUE7QUFBQTtBQUdqQyx1QkFBZSxTQUFRO0FBQ3JCO0FBQ0UscUJBQVMsUUFBUSxVQUFVLFFBQVEsT0FBTyxJQUFJLE1BQU0sUUFBUSxJQUFJLFFBQVEsSUFBSSxJQUFJLFFBQVEsR0FBRyxRQUFRLE9BQU8sU0FBUztBQUNqSCxtQkFBSyxRQUFRLEtBQUssVUFBVTtBQUFBO0FBRzlCLHlCQUFhLFNBQVMsU0FBUTtBQUFBO0FBQUE7QUFJbEMsOEJBQXNCLE9BQU8sU0FBUSxNQUFNO0FBR3pDO0FBQ0UsZ0JBQUksMEJBQXlCLHFCQUFxQjtBQUNsRCxnQkFBSSxRQUFRLHdCQUF1QjtBQUVuQyxnQkFBSSxVQUFVLElBQUk7QUFDaEIseUJBQVU7QUFDVixxQkFBTyxLQUFLLE9BQU8sQ0FBQztBQUFBO0FBR3RCLGdCQUFJLGlCQUFpQixLQUFLLElBQUksU0FBVSxNQUFNO0FBQzVDLHFCQUFPLEtBQUs7QUFBQTtBQUdkLDJCQUFlLFFBQVEsY0FBYztBQUlyQyxxQkFBUyxVQUFVLE1BQU0sS0FBSyxRQUFRLFFBQVEsU0FBUztBQUFBO0FBQUE7QUFJM0QsWUFBSSwwQ0FBMEM7QUFFOUMsMEJBQWtCLGdCQUFnQixZQUFZO0FBQzVDO0FBQ0UsZ0JBQUksZUFBZSxlQUFlO0FBQ2xDLGdCQUFJLGdCQUFnQixnQkFBaUIsY0FBYSxlQUFlLGFBQWEsU0FBUztBQUN2RixnQkFBSSxhQUFhLGdCQUFnQixNQUFNO0FBRXZDLGdCQUFJLHdDQUF3QyxhQUFhO0FBQ3ZEO0FBQUE7QUFHRixrQkFBTSx5UEFBd1EsWUFBWTtBQUUxUixvREFBd0MsY0FBYztBQUFBO0FBQUE7QUFRMUQsWUFBSSx1QkFBdUI7QUFBQSxVQVF6QixXQUFXLFNBQVUsZ0JBQWdCO0FBQ25DLG1CQUFPO0FBQUE7QUFBQSxVQWtCVCxvQkFBb0IsU0FBVSxnQkFBZ0IsVUFBVSxZQUFZO0FBQ2xFLHFCQUFTLGdCQUFnQjtBQUFBO0FBQUEsVUFnQjNCLHFCQUFxQixTQUFVLGdCQUFnQixlQUFlLFVBQVUsWUFBWTtBQUNsRixxQkFBUyxnQkFBZ0I7QUFBQTtBQUFBLFVBZTNCLGlCQUFpQixTQUFVLGdCQUFnQixjQUFjLFVBQVUsWUFBWTtBQUM3RSxxQkFBUyxnQkFBZ0I7QUFBQTtBQUFBO0FBSTdCLFlBQUksY0FBYztBQUVsQjtBQUNFLGlCQUFPLE9BQU87QUFBQTtBQU9oQiwyQkFBbUIsT0FBTyxTQUFTLFNBQVM7QUFDMUMsZUFBSyxRQUFRO0FBQ2IsZUFBSyxVQUFVO0FBRWYsZUFBSyxPQUFPO0FBR1osZUFBSyxVQUFVLFdBQVc7QUFBQTtBQUc1QixrQkFBVSxVQUFVLG1CQUFtQjtBQTJCdkMsa0JBQVUsVUFBVSxXQUFXLFNBQVUsY0FBYyxVQUFVO0FBQy9ELGNBQUksQ0FBRSxRQUFPLGlCQUFpQixZQUFZLE9BQU8saUJBQWlCLGNBQWMsZ0JBQWdCLE9BQU87QUFDckc7QUFDRSxvQkFBTSxNQUFPO0FBQUE7QUFBQTtBQUlqQixlQUFLLFFBQVEsZ0JBQWdCLE1BQU0sY0FBYyxVQUFVO0FBQUE7QUFrQjdELGtCQUFVLFVBQVUsY0FBYyxTQUFVLFVBQVU7QUFDcEQsZUFBSyxRQUFRLG1CQUFtQixNQUFNLFVBQVU7QUFBQTtBQVNsRDtBQUNFLGNBQUksaUJBQWlCO0FBQUEsWUFDbkIsV0FBVyxDQUFDLGFBQWE7QUFBQSxZQUN6QixjQUFjLENBQUMsZ0JBQWdCO0FBQUE7QUFHakMsY0FBSSwyQkFBMkIsU0FBVSxZQUFZLE1BQU07QUFDekQsbUJBQU8sZUFBZSxVQUFVLFdBQVcsWUFBWTtBQUFBLGNBQ3JELEtBQUssV0FBWTtBQUNmLHFCQUFLLCtEQUErRCxLQUFLLElBQUksS0FBSztBQUVsRix1QkFBTztBQUFBO0FBQUE7QUFBQTtBQUtiLG1CQUFTLFVBQVUsZ0JBQWdCO0FBQ2pDLGdCQUFJLGVBQWUsZUFBZSxTQUFTO0FBQ3pDLHVDQUF5QixRQUFRLGVBQWU7QUFBQTtBQUFBO0FBQUE7QUFLdEQsa0NBQTBCO0FBQUE7QUFFMUIsdUJBQWUsWUFBWSxVQUFVO0FBS3JDLCtCQUF1QixPQUFPLFNBQVMsU0FBUztBQUM5QyxlQUFLLFFBQVE7QUFDYixlQUFLLFVBQVU7QUFFZixlQUFLLE9BQU87QUFDWixlQUFLLFVBQVUsV0FBVztBQUFBO0FBRzVCLFlBQUkseUJBQXlCLGNBQWMsWUFBWSxJQUFJO0FBQzNELCtCQUF1QixjQUFjO0FBRXJDLGdCQUFRLHdCQUF3QixVQUFVO0FBRTFDLCtCQUF1Qix1QkFBdUI7QUFHOUMsNkJBQXFCO0FBQ25CLGNBQUksWUFBWTtBQUFBLFlBQ2QsU0FBUztBQUFBO0FBR1g7QUFDRSxtQkFBTyxLQUFLO0FBQUE7QUFHZCxpQkFBTztBQUFBO0FBR1QsZ0NBQXdCLFdBQVcsV0FBVyxhQUFhO0FBQ3pELGNBQUksZUFBZSxVQUFVLGVBQWUsVUFBVSxRQUFRO0FBQzlELGlCQUFPLFVBQVUsZUFBZ0Isa0JBQWlCLEtBQUssY0FBYyxNQUFNLGVBQWUsTUFBTTtBQUFBO0FBR2xHLGdDQUF3QixNQUFNO0FBQzVCLGlCQUFPLEtBQUssZUFBZTtBQUFBO0FBRzdCLGtDQUEwQixNQUFNO0FBQzlCLGNBQUksUUFBUSxNQUFNO0FBRWhCLG1CQUFPO0FBQUE7QUFHVDtBQUNFLGdCQUFJLE9BQU8sS0FBSyxRQUFRLFVBQVU7QUFDaEMsb0JBQU07QUFBQTtBQUFBO0FBSVYsY0FBSSxPQUFPLFNBQVMsWUFBWTtBQUM5QixtQkFBTyxLQUFLLGVBQWUsS0FBSyxRQUFRO0FBQUE7QUFHMUMsY0FBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixtQkFBTztBQUFBO0FBR1Qsa0JBQVE7QUFBQSxpQkFDRCxRQUFRO0FBQ1gscUJBQU87QUFBQSxpQkFFSjtBQUNILHFCQUFPO0FBQUEsaUJBRUosUUFBUTtBQUNYLHFCQUFPO0FBQUEsaUJBRUosUUFBUTtBQUNYLHFCQUFPO0FBQUEsaUJBRUosUUFBUTtBQUNYLHFCQUFPO0FBQUEsaUJBRUo7QUFDSCxxQkFBTztBQUFBO0FBR1gsY0FBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixvQkFBUSxLQUFLO0FBQUEsbUJBQ047QUFDSCxvQkFBSSxVQUFVO0FBQ2QsdUJBQU8sZUFBZSxXQUFXO0FBQUEsbUJBRTlCO0FBQ0gsb0JBQUksV0FBVztBQUNmLHVCQUFPLGVBQWUsU0FBUyxZQUFZO0FBQUEsbUJBRXhDO0FBQ0gsdUJBQU8sZUFBZSxNQUFNLEtBQUssUUFBUTtBQUFBLG1CQUV0QztBQUNILHVCQUFPLGlCQUFpQixLQUFLO0FBQUEsbUJBRTFCO0FBQ0gsdUJBQU8saUJBQWlCLEtBQUs7QUFBQSxtQkFFMUIsaUJBQ0g7QUFDRSxvQkFBSSxnQkFBZ0I7QUFDcEIsb0JBQUksVUFBVSxjQUFjO0FBQzVCLG9CQUFJLFFBQU8sY0FBYztBQUV6QixvQkFBSTtBQUNGLHlCQUFPLGlCQUFpQixNQUFLO0FBQUEseUJBQ3RCLEdBQVA7QUFDQSx5QkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTWpCLGlCQUFPO0FBQUE7QUFHVCxZQUFJLGtCQUFpQixPQUFPLFVBQVU7QUFDdEMsWUFBSSxpQkFBaUI7QUFBQSxVQUNuQixLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUE7QUFFWixZQUFJLDRCQUE0Qiw0QkFBNEI7QUFFNUQ7QUFDRSxtQ0FBeUI7QUFBQTtBQUczQiw2QkFBcUIsU0FBUTtBQUMzQjtBQUNFLGdCQUFJLGdCQUFlLEtBQUssU0FBUSxRQUFRO0FBQ3RDLGtCQUFJLFNBQVMsT0FBTyx5QkFBeUIsU0FBUSxPQUFPO0FBRTVELGtCQUFJLFVBQVUsT0FBTyxnQkFBZ0I7QUFDbkMsdUJBQU87QUFBQTtBQUFBO0FBQUE7QUFLYixpQkFBTyxRQUFPLFFBQVE7QUFBQTtBQUd4Qiw2QkFBcUIsU0FBUTtBQUMzQjtBQUNFLGdCQUFJLGdCQUFlLEtBQUssU0FBUSxRQUFRO0FBQ3RDLGtCQUFJLFNBQVMsT0FBTyx5QkFBeUIsU0FBUSxPQUFPO0FBRTVELGtCQUFJLFVBQVUsT0FBTyxnQkFBZ0I7QUFDbkMsdUJBQU87QUFBQTtBQUFBO0FBQUE7QUFLYixpQkFBTyxRQUFPLFFBQVE7QUFBQTtBQUd4Qiw0Q0FBb0MsT0FBTyxhQUFhO0FBQ3RELGNBQUksd0JBQXdCLFdBQVk7QUFDdEM7QUFDRSxrQkFBSSxDQUFDLDRCQUE0QjtBQUMvQiw2Q0FBNkI7QUFFN0Isc0JBQU0sNk9BQTRQO0FBQUE7QUFBQTtBQUFBO0FBS3hRLGdDQUFzQixpQkFBaUI7QUFDdkMsaUJBQU8sZUFBZSxPQUFPLE9BQU87QUFBQSxZQUNsQyxLQUFLO0FBQUEsWUFDTCxjQUFjO0FBQUE7QUFBQTtBQUlsQiw0Q0FBb0MsT0FBTyxhQUFhO0FBQ3RELGNBQUksd0JBQXdCLFdBQVk7QUFDdEM7QUFDRSxrQkFBSSxDQUFDLDRCQUE0QjtBQUMvQiw2Q0FBNkI7QUFFN0Isc0JBQU0sNk9BQTRQO0FBQUE7QUFBQTtBQUFBO0FBS3hRLGdDQUFzQixpQkFBaUI7QUFDdkMsaUJBQU8sZUFBZSxPQUFPLE9BQU87QUFBQSxZQUNsQyxLQUFLO0FBQUEsWUFDTCxjQUFjO0FBQUE7QUFBQTtBQUlsQixzREFBOEMsU0FBUTtBQUNwRDtBQUNFLGdCQUFJLE9BQU8sUUFBTyxRQUFRLFlBQVksa0JBQWtCLFdBQVcsUUFBTyxVQUFVLGtCQUFrQixRQUFRLGNBQWMsUUFBTyxRQUFRO0FBQ3pJLGtCQUFJLGdCQUFnQixpQkFBaUIsa0JBQWtCLFFBQVE7QUFFL0Qsa0JBQUksQ0FBQyx1QkFBdUIsZ0JBQWdCO0FBQzFDLHNCQUFNLDZWQUFzWCxlQUFlLFFBQU87QUFFbFosdUNBQXVCLGlCQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMkJoRCxZQUFJLGVBQWUsU0FBVSxNQUFNLEtBQUssS0FBSyxPQUFNLFFBQVEsT0FBTyxPQUFPO0FBQ3ZFLGNBQUksVUFBVTtBQUFBLFlBRVosVUFBVTtBQUFBLFlBRVY7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUVBLFFBQVE7QUFBQTtBQUdWO0FBS0Usb0JBQVEsU0FBUztBQUtqQixtQkFBTyxlQUFlLFFBQVEsUUFBUSxhQUFhO0FBQUEsY0FDakQsY0FBYztBQUFBLGNBQ2QsWUFBWTtBQUFBLGNBQ1osVUFBVTtBQUFBLGNBQ1YsT0FBTztBQUFBO0FBR1QsbUJBQU8sZUFBZSxTQUFTLFNBQVM7QUFBQSxjQUN0QyxjQUFjO0FBQUEsY0FDZCxZQUFZO0FBQUEsY0FDWixVQUFVO0FBQUEsY0FDVixPQUFPO0FBQUE7QUFJVCxtQkFBTyxlQUFlLFNBQVMsV0FBVztBQUFBLGNBQ3hDLGNBQWM7QUFBQSxjQUNkLFlBQVk7QUFBQSxjQUNaLFVBQVU7QUFBQSxjQUNWLE9BQU87QUFBQTtBQUdULGdCQUFJLE9BQU8sUUFBUTtBQUNqQixxQkFBTyxPQUFPLFFBQVE7QUFDdEIscUJBQU8sT0FBTztBQUFBO0FBQUE7QUFJbEIsaUJBQU87QUFBQTtBQU9ULGdDQUF1QixNQUFNLFNBQVEsVUFBVTtBQUM3QyxjQUFJO0FBRUosY0FBSSxRQUFRO0FBQ1osY0FBSSxNQUFNO0FBQ1YsY0FBSSxNQUFNO0FBQ1YsY0FBSSxRQUFPO0FBQ1gsY0FBSSxTQUFTO0FBRWIsY0FBSSxXQUFVLE1BQU07QUFDbEIsZ0JBQUksWUFBWSxVQUFTO0FBQ3ZCLG9CQUFNLFFBQU87QUFFYjtBQUNFLHFEQUFxQztBQUFBO0FBQUE7QUFJekMsZ0JBQUksWUFBWSxVQUFTO0FBQ3ZCLG9CQUFNLEtBQUssUUFBTztBQUFBO0FBR3BCLG9CQUFPLFFBQU8sV0FBVyxTQUFZLE9BQU8sUUFBTztBQUNuRCxxQkFBUyxRQUFPLGFBQWEsU0FBWSxPQUFPLFFBQU87QUFFdkQsaUJBQUssWUFBWSxTQUFRO0FBQ3ZCLGtCQUFJLGdCQUFlLEtBQUssU0FBUSxhQUFhLENBQUMsZUFBZSxlQUFlLFdBQVc7QUFDckYsc0JBQU0sWUFBWSxRQUFPO0FBQUE7QUFBQTtBQUFBO0FBTy9CLGNBQUksaUJBQWlCLFVBQVUsU0FBUztBQUV4QyxjQUFJLG1CQUFtQixHQUFHO0FBQ3hCLGtCQUFNLFdBQVc7QUFBQSxxQkFDUixpQkFBaUIsR0FBRztBQUM3QixnQkFBSSxhQUFhLE1BQU07QUFFdkIscUJBQVMsSUFBSSxHQUFHLElBQUksZ0JBQWdCLEtBQUs7QUFDdkMseUJBQVcsS0FBSyxVQUFVLElBQUk7QUFBQTtBQUdoQztBQUNFLGtCQUFJLE9BQU8sUUFBUTtBQUNqQix1QkFBTyxPQUFPO0FBQUE7QUFBQTtBQUlsQixrQkFBTSxXQUFXO0FBQUE7QUFJbkIsY0FBSSxRQUFRLEtBQUssY0FBYztBQUM3QixnQkFBSSxlQUFlLEtBQUs7QUFFeEIsaUJBQUssWUFBWSxjQUFjO0FBQzdCLGtCQUFJLE1BQU0sY0FBYyxRQUFXO0FBQ2pDLHNCQUFNLFlBQVksYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUtyQztBQUNFLGdCQUFJLE9BQU8sS0FBSztBQUNkLGtCQUFJLGNBQWMsT0FBTyxTQUFTLGFBQWEsS0FBSyxlQUFlLEtBQUssUUFBUSxZQUFZO0FBRTVGLGtCQUFJLEtBQUs7QUFDUCwyQ0FBMkIsT0FBTztBQUFBO0FBR3BDLGtCQUFJLEtBQUs7QUFDUCwyQ0FBMkIsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUt4QyxpQkFBTyxhQUFhLE1BQU0sS0FBSyxLQUFLLE9BQU0sUUFBUSxrQkFBa0IsU0FBUztBQUFBO0FBRS9FLG9DQUE0QixZQUFZLFFBQVE7QUFDOUMsY0FBSSxhQUFhLGFBQWEsV0FBVyxNQUFNLFFBQVEsV0FBVyxLQUFLLFdBQVcsT0FBTyxXQUFXLFNBQVMsV0FBVyxRQUFRLFdBQVc7QUFDM0ksaUJBQU87QUFBQTtBQU9ULDhCQUFzQixTQUFTLFNBQVEsVUFBVTtBQUMvQyxjQUFJLENBQUMsQ0FBRSxhQUFZLFFBQVEsWUFBWSxTQUFZO0FBQ2pEO0FBQ0Usb0JBQU0sTUFBTyxtRkFBbUYsVUFBVTtBQUFBO0FBQUE7QUFJOUcsY0FBSTtBQUVKLGNBQUksUUFBUSxRQUFRLElBQUksUUFBUTtBQUdoQyxjQUFJLE1BQU0sUUFBUTtBQUNsQixjQUFJLE1BQU0sUUFBUTtBQUVsQixjQUFJLFFBQU8sUUFBUTtBQUluQixjQUFJLFNBQVMsUUFBUTtBQUVyQixjQUFJLFFBQVEsUUFBUTtBQUVwQixjQUFJLFdBQVUsTUFBTTtBQUNsQixnQkFBSSxZQUFZLFVBQVM7QUFFdkIsb0JBQU0sUUFBTztBQUNiLHNCQUFRLGtCQUFrQjtBQUFBO0FBRzVCLGdCQUFJLFlBQVksVUFBUztBQUN2QixvQkFBTSxLQUFLLFFBQU87QUFBQTtBQUlwQixnQkFBSTtBQUVKLGdCQUFJLFFBQVEsUUFBUSxRQUFRLEtBQUssY0FBYztBQUM3Qyw2QkFBZSxRQUFRLEtBQUs7QUFBQTtBQUc5QixpQkFBSyxZQUFZLFNBQVE7QUFDdkIsa0JBQUksZ0JBQWUsS0FBSyxTQUFRLGFBQWEsQ0FBQyxlQUFlLGVBQWUsV0FBVztBQUNyRixvQkFBSSxRQUFPLGNBQWMsVUFBYSxpQkFBaUIsUUFBVztBQUVoRSx3QkFBTSxZQUFZLGFBQWE7QUFBQSx1QkFDMUI7QUFDTCx3QkFBTSxZQUFZLFFBQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFqQyxjQUFJLGlCQUFpQixVQUFVLFNBQVM7QUFFeEMsY0FBSSxtQkFBbUIsR0FBRztBQUN4QixrQkFBTSxXQUFXO0FBQUEscUJBQ1IsaUJBQWlCLEdBQUc7QUFDN0IsZ0JBQUksYUFBYSxNQUFNO0FBRXZCLHFCQUFTLElBQUksR0FBRyxJQUFJLGdCQUFnQixLQUFLO0FBQ3ZDLHlCQUFXLEtBQUssVUFBVSxJQUFJO0FBQUE7QUFHaEMsa0JBQU0sV0FBVztBQUFBO0FBR25CLGlCQUFPLGFBQWEsUUFBUSxNQUFNLEtBQUssS0FBSyxPQUFNLFFBQVEsT0FBTztBQUFBO0FBVW5FLGlDQUF3QixRQUFRO0FBQzlCLGlCQUFPLE9BQU8sV0FBVyxZQUFZLFdBQVcsUUFBUSxPQUFPLGFBQWE7QUFBQTtBQUc5RSxZQUFJLFlBQVk7QUFDaEIsWUFBSSxlQUFlO0FBUW5CLHlCQUFnQixLQUFLO0FBQ25CLGNBQUksY0FBYztBQUNsQixjQUFJLGdCQUFnQjtBQUFBLFlBQ2xCLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFBQTtBQUVQLGNBQUksZ0JBQWdCLElBQUksUUFBUSxhQUFhLFNBQVUsT0FBTztBQUM1RCxtQkFBTyxjQUFjO0FBQUE7QUFFdkIsaUJBQU8sTUFBTTtBQUFBO0FBUWYsWUFBSSxtQkFBbUI7QUFDdkIsWUFBSSw2QkFBNkI7QUFFakMsdUNBQStCLE1BQU07QUFDbkMsaUJBQU8sS0FBSyxRQUFRLDRCQUE0QjtBQUFBO0FBV2xELCtCQUF1QixTQUFTLE9BQU87QUFHckMsY0FBSSxPQUFPLFlBQVksWUFBWSxZQUFZLFFBQVEsUUFBUSxPQUFPLE1BQU07QUFFMUUsbUJBQU8sUUFBTyxLQUFLLFFBQVE7QUFBQTtBQUk3QixpQkFBTyxNQUFNLFNBQVM7QUFBQTtBQUd4Qiw4QkFBc0IsVUFBVSxPQUFPLGVBQWUsV0FBVyxVQUFVO0FBQ3pFLGNBQUksT0FBTyxPQUFPO0FBRWxCLGNBQUksU0FBUyxlQUFlLFNBQVMsV0FBVztBQUU5Qyx1QkFBVztBQUFBO0FBR2IsY0FBSSxpQkFBaUI7QUFFckIsY0FBSSxhQUFhLE1BQU07QUFDckIsNkJBQWlCO0FBQUEsaUJBQ1o7QUFDTCxvQkFBUTtBQUFBLG1CQUNEO0FBQUEsbUJBQ0E7QUFDSCxpQ0FBaUI7QUFDakI7QUFBQSxtQkFFRztBQUNILHdCQUFRLFNBQVM7QUFBQSx1QkFDVjtBQUFBLHVCQUNBO0FBQ0gscUNBQWlCO0FBQUE7QUFBQTtBQUFBO0FBTTNCLGNBQUksZ0JBQWdCO0FBQ2xCLGdCQUFJLFNBQVM7QUFDYixnQkFBSSxjQUFjLFNBQVM7QUFHM0IsZ0JBQUksV0FBVyxjQUFjLEtBQUssWUFBWSxjQUFjLFFBQVEsS0FBSztBQUV6RSxnQkFBSSxNQUFNLFFBQVEsY0FBYztBQUM5QixrQkFBSSxrQkFBa0I7QUFFdEIsa0JBQUksWUFBWSxNQUFNO0FBQ3BCLGtDQUFrQixzQkFBc0IsWUFBWTtBQUFBO0FBR3RELDJCQUFhLGFBQWEsT0FBTyxpQkFBaUIsSUFBSSxTQUFVLEdBQUc7QUFDakUsdUJBQU87QUFBQTtBQUFBLHVCQUVBLGVBQWUsTUFBTTtBQUM5QixrQkFBSSxnQkFBZSxjQUFjO0FBQy9CLDhCQUFjLG1CQUFtQixhQUVqQyxnQkFDQSxhQUFZLE9BQVEsRUFBQyxVQUFVLE9BQU8sUUFBUSxZQUFZLE9BQzFELHNCQUFzQixLQUFLLFlBQVksT0FBTyxNQUFNLE1BQU07QUFBQTtBQUc1RCxvQkFBTSxLQUFLO0FBQUE7QUFHYixtQkFBTztBQUFBO0FBR1QsY0FBSTtBQUNKLGNBQUk7QUFDSixjQUFJLGVBQWU7QUFFbkIsY0FBSSxpQkFBaUIsY0FBYyxLQUFLLFlBQVksWUFBWTtBQUVoRSxjQUFJLE1BQU0sUUFBUSxXQUFXO0FBQzNCLHFCQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQ3hDLHNCQUFRLFNBQVM7QUFDakIseUJBQVcsaUJBQWlCLGNBQWMsT0FBTztBQUNqRCw4QkFBZ0IsYUFBYSxPQUFPLE9BQU8sZUFBZSxVQUFVO0FBQUE7QUFBQSxpQkFFakU7QUFDTCxnQkFBSSxhQUFhLGNBQWM7QUFFL0IsZ0JBQUksT0FBTyxlQUFlLFlBQVk7QUFDcEMsa0JBQUksbUJBQW1CO0FBRXZCO0FBRUUsb0JBQUksZUFBZSxpQkFBaUIsU0FBUztBQUMzQyxzQkFBSSxDQUFDLGtCQUFrQjtBQUNyQix5QkFBSztBQUFBO0FBR1AscUNBQW1CO0FBQUE7QUFBQTtBQUl2QixrQkFBSSxXQUFXLFdBQVcsS0FBSztBQUMvQixrQkFBSTtBQUNKLGtCQUFJLEtBQUs7QUFFVCxxQkFBTyxDQUFFLFFBQU8sU0FBUyxRQUFRLE1BQU07QUFDckMsd0JBQVEsS0FBSztBQUNiLDJCQUFXLGlCQUFpQixjQUFjLE9BQU87QUFDakQsZ0NBQWdCLGFBQWEsT0FBTyxPQUFPLGVBQWUsVUFBVTtBQUFBO0FBQUEsdUJBRTdELFNBQVMsVUFBVTtBQUM1QixrQkFBSSxpQkFBaUIsS0FBSztBQUUxQjtBQUNFO0FBQ0Usd0JBQU0sTUFBTyxvREFBcUQsb0JBQW1CLG9CQUFvQix1QkFBdUIsT0FBTyxLQUFLLFVBQVUsS0FBSyxRQUFRLE1BQU0sa0JBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNbk0saUJBQU87QUFBQTtBQWdCVCw2QkFBcUIsVUFBVSxNQUFNLFNBQVM7QUFDNUMsY0FBSSxZQUFZLE1BQU07QUFDcEIsbUJBQU87QUFBQTtBQUdULGNBQUksU0FBUztBQUNiLGNBQUksUUFBUTtBQUNaLHVCQUFhLFVBQVUsUUFBUSxJQUFJLElBQUksU0FBVSxPQUFPO0FBQ3RELG1CQUFPLEtBQUssS0FBSyxTQUFTLE9BQU87QUFBQTtBQUVuQyxpQkFBTztBQUFBO0FBYVQsK0JBQXVCLFVBQVU7QUFDL0IsY0FBSSxJQUFJO0FBQ1Isc0JBQVksVUFBVSxXQUFZO0FBQ2hDO0FBQUE7QUFFRixpQkFBTztBQUFBO0FBZVQsaUNBQXlCLFVBQVUsYUFBYSxnQkFBZ0I7QUFDOUQsc0JBQVksVUFBVSxXQUFZO0FBQ2hDLHdCQUFZLE1BQU0sTUFBTTtBQUFBLGFBQ3ZCO0FBQUE7QUFVTCx5QkFBaUIsVUFBVTtBQUN6QixpQkFBTyxZQUFZLFVBQVUsU0FBVSxPQUFPO0FBQzVDLG1CQUFPO0FBQUEsZ0JBQ0g7QUFBQTtBQWtCUiwyQkFBbUIsVUFBVTtBQUMzQixjQUFJLENBQUMsZ0JBQWUsV0FBVztBQUM3QjtBQUNFLG9CQUFNLE1BQU87QUFBQTtBQUFBO0FBSWpCLGlCQUFPO0FBQUE7QUFHVCxnQ0FBdUIsY0FBYyxzQkFBc0I7QUFDekQsY0FBSSx5QkFBeUIsUUFBVztBQUN0QyxtQ0FBdUI7QUFBQSxpQkFDbEI7QUFDTDtBQUNFLGtCQUFJLHlCQUF5QixRQUFRLE9BQU8seUJBQXlCLFlBQVk7QUFDL0Usc0JBQU0sK0ZBQW9HO0FBQUE7QUFBQTtBQUFBO0FBS2hILGNBQUksVUFBVTtBQUFBLFlBQ1osVUFBVTtBQUFBLFlBQ1YsdUJBQXVCO0FBQUEsWUFNdkIsZUFBZTtBQUFBLFlBQ2YsZ0JBQWdCO0FBQUEsWUFHaEIsY0FBYztBQUFBLFlBRWQsVUFBVTtBQUFBLFlBQ1YsVUFBVTtBQUFBO0FBRVosa0JBQVEsV0FBVztBQUFBLFlBQ2pCLFVBQVU7QUFBQSxZQUNWLFVBQVU7QUFBQTtBQUVaLGNBQUksNENBQTRDO0FBQ2hELGNBQUksc0NBQXNDO0FBQzFDLGNBQUksc0NBQXNDO0FBRTFDO0FBSUUsZ0JBQUksV0FBVztBQUFBLGNBQ2IsVUFBVTtBQUFBLGNBQ1YsVUFBVTtBQUFBLGNBQ1YsdUJBQXVCLFFBQVE7QUFBQTtBQUdqQyxtQkFBTyxpQkFBaUIsVUFBVTtBQUFBLGNBQ2hDLFVBQVU7QUFBQSxnQkFDUixLQUFLLFdBQVk7QUFDZixzQkFBSSxDQUFDLHFDQUFxQztBQUN4QywwREFBc0M7QUFFdEMsMEJBQU07QUFBQTtBQUdSLHlCQUFPLFFBQVE7QUFBQTtBQUFBLGdCQUVqQixLQUFLLFNBQVUsV0FBVztBQUN4QiwwQkFBUSxXQUFXO0FBQUE7QUFBQTtBQUFBLGNBR3ZCLGVBQWU7QUFBQSxnQkFDYixLQUFLLFdBQVk7QUFDZix5QkFBTyxRQUFRO0FBQUE7QUFBQSxnQkFFakIsS0FBSyxTQUFVLGVBQWU7QUFDNUIsMEJBQVEsZ0JBQWdCO0FBQUE7QUFBQTtBQUFBLGNBRzVCLGdCQUFnQjtBQUFBLGdCQUNkLEtBQUssV0FBWTtBQUNmLHlCQUFPLFFBQVE7QUFBQTtBQUFBLGdCQUVqQixLQUFLLFNBQVUsZ0JBQWdCO0FBQzdCLDBCQUFRLGlCQUFpQjtBQUFBO0FBQUE7QUFBQSxjQUc3QixjQUFjO0FBQUEsZ0JBQ1osS0FBSyxXQUFZO0FBQ2YseUJBQU8sUUFBUTtBQUFBO0FBQUEsZ0JBRWpCLEtBQUssU0FBVSxjQUFjO0FBQzNCLDBCQUFRLGVBQWU7QUFBQTtBQUFBO0FBQUEsY0FHM0IsVUFBVTtBQUFBLGdCQUNSLEtBQUssV0FBWTtBQUNmLHNCQUFJLENBQUMsMkNBQTJDO0FBQzlDLGdFQUE0QztBQUU1QywwQkFBTTtBQUFBO0FBR1IseUJBQU8sUUFBUTtBQUFBO0FBQUE7QUFBQSxjQUduQixhQUFhO0FBQUEsZ0JBQ1gsS0FBSyxXQUFZO0FBQ2YseUJBQU8sUUFBUTtBQUFBO0FBQUEsZ0JBRWpCLEtBQUssU0FBVSxhQUFhO0FBQzFCLHNCQUFJLENBQUMscUNBQXFDO0FBQ3hDLHlCQUFLLHVJQUE0STtBQUVqSiwwREFBc0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU05QyxvQkFBUSxXQUFXO0FBQUE7QUFHckI7QUFDRSxvQkFBUSxtQkFBbUI7QUFDM0Isb0JBQVEsb0JBQW9CO0FBQUE7QUFHOUIsaUJBQU87QUFBQTtBQUdULFlBQUksZ0JBQWdCO0FBQ3BCLFlBQUksVUFBVTtBQUNkLFlBQUksV0FBVztBQUNmLFlBQUksV0FBVztBQUVmLGlDQUF5QixTQUFTO0FBQ2hDLGNBQUksUUFBUSxZQUFZLGVBQWU7QUFDckMsZ0JBQUksT0FBTyxRQUFRO0FBQ25CLGdCQUFJLFdBQVc7QUFFZixnQkFBSSxVQUFVO0FBQ2Qsb0JBQVEsVUFBVTtBQUNsQixvQkFBUSxVQUFVO0FBQ2xCLHFCQUFTLEtBQUssU0FBVSxjQUFjO0FBQ3BDLGtCQUFJLFFBQVEsWUFBWSxTQUFTO0FBQy9CLG9CQUFJLGdCQUFnQixhQUFhO0FBRWpDO0FBQ0Usc0JBQUksa0JBQWtCLFFBQVc7QUFDL0IsMEJBQU0seUtBQzBEO0FBQUE7QUFBQTtBQUtwRSxvQkFBSSxXQUFXO0FBQ2YseUJBQVMsVUFBVTtBQUNuQix5QkFBUyxVQUFVO0FBQUE7QUFBQSxlQUVwQixTQUFVLFFBQU87QUFDbEIsa0JBQUksUUFBUSxZQUFZLFNBQVM7QUFFL0Isb0JBQUksV0FBVztBQUNmLHlCQUFTLFVBQVU7QUFDbkIseUJBQVMsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUt6QixjQUFJLFFBQVEsWUFBWSxVQUFVO0FBQ2hDLG1CQUFPLFFBQVE7QUFBQSxpQkFDVjtBQUNMLGtCQUFNLFFBQVE7QUFBQTtBQUFBO0FBSWxCLHNCQUFjLE1BQU07QUFDbEIsY0FBSSxVQUFVO0FBQUEsWUFFWixTQUFTO0FBQUEsWUFDVCxTQUFTO0FBQUE7QUFFWCxjQUFJLFdBQVc7QUFBQSxZQUNiLFVBQVU7QUFBQSxZQUNWLFVBQVU7QUFBQSxZQUNWLE9BQU87QUFBQTtBQUdUO0FBRUUsZ0JBQUk7QUFDSixnQkFBSTtBQUVKLG1CQUFPLGlCQUFpQixVQUFVO0FBQUEsY0FDaEMsY0FBYztBQUFBLGdCQUNaLGNBQWM7QUFBQSxnQkFDZCxLQUFLLFdBQVk7QUFDZix5QkFBTztBQUFBO0FBQUEsZ0JBRVQsS0FBSyxTQUFVLGlCQUFpQjtBQUM5Qix3QkFBTTtBQUVOLGlDQUFlO0FBR2YseUJBQU8sZUFBZSxVQUFVLGdCQUFnQjtBQUFBLG9CQUM5QyxZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FJbEIsV0FBVztBQUFBLGdCQUNULGNBQWM7QUFBQSxnQkFDZCxLQUFLLFdBQVk7QUFDZix5QkFBTztBQUFBO0FBQUEsZ0JBRVQsS0FBSyxTQUFVLGNBQWM7QUFDM0Isd0JBQU07QUFFTiw4QkFBWTtBQUdaLHlCQUFPLGVBQWUsVUFBVSxhQUFhO0FBQUEsb0JBQzNDLFlBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT3RCLGlCQUFPO0FBQUE7QUFHVCw2QkFBb0IsUUFBUTtBQUMxQjtBQUNFLGdCQUFJLFVBQVUsUUFBUSxPQUFPLGFBQWEsaUJBQWlCO0FBQ3pELG9CQUFNO0FBQUEsdUJBQ0csT0FBTyxXQUFXLFlBQVk7QUFDdkMsb0JBQU0sMkRBQTJELFdBQVcsT0FBTyxTQUFTLE9BQU87QUFBQSxtQkFDOUY7QUFDTCxrQkFBSSxPQUFPLFdBQVcsS0FBSyxPQUFPLFdBQVcsR0FBRztBQUM5QyxzQkFBTSxnRkFBZ0YsT0FBTyxXQUFXLElBQUksNkNBQTZDO0FBQUE7QUFBQTtBQUk3SixnQkFBSSxVQUFVLE1BQU07QUFDbEIsa0JBQUksT0FBTyxnQkFBZ0IsUUFBUSxPQUFPLGFBQWEsTUFBTTtBQUMzRCxzQkFBTTtBQUFBO0FBQUE7QUFBQTtBQUtaLGNBQUksY0FBYztBQUFBLFlBQ2hCLFVBQVU7QUFBQSxZQUNWO0FBQUE7QUFHRjtBQUNFLGdCQUFJO0FBQ0osbUJBQU8sZUFBZSxhQUFhLGVBQWU7QUFBQSxjQUNoRCxZQUFZO0FBQUEsY0FDWixjQUFjO0FBQUEsY0FDZCxLQUFLLFdBQVk7QUFDZix1QkFBTztBQUFBO0FBQUEsY0FFVCxLQUFLLFNBQVUsTUFBTTtBQUNuQiwwQkFBVTtBQUVWLG9CQUFJLE9BQU8sZUFBZSxNQUFNO0FBQzlCLHlCQUFPLGNBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU03QixpQkFBTztBQUFBO0FBS1QsWUFBSSxpQkFBaUI7QUFFckIsb0NBQTRCLE1BQU07QUFDaEMsY0FBSSxPQUFPLFNBQVMsWUFBWSxPQUFPLFNBQVMsWUFBWTtBQUMxRCxtQkFBTztBQUFBO0FBSVQsY0FBSSxTQUFTLFFBQVEsWUFBWSxTQUFTLFFBQVEsWUFBWSxTQUFTLGlDQUFpQyxTQUFTLFFBQVEsY0FBYyxTQUFTLFFBQVEsWUFBWSxTQUFTLDRCQUE0QixTQUFTLDRCQUE0QixnQkFBaUI7QUFDN1AsbUJBQU87QUFBQTtBQUdULGNBQUksT0FBTyxTQUFTLFlBQVksU0FBUyxNQUFNO0FBQzdDLGdCQUFJLEtBQUssYUFBYSxtQkFBbUIsS0FBSyxhQUFhLG1CQUFtQixLQUFLLGFBQWEsdUJBQXVCLEtBQUssYUFBYSxzQkFBc0IsS0FBSyxhQUFhLDBCQUEwQixLQUFLLGFBQWEsMEJBQTBCLEtBQUssYUFBYSxvQkFBb0IsS0FBSyxPQUFPLHlCQUF5QjtBQUNoVSxxQkFBTztBQUFBO0FBQUE7QUFJWCxpQkFBTztBQUFBO0FBR1Qsc0JBQWMsTUFBTSxVQUFTO0FBQzNCO0FBQ0UsZ0JBQUksQ0FBQyxtQkFBbUIsT0FBTztBQUM3QixvQkFBTSxzRUFBMkUsU0FBUyxPQUFPLFNBQVMsT0FBTztBQUFBO0FBQUE7QUFJckgsY0FBSSxjQUFjO0FBQUEsWUFDaEIsVUFBVTtBQUFBLFlBQ1Y7QUFBQSxZQUNBLFNBQVMsYUFBWSxTQUFZLE9BQU87QUFBQTtBQUcxQztBQUNFLGdCQUFJO0FBQ0osbUJBQU8sZUFBZSxhQUFhLGVBQWU7QUFBQSxjQUNoRCxZQUFZO0FBQUEsY0FDWixjQUFjO0FBQUEsY0FDZCxLQUFLLFdBQVk7QUFDZix1QkFBTztBQUFBO0FBQUEsY0FFVCxLQUFLLFNBQVUsTUFBTTtBQUNuQiwwQkFBVTtBQUVWLG9CQUFJLEtBQUssZUFBZSxNQUFNO0FBQzVCLHVCQUFLLGNBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU0zQixpQkFBTztBQUFBO0FBR1QscUNBQTZCO0FBQzNCLGNBQUksYUFBYSx1QkFBdUI7QUFFeEMsY0FBSSxDQUFFLGdCQUFlLE9BQU87QUFDMUI7QUFDRSxvQkFBTSxNQUFPO0FBQUE7QUFBQTtBQUlqQixpQkFBTztBQUFBO0FBR1QsNkJBQW9CLFNBQVMsdUJBQXVCO0FBQ2xELGNBQUksYUFBYTtBQUVqQjtBQUNFLGdCQUFJLDBCQUEwQixRQUFXO0FBQ3ZDLG9CQUFNLG9IQUE4SCx1QkFBdUIsT0FBTywwQkFBMEIsWUFBWSxNQUFNLFFBQVEsVUFBVSxNQUFNLGdKQUEwSjtBQUFBO0FBSWxZLGdCQUFJLFFBQVEsYUFBYSxRQUFXO0FBQ2xDLGtCQUFJLGNBQWMsUUFBUTtBQUcxQixrQkFBSSxZQUFZLGFBQWEsU0FBUztBQUNwQyxzQkFBTTtBQUFBLHlCQUNHLFlBQVksYUFBYSxTQUFTO0FBQzNDLHNCQUFNO0FBQUE7QUFBQTtBQUFBO0FBS1osaUJBQU8sV0FBVyxXQUFXLFNBQVM7QUFBQTtBQUV4QywyQkFBa0IsY0FBYztBQUM5QixjQUFJLGFBQWE7QUFDakIsaUJBQU8sV0FBVyxTQUFTO0FBQUE7QUFFN0IsNEJBQW9CLFNBQVMsWUFBWSxPQUFNO0FBQzdDLGNBQUksYUFBYTtBQUNqQixpQkFBTyxXQUFXLFdBQVcsU0FBUyxZQUFZO0FBQUE7QUFFcEQseUJBQWdCLGNBQWM7QUFDNUIsY0FBSSxhQUFhO0FBQ2pCLGlCQUFPLFdBQVcsT0FBTztBQUFBO0FBRTNCLDRCQUFtQixRQUFRLE1BQU07QUFDL0IsY0FBSSxhQUFhO0FBQ2pCLGlCQUFPLFdBQVcsVUFBVSxRQUFRO0FBQUE7QUFFdEMsa0NBQXlCLFFBQVEsTUFBTTtBQUNyQyxjQUFJLGFBQWE7QUFDakIsaUJBQU8sV0FBVyxnQkFBZ0IsUUFBUTtBQUFBO0FBRTVDLDhCQUFxQixVQUFVLE1BQU07QUFDbkMsY0FBSSxhQUFhO0FBQ2pCLGlCQUFPLFdBQVcsWUFBWSxVQUFVO0FBQUE7QUFFMUMsMEJBQWlCLFFBQVEsTUFBTTtBQUM3QixjQUFJLGFBQWE7QUFDakIsaUJBQU8sV0FBVyxRQUFRLFFBQVE7QUFBQTtBQUVwQyxxQ0FBNkIsS0FBSyxRQUFRLE1BQU07QUFDOUMsY0FBSSxhQUFhO0FBQ2pCLGlCQUFPLFdBQVcsb0JBQW9CLEtBQUssUUFBUTtBQUFBO0FBRXJELCtCQUF1QixPQUFPLGFBQWE7QUFDekM7QUFDRSxnQkFBSSxhQUFhO0FBQ2pCLG1CQUFPLFdBQVcsY0FBYyxPQUFPO0FBQUE7QUFBQTtBQVEzQyxZQUFJLGdCQUFnQjtBQUNwQixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUk7QUFDSixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUk7QUFDSixZQUFJO0FBRUosK0JBQXVCO0FBQUE7QUFFdkIsb0JBQVkscUJBQXFCO0FBQ2pDLCtCQUF1QjtBQUNyQjtBQUNFLGdCQUFJLGtCQUFrQixHQUFHO0FBRXZCLHdCQUFVLFFBQVE7QUFDbEIseUJBQVcsUUFBUTtBQUNuQix5QkFBVyxRQUFRO0FBQ25CLDBCQUFZLFFBQVE7QUFDcEIsMEJBQVksUUFBUTtBQUNwQixtQ0FBcUIsUUFBUTtBQUM3Qiw2QkFBZSxRQUFRO0FBRXZCLGtCQUFJLFFBQVE7QUFBQSxnQkFDVixjQUFjO0FBQUEsZ0JBQ2QsWUFBWTtBQUFBLGdCQUNaLE9BQU87QUFBQSxnQkFDUCxVQUFVO0FBQUE7QUFHWixxQkFBTyxpQkFBaUIsU0FBUztBQUFBLGdCQUMvQixNQUFNO0FBQUEsZ0JBQ04sS0FBSztBQUFBLGdCQUNMLE1BQU07QUFBQSxnQkFDTixPQUFPO0FBQUEsZ0JBQ1AsT0FBTztBQUFBLGdCQUNQLGdCQUFnQjtBQUFBLGdCQUNoQixVQUFVO0FBQUE7QUFBQTtBQUtkO0FBQUE7QUFBQTtBQUdKLGdDQUF3QjtBQUN0QjtBQUNFO0FBRUEsZ0JBQUksa0JBQWtCLEdBQUc7QUFFdkIsa0JBQUksUUFBUTtBQUFBLGdCQUNWLGNBQWM7QUFBQSxnQkFDZCxZQUFZO0FBQUEsZ0JBQ1osVUFBVTtBQUFBO0FBR1oscUJBQU8saUJBQWlCLFNBQVM7QUFBQSxnQkFDL0IsS0FBSyxRQUFRLElBQUksT0FBTztBQUFBLGtCQUN0QixPQUFPO0FBQUE7QUFBQSxnQkFFVCxNQUFNLFFBQVEsSUFBSSxPQUFPO0FBQUEsa0JBQ3ZCLE9BQU87QUFBQTtBQUFBLGdCQUVULE1BQU0sUUFBUSxJQUFJLE9BQU87QUFBQSxrQkFDdkIsT0FBTztBQUFBO0FBQUEsZ0JBRVQsT0FBTyxRQUFRLElBQUksT0FBTztBQUFBLGtCQUN4QixPQUFPO0FBQUE7QUFBQSxnQkFFVCxPQUFPLFFBQVEsSUFBSSxPQUFPO0FBQUEsa0JBQ3hCLE9BQU87QUFBQTtBQUFBLGdCQUVULGdCQUFnQixRQUFRLElBQUksT0FBTztBQUFBLGtCQUNqQyxPQUFPO0FBQUE7QUFBQSxnQkFFVCxVQUFVLFFBQVEsSUFBSSxPQUFPO0FBQUEsa0JBQzNCLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFNYixnQkFBSSxnQkFBZ0IsR0FBRztBQUNyQixvQkFBTTtBQUFBO0FBQUE7QUFBQTtBQUtaLFlBQUksMkJBQTJCLHFCQUFxQjtBQUNwRCxZQUFJO0FBQ0osK0NBQXVDLE1BQU0sUUFBUSxTQUFTO0FBQzVEO0FBQ0UsZ0JBQUksV0FBVyxRQUFXO0FBRXhCLGtCQUFJO0FBQ0Ysc0JBQU07QUFBQSx1QkFDQyxHQUFQO0FBQ0Esb0JBQUksUUFBUSxFQUFFLE1BQU0sT0FBTyxNQUFNO0FBQ2pDLHlCQUFTLFNBQVMsTUFBTSxNQUFNO0FBQUE7QUFBQTtBQUtsQyxtQkFBTyxPQUFPLFNBQVM7QUFBQTtBQUFBO0FBRzNCLFlBQUksVUFBVTtBQUNkLFlBQUk7QUFFSjtBQUNFLGNBQUksa0JBQWtCLE9BQU8sWUFBWSxhQUFhLFVBQVU7QUFDaEUsZ0NBQXNCLElBQUk7QUFBQTtBQUc1Qiw4Q0FBc0MsSUFBSSxXQUFXO0FBRW5ELGNBQUksQ0FBQyxNQUFNLFNBQVM7QUFDbEIsbUJBQU87QUFBQTtBQUdUO0FBQ0UsZ0JBQUksUUFBUSxvQkFBb0IsSUFBSTtBQUVwQyxnQkFBSSxVQUFVLFFBQVc7QUFDdkIscUJBQU87QUFBQTtBQUFBO0FBSVgsY0FBSTtBQUNKLG9CQUFVO0FBQ1YsY0FBSSw0QkFBNEIsTUFBTTtBQUV0QyxnQkFBTSxvQkFBb0I7QUFDMUIsY0FBSTtBQUVKO0FBQ0UsaUNBQXFCLHlCQUF5QjtBQUc5QyxxQ0FBeUIsVUFBVTtBQUNuQztBQUFBO0FBR0YsY0FBSTtBQUVGLGdCQUFJLFdBQVc7QUFFYixrQkFBSSxPQUFPLFdBQVk7QUFDckIsc0JBQU07QUFBQTtBQUlSLHFCQUFPLGVBQWUsS0FBSyxXQUFXLFNBQVM7QUFBQSxnQkFDN0MsS0FBSyxXQUFZO0FBR2Ysd0JBQU07QUFBQTtBQUFBO0FBSVYsa0JBQUksT0FBTyxZQUFZLFlBQVksUUFBUSxXQUFXO0FBR3BELG9CQUFJO0FBQ0YsMEJBQVEsVUFBVSxNQUFNO0FBQUEseUJBQ2pCLEdBQVA7QUFDQSw0QkFBVTtBQUFBO0FBR1osd0JBQVEsVUFBVSxJQUFJLElBQUk7QUFBQSxxQkFDckI7QUFDTCxvQkFBSTtBQUNGLHVCQUFLO0FBQUEseUJBQ0UsR0FBUDtBQUNBLDRCQUFVO0FBQUE7QUFHWixtQkFBRyxLQUFLLEtBQUs7QUFBQTtBQUFBLG1CQUVWO0FBQ0wsa0JBQUk7QUFDRixzQkFBTTtBQUFBLHVCQUNDLEdBQVA7QUFDQSwwQkFBVTtBQUFBO0FBR1o7QUFBQTtBQUFBLG1CQUVLLFFBQVA7QUFFQSxnQkFBSSxVQUFVLFdBQVcsT0FBTyxPQUFPLFVBQVUsVUFBVTtBQUd6RCxrQkFBSSxjQUFjLE9BQU8sTUFBTSxNQUFNO0FBQ3JDLGtCQUFJLGVBQWUsUUFBUSxNQUFNLE1BQU07QUFDdkMsa0JBQUksSUFBSSxZQUFZLFNBQVM7QUFDN0Isa0JBQUksSUFBSSxhQUFhLFNBQVM7QUFFOUIscUJBQU8sS0FBSyxLQUFLLEtBQUssS0FBSyxZQUFZLE9BQU8sYUFBYSxJQUFJO0FBTzdEO0FBQUE7QUFHRixxQkFBTyxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSztBQUdqQyxvQkFBSSxZQUFZLE9BQU8sYUFBYSxJQUFJO0FBTXRDLHNCQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDdEIsdUJBQUc7QUFDRDtBQUNBO0FBR0EsMEJBQUksSUFBSSxLQUFLLFlBQVksT0FBTyxhQUFhLElBQUk7QUFFL0MsNEJBQUksU0FBUyxPQUFPLFlBQVksR0FBRyxRQUFRLFlBQVk7QUFFdkQ7QUFDRSw4QkFBSSxPQUFPLE9BQU8sWUFBWTtBQUM1QixnREFBb0IsSUFBSSxJQUFJO0FBQUE7QUFBQTtBQUtoQywrQkFBTztBQUFBO0FBQUEsNkJBRUYsS0FBSyxLQUFLLEtBQUs7QUFBQTtBQUcxQjtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUlOO0FBQ0Esc0JBQVU7QUFFVjtBQUNFLHVDQUF5QixVQUFVO0FBQ25DO0FBQUE7QUFHRixrQkFBTSxvQkFBb0I7QUFBQTtBQUk1QixjQUFJLE9BQU8sS0FBSyxHQUFHLGVBQWUsR0FBRyxPQUFPO0FBQzVDLGNBQUksaUJBQWlCLE9BQU8sOEJBQThCLFFBQVE7QUFFbEU7QUFDRSxnQkFBSSxPQUFPLE9BQU8sWUFBWTtBQUM1QixrQ0FBb0IsSUFBSSxJQUFJO0FBQUE7QUFBQTtBQUloQyxpQkFBTztBQUFBO0FBRVQsZ0RBQXdDLElBQUksUUFBUSxTQUFTO0FBQzNEO0FBQ0UsbUJBQU8sNkJBQTZCLElBQUk7QUFBQTtBQUFBO0FBSTVDLGlDQUF5QixZQUFXO0FBQ2xDLGNBQUksWUFBWSxXQUFVO0FBQzFCLGlCQUFPLENBQUMsQ0FBRSxjQUFhLFVBQVU7QUFBQTtBQUduQyxzREFBOEMsTUFBTSxRQUFRLFNBQVM7QUFFbkUsY0FBSSxRQUFRLE1BQU07QUFDaEIsbUJBQU87QUFBQTtBQUdULGNBQUksT0FBTyxTQUFTLFlBQVk7QUFDOUI7QUFDRSxxQkFBTyw2QkFBNkIsTUFBTSxnQkFBZ0I7QUFBQTtBQUFBO0FBSTlELGNBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsbUJBQU8sOEJBQThCO0FBQUE7QUFHdkMsa0JBQVE7QUFBQSxpQkFDRCxRQUFRO0FBQ1gscUJBQU8sOEJBQThCO0FBQUEsaUJBRWxDO0FBQ0gscUJBQU8sOEJBQThCO0FBQUE7QUFHekMsY0FBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixvQkFBUSxLQUFLO0FBQUEsbUJBQ047QUFDSCx1QkFBTywrQkFBK0IsS0FBSztBQUFBLG1CQUV4QztBQUVILHVCQUFPLHFDQUFxQyxLQUFLLE1BQU0sUUFBUTtBQUFBLG1CQUU1RDtBQUNILHVCQUFPLCtCQUErQixLQUFLO0FBQUEsbUJBRXhDLGlCQUNIO0FBQ0Usb0JBQUksZ0JBQWdCO0FBQ3BCLG9CQUFJLFVBQVUsY0FBYztBQUM1QixvQkFBSSxRQUFPLGNBQWM7QUFFekIsb0JBQUk7QUFFRix5QkFBTyxxQ0FBcUMsTUFBSyxVQUFVLFFBQVE7QUFBQSx5QkFDNUQsR0FBUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS1YsaUJBQU87QUFBQTtBQUdULFlBQUkscUJBQXFCO0FBQ3pCLFlBQUksMkJBQTJCLHFCQUFxQjtBQUVwRCwrQ0FBdUMsU0FBUztBQUM5QztBQUNFLGdCQUFJLFNBQVM7QUFDWCxrQkFBSSxRQUFRLFFBQVE7QUFDcEIsa0JBQUksUUFBUSxxQ0FBcUMsUUFBUSxNQUFNLFFBQVEsU0FBUyxRQUFRLE1BQU0sT0FBTztBQUNyRyx1Q0FBeUIsbUJBQW1CO0FBQUEsbUJBQ3ZDO0FBQ0wsdUNBQXlCLG1CQUFtQjtBQUFBO0FBQUE7QUFBQTtBQUtsRCxnQ0FBd0IsV0FBVyxRQUFRLFVBQVUsZUFBZSxTQUFTO0FBQzNFO0FBRUUsZ0JBQUksTUFBTSxTQUFTLEtBQUssS0FBSyxPQUFPLFVBQVU7QUFFOUMscUJBQVMsZ0JBQWdCLFdBQVc7QUFDbEMsa0JBQUksSUFBSSxXQUFXLGVBQWU7QUFDaEMsb0JBQUksVUFBVTtBQUlkLG9CQUFJO0FBR0Ysc0JBQUksT0FBTyxVQUFVLGtCQUFrQixZQUFZO0FBQ2pELHdCQUFJLE1BQU0sTUFBTyxrQkFBaUIsaUJBQWlCLE9BQU8sV0FBVyxZQUFZLGVBQWUsK0ZBQW9HLE9BQU8sVUFBVSxnQkFBZ0I7QUFDck8sd0JBQUksT0FBTztBQUNYLDBCQUFNO0FBQUE7QUFHUiw0QkFBVSxVQUFVLGNBQWMsUUFBUSxjQUFjLGVBQWUsVUFBVSxNQUFNO0FBQUEseUJBQ2hGLElBQVA7QUFDQSw0QkFBVTtBQUFBO0FBR1osb0JBQUksV0FBVyxDQUFFLG9CQUFtQixRQUFRO0FBQzFDLGdEQUE4QjtBQUU5Qix3QkFBTSw0UkFBcVQsaUJBQWlCLGVBQWUsVUFBVSxjQUFjLE9BQU87QUFFMVgsZ0RBQThCO0FBQUE7QUFHaEMsb0JBQUksbUJBQW1CLFNBQVMsQ0FBRSxTQUFRLFdBQVcscUJBQXFCO0FBR3hFLHFDQUFtQixRQUFRLFdBQVc7QUFDdEMsZ0RBQThCO0FBRTlCLHdCQUFNLHNCQUFzQixVQUFVLFFBQVE7QUFFOUMsZ0RBQThCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU94QyxpREFBeUMsU0FBUztBQUNoRDtBQUNFLGdCQUFJLFNBQVM7QUFDWCxrQkFBSSxRQUFRLFFBQVE7QUFDcEIsa0JBQUksUUFBUSxxQ0FBcUMsUUFBUSxNQUFNLFFBQVEsU0FBUyxRQUFRLE1BQU0sT0FBTztBQUNyRyxpQ0FBbUI7QUFBQSxtQkFDZDtBQUNMLGlDQUFtQjtBQUFBO0FBQUE7QUFBQTtBQUt6QixZQUFJO0FBRUo7QUFDRSwwQ0FBZ0M7QUFBQTtBQUdsQywrQ0FBdUM7QUFDckMsY0FBSSxrQkFBa0IsU0FBUztBQUM3QixnQkFBSSxPQUFPLGlCQUFpQixrQkFBa0IsUUFBUTtBQUV0RCxnQkFBSSxNQUFNO0FBQ1IscUJBQU8scUNBQXFDLE9BQU87QUFBQTtBQUFBO0FBSXZELGlCQUFPO0FBQUE7QUFHVCw0Q0FBb0MsUUFBUTtBQUMxQyxjQUFJLFdBQVcsUUFBVztBQUN4QixnQkFBSSxXQUFXLE9BQU8sU0FBUyxRQUFRLGFBQWE7QUFDcEQsZ0JBQUksYUFBYSxPQUFPO0FBQ3hCLG1CQUFPLDRCQUE0QixXQUFXLE1BQU0sYUFBYTtBQUFBO0FBR25FLGlCQUFPO0FBQUE7QUFHVCxvREFBNEMsY0FBYztBQUN4RCxjQUFJLGlCQUFpQixRQUFRLGlCQUFpQixRQUFXO0FBQ3ZELG1CQUFPLDJCQUEyQixhQUFhO0FBQUE7QUFHakQsaUJBQU87QUFBQTtBQVNULFlBQUksd0JBQXdCO0FBRTVCLDhDQUFzQyxZQUFZO0FBQ2hELGNBQUksT0FBTztBQUVYLGNBQUksQ0FBQyxNQUFNO0FBQ1QsZ0JBQUksYUFBYSxPQUFPLGVBQWUsV0FBVyxhQUFhLFdBQVcsZUFBZSxXQUFXO0FBRXBHLGdCQUFJLFlBQVk7QUFDZCxxQkFBTyxnREFBZ0QsYUFBYTtBQUFBO0FBQUE7QUFJeEUsaUJBQU87QUFBQTtBQWVULHFDQUE2QixTQUFTLFlBQVk7QUFDaEQsY0FBSSxDQUFDLFFBQVEsVUFBVSxRQUFRLE9BQU8sYUFBYSxRQUFRLE9BQU8sTUFBTTtBQUN0RTtBQUFBO0FBR0Ysa0JBQVEsT0FBTyxZQUFZO0FBQzNCLGNBQUksNEJBQTRCLDZCQUE2QjtBQUU3RCxjQUFJLHNCQUFzQiw0QkFBNEI7QUFDcEQ7QUFBQTtBQUdGLGdDQUFzQiw2QkFBNkI7QUFJbkQsY0FBSSxhQUFhO0FBRWpCLGNBQUksV0FBVyxRQUFRLFVBQVUsUUFBUSxXQUFXLGtCQUFrQixTQUFTO0FBRTdFLHlCQUFhLGlDQUFpQyxpQkFBaUIsUUFBUSxPQUFPLFFBQVE7QUFBQTtBQUd4RjtBQUNFLDRDQUFnQztBQUVoQyxrQkFBTSw2SEFBa0ksMkJBQTJCO0FBRW5LLDRDQUFnQztBQUFBO0FBQUE7QUFjcEMsbUNBQTJCLE1BQU0sWUFBWTtBQUMzQyxjQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCO0FBQUE7QUFHRixjQUFJLE1BQU0sUUFBUSxPQUFPO0FBQ3ZCLHFCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLGtCQUFJLFFBQVEsS0FBSztBQUVqQixrQkFBSSxnQkFBZSxRQUFRO0FBQ3pCLG9DQUFvQixPQUFPO0FBQUE7QUFBQTtBQUFBLHFCQUd0QixnQkFBZSxPQUFPO0FBRS9CLGdCQUFJLEtBQUssUUFBUTtBQUNmLG1CQUFLLE9BQU8sWUFBWTtBQUFBO0FBQUEscUJBRWpCLE1BQU07QUFDZixnQkFBSSxhQUFhLGNBQWM7QUFFL0IsZ0JBQUksT0FBTyxlQUFlLFlBQVk7QUFHcEMsa0JBQUksZUFBZSxLQUFLLFNBQVM7QUFDL0Isb0JBQUksV0FBVyxXQUFXLEtBQUs7QUFDL0Isb0JBQUk7QUFFSix1QkFBTyxDQUFFLFFBQU8sU0FBUyxRQUFRLE1BQU07QUFDckMsc0JBQUksZ0JBQWUsS0FBSyxRQUFRO0FBQzlCLHdDQUFvQixLQUFLLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFlNUMsbUNBQTJCLFNBQVM7QUFDbEM7QUFDRSxnQkFBSSxPQUFPLFFBQVE7QUFFbkIsZ0JBQUksU0FBUyxRQUFRLFNBQVMsVUFBYSxPQUFPLFNBQVMsVUFBVTtBQUNuRTtBQUFBO0FBR0YsZ0JBQUk7QUFFSixnQkFBSSxPQUFPLFNBQVMsWUFBWTtBQUM5QiwwQkFBWSxLQUFLO0FBQUEsdUJBQ1IsT0FBTyxTQUFTLFlBQWEsTUFBSyxhQUFhLDBCQUUxRCxLQUFLLGFBQWEsa0JBQWtCO0FBQ2xDLDBCQUFZLEtBQUs7QUFBQSxtQkFDWjtBQUNMO0FBQUE7QUFHRixnQkFBSSxXQUFXO0FBRWIsa0JBQUksT0FBTyxpQkFBaUI7QUFDNUIsNkJBQWUsV0FBVyxRQUFRLE9BQU8sUUFBUSxNQUFNO0FBQUEsdUJBQzlDLEtBQUssY0FBYyxVQUFhLENBQUMsK0JBQStCO0FBQ3pFLDhDQUFnQztBQUVoQyxrQkFBSSxRQUFRLGlCQUFpQjtBQUU3QixvQkFBTSx1R0FBdUcsU0FBUztBQUFBO0FBR3hILGdCQUFJLE9BQU8sS0FBSyxvQkFBb0IsY0FBYyxDQUFDLEtBQUssZ0JBQWdCLHNCQUFzQjtBQUM1RixvQkFBTTtBQUFBO0FBQUE7QUFBQTtBQVVaLHVDQUErQixVQUFVO0FBQ3ZDO0FBQ0UsZ0JBQUksUUFBTyxPQUFPLEtBQUssU0FBUztBQUVoQyxxQkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFLLFFBQVEsS0FBSztBQUNwQyxrQkFBSSxNQUFNLE1BQUs7QUFFZixrQkFBSSxRQUFRLGNBQWMsUUFBUSxPQUFPO0FBQ3ZDLGdEQUFnQztBQUVoQyxzQkFBTSw0R0FBaUg7QUFFdkgsZ0RBQWdDO0FBQ2hDO0FBQUE7QUFBQTtBQUlKLGdCQUFJLFNBQVMsUUFBUSxNQUFNO0FBQ3pCLDhDQUFnQztBQUVoQyxvQkFBTTtBQUVOLDhDQUFnQztBQUFBO0FBQUE7QUFBQTtBQUl0Qyw2Q0FBcUMsTUFBTSxPQUFPLFVBQVU7QUFDMUQsY0FBSSxZQUFZLG1CQUFtQjtBQUduQyxjQUFJLENBQUMsV0FBVztBQUNkLGdCQUFJLE9BQU87QUFFWCxnQkFBSSxTQUFTLFVBQWEsT0FBTyxTQUFTLFlBQVksU0FBUyxRQUFRLE9BQU8sS0FBSyxNQUFNLFdBQVcsR0FBRztBQUNyRyxzQkFBUTtBQUFBO0FBR1YsZ0JBQUksYUFBYSxtQ0FBbUM7QUFFcEQsZ0JBQUksWUFBWTtBQUNkLHNCQUFRO0FBQUEsbUJBQ0g7QUFDTCxzQkFBUTtBQUFBO0FBR1YsZ0JBQUk7QUFFSixnQkFBSSxTQUFTLE1BQU07QUFDakIsMkJBQWE7QUFBQSx1QkFDSixNQUFNLFFBQVEsT0FBTztBQUM5QiwyQkFBYTtBQUFBLHVCQUNKLFNBQVMsVUFBYSxLQUFLLGFBQWEsb0JBQW9CO0FBQ3JFLDJCQUFhLE1BQU8sa0JBQWlCLEtBQUssU0FBUyxhQUFhO0FBQ2hFLHFCQUFPO0FBQUEsbUJBQ0Y7QUFDTCwyQkFBYSxPQUFPO0FBQUE7QUFHdEI7QUFDRSxvQkFBTSxxSkFBK0osWUFBWTtBQUFBO0FBQUE7QUFJckwsY0FBSSxVQUFVLGVBQWMsTUFBTSxNQUFNO0FBR3hDLGNBQUksV0FBVyxNQUFNO0FBQ25CLG1CQUFPO0FBQUE7QUFRVCxjQUFJLFdBQVc7QUFDYixxQkFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLFFBQVEsS0FBSztBQUN6QyxnQ0FBa0IsVUFBVSxJQUFJO0FBQUE7QUFBQTtBQUlwQyxjQUFJLFNBQVMsUUFBUSxVQUFVO0FBQzdCLGtDQUFzQjtBQUFBLGlCQUNqQjtBQUNMLDhCQUFrQjtBQUFBO0FBR3BCLGlCQUFPO0FBQUE7QUFFVCxZQUFJLHNDQUFzQztBQUMxQyw2Q0FBcUMsTUFBTTtBQUN6QyxjQUFJLG1CQUFtQiw0QkFBNEIsS0FBSyxNQUFNO0FBQzlELDJCQUFpQixPQUFPO0FBRXhCO0FBQ0UsZ0JBQUksQ0FBQyxxQ0FBcUM7QUFDeEMsb0RBQXNDO0FBRXRDLG1CQUFLO0FBQUE7QUFJUCxtQkFBTyxlQUFlLGtCQUFrQixRQUFRO0FBQUEsY0FDOUMsWUFBWTtBQUFBLGNBQ1osS0FBSyxXQUFZO0FBQ2YscUJBQUs7QUFFTCx1QkFBTyxlQUFlLE1BQU0sUUFBUTtBQUFBLGtCQUNsQyxPQUFPO0FBQUE7QUFFVCx1QkFBTztBQUFBO0FBQUE7QUFBQTtBQUtiLGlCQUFPO0FBQUE7QUFFVCw0Q0FBb0MsU0FBUyxPQUFPLFVBQVU7QUFDNUQsY0FBSSxhQUFhLGFBQWEsTUFBTSxNQUFNO0FBRTFDLG1CQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3pDLDhCQUFrQixVQUFVLElBQUksV0FBVztBQUFBO0FBRzdDLDRCQUFrQjtBQUNsQixpQkFBTztBQUFBO0FBR1Q7QUFFRSxjQUFJO0FBQ0YsZ0JBQUksZUFBZSxPQUFPLE9BQU87QUFHakMsZ0JBQUksSUFBSSxDQUFDLENBQUMsY0FBYztBQUN4QixnQkFBSSxJQUFJLENBQUM7QUFBQSxtQkFFRixHQUFQO0FBQUE7QUFBQTtBQUlKLFlBQUksa0JBQW1CO0FBQ3ZCLFlBQUksaUJBQWtCO0FBQ3RCLFlBQUksZ0JBQWlCO0FBQ3JCLFlBQUksWUFBVztBQUFBLFVBQ2IsS0FBSztBQUFBLFVBQ0wsU0FBUztBQUFBLFVBQ1QsT0FBTztBQUFBLFVBQ1A7QUFBQSxVQUNBLE1BQU07QUFBQTtBQUdSLGdCQUFRLFdBQVc7QUFDbkIsZ0JBQVEsWUFBWTtBQUNwQixnQkFBUSxnQkFBZ0I7QUFDeEIsZ0JBQVEscURBQXFEO0FBQzdELGdCQUFRLGVBQWU7QUFDdkIsZ0JBQVEsZ0JBQWdCO0FBQ3hCLGdCQUFRLGdCQUFnQjtBQUN4QixnQkFBUSxnQkFBZ0I7QUFDeEIsZ0JBQVEsWUFBWTtBQUNwQixnQkFBUSxhQUFhO0FBQ3JCLGdCQUFRLGlCQUFpQjtBQUN6QixnQkFBUSxPQUFPO0FBQ2YsZ0JBQVEsT0FBTztBQUNmLGdCQUFRLGNBQWM7QUFDdEIsZ0JBQVEsYUFBYTtBQUNyQixnQkFBUSxnQkFBZ0I7QUFDeEIsZ0JBQVEsWUFBWTtBQUNwQixnQkFBUSxzQkFBc0I7QUFDOUIsZ0JBQVEsa0JBQWtCO0FBQzFCLGdCQUFRLFVBQVU7QUFDbEIsZ0JBQVEsYUFBYTtBQUNyQixnQkFBUSxTQUFTO0FBQ2pCLGdCQUFRLFdBQVc7QUFDbkIsZ0JBQVEsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUMxeEVsQjtBQUFBO0FBQUE7QUFBQTtBQUVBLFFBQUksT0FBdUM7QUFDekMsYUFBTyxVQUFVO0FBQUEsV0FDWjtBQUNMLGFBQU8sVUFBVTtBQUFBO0FBQUE7QUFBQTs7O0FDTG5CO0FBQUE7QUFBQTtBQUFBLFlBQXVCO0FBQUE7QUFBQTs7O0FDQXZCO0FBQUE7QUFBQTtBQUFBO0FBRUEsUUFBSSxzQkFBc0I7QUFBQSxNQUN4QixjQUFjO0FBQUEsTUFDZCxLQUFLO0FBQUEsTUFDTCxRQUFRO0FBQUE7QUFHViw4QkFBMEIsS0FBSztBQUM3QixhQUFPLE9BQU8sUUFBUSxZQUFZLENBQUMsQ0FBQyxJQUFJO0FBQUE7QUFHMUMseUJBQXFCLGdCQUFnQixVQUFTO0FBQzVDLFVBQUksUUFBUSxlQUFlLE1BQU0sS0FBSyxPQUFPO0FBQzdDLFVBQUksWUFBWSxNQUFNLFFBQVEsTUFBTTtBQUNwQyxVQUFJLE9BQU8sVUFBVTtBQUNyQixVQUFJLFFBQVEsVUFBVSxLQUFLO0FBRTNCLGlCQUFVLFdBQ04sT0FBTyxPQUFPLElBQUkscUJBQXFCLFlBQ3ZDO0FBRUosVUFBSTtBQUNGLGdCQUFRLFNBQVEsZUFBZSxtQkFBbUIsU0FBUztBQUFBLGVBQ3BELEdBQVA7QUFDQSxnQkFBUSxNQUNOLGdGQUNFLFFBQ0EsaUVBQ0Y7QUFBQTtBQUlKLFVBQUksU0FBUztBQUFBLFFBQ1g7QUFBQSxRQUNBO0FBQUE7QUFHRixZQUFNLFFBQVEsU0FBVSxNQUFNO0FBQzVCLFlBQUksUUFBUSxLQUFLLE1BQU07QUFDdkIsWUFBSSxNQUFNLE1BQU0sUUFBUSxXQUFXO0FBQ25DLFlBQUksU0FBUSxNQUFNLEtBQUs7QUFDdkIsWUFBSSxRQUFRLFdBQVc7QUFDckIsaUJBQU8sVUFBVSxJQUFJLEtBQUs7QUFBQSxtQkFDakIsUUFBUSxXQUFXO0FBQzVCLGlCQUFPLFNBQVMsU0FBUyxRQUFPO0FBQUEsbUJBQ3ZCLFFBQVEsVUFBVTtBQUMzQixpQkFBTyxTQUFTO0FBQUEsbUJBQ1AsUUFBUSxZQUFZO0FBQzdCLGlCQUFPLFdBQVc7QUFBQSxtQkFDVCxRQUFRLFlBQVk7QUFDN0IsaUJBQU8sV0FBVztBQUFBLGVBQ2I7QUFDTCxpQkFBTyxPQUFPO0FBQUE7QUFBQTtBQUlsQixhQUFPO0FBQUE7QUFHVCxtQkFBZSxPQUFPLFVBQVM7QUFDN0IsaUJBQVUsV0FDTixPQUFPLE9BQU8sSUFBSSxxQkFBcUIsWUFDdkM7QUFFSixVQUFJLENBQUMsT0FBTztBQUNWLFlBQUksQ0FBQyxTQUFRLEtBQUs7QUFDaEIsaUJBQU87QUFBQSxlQUNGO0FBQ0wsaUJBQU87QUFBQTtBQUFBO0FBSVgsVUFBSSxNQUFNLFdBQVcsTUFBTSxRQUFRLGVBQWU7QUFFaEQsZ0JBQVEsTUFBTSxRQUFRO0FBQUEsaUJBQ2IsTUFBTSxTQUFTO0FBRXhCLFlBQUksTUFDRixNQUFNLFFBQ0osT0FBTyxLQUFLLE1BQU0sU0FBUyxLQUFLLFNBQVUsS0FBSztBQUM3QyxpQkFBTyxJQUFJLGtCQUFrQjtBQUFBO0FBSW5DLFlBQUksQ0FBQyxPQUFPLE1BQU0sUUFBUSxVQUFVLENBQUMsU0FBUSxRQUFRO0FBQ25ELGtCQUFRLEtBQ047QUFBQTtBQUdKLGdCQUFRO0FBQUE7QUFFVixVQUFJLENBQUMsTUFBTSxRQUFRLFFBQVE7QUFDekIsZ0JBQVEsQ0FBQztBQUFBO0FBR1gsaUJBQVUsV0FDTixPQUFPLE9BQU8sSUFBSSxxQkFBcUIsWUFDdkM7QUFFSixVQUFJLENBQUMsU0FBUSxLQUFLO0FBQ2hCLGVBQU8sTUFBTSxPQUFPLGtCQUFrQixJQUFJLFNBQVUsS0FBSztBQUN2RCxpQkFBTyxZQUFZLEtBQUs7QUFBQTtBQUFBLGFBRXJCO0FBQ0wsWUFBSSxVQUFVO0FBQ2QsZUFBTyxNQUFNLE9BQU8sa0JBQWtCLE9BQU8sU0FBVSxVQUFTLEtBQUs7QUFDbkUsY0FBSSxTQUFTLFlBQVksS0FBSztBQUM5QixtQkFBUSxPQUFPLFFBQVE7QUFDdkIsaUJBQU87QUFBQSxXQUNOO0FBQUE7QUFBQTtBQWVQLGlDQUE0QixlQUFlO0FBQ3pDLFVBQUksTUFBTSxRQUFRLGdCQUFnQjtBQUNoQyxlQUFPO0FBQUE7QUFFVCxVQUFJLE9BQU8sa0JBQWtCLFVBQVU7QUFDckMsZUFBTztBQUFBO0FBR1QsVUFBSSxpQkFBaUI7QUFDckIsVUFBSSxNQUFNO0FBQ1YsVUFBSTtBQUNKLFVBQUk7QUFDSixVQUFJO0FBQ0osVUFBSTtBQUNKLFVBQUk7QUFFSixnQ0FBMEI7QUFDeEIsZUFBTyxNQUFNLGNBQWMsVUFBVSxLQUFLLEtBQUssY0FBYyxPQUFPLE9BQU87QUFDekUsaUJBQU87QUFBQTtBQUVULGVBQU8sTUFBTSxjQUFjO0FBQUE7QUFHN0IsZ0NBQTBCO0FBQ3hCLGFBQUssY0FBYyxPQUFPO0FBRTFCLGVBQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPO0FBQUE7QUFHNUMsYUFBTyxNQUFNLGNBQWMsUUFBUTtBQUNqQyxnQkFBUTtBQUNSLGdDQUF3QjtBQUV4QixlQUFPLGtCQUFrQjtBQUN2QixlQUFLLGNBQWMsT0FBTztBQUMxQixjQUFJLE9BQU8sS0FBSztBQUVkLHdCQUFZO0FBQ1osbUJBQU87QUFFUDtBQUNBLHdCQUFZO0FBRVosbUJBQU8sTUFBTSxjQUFjLFVBQVUsa0JBQWtCO0FBQ3JELHFCQUFPO0FBQUE7QUFJVCxnQkFBSSxNQUFNLGNBQWMsVUFBVSxjQUFjLE9BQU8sU0FBUyxLQUFLO0FBRW5FLHNDQUF3QjtBQUV4QixvQkFBTTtBQUNOLDZCQUFlLEtBQUssY0FBYyxVQUFVLE9BQU87QUFDbkQsc0JBQVE7QUFBQSxtQkFDSDtBQUdMLG9CQUFNLFlBQVk7QUFBQTtBQUFBLGlCQUVmO0FBQ0wsbUJBQU87QUFBQTtBQUFBO0FBSVgsWUFBSSxDQUFDLHlCQUF5QixPQUFPLGNBQWMsUUFBUTtBQUN6RCx5QkFBZSxLQUFLLGNBQWMsVUFBVSxPQUFPLGNBQWM7QUFBQTtBQUFBO0FBSXJFLGFBQU87QUFBQTtBQUdULFdBQU8sVUFBVTtBQUNqQixXQUFPLFFBQVEsUUFBUTtBQUN2QixXQUFPLFFBQVEsY0FBYztBQUM3QixXQUFPLFFBQVEscUJBQXFCO0FBQUE7QUFBQTs7O0FDek1wQztBQUFBO0FBQUE7QUFBQTtBQUVBLFFBQU0sU0FBUztBQUNmLFFBQU0sa0JBQWlCLE9BQU87QUFDOUIsUUFBTSxTQUFTLENBQUMsU0FBUSxhQUFhO0FBQ3BDLGlCQUFXLE9BQU8sU0FBUTtBQUN6QixZQUFJLGdCQUFlLEtBQUssU0FBUSxNQUFNO0FBQ3JDLG1CQUFTLEtBQUssUUFBTztBQUFBO0FBQUE7QUFBQTtBQUt4QixRQUFNLFNBQVMsQ0FBQyxhQUFhLFdBQVc7QUFDdkMsVUFBSSxDQUFDLFFBQVE7QUFDWixlQUFPO0FBQUE7QUFFUixhQUFPLFFBQVEsQ0FBQyxLQUFLLFVBQVU7QUFDOUIsb0JBQVksT0FBTztBQUFBO0FBRXBCLGFBQU87QUFBQTtBQUdSLFFBQU0sV0FBVSxDQUFDLE9BQU8sYUFBYTtBQUNwQyxZQUFNLFNBQVMsTUFBTTtBQUNyQixVQUFJLFFBQVE7QUFDWixhQUFPLEVBQUUsUUFBUSxRQUFRO0FBQ3hCLGlCQUFTLE1BQU07QUFBQTtBQUFBO0FBSWpCLFFBQU0sZ0JBQWdCLENBQUMsUUFBUTtBQUM5QixhQUFPLFFBQVMsVUFBUyxLQUFLLE1BQU07QUFBQTtBQUdyQyxRQUFNLGNBQWMsQ0FBQyxNQUFNLGNBQWM7QUFDeEMsVUFBSSxlQUFjLEtBQUssU0FBUztBQUNoQyxVQUFJO0FBQVcsZUFBTztBQUN0QixhQUFPLGFBQVk7QUFBQTtBQUdwQixRQUFNLFlBQVcsT0FBTztBQUN4QixRQUFNLFdBQVUsTUFBTTtBQUN0QixRQUFNLFlBQVcsQ0FBQyxVQUFVO0FBQzNCLGFBQU8sT0FBTyxXQUFXLGNBQWMsT0FBTyxTQUFTO0FBQUE7QUFFeEQsUUFBTSxZQUFXLENBQUMsVUFBVTtBQUUzQixhQUFPLFVBQVMsS0FBSyxVQUFVO0FBQUE7QUFFaEMsUUFBTSxZQUFXLENBQUMsVUFBVTtBQUMzQixhQUFPLE9BQU8sU0FBUyxZQUN0QixVQUFTLEtBQUssVUFBVTtBQUFBO0FBRTFCLFFBQU0sWUFBVyxDQUFDLFVBQVU7QUFDM0IsYUFBTyxPQUFPLFNBQVMsWUFDdEIsVUFBUyxLQUFLLFVBQVU7QUFBQTtBQUUxQixRQUFNLGNBQWEsQ0FBQyxVQUFVO0FBQzdCLGFBQU8sT0FBTyxTQUFTO0FBQUE7QUFFeEIsUUFBTSxRQUFRLENBQUMsVUFBVTtBQUN4QixhQUFPLFVBQVMsS0FBSyxVQUFVO0FBQUE7QUFFaEMsUUFBTSxRQUFRLENBQUMsVUFBVTtBQUN4QixhQUFPLFVBQVMsS0FBSyxVQUFVO0FBQUE7QUFNaEMsUUFBTSxnQkFBZ0I7QUFBQSxNQUNyQixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixLQUFNO0FBQUE7QUFJUCxRQUFNLG9CQUFvQjtBQUUxQixRQUFNLGFBQWE7QUFDbkIsUUFBTSxrQkFBa0I7QUFFeEIsUUFBTSx3QkFBd0I7QUFDOUIsUUFBTSxzQkFBc0I7QUFFNUIsUUFBTSxTQUFRLENBQUMsVUFBVSxhQUFZO0FBQ3BDLFlBQU0sc0JBQXNCLE1BQU07QUFDakMsb0JBQVk7QUFDWixVQUFFLFNBQVE7QUFDVixpQkFBUyxTQUFRLE9BQU8sT0FBTyxTQUFRO0FBQUE7QUFHeEMsWUFBTSxZQUFXO0FBQUEsUUFDaEIsb0JBQW9CO0FBQUEsUUFDcEIsV0FBVztBQUFBLFFBQ1gsbUJBQW1CO0FBQUEsUUFDbkIsVUFBVTtBQUFBLFFBQ1YsUUFBUTtBQUFBLFFBQ1IsT0FBTztBQUFBLFFBQ1AsUUFBUTtBQUFBLFFBQ1IsV0FBVztBQUFBLFFBQ1gsZ0JBQWdCO0FBQUEsUUFDaEIsV0FBVztBQUFBLFFBQ1gsVUFBVTtBQUFBLFFBQ1YsZUFBZTtBQUFBLFFBQ2YsZUFBZTtBQUFBLFFBQ2YsZUFBZTtBQUFBO0FBRWhCLFlBQU0sUUFBTyxZQUFXLFNBQVE7QUFDaEMsVUFBSSxPQUFNO0FBQ1Qsa0JBQVMsU0FBUztBQUNsQixrQkFBUyxPQUFPO0FBQUE7QUFFakIsaUJBQVUsT0FBTyxXQUFVO0FBQzNCLFVBQ0MsU0FBUSxVQUFVLFlBQ2xCLFNBQVEsVUFBVSxZQUNsQixTQUFRLFVBQVUsWUFDakI7QUFDRCxpQkFBUSxTQUFTO0FBQUE7QUFFbEIsWUFBTSxRQUFRLFNBQVEsVUFBVSxXQUMvQixNQUNDLFNBQVEsVUFBVSxhQUNsQixNQUNBO0FBRUYsWUFBTSxVQUFVLFNBQVE7QUFDeEIsWUFBTSxlQUFlLFNBQVE7QUFDN0IsVUFBSSxTQUFTLFNBQVEsT0FBTyxPQUFPLFNBQVE7QUFDM0MsVUFBSSxZQUFZO0FBQ2hCLFlBQU0sVUFBVSxTQUFRO0FBQ3hCLFlBQU0sVUFBVSxTQUFRO0FBQ3hCLFlBQU0sVUFBVSxVQUFVLEtBQUs7QUFDL0IsVUFBSTtBQUNKLFVBQUksVUFBVTtBQUNkLFlBQU0sZ0JBQWdCLFNBQVEsV0FBVztBQUN6QyxZQUFNLGdCQUFnQixTQUFRLFdBQVc7QUFDekMsWUFBTSxnQkFBZ0IsU0FBUSxXQUFXO0FBQ3pDLFlBQU0sZ0JBQWdCLFNBQVEsV0FBVztBQUV6QyxVQUFJLFNBQVEsWUFBWSxZQUFXLFNBQVMsU0FBUztBQUNwRCxtQkFBVyxTQUFTO0FBQUE7QUFHckIsVUFBSSxDQUFDLFVBQVMsV0FBVztBQUN4QixZQUFJLE1BQU0sV0FBVztBQUNwQixjQUFJLFNBQVMsUUFBUSxHQUFHO0FBQ3ZCLG1CQUFPO0FBQUE7QUFFUixjQUFJLENBQUMsU0FBUztBQUNiLHFCQUFRLGNBQWM7QUFDdEIscUJBQVEsY0FBYztBQUFBO0FBRXZCLGlCQUFPLGFBQWEsT0FBTSxNQUFNLEtBQUssV0FBVyxZQUFXO0FBQUE7QUFFNUQsWUFBSSxNQUFNLFdBQVc7QUFDcEIsY0FBSSxTQUFTLFFBQVEsR0FBRztBQUN2QixtQkFBTztBQUFBO0FBRVIsaUJBQU8sYUFBYSxPQUFNLE1BQU0sS0FBSyxXQUFXLFlBQVc7QUFBQTtBQUU1RCxZQUFJLFVBQVMsV0FBVztBQUN2QixjQUFJLFNBQVMsVUFBVSxHQUFHO0FBQ3pCLG1CQUFPO0FBQUE7QUFFUixpQkFBTyxpQkFBaUIsT0FBTSxNQUFNLEtBQUssV0FBVyxZQUFXO0FBQUE7QUFFaEUsWUFBSSxTQUFRLFdBQVc7QUFDdEIsbUJBQVM7QUFDVCxtQkFBUSxPQUFPO0FBQ2YsY0FBSSxTQUFTO0FBQ1oscUJBQVEsY0FBYztBQUN0QixxQkFBUSxjQUFjO0FBQUE7QUFFdkIsY0FBSSxDQUFDLFNBQVM7QUFDYjtBQUFBO0FBRUQsbUJBQVEsVUFBVSxDQUFDLFVBQVU7QUFDNUIsc0JBQVU7QUFDVixnQkFBSSxTQUFTO0FBQ1osdUJBQVEsY0FBYztBQUFBO0FBRXZCLG1CQUFPLEtBQ0wsWUFBVyxVQUFVLEtBQUssVUFDM0IsT0FBTSxPQUFPO0FBQUE7QUFHZixjQUFJLFNBQVM7QUFDWixtQkFBTztBQUFBO0FBRVIsY0FBSSxTQUFTO0FBQ1osbUJBQU8sTUFBTSxPQUFPLEtBQUssUUFBUTtBQUFBO0FBRWxDLGlCQUFPLE1BQU0sVUFBVSxPQUFPLEtBQUssTUFBTSxXQUFXLFVBQ2xELFdBQVUsS0FBSyxhQUFhO0FBQUEsbUJBQ3BCLFVBQVMsV0FBVztBQUM5QixjQUFJLE9BQU07QUFFVCxtQkFBTyxLQUFLLFVBQVU7QUFBQTtBQUV2QixjQUFJLGVBQWU7QUFDbEIsbUJBQU8sT0FBTztBQUFBO0FBRWYsY0FBSSxlQUFlO0FBQ2xCLGdCQUFJLGVBQWMsU0FBUyxTQUFTO0FBQ3BDLGdCQUFJLENBQUMsY0FBYztBQUNsQiw2QkFBYyxhQUFZO0FBQUE7QUFFM0IsbUJBQU8sT0FBTztBQUFBO0FBRWYsY0FBSSxlQUFlO0FBQ2xCLG1CQUFPLE9BQU8sU0FBUyxTQUFTO0FBQUE7QUFFakMsY0FBSSxlQUFlO0FBQ2xCLG1CQUFPLE9BQU8sU0FBUyxTQUFTO0FBQUE7QUFBQSxtQkFFdkIsQ0FBQyxVQUFTLFdBQVc7QUFDL0IsY0FBSSxPQUFNO0FBSVQsbUJBQU8sS0FBSyxVQUFVLGFBQWE7QUFBQTtBQUVwQyxpQkFBTyxPQUFPO0FBQUEsZUFDUjtBQUNOLG1CQUFTO0FBQ1QsbUJBQVEsT0FBTztBQUNmO0FBQ0EsaUJBQU8sVUFBVSxDQUFDLEtBQUssVUFBVTtBQUNoQyxzQkFBVTtBQUNWLG1CQUFPLEtBQ0wsV0FBVSxLQUFLLFVBQ2hCLE9BQU0sS0FBSyxZQUFXLE1BQ3JCLFdBQVUsS0FBSyxPQUNoQixPQUFNLE9BQU87QUFBQTtBQUdmLGNBQUksU0FBUztBQUNaLG1CQUFPO0FBQUE7QUFFUixpQkFBTyxNQUFNLFVBQVUsT0FBTyxLQUFLLE1BQU0sV0FBVyxVQUNsRCxXQUFVLEtBQUssYUFBYTtBQUFBO0FBQUE7QUFJaEMsWUFBTSxRQUFRLFNBQVEsbUJBQW1CLHdCQUF3QjtBQUNqRSxlQUFTLFNBQVMsUUFBUSxPQUFPLENBQUMsTUFBTSxNQUFNLE1BQU0sV0FBVyxPQUFPLFdBQVc7QUFDaEYsWUFBSSxNQUFNO0FBQ1QsY0FBSSxTQUFRO0FBQVMsbUJBQU87QUFDNUIsZ0JBQU0sUUFBUSxLQUFLLFdBQVc7QUFDOUIsZ0JBQU0sU0FBUyxLQUFLLFdBQVc7QUFDL0IsY0FBSSxTQUFRLEtBQUs7QUFFaEIsa0JBQU0sWUFBYSxTQUFRLFNBQVUsT0FBUSxTQUFTLFFBQVM7QUFDL0Qsa0JBQU0sT0FBTSxZQUFZLFdBQVc7QUFDbkMsbUJBQU8sU0FBUyxPQUFNO0FBQUE7QUFFdkIsaUJBQU8sY0FBYyxZQUFZLE9BQU8saUJBQWlCLGNBQWMsWUFBWSxRQUFRO0FBQUE7QUFHNUYsWUFBSSxNQUFNO0FBQ1QsaUJBQU8sY0FBYyxZQUFZLEtBQUssV0FBVyxJQUFJO0FBQUE7QUFHdEQsWUFDQyxRQUFRLFFBQ1IsQ0FBQyxTQUNELENBQUMsV0FBVyxLQUFLLE9BQU8sT0FBTyxRQUFRLEtBQ3RDO0FBQ0QsaUJBQU87QUFBQTtBQUdSLFlBQUksV0FBVztBQUNkLGNBQUksYUFBYSxTQUFTLFNBQVEsa0JBQWtCO0FBQ25ELG1CQUFPLE9BQU87QUFBQTtBQUVmLGlCQUFPO0FBQUE7QUFHUixZQUFJLGtCQUFrQixLQUFLLE9BQU87QUFFakMsaUJBQU8sY0FBYztBQUFBO0FBR3RCLFlBQUksU0FBUSxXQUFXLENBQUMsZ0JBQWdCLEtBQUssT0FBTztBQUNuRCxpQkFBTztBQUFBO0FBR1IsY0FBTSxNQUFNLFlBQVksS0FBSyxXQUFXLElBQUk7QUFDNUMsWUFBSSxTQUFRLElBQUksU0FBUyxHQUFHO0FBQzNCLGlCQUFPLGNBQWM7QUFBQTtBQUd0QixlQUFPLFFBQVMsUUFBTyxLQUFLLE1BQU07QUFBQTtBQUduQyxVQUFJLFNBQVMsS0FBSztBQUNqQixpQkFBUyxPQUFPLFFBQVEsU0FBUztBQUFBO0FBRWxDLFVBQUksU0FBUSxpQkFBaUI7QUFFNUIsaUJBQVMsT0FDUCxRQUFRLHVCQUF1QixVQUMvQixRQUFRLFNBQVMsUUFBTyxlQUFlO0FBQUE7QUFFMUMsVUFBSSxTQUFRLE1BQU07QUFDakIsaUJBQVMsUUFBUSxTQUFTO0FBQUE7QUFFM0IsYUFBTztBQUFBO0FBR1IsV0FBTSxVQUFVO0FBRWhCLFdBQU8sVUFBVTtBQUFBO0FBQUE7OztBQ3RUakIseUJBQXlCO0FBQUE7QUFHekIsd0JBQXdCO0FBQ3RCLGVBQWEsS0FBSyxLQUFLO0FBQUE7QUE2Q3pCLDBCQUEwQixNQUFNO0FBQzlCLE1BQUksS0FBSyxrQkFBa0I7QUFDekIsV0FBTyxhQUFhO0FBQ3RCLFNBQU8sS0FBSztBQUFBO0FBWWQsa0JBQWtCLFNBQVMsTUFBTSxPQUFNO0FBQ3JDLE1BQUk7QUFDRixZQUFRLEtBQUs7QUFBQSxPQUNWO0FBQ0gsUUFBSSxNQUFNLFFBQVE7QUFDbEIsUUFBSSxhQUFZLFdBQVcsU0FBUztBQUNwQyxhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRTtBQUN6QixpQkFBVSxHQUFHLEtBQUs7QUFBQTtBQUFBO0FBR3hCLGlCQUFpQixTQUFTLE1BQU0sT0FBTSxNQUFNO0FBQzFDLE1BQUk7QUFDRixZQUFRLEtBQUssT0FBTTtBQUFBLE9BQ2hCO0FBQ0gsUUFBSSxNQUFNLFFBQVE7QUFDbEIsUUFBSSxhQUFZLFdBQVcsU0FBUztBQUNwQyxhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRTtBQUN6QixpQkFBVSxHQUFHLEtBQUssT0FBTTtBQUFBO0FBQUE7QUFHOUIsaUJBQWlCLFNBQVMsTUFBTSxPQUFNLE1BQU0sTUFBTTtBQUNoRCxNQUFJO0FBQ0YsWUFBUSxLQUFLLE9BQU0sTUFBTTtBQUFBLE9BQ3RCO0FBQ0gsUUFBSSxNQUFNLFFBQVE7QUFDbEIsUUFBSSxhQUFZLFdBQVcsU0FBUztBQUNwQyxhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRTtBQUN6QixpQkFBVSxHQUFHLEtBQUssT0FBTSxNQUFNO0FBQUE7QUFBQTtBQUdwQyxtQkFBbUIsU0FBUyxNQUFNLE9BQU0sTUFBTSxNQUFNLE1BQU07QUFDeEQsTUFBSTtBQUNGLFlBQVEsS0FBSyxPQUFNLE1BQU0sTUFBTTtBQUFBLE9BQzVCO0FBQ0gsUUFBSSxNQUFNLFFBQVE7QUFDbEIsUUFBSSxhQUFZLFdBQVcsU0FBUztBQUNwQyxhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRTtBQUN6QixpQkFBVSxHQUFHLEtBQUssT0FBTSxNQUFNLE1BQU07QUFBQTtBQUFBO0FBSTFDLGtCQUFrQixTQUFTLE1BQU0sT0FBTSxNQUFNO0FBQzNDLE1BQUk7QUFDRixZQUFRLE1BQU0sT0FBTTtBQUFBLE9BQ2pCO0FBQ0gsUUFBSSxNQUFNLFFBQVE7QUFDbEIsUUFBSSxhQUFZLFdBQVcsU0FBUztBQUNwQyxhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRTtBQUN6QixpQkFBVSxHQUFHLE1BQU0sT0FBTTtBQUFBO0FBQUE7QUF5RS9CLHNCQUFzQixRQUFRLE1BQU0sVUFBVSxTQUFTO0FBQ3JELE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSTtBQUVKLE1BQUksT0FBTyxhQUFhO0FBQ3RCLFVBQU0sSUFBSSxVQUFVO0FBRXRCLFdBQVMsT0FBTztBQUNoQixNQUFJLENBQUMsUUFBUTtBQUNYLGFBQVMsT0FBTyxVQUFVLElBQUk7QUFDOUIsV0FBTyxlQUFlO0FBQUEsU0FDakI7QUFHTCxRQUFJLE9BQU8sYUFBYTtBQUN0QixhQUFPLEtBQUssZUFBZSxNQUNmLFNBQVMsV0FBVyxTQUFTLFdBQVc7QUFJcEQsZUFBUyxPQUFPO0FBQUE7QUFFbEIsZUFBVyxPQUFPO0FBQUE7QUFHcEIsTUFBSSxDQUFDLFVBQVU7QUFFYixlQUFXLE9BQU8sUUFBUTtBQUMxQixNQUFFLE9BQU87QUFBQSxTQUNKO0FBQ0wsUUFBSSxPQUFPLGFBQWEsWUFBWTtBQUVsQyxpQkFBVyxPQUFPLFFBQVEsVUFBVSxDQUFDLFVBQVUsWUFDWCxDQUFDLFVBQVU7QUFBQSxXQUMxQztBQUVMLFVBQUksU0FBUztBQUNYLGlCQUFTLFFBQVE7QUFBQSxhQUNaO0FBQ0wsaUJBQVMsS0FBSztBQUFBO0FBQUE7QUFLbEIsUUFBSSxDQUFDLFNBQVMsUUFBUTtBQUNwQixVQUFJLGlCQUFpQjtBQUNyQixVQUFJLEtBQUssSUFBSSxLQUFLLFNBQVMsU0FBUyxHQUFHO0FBQ3JDLGlCQUFTLFNBQVM7QUFDbEIsWUFBSSxJQUFJLElBQUksTUFBTSxpREFDRSxTQUFTLFNBQVMsTUFBTSxPQUFPO0FBRW5ELFVBQUUsT0FBTztBQUNULFVBQUUsVUFBVTtBQUNaLFVBQUUsT0FBTztBQUNULFVBQUUsUUFBUSxTQUFTO0FBQ25CLG9CQUFZO0FBQUE7QUFBQTtBQUFBO0FBS2xCLFNBQU87QUFBQTtBQUVULHFCQUFxQixHQUFHO0FBQ3RCLFNBQU8sUUFBUSxTQUFTLGFBQWEsUUFBUSxLQUFLLEtBQUssUUFBUSxJQUFJO0FBQUE7QUFhckUsbUJBQW1CLFFBQVEsTUFBTSxVQUFVO0FBQ3pDLE1BQUksUUFBUTtBQUNaLGVBQWE7QUFDWCxXQUFPLGVBQWUsTUFBTTtBQUM1QixRQUFJLENBQUMsT0FBTztBQUNWLGNBQVE7QUFDUixlQUFTLE1BQU0sUUFBUTtBQUFBO0FBQUE7QUFHM0IsSUFBRSxXQUFXO0FBQ2IsU0FBTztBQUFBO0FBMkpULHVCQUF1QixNQUFNO0FBQzNCLE1BQUksU0FBUyxLQUFLO0FBRWxCLE1BQUksUUFBUTtBQUNWLFFBQUksYUFBYSxPQUFPO0FBRXhCLFFBQUksT0FBTyxlQUFlLFlBQVk7QUFDcEMsYUFBTztBQUFBLGVBQ0UsWUFBWTtBQUNyQixhQUFPLFdBQVc7QUFBQTtBQUFBO0FBSXRCLFNBQU87QUFBQTtBQVFULG1CQUFtQixNQUFNLE9BQU87QUFDOUIsV0FBUyxJQUFJLE9BQU8sSUFBSSxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ2xFLFNBQUssS0FBSyxLQUFLO0FBQ2pCLE9BQUs7QUFBQTtBQUdQLG9CQUFvQixLQUFLLEdBQUc7QUFDMUIsTUFBSSxRQUFPLElBQUksTUFBTTtBQUNyQixTQUFPO0FBQ0wsVUFBSyxLQUFLLElBQUk7QUFDaEIsU0FBTztBQUFBO0FBR1QseUJBQXlCLEtBQUs7QUFDNUIsTUFBSSxNQUFNLElBQUksTUFBTSxJQUFJO0FBQ3hCLFdBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsR0FBRztBQUNuQyxRQUFJLEtBQUssSUFBSSxHQUFHLFlBQVksSUFBSTtBQUFBO0FBRWxDLFNBQU87QUFBQTtBQXpkVCxJQUVJLFFBV0c7QUFiUDtBQUFBO0FBQUE7QUFBQTtBQVFBLGtCQUFjLFlBQVksT0FBTyxPQUFPO0FBS3hDLElBQU8saUJBQVE7QUFLZixpQkFBYSxlQUFlO0FBRTVCLGlCQUFhLGVBQWU7QUFFNUIsaUJBQWEsVUFBVSxTQUFTO0FBQ2hDLGlCQUFhLFVBQVUsVUFBVTtBQUNqQyxpQkFBYSxVQUFVLGdCQUFnQjtBQUl2QyxpQkFBYSxzQkFBc0I7QUFFbkMsaUJBQWEsT0FBTyxXQUFXO0FBQzdCLFdBQUssU0FBUztBQUNkLFVBQUksYUFBYSxjQUFjO0FBRTdCLFlBQUksT0FBTyxVQUFVLENBQUUsaUJBQWdCLE9BQU8sU0FBUztBQUNyRCxlQUFLLFNBQVMsT0FBTztBQUFBO0FBQUE7QUFJekIsVUFBSSxDQUFDLEtBQUssV0FBVyxLQUFLLFlBQVksT0FBTyxlQUFlLE1BQU0sU0FBUztBQUN6RSxhQUFLLFVBQVUsSUFBSTtBQUNuQixhQUFLLGVBQWU7QUFBQTtBQUd0QixXQUFLLGdCQUFnQixLQUFLLGlCQUFpQjtBQUFBO0FBSzdDLGlCQUFhLFVBQVUsa0JBQWtCLHlCQUF5QixHQUFHO0FBQ25FLFVBQUksT0FBTyxNQUFNLFlBQVksSUFBSSxLQUFLLE1BQU07QUFDMUMsY0FBTSxJQUFJLFVBQVU7QUFDdEIsV0FBSyxnQkFBZ0I7QUFDckIsYUFBTztBQUFBO0FBU1QsaUJBQWEsVUFBVSxrQkFBa0IsMkJBQTJCO0FBQ2xFLGFBQU8saUJBQWlCO0FBQUE7QUE0RDFCLGlCQUFhLFVBQVUsT0FBTyxjQUFjLE1BQU07QUFDaEQsVUFBSSxJQUFJLFNBQVMsS0FBSyxNQUFNLEdBQUcsUUFBUTtBQUN2QyxVQUFJLGlCQUFpQjtBQUNyQixVQUFJLFVBQVcsU0FBUztBQUV4QixlQUFTLEtBQUs7QUFDZCxVQUFJO0FBQ0Ysa0JBQVcsV0FBVyxPQUFPLFNBQVM7QUFBQSxlQUMvQixDQUFDO0FBQ1IsZUFBTztBQUVULGdCQUFTLEtBQUs7QUFHZCxVQUFJLFNBQVM7QUFDWCxhQUFLLFVBQVU7QUFDZixZQUFJLFNBQVE7QUFDVixjQUFJLENBQUM7QUFDSCxpQkFBSyxJQUFJLE1BQU07QUFDakIsYUFBRyxnQkFBZ0I7QUFDbkIsYUFBRyxTQUFTO0FBQ1osYUFBRyxlQUFlO0FBQ2xCLGtCQUFPLEtBQUssU0FBUztBQUFBLG1CQUNaLGNBQWMsT0FBTztBQUM5QixnQkFBTTtBQUFBLGVBQ0Q7QUFFTCxjQUFJLE1BQU0sSUFBSSxNQUFNLDJDQUEyQyxLQUFLO0FBQ3BFLGNBQUksVUFBVTtBQUNkLGdCQUFNO0FBQUE7QUFFUixlQUFPO0FBQUE7QUFHVCxnQkFBVSxPQUFPO0FBRWpCLFVBQUksQ0FBQztBQUNILGVBQU87QUFFVCxVQUFJLE9BQU8sT0FBTyxZQUFZO0FBQzlCLFlBQU0sVUFBVTtBQUNoQixjQUFRO0FBQUEsYUFFRDtBQUNILG1CQUFTLFNBQVMsTUFBTTtBQUN4QjtBQUFBLGFBQ0c7QUFDSCxrQkFBUSxTQUFTLE1BQU0sTUFBTSxVQUFVO0FBQ3ZDO0FBQUEsYUFDRztBQUNILGtCQUFRLFNBQVMsTUFBTSxNQUFNLFVBQVUsSUFBSSxVQUFVO0FBQ3JEO0FBQUEsYUFDRztBQUNILG9CQUFVLFNBQVMsTUFBTSxNQUFNLFVBQVUsSUFBSSxVQUFVLElBQUksVUFBVTtBQUNyRTtBQUFBO0FBR0EsaUJBQU8sSUFBSSxNQUFNLE1BQU07QUFDdkIsZUFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLO0FBQ25CLGlCQUFLLElBQUksS0FBSyxVQUFVO0FBQzFCLG1CQUFTLFNBQVMsTUFBTSxNQUFNO0FBQUE7QUFHbEMsVUFBSTtBQUNGLGdCQUFPO0FBRVQsYUFBTztBQUFBO0FBcUVULGlCQUFhLFVBQVUsY0FBYyxxQkFBcUIsTUFBTSxVQUFVO0FBQ3hFLGFBQU8sYUFBYSxNQUFNLE1BQU0sVUFBVTtBQUFBO0FBRzVDLGlCQUFhLFVBQVUsS0FBSyxhQUFhLFVBQVU7QUFFbkQsaUJBQWEsVUFBVSxrQkFDbkIseUJBQXlCLE1BQU0sVUFBVTtBQUN2QyxhQUFPLGFBQWEsTUFBTSxNQUFNLFVBQVU7QUFBQTtBQWdCaEQsaUJBQWEsVUFBVSxPQUFPLGNBQWMsTUFBTSxVQUFVO0FBQzFELFVBQUksT0FBTyxhQUFhO0FBQ3RCLGNBQU0sSUFBSSxVQUFVO0FBQ3RCLFdBQUssR0FBRyxNQUFNLFVBQVUsTUFBTSxNQUFNO0FBQ3BDLGFBQU87QUFBQTtBQUdULGlCQUFhLFVBQVUsc0JBQ25CLDZCQUE2QixNQUFNLFVBQVU7QUFDM0MsVUFBSSxPQUFPLGFBQWE7QUFDdEIsY0FBTSxJQUFJLFVBQVU7QUFDdEIsV0FBSyxnQkFBZ0IsTUFBTSxVQUFVLE1BQU0sTUFBTTtBQUNqRCxhQUFPO0FBQUE7QUFJYixpQkFBYSxVQUFVLGlCQUNuQix3QkFBd0IsTUFBTSxVQUFVO0FBQ3RDLFVBQUksTUFBTSxRQUFRLFVBQVUsR0FBRztBQUUvQixVQUFJLE9BQU8sYUFBYTtBQUN0QixjQUFNLElBQUksVUFBVTtBQUV0QixlQUFTLEtBQUs7QUFDZCxVQUFJLENBQUM7QUFDSCxlQUFPO0FBRVQsYUFBTyxPQUFPO0FBQ2QsVUFBSSxDQUFDO0FBQ0gsZUFBTztBQUVULFVBQUksU0FBUyxZQUFhLEtBQUssWUFBWSxLQUFLLGFBQWEsVUFBVztBQUN0RSxZQUFJLEVBQUUsS0FBSyxpQkFBaUI7QUFDMUIsZUFBSyxVQUFVLElBQUk7QUFBQSxhQUNoQjtBQUNILGlCQUFPLE9BQU87QUFDZCxjQUFJLE9BQU87QUFDVCxpQkFBSyxLQUFLLGtCQUFrQixNQUFNLEtBQUssWUFBWTtBQUFBO0FBQUEsaUJBRTlDLE9BQU8sU0FBUyxZQUFZO0FBQ3JDLG1CQUFXO0FBRVgsYUFBSyxJQUFJLEtBQUssUUFBUSxNQUFNLEtBQUk7QUFDOUIsY0FBSSxLQUFLLE9BQU8sWUFDWCxLQUFLLEdBQUcsWUFBWSxLQUFLLEdBQUcsYUFBYSxVQUFXO0FBQ3ZELCtCQUFtQixLQUFLLEdBQUc7QUFDM0IsdUJBQVc7QUFDWDtBQUFBO0FBQUE7QUFJSixZQUFJLFdBQVc7QUFDYixpQkFBTztBQUVULFlBQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsZUFBSyxLQUFLO0FBQ1YsY0FBSSxFQUFFLEtBQUssaUJBQWlCLEdBQUc7QUFDN0IsaUJBQUssVUFBVSxJQUFJO0FBQ25CLG1CQUFPO0FBQUEsaUJBQ0Y7QUFDTCxtQkFBTyxPQUFPO0FBQUE7QUFBQSxlQUVYO0FBQ0wsb0JBQVUsTUFBTTtBQUFBO0FBR2xCLFlBQUksT0FBTztBQUNULGVBQUssS0FBSyxrQkFBa0IsTUFBTSxvQkFBb0I7QUFBQTtBQUcxRCxhQUFPO0FBQUE7QUFHYixpQkFBYSxVQUFVLHFCQUNuQiw0QkFBNEIsTUFBTTtBQUNoQyxVQUFJLFlBQVc7QUFFZixlQUFTLEtBQUs7QUFDZCxVQUFJLENBQUM7QUFDSCxlQUFPO0FBR1QsVUFBSSxDQUFDLE9BQU8sZ0JBQWdCO0FBQzFCLFlBQUksVUFBVSxXQUFXLEdBQUc7QUFDMUIsZUFBSyxVQUFVLElBQUk7QUFDbkIsZUFBSyxlQUFlO0FBQUEsbUJBQ1gsT0FBTyxPQUFPO0FBQ3ZCLGNBQUksRUFBRSxLQUFLLGlCQUFpQjtBQUMxQixpQkFBSyxVQUFVLElBQUk7QUFBQTtBQUVuQixtQkFBTyxPQUFPO0FBQUE7QUFFbEIsZUFBTztBQUFBO0FBSVQsVUFBSSxVQUFVLFdBQVcsR0FBRztBQUMxQixZQUFJLFFBQU8sT0FBTyxLQUFLO0FBQ3ZCLGlCQUFTLElBQUksR0FBRyxLQUFLLElBQUksTUFBSyxRQUFRLEVBQUUsR0FBRztBQUN6QyxnQkFBTSxNQUFLO0FBQ1gsY0FBSSxRQUFRO0FBQWtCO0FBQzlCLGVBQUssbUJBQW1CO0FBQUE7QUFFMUIsYUFBSyxtQkFBbUI7QUFDeEIsYUFBSyxVQUFVLElBQUk7QUFDbkIsYUFBSyxlQUFlO0FBQ3BCLGVBQU87QUFBQTtBQUdULG1CQUFZLE9BQU87QUFFbkIsVUFBSSxPQUFPLGVBQWMsWUFBWTtBQUNuQyxhQUFLLGVBQWUsTUFBTTtBQUFBLGlCQUNqQixZQUFXO0FBRXBCLFdBQUc7QUFDRCxlQUFLLGVBQWUsTUFBTSxXQUFVLFdBQVUsU0FBUztBQUFBLGlCQUNoRCxXQUFVO0FBQUE7QUFHckIsYUFBTztBQUFBO0FBR2IsaUJBQWEsVUFBVSxZQUFZLG1CQUFtQixNQUFNO0FBQzFELFVBQUk7QUFDSixVQUFJO0FBQ0osVUFBSSxTQUFTLEtBQUs7QUFFbEIsVUFBSSxDQUFDO0FBQ0gsY0FBTTtBQUFBLFdBQ0g7QUFDSCxxQkFBYSxPQUFPO0FBQ3BCLFlBQUksQ0FBQztBQUNILGdCQUFNO0FBQUEsaUJBQ0MsT0FBTyxlQUFlO0FBQzdCLGdCQUFNLENBQUMsV0FBVyxZQUFZO0FBQUE7QUFFOUIsZ0JBQU0sZ0JBQWdCO0FBQUE7QUFHMUIsYUFBTztBQUFBO0FBR1QsaUJBQWEsZ0JBQWdCLFNBQVMsU0FBUyxNQUFNO0FBQ25ELFVBQUksT0FBTyxRQUFRLGtCQUFrQixZQUFZO0FBQy9DLGVBQU8sUUFBUSxjQUFjO0FBQUEsYUFDeEI7QUFDTCxlQUFPLGNBQWMsS0FBSyxTQUFTO0FBQUE7QUFBQTtBQUl2QyxpQkFBYSxVQUFVLGdCQUFnQjtBQWlCdkMsaUJBQWEsVUFBVSxhQUFhLHNCQUFzQjtBQUN4RCxhQUFPLEtBQUssZUFBZSxJQUFJLFFBQVEsUUFBUSxLQUFLLFdBQVc7QUFBQTtBQUFBO0FBQUE7OztBQ2hjakUsNEJBQTRCO0FBQ3hCLFFBQU0sSUFBSSxNQUFNO0FBQUE7QUFFcEIsK0JBQWdDO0FBQzVCLFFBQU0sSUFBSSxNQUFNO0FBQUE7QUFXcEIsb0JBQW9CLEtBQUs7QUFDckIsTUFBSSxxQkFBcUIsWUFBWTtBQUVqQyxXQUFPLFdBQVcsS0FBSztBQUFBO0FBRzNCLE1BQUssc0JBQXFCLG9CQUFvQixDQUFDLHFCQUFxQixZQUFZO0FBQzVFLHVCQUFtQjtBQUNuQixXQUFPLFdBQVcsS0FBSztBQUFBO0FBRTNCLE1BQUk7QUFFQSxXQUFPLGlCQUFpQixLQUFLO0FBQUEsV0FDekIsR0FBTjtBQUNFLFFBQUk7QUFFQSxhQUFPLGlCQUFpQixLQUFLLE1BQU0sS0FBSztBQUFBLGFBQ3BDLElBQU47QUFFRSxhQUFPLGlCQUFpQixLQUFLLE1BQU0sS0FBSztBQUFBO0FBQUE7QUFBQTtBQU1wRCx5QkFBeUIsUUFBUTtBQUM3QixNQUFJLHVCQUF1QixjQUFjO0FBRXJDLFdBQU8sYUFBYTtBQUFBO0FBR3hCLE1BQUssd0JBQXVCLHVCQUF1QixDQUFDLHVCQUF1QixjQUFjO0FBQ3JGLHlCQUFxQjtBQUNyQixXQUFPLGFBQWE7QUFBQTtBQUV4QixNQUFJO0FBRUEsV0FBTyxtQkFBbUI7QUFBQSxXQUNyQixHQUFQO0FBQ0UsUUFBSTtBQUVBLGFBQU8sbUJBQW1CLEtBQUssTUFBTTtBQUFBLGFBQ2hDLElBQVA7QUFHRSxhQUFPLG1CQUFtQixLQUFLLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFZakQsMkJBQTJCO0FBQ3ZCLE1BQUksQ0FBQyxZQUFZLENBQUMsY0FBYztBQUM1QjtBQUFBO0FBRUosYUFBVztBQUNYLE1BQUksYUFBYSxRQUFRO0FBQ3JCLFlBQVEsYUFBYSxPQUFPO0FBQUEsU0FDekI7QUFDSCxpQkFBYTtBQUFBO0FBRWpCLE1BQUksTUFBTSxRQUFRO0FBQ2Q7QUFBQTtBQUFBO0FBSVIsc0JBQXNCO0FBQ2xCLE1BQUksVUFBVTtBQUNWO0FBQUE7QUFFSixNQUFJLFVBQVUsV0FBVztBQUN6QixhQUFXO0FBRVgsTUFBSSxNQUFNLE1BQU07QUFDaEIsU0FBTSxLQUFLO0FBQ1AsbUJBQWU7QUFDZixZQUFRO0FBQ1IsV0FBTyxFQUFFLGFBQWEsS0FBSztBQUN2QixVQUFJLGNBQWM7QUFDZCxxQkFBYSxZQUFZO0FBQUE7QUFBQTtBQUdqQyxpQkFBYTtBQUNiLFVBQU0sTUFBTTtBQUFBO0FBRWhCLGlCQUFlO0FBQ2YsYUFBVztBQUNYLGtCQUFnQjtBQUFBO0FBRXBCLGtCQUFrQixLQUFLO0FBQ25CLE1BQUksT0FBTyxJQUFJLE1BQU0sVUFBVSxTQUFTO0FBQ3hDLE1BQUksVUFBVSxTQUFTLEdBQUc7QUFDdEIsYUFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QyxXQUFLLElBQUksS0FBSyxVQUFVO0FBQUE7QUFBQTtBQUdoQyxRQUFNLEtBQUssSUFBSSxLQUFLLEtBQUs7QUFDekIsTUFBSSxNQUFNLFdBQVcsS0FBSyxDQUFDLFVBQVU7QUFDakMsZUFBVztBQUFBO0FBQUE7QUFJbkIsY0FBYyxLQUFLLE9BQU87QUFDdEIsT0FBSyxNQUFNO0FBQ1gsT0FBSyxRQUFRO0FBQUE7QUFlakIsZ0JBQWdCO0FBQUE7QUFVaEIsaUJBQWlCLE1BQU07QUFDbkIsUUFBTSxJQUFJLE1BQU07QUFBQTtBQUdwQixlQUFnQjtBQUFFLFNBQU87QUFBQTtBQUN6QixlQUFnQixLQUFLO0FBQ2pCLFFBQU0sSUFBSSxNQUFNO0FBQUE7QUFDbkIsaUJBQWlCO0FBQUUsU0FBTztBQUFBO0FBYzNCLGdCQUFnQixtQkFBa0I7QUFDaEMsTUFBSSxZQUFZLGVBQWUsS0FBSyxlQUFhO0FBQ2pELE1BQUksVUFBVSxLQUFLLE1BQU07QUFDekIsTUFBSSxjQUFjLEtBQUssTUFBTyxZQUFVLElBQUc7QUFDM0MsTUFBSSxtQkFBbUI7QUFDckIsY0FBVSxVQUFVLGtCQUFrQjtBQUN0QyxrQkFBYyxjQUFjLGtCQUFrQjtBQUM5QyxRQUFJLGNBQVksR0FBRztBQUNqQjtBQUNBLHFCQUFlO0FBQUE7QUFBQTtBQUduQixTQUFPLENBQUMsU0FBUTtBQUFBO0FBSWxCLGtCQUFrQjtBQUNoQixNQUFJLGNBQWMsSUFBSTtBQUN0QixNQUFJLE1BQU0sY0FBYztBQUN4QixTQUFPLE1BQU07QUFBQTtBQWpNZixJQVNJLGtCQUNBLG9CQTREQSxPQUNBLFVBQ0EsY0FDQSxZQTREQSxPQUNBLFVBQ0EsU0FDQSxLQUNBLE1BQ0EsU0FDQSxVQUNBLFNBQ0EsUUFJQSxJQUNBLGNBQ0EsT0FDQSxLQUNBLGlCQUNBLHFCQUNBLE9BWUEsYUFDQSxnQkF5QkEsV0FPQSxXQTBCRztBQTlOUDtBQUFBO0FBQUE7QUFTQSxJQUFJLG1CQUFtQjtBQUN2QixJQUFJLHFCQUFxQjtBQUN6QixRQUFJLE9BQU8sV0FBTyxlQUFlLFlBQVk7QUFDekMseUJBQW1CO0FBQUE7QUFFdkIsUUFBSSxPQUFPLFdBQU8saUJBQWlCLFlBQVk7QUFDM0MsMkJBQXFCO0FBQUE7QUF1RHpCLElBQUksUUFBUTtBQUNaLElBQUksV0FBVztBQUVmLElBQUksYUFBYTtBQXlEakIsU0FBSyxVQUFVLE1BQU0sV0FBWTtBQUM3QixXQUFLLElBQUksTUFBTSxNQUFNLEtBQUs7QUFBQTtBQUU5QixJQUFJLFFBQVE7QUFDWixJQUFJLFdBQVc7QUFDZixJQUFJLFVBQVU7QUFDZCxJQUFJLE1BQU07QUFDVixJQUFJLE9BQU87QUFDWCxJQUFJLFVBQVU7QUFDZCxJQUFJLFdBQVc7QUFDZixJQUFJLFVBQVU7QUFDZCxJQUFJLFNBQVM7QUFJYixJQUFJLEtBQUs7QUFDVCxJQUFJLGVBQWM7QUFDbEIsSUFBSSxRQUFPO0FBQ1gsSUFBSSxNQUFNO0FBQ1YsSUFBSSxrQkFBaUI7QUFDckIsSUFBSSxzQkFBcUI7QUFDekIsSUFBSSxRQUFPO0FBWVgsSUFBSSxjQUFjLFdBQU8sZUFBZTtBQUN4QyxJQUFJLGlCQUNGLFlBQVksT0FDWixZQUFZLFVBQ1osWUFBWSxTQUNaLFlBQVksUUFDWixZQUFZLGFBQ1osV0FBVTtBQUFFLGFBQVEsSUFBSSxPQUFRO0FBQUE7QUFtQmxDLElBQUksWUFBWSxJQUFJO0FBT3BCLElBQUksWUFBWTtBQUFBLE1BQ2Q7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxhQUFhO0FBQUEsTUFDYixNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0EsZ0JBQWdCO0FBQUEsTUFDaEIsb0JBQW9CO0FBQUEsTUFDcEIsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBR0YsSUFBTyxrQkFBUTtBQUFBO0FBQUE7OztBQzlOZixJQUNJLFVBdUJHO0FBeEJQO0FBQUE7QUFBQTtBQUVBLFFBQUksT0FBTyxPQUFPLFdBQVcsWUFBVztBQUN0QyxpQkFBVyxtQkFBa0IsTUFBTSxXQUFXO0FBRTVDLGFBQUssU0FBUztBQUNkLGFBQUssWUFBWSxPQUFPLE9BQU8sVUFBVSxXQUFXO0FBQUEsVUFDbEQsYUFBYTtBQUFBLFlBQ1gsT0FBTztBQUFBLFlBQ1AsWUFBWTtBQUFBLFlBQ1osVUFBVTtBQUFBLFlBQ1YsY0FBYztBQUFBO0FBQUE7QUFBQTtBQUFBLFdBSWY7QUFDTCxpQkFBVyxtQkFBa0IsTUFBTSxXQUFXO0FBQzVDLGFBQUssU0FBUztBQUNkLFlBQUksV0FBVyxXQUFZO0FBQUE7QUFDM0IsaUJBQVMsWUFBWSxVQUFVO0FBQy9CLGFBQUssWUFBWSxJQUFJO0FBQ3JCLGFBQUssVUFBVSxjQUFjO0FBQUE7QUFBQTtBQUdqQyxJQUFPLG1CQUFRO0FBQUE7QUFBQTs7O0FDRlIsZ0JBQWdCLEdBQUc7QUFDeEIsTUFBSSxDQUFDLFNBQVMsSUFBSTtBQUNoQixRQUFJLFVBQVU7QUFDZCxhQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3pDLGNBQVEsS0FBSyxRQUFRLFVBQVU7QUFBQTtBQUVqQyxXQUFPLFFBQVEsS0FBSztBQUFBO0FBR3RCLE1BQUksSUFBSTtBQUNSLE1BQUksT0FBTztBQUNYLE1BQUksTUFBTSxLQUFLO0FBQ2YsTUFBSSxNQUFNLE9BQU8sR0FBRyxRQUFRLGNBQWMsU0FBUyxJQUFHO0FBQ3BELFFBQUksT0FBTTtBQUFNLGFBQU87QUFDdkIsUUFBSSxLQUFLO0FBQUssYUFBTztBQUNyQixZQUFRO0FBQUEsV0FDRDtBQUFNLGVBQU8sT0FBTyxLQUFLO0FBQUEsV0FDekI7QUFBTSxlQUFPLE9BQU8sS0FBSztBQUFBLFdBQ3pCO0FBQ0gsWUFBSTtBQUNGLGlCQUFPLEtBQUssVUFBVSxLQUFLO0FBQUEsaUJBQ3BCLEdBQVA7QUFDQSxpQkFBTztBQUFBO0FBQUE7QUFHVCxlQUFPO0FBQUE7QUFBQTtBQUdiLFdBQVMsSUFBSSxLQUFLLElBQUksSUFBSSxLQUFLLElBQUksS0FBSyxFQUFFLElBQUk7QUFDNUMsUUFBSSxPQUFPLE1BQU0sQ0FBQyxTQUFTLElBQUk7QUFDN0IsYUFBTyxNQUFNO0FBQUEsV0FDUjtBQUNMLGFBQU8sTUFBTSxRQUFRO0FBQUE7QUFBQTtBQUd6QixTQUFPO0FBQUE7QUFPRixtQkFBbUIsSUFBSSxLQUFLO0FBRWpDLE1BQUksWUFBWSxXQUFPLFVBQVU7QUFDL0IsV0FBTyxXQUFXO0FBQ2hCLGFBQU8sVUFBVSxJQUFJLEtBQUssTUFBTSxNQUFNO0FBQUE7QUFBQTtBQUkxQyxNQUFJLGdCQUFRLGtCQUFrQixNQUFNO0FBQ2xDLFdBQU87QUFBQTtBQUdULE1BQUksU0FBUztBQUNiLHdCQUFzQjtBQUNwQixRQUFJLENBQUMsUUFBUTtBQUNYLFVBQUksZ0JBQVEsa0JBQWtCO0FBQzVCLGNBQU0sSUFBSSxNQUFNO0FBQUEsaUJBQ1AsZ0JBQVEsa0JBQWtCO0FBQ25DLGdCQUFRLE1BQU07QUFBQSxhQUNUO0FBQ0wsZ0JBQVEsTUFBTTtBQUFBO0FBRWhCLGVBQVM7QUFBQTtBQUVYLFdBQU8sR0FBRyxNQUFNLE1BQU07QUFBQTtBQUd4QixTQUFPO0FBQUE7QUFNRixrQkFBa0IsS0FBSztBQUM1QixNQUFJLFlBQVk7QUFDZCxtQkFBZSxnQkFBUSxJQUFJLGNBQWM7QUFDM0MsUUFBTSxJQUFJO0FBQ1YsTUFBSSxDQUFDLE9BQU8sTUFBTTtBQUNoQixRQUFJLElBQUksT0FBTyxRQUFRLE1BQU0sT0FBTyxLQUFLLEtBQUssZUFBZTtBQUMzRCxVQUFJLE1BQU07QUFDVixhQUFPLE9BQU8sV0FBVztBQUN2QixZQUFJLE1BQU0sT0FBTyxNQUFNLE1BQU07QUFDN0IsZ0JBQVEsTUFBTSxhQUFhLEtBQUssS0FBSztBQUFBO0FBQUEsV0FFbEM7QUFDTCxhQUFPLE9BQU8sV0FBVztBQUFBO0FBQUE7QUFBQTtBQUc3QixTQUFPLE9BQU87QUFBQTtBQVlULGlCQUFpQixLQUFLLE1BQU07QUFFakMsTUFBSSxNQUFNO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUE7QUFHWCxNQUFJLFVBQVUsVUFBVTtBQUFHLFFBQUksUUFBUSxVQUFVO0FBQ2pELE1BQUksVUFBVSxVQUFVO0FBQUcsUUFBSSxTQUFTLFVBQVU7QUFDbEQsTUFBSSxVQUFVLE9BQU87QUFFbkIsUUFBSSxhQUFhO0FBQUEsYUFDUixNQUFNO0FBRWYsWUFBUSxLQUFLO0FBQUE7QUFHZixNQUFJLFlBQVksSUFBSTtBQUFhLFFBQUksYUFBYTtBQUNsRCxNQUFJLFlBQVksSUFBSTtBQUFRLFFBQUksUUFBUTtBQUN4QyxNQUFJLFlBQVksSUFBSTtBQUFTLFFBQUksU0FBUztBQUMxQyxNQUFJLFlBQVksSUFBSTtBQUFnQixRQUFJLGdCQUFnQjtBQUN4RCxNQUFJLElBQUk7QUFBUSxRQUFJLFVBQVU7QUFDOUIsU0FBTyxZQUFZLEtBQUssS0FBSyxJQUFJO0FBQUE7QUFrQ25DLDBCQUEwQixLQUFLLFdBQVc7QUFDeEMsTUFBSSxRQUFRLFFBQVEsT0FBTztBQUUzQixNQUFJLE9BQU87QUFDVCxXQUFPLE9BQVksUUFBUSxPQUFPLE9BQU8sS0FBSyxNQUFNLE1BQzdDLE9BQVksUUFBUSxPQUFPLE9BQU8sS0FBSztBQUFBLFNBQ3pDO0FBQ0wsV0FBTztBQUFBO0FBQUE7QUFLWCx3QkFBd0IsS0FBSyxXQUFXO0FBQ3RDLFNBQU87QUFBQTtBQUlULHFCQUFxQixPQUFPO0FBQzFCLE1BQUksT0FBTztBQUVYLFFBQU0sUUFBUSxTQUFTLEtBQUssS0FBSztBQUMvQixTQUFLLE9BQU87QUFBQTtBQUdkLFNBQU87QUFBQTtBQUlULHFCQUFxQixLQUFLLE9BQU8sY0FBYztBQUc3QyxNQUFJLElBQUksaUJBQ0osU0FDQSxXQUFXLE1BQU0sWUFFakIsTUFBTSxZQUFZLFdBRWxCLENBQUUsT0FBTSxlQUFlLE1BQU0sWUFBWSxjQUFjLFFBQVE7QUFDakUsUUFBSSxNQUFNLE1BQU0sUUFBUSxjQUFjO0FBQ3RDLFFBQUksQ0FBQyxTQUFTLE1BQU07QUFDbEIsWUFBTSxZQUFZLEtBQUssS0FBSztBQUFBO0FBRTlCLFdBQU87QUFBQTtBQUlULE1BQUksWUFBWSxnQkFBZ0IsS0FBSztBQUNyQyxNQUFJLFdBQVc7QUFDYixXQUFPO0FBQUE7QUFJVCxNQUFJLFFBQU8sT0FBTyxLQUFLO0FBQ3ZCLE1BQUksY0FBYyxZQUFZO0FBRTlCLE1BQUksSUFBSSxZQUFZO0FBQ2xCLFlBQU8sT0FBTyxvQkFBb0I7QUFBQTtBQUtwQyxNQUFJLFFBQVEsVUFDSixPQUFLLFFBQVEsY0FBYyxLQUFLLE1BQUssUUFBUSxrQkFBa0IsSUFBSTtBQUN6RSxXQUFPLFlBQVk7QUFBQTtBQUlyQixNQUFJLE1BQUssV0FBVyxHQUFHO0FBQ3JCLFFBQUksV0FBVyxRQUFRO0FBQ3JCLFVBQUksT0FBTyxNQUFNLE9BQU8sT0FBTyxNQUFNLE9BQU87QUFDNUMsYUFBTyxJQUFJLFFBQVEsY0FBYyxPQUFPLEtBQUs7QUFBQTtBQUUvQyxRQUFJLFNBQVMsUUFBUTtBQUNuQixhQUFPLElBQUksUUFBUSxPQUFPLFVBQVUsU0FBUyxLQUFLLFFBQVE7QUFBQTtBQUU1RCxRQUFJLE9BQU8sUUFBUTtBQUNqQixhQUFPLElBQUksUUFBUSxLQUFLLFVBQVUsU0FBUyxLQUFLLFFBQVE7QUFBQTtBQUUxRCxRQUFJLFFBQVEsUUFBUTtBQUNsQixhQUFPLFlBQVk7QUFBQTtBQUFBO0FBSXZCLE1BQUksT0FBTyxJQUFJLFFBQVEsT0FBTyxTQUFTLENBQUMsS0FBSztBQUc3QyxNQUFJLFFBQVEsUUFBUTtBQUNsQixZQUFRO0FBQ1IsYUFBUyxDQUFDLEtBQUs7QUFBQTtBQUlqQixNQUFJLFdBQVcsUUFBUTtBQUNyQixRQUFJLElBQUksTUFBTSxPQUFPLE9BQU8sTUFBTSxPQUFPO0FBQ3pDLFdBQU8sZUFBZSxJQUFJO0FBQUE7QUFJNUIsTUFBSSxTQUFTLFFBQVE7QUFDbkIsV0FBTyxNQUFNLE9BQU8sVUFBVSxTQUFTLEtBQUs7QUFBQTtBQUk5QyxNQUFJLE9BQU8sUUFBUTtBQUNqQixXQUFPLE1BQU0sS0FBSyxVQUFVLFlBQVksS0FBSztBQUFBO0FBSS9DLE1BQUksUUFBUSxRQUFRO0FBQ2xCLFdBQU8sTUFBTSxZQUFZO0FBQUE7QUFHM0IsTUFBSSxNQUFLLFdBQVcsS0FBTSxFQUFDLFNBQVMsTUFBTSxVQUFVLElBQUk7QUFDdEQsV0FBTyxPQUFPLEtBQUssT0FBTyxPQUFPO0FBQUE7QUFHbkMsTUFBSSxlQUFlLEdBQUc7QUFDcEIsUUFBSSxTQUFTLFFBQVE7QUFDbkIsYUFBTyxJQUFJLFFBQVEsT0FBTyxVQUFVLFNBQVMsS0FBSyxRQUFRO0FBQUEsV0FDckQ7QUFDTCxhQUFPLElBQUksUUFBUSxZQUFZO0FBQUE7QUFBQTtBQUluQyxNQUFJLEtBQUssS0FBSztBQUVkLE1BQUk7QUFDSixNQUFJLE9BQU87QUFDVCxhQUFTLFlBQVksS0FBSyxPQUFPLGNBQWMsYUFBYTtBQUFBLFNBQ3ZEO0FBQ0wsYUFBUyxNQUFLLElBQUksU0FBUyxLQUFLO0FBQzlCLGFBQU8sZUFBZSxLQUFLLE9BQU8sY0FBYyxhQUFhLEtBQUs7QUFBQTtBQUFBO0FBSXRFLE1BQUksS0FBSztBQUVULFNBQU8scUJBQXFCLFFBQVEsTUFBTTtBQUFBO0FBSTVDLHlCQUF5QixLQUFLLE9BQU87QUFDbkMsTUFBSSxZQUFZO0FBQ2QsV0FBTyxJQUFJLFFBQVEsYUFBYTtBQUNsQyxNQUFJLFNBQVMsUUFBUTtBQUNuQixRQUFJLFNBQVMsTUFBTyxLQUFLLFVBQVUsT0FBTyxRQUFRLFVBQVUsSUFDbEIsUUFBUSxNQUFNLE9BQ2QsUUFBUSxRQUFRLE9BQU87QUFDakUsV0FBTyxJQUFJLFFBQVEsUUFBUTtBQUFBO0FBRTdCLE1BQUksU0FBUztBQUNYLFdBQU8sSUFBSSxRQUFRLEtBQUssT0FBTztBQUNqQyxNQUFJLFVBQVU7QUFDWixXQUFPLElBQUksUUFBUSxLQUFLLE9BQU87QUFFakMsTUFBSSxPQUFPO0FBQ1QsV0FBTyxJQUFJLFFBQVEsUUFBUTtBQUFBO0FBSS9CLHFCQUFxQixPQUFPO0FBQzFCLFNBQU8sTUFBTSxNQUFNLFVBQVUsU0FBUyxLQUFLLFNBQVM7QUFBQTtBQUl0RCxxQkFBcUIsS0FBSyxPQUFPLGNBQWMsYUFBYSxPQUFNO0FBQ2hFLE1BQUksU0FBUztBQUNiLFdBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDNUMsUUFBSSxlQUFlLE9BQU8sT0FBTyxLQUFLO0FBQ3BDLGFBQU8sS0FBSyxlQUFlLEtBQUssT0FBTyxjQUFjLGFBQ2pELE9BQU8sSUFBSTtBQUFBLFdBQ1Y7QUFDTCxhQUFPLEtBQUs7QUFBQTtBQUFBO0FBR2hCLFFBQUssUUFBUSxTQUFTLEtBQUs7QUFDekIsUUFBSSxDQUFDLElBQUksTUFBTSxVQUFVO0FBQ3ZCLGFBQU8sS0FBSyxlQUFlLEtBQUssT0FBTyxjQUFjLGFBQ2pELEtBQUs7QUFBQTtBQUFBO0FBR2IsU0FBTztBQUFBO0FBSVQsd0JBQXdCLEtBQUssT0FBTyxjQUFjLGFBQWEsS0FBSyxPQUFPO0FBQ3pFLE1BQUksTUFBTSxLQUFLO0FBQ2YsU0FBTyxPQUFPLHlCQUF5QixPQUFPLFFBQVEsRUFBRSxPQUFPLE1BQU07QUFDckUsTUFBSSxLQUFLLEtBQUs7QUFDWixRQUFJLEtBQUssS0FBSztBQUNaLFlBQU0sSUFBSSxRQUFRLG1CQUFtQjtBQUFBLFdBQ2hDO0FBQ0wsWUFBTSxJQUFJLFFBQVEsWUFBWTtBQUFBO0FBQUEsU0FFM0I7QUFDTCxRQUFJLEtBQUssS0FBSztBQUNaLFlBQU0sSUFBSSxRQUFRLFlBQVk7QUFBQTtBQUFBO0FBR2xDLE1BQUksQ0FBQyxlQUFlLGFBQWEsTUFBTTtBQUNyQyxXQUFPLE1BQU0sTUFBTTtBQUFBO0FBRXJCLE1BQUksQ0FBQyxLQUFLO0FBQ1IsUUFBSSxJQUFJLEtBQUssUUFBUSxLQUFLLFNBQVMsR0FBRztBQUNwQyxVQUFJLE9BQU8sZUFBZTtBQUN4QixjQUFNLFlBQVksS0FBSyxLQUFLLE9BQU87QUFBQSxhQUM5QjtBQUNMLGNBQU0sWUFBWSxLQUFLLEtBQUssT0FBTyxlQUFlO0FBQUE7QUFFcEQsVUFBSSxJQUFJLFFBQVEsUUFBUSxJQUFJO0FBQzFCLFlBQUksT0FBTztBQUNULGdCQUFNLElBQUksTUFBTSxNQUFNLElBQUksU0FBUyxNQUFNO0FBQ3ZDLG1CQUFPLE9BQU87QUFBQSxhQUNiLEtBQUssTUFBTSxPQUFPO0FBQUEsZUFDaEI7QUFDTCxnQkFBTSxPQUFPLElBQUksTUFBTSxNQUFNLElBQUksU0FBUyxNQUFNO0FBQzlDLG1CQUFPLFFBQVE7QUFBQSxhQUNkLEtBQUs7QUFBQTtBQUFBO0FBQUEsV0FHUDtBQUNMLFlBQU0sSUFBSSxRQUFRLGNBQWM7QUFBQTtBQUFBO0FBR3BDLE1BQUksWUFBWSxPQUFPO0FBQ3JCLFFBQUksU0FBUyxJQUFJLE1BQU0sVUFBVTtBQUMvQixhQUFPO0FBQUE7QUFFVCxXQUFPLEtBQUssVUFBVSxLQUFLO0FBQzNCLFFBQUksS0FBSyxNQUFNLGlDQUFpQztBQUM5QyxhQUFPLEtBQUssT0FBTyxHQUFHLEtBQUssU0FBUztBQUNwQyxhQUFPLElBQUksUUFBUSxNQUFNO0FBQUEsV0FDcEI7QUFDTCxhQUFPLEtBQUssUUFBUSxNQUFNLE9BQ2QsUUFBUSxRQUFRLEtBQ2hCLFFBQVEsWUFBWTtBQUNoQyxhQUFPLElBQUksUUFBUSxNQUFNO0FBQUE7QUFBQTtBQUk3QixTQUFPLE9BQU8sT0FBTztBQUFBO0FBSXZCLDhCQUE4QixRQUFRLE1BQU0sUUFBUTtBQUNsRCxNQUFJLGNBQWM7QUFDbEIsTUFBSSxTQUFTLE9BQU8sT0FBTyxTQUFTLE1BQU0sS0FBSztBQUM3QztBQUNBLFFBQUksSUFBSSxRQUFRLFNBQVM7QUFBRztBQUM1QixXQUFPLE9BQU8sSUFBSSxRQUFRLG1CQUFtQixJQUFJLFNBQVM7QUFBQSxLQUN6RDtBQUVILE1BQUksU0FBUyxJQUFJO0FBQ2YsV0FBTyxPQUFPLEtBQ04sVUFBUyxLQUFLLEtBQUssT0FBTyxTQUMzQixNQUNBLE9BQU8sS0FBSyxXQUNaLE1BQ0EsT0FBTztBQUFBO0FBR2hCLFNBQU8sT0FBTyxLQUFLLE9BQU8sTUFBTSxPQUFPLEtBQUssUUFBUSxNQUFNLE9BQU87QUFBQTtBQU01RCxpQkFBaUIsSUFBSTtBQUMxQixTQUFPLE1BQU0sUUFBUTtBQUFBO0FBR2hCLG1CQUFtQixLQUFLO0FBQzdCLFNBQU8sT0FBTyxRQUFRO0FBQUE7QUFHakIsZ0JBQWdCLEtBQUs7QUFDMUIsU0FBTyxRQUFRO0FBQUE7QUFPVixrQkFBa0IsS0FBSztBQUM1QixTQUFPLE9BQU8sUUFBUTtBQUFBO0FBR2pCLGtCQUFrQixLQUFLO0FBQzVCLFNBQU8sT0FBTyxRQUFRO0FBQUE7QUFPakIscUJBQXFCLEtBQUs7QUFDL0IsU0FBTyxRQUFRO0FBQUE7QUFHVixrQkFBa0IsSUFBSTtBQUMzQixTQUFPLFNBQVMsT0FBTyxlQUFlLFFBQVE7QUFBQTtBQUd6QyxrQkFBa0IsS0FBSztBQUM1QixTQUFPLE9BQU8sUUFBUSxZQUFZLFFBQVE7QUFBQTtBQUdyQyxnQkFBZ0IsR0FBRztBQUN4QixTQUFPLFNBQVMsTUFBTSxlQUFlLE9BQU87QUFBQTtBQUd2QyxpQkFBaUIsR0FBRztBQUN6QixTQUFPLFNBQVMsTUFDWCxnQkFBZSxPQUFPLG9CQUFvQixhQUFhO0FBQUE7QUFHdkQsb0JBQW9CLEtBQUs7QUFDOUIsU0FBTyxPQUFPLFFBQVE7QUFBQTtBQWdCeEIsd0JBQXdCLEdBQUc7QUFDekIsU0FBTyxPQUFPLFVBQVUsU0FBUyxLQUFLO0FBQUE7QUE0Q2pDLGlCQUFpQixRQUFRLEtBQUs7QUFFbkMsTUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTO0FBQU0sV0FBTztBQUVuQyxNQUFJLFFBQU8sT0FBTyxLQUFLO0FBQ3ZCLE1BQUksSUFBSSxNQUFLO0FBQ2IsU0FBTyxLQUFLO0FBQ1YsV0FBTyxNQUFLLE1BQU0sSUFBSSxNQUFLO0FBQUE7QUFFN0IsU0FBTztBQUFBO0FBR1Qsd0JBQXdCLEtBQUssTUFBTTtBQUNqQyxTQUFPLE9BQU8sVUFBVSxlQUFlLEtBQUssS0FBSztBQUFBO0FBM2pCbkQsSUFxQkksY0EwRUEsUUFDQTtBQWhHSjtBQUFBO0FBQUE7QUFvQkE7QUF1aEJBO0FBdGhCQSxJQUFJLGVBQWU7QUEwRW5CLElBQUksU0FBUztBQXVEYixZQUFRLFNBQVM7QUFBQSxNQUNmLFFBQVMsQ0FBQyxHQUFHO0FBQUEsTUFDYixVQUFXLENBQUMsR0FBRztBQUFBLE1BQ2YsYUFBYyxDQUFDLEdBQUc7QUFBQSxNQUNsQixXQUFZLENBQUMsR0FBRztBQUFBLE1BQ2hCLFNBQVUsQ0FBQyxJQUFJO0FBQUEsTUFDZixRQUFTLENBQUMsSUFBSTtBQUFBLE1BQ2QsU0FBVSxDQUFDLElBQUk7QUFBQSxNQUNmLFFBQVMsQ0FBQyxJQUFJO0FBQUEsTUFDZCxRQUFTLENBQUMsSUFBSTtBQUFBLE1BQ2QsU0FBVSxDQUFDLElBQUk7QUFBQSxNQUNmLFdBQVksQ0FBQyxJQUFJO0FBQUEsTUFDakIsT0FBUSxDQUFDLElBQUk7QUFBQSxNQUNiLFVBQVcsQ0FBQyxJQUFJO0FBQUE7QUFJbEIsWUFBUSxTQUFTO0FBQUEsTUFDZixXQUFXO0FBQUEsTUFDWCxVQUFVO0FBQUEsTUFDVixXQUFXO0FBQUEsTUFDWCxhQUFhO0FBQUEsTUFDYixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFFUixVQUFVO0FBQUE7QUFBQTtBQUFBOzs7QUM1S1osZ0JBQWlCO0FBQ2YsV0FBUztBQUNULE1BQUksT0FBTztBQUNYLFdBQVMsSUFBSSxHQUFHLE1BQU0sS0FBSyxRQUFRLElBQUksS0FBSyxFQUFFLEdBQUc7QUFDL0MsV0FBTyxLQUFLLEtBQUs7QUFDakIsY0FBVSxLQUFLLFdBQVcsTUFBTTtBQUFBO0FBR2xDLFlBQVUsSUFBSSxXQUFXLE1BQU07QUFDL0IsWUFBVSxJQUFJLFdBQVcsTUFBTTtBQUFBO0FBR2pDLHFCQUFzQixLQUFLO0FBQ3pCLE1BQUksQ0FBQyxRQUFRO0FBQ1g7QUFBQTtBQUVGLE1BQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxjQUFjO0FBQ2hDLE1BQUksTUFBTSxJQUFJO0FBRWQsTUFBSSxNQUFNLElBQUksR0FBRztBQUNmLFVBQU0sSUFBSSxNQUFNO0FBQUE7QUFRbEIsaUJBQWUsSUFBSSxNQUFNLE9BQU8sTUFBTSxJQUFJLElBQUksTUFBTSxPQUFPLE1BQU0sSUFBSTtBQUdyRSxRQUFNLElBQUksSUFBSSxNQUFNLElBQUksSUFBSTtBQUc1QixNQUFJLGVBQWUsSUFBSSxNQUFNLElBQUk7QUFFakMsTUFBSSxJQUFJO0FBRVIsT0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHO0FBQ3hDLFVBQU8sVUFBVSxJQUFJLFdBQVcsT0FBTyxLQUFPLFVBQVUsSUFBSSxXQUFXLElBQUksT0FBTyxLQUFPLFVBQVUsSUFBSSxXQUFXLElBQUksT0FBTyxJQUFLLFVBQVUsSUFBSSxXQUFXLElBQUk7QUFDL0osUUFBSSxPQUFRLE9BQU8sS0FBTTtBQUN6QixRQUFJLE9BQVEsT0FBTyxJQUFLO0FBQ3hCLFFBQUksT0FBTyxNQUFNO0FBQUE7QUFHbkIsTUFBSSxpQkFBaUIsR0FBRztBQUN0QixVQUFPLFVBQVUsSUFBSSxXQUFXLE9BQU8sSUFBTSxVQUFVLElBQUksV0FBVyxJQUFJLE9BQU87QUFDakYsUUFBSSxPQUFPLE1BQU07QUFBQSxhQUNSLGlCQUFpQixHQUFHO0FBQzdCLFVBQU8sVUFBVSxJQUFJLFdBQVcsT0FBTyxLQUFPLFVBQVUsSUFBSSxXQUFXLElBQUksT0FBTyxJQUFNLFVBQVUsSUFBSSxXQUFXLElBQUksT0FBTztBQUM1SCxRQUFJLE9BQVEsT0FBTyxJQUFLO0FBQ3hCLFFBQUksT0FBTyxNQUFNO0FBQUE7QUFHbkIsU0FBTztBQUFBO0FBR1QseUJBQTBCLEtBQUs7QUFDN0IsU0FBTyxPQUFPLE9BQU8sS0FBSyxNQUFRLE9BQU8sT0FBTyxLQUFLLE1BQVEsT0FBTyxPQUFPLElBQUksTUFBUSxPQUFPLE1BQU07QUFBQTtBQUd0RyxxQkFBc0IsT0FBTyxPQUFPLEtBQUs7QUFDdkMsTUFBSTtBQUNKLE1BQUksU0FBUztBQUNiLFdBQVMsSUFBSSxPQUFPLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDbkMsVUFBTyxPQUFNLE1BQU0sTUFBTyxPQUFNLElBQUksTUFBTSxLQUFNLE1BQU0sSUFBSTtBQUMxRCxXQUFPLEtBQUssZ0JBQWdCO0FBQUE7QUFFOUIsU0FBTyxPQUFPLEtBQUs7QUFBQTtBQUdyQix1QkFBd0IsT0FBTztBQUM3QixNQUFJLENBQUMsUUFBUTtBQUNYO0FBQUE7QUFFRixNQUFJO0FBQ0osTUFBSSxNQUFNLE1BQU07QUFDaEIsTUFBSSxhQUFhLE1BQU07QUFDdkIsTUFBSSxTQUFTO0FBQ2IsTUFBSSxRQUFRO0FBQ1osTUFBSSxpQkFBaUI7QUFHckIsV0FBUyxJQUFJLEdBQUcsT0FBTyxNQUFNLFlBQVksSUFBSSxNQUFNLEtBQUssZ0JBQWdCO0FBQ3RFLFVBQU0sS0FBSyxZQUFZLE9BQU8sR0FBSSxJQUFJLGlCQUFrQixPQUFPLE9BQVEsSUFBSTtBQUFBO0FBSTdFLE1BQUksZUFBZSxHQUFHO0FBQ3BCLFVBQU0sTUFBTSxNQUFNO0FBQ2xCLGNBQVUsT0FBTyxPQUFPO0FBQ3hCLGNBQVUsT0FBUSxPQUFPLElBQUs7QUFDOUIsY0FBVTtBQUFBLGFBQ0QsZUFBZSxHQUFHO0FBQzNCLFVBQU8sT0FBTSxNQUFNLE1BQU0sS0FBTSxNQUFNLE1BQU07QUFDM0MsY0FBVSxPQUFPLE9BQU87QUFDeEIsY0FBVSxPQUFRLE9BQU8sSUFBSztBQUM5QixjQUFVLE9BQVEsT0FBTyxJQUFLO0FBQzlCLGNBQVU7QUFBQTtBQUdaLFFBQU0sS0FBSztBQUVYLFNBQU8sTUFBTSxLQUFLO0FBQUE7QUFHcEIsY0FBZSxRQUFRLFFBQVEsTUFBTSxNQUFNLFFBQVE7QUFDakQsTUFBSSxHQUFHO0FBQ1AsTUFBSSxPQUFPLFNBQVMsSUFBSSxPQUFPO0FBQy9CLE1BQUksT0FBUSxNQUFLLFFBQVE7QUFDekIsTUFBSSxRQUFRLFFBQVE7QUFDcEIsTUFBSSxRQUFRO0FBQ1osTUFBSSxJQUFJLE9BQVEsU0FBUyxJQUFLO0FBQzlCLE1BQUksSUFBSSxPQUFPLEtBQUs7QUFDcEIsTUFBSSxJQUFJLE9BQU8sU0FBUztBQUV4QixPQUFLO0FBRUwsTUFBSSxJQUFNLE1BQU0sQ0FBQyxTQUFVO0FBQzNCLFFBQU8sQ0FBQztBQUNSLFdBQVM7QUFDVCxTQUFPLFFBQVEsR0FBRyxJQUFJLElBQUksTUFBTSxPQUFPLFNBQVMsSUFBSSxLQUFLLEdBQUcsU0FBUyxHQUFHO0FBQUE7QUFFeEUsTUFBSSxJQUFNLE1BQU0sQ0FBQyxTQUFVO0FBQzNCLFFBQU8sQ0FBQztBQUNSLFdBQVM7QUFDVCxTQUFPLFFBQVEsR0FBRyxJQUFJLElBQUksTUFBTSxPQUFPLFNBQVMsSUFBSSxLQUFLLEdBQUcsU0FBUyxHQUFHO0FBQUE7QUFFeEUsTUFBSSxNQUFNLEdBQUc7QUFDWCxRQUFJLElBQUk7QUFBQSxhQUNDLE1BQU0sTUFBTTtBQUNyQixXQUFPLElBQUksTUFBUSxLQUFJLEtBQUssS0FBSztBQUFBLFNBQzVCO0FBQ0wsUUFBSSxJQUFJLEtBQUssSUFBSSxHQUFHO0FBQ3BCLFFBQUksSUFBSTtBQUFBO0FBRVYsU0FBUSxLQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssSUFBSSxHQUFHLElBQUk7QUFBQTtBQUc1QyxlQUFnQixRQUFRLE9BQU8sUUFBUSxNQUFNLE1BQU0sUUFBUTtBQUN6RCxNQUFJLEdBQUcsR0FBRztBQUNWLE1BQUksT0FBTyxTQUFTLElBQUksT0FBTztBQUMvQixNQUFJLE9BQVEsTUFBSyxRQUFRO0FBQ3pCLE1BQUksUUFBUSxRQUFRO0FBQ3BCLE1BQUksS0FBTSxTQUFTLEtBQUssS0FBSyxJQUFJLEdBQUcsT0FBTyxLQUFLLElBQUksR0FBRyxPQUFPO0FBQzlELE1BQUksSUFBSSxPQUFPLElBQUssU0FBUztBQUM3QixNQUFJLElBQUksT0FBTyxJQUFJO0FBQ25CLE1BQUksSUFBSSxRQUFRLEtBQU0sVUFBVSxLQUFLLElBQUksUUFBUSxJQUFLLElBQUk7QUFFMUQsVUFBUSxLQUFLLElBQUk7QUFFakIsTUFBSSxNQUFNLFVBQVUsVUFBVSxVQUFVO0FBQ3RDLFFBQUksTUFBTSxTQUFTLElBQUk7QUFDdkIsUUFBSTtBQUFBLFNBQ0M7QUFDTCxRQUFJLEtBQUssTUFBTSxLQUFLLElBQUksU0FBUyxLQUFLO0FBQ3RDLFFBQUksUUFBUyxLQUFJLEtBQUssSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHO0FBQ3JDO0FBQ0EsV0FBSztBQUFBO0FBRVAsUUFBSSxJQUFJLFNBQVMsR0FBRztBQUNsQixlQUFTLEtBQUs7QUFBQSxXQUNUO0FBQ0wsZUFBUyxLQUFLLEtBQUssSUFBSSxHQUFHLElBQUk7QUFBQTtBQUVoQyxRQUFJLFFBQVEsS0FBSyxHQUFHO0FBQ2xCO0FBQ0EsV0FBSztBQUFBO0FBR1AsUUFBSSxJQUFJLFNBQVMsTUFBTTtBQUNyQixVQUFJO0FBQ0osVUFBSTtBQUFBLGVBQ0ssSUFBSSxTQUFTLEdBQUc7QUFDekIsVUFBSyxTQUFRLElBQUksS0FBSyxLQUFLLElBQUksR0FBRztBQUNsQyxVQUFJLElBQUk7QUFBQSxXQUNIO0FBQ0wsVUFBSSxRQUFRLEtBQUssSUFBSSxHQUFHLFFBQVEsS0FBSyxLQUFLLElBQUksR0FBRztBQUNqRCxVQUFJO0FBQUE7QUFBQTtBQUlSLFNBQU8sUUFBUSxHQUFHLE9BQU8sU0FBUyxLQUFLLElBQUksS0FBTSxLQUFLLEdBQUcsS0FBSyxLQUFLLFFBQVEsR0FBRztBQUFBO0FBRTlFLE1BQUssS0FBSyxPQUFRO0FBQ2xCLFVBQVE7QUFDUixTQUFPLE9BQU8sR0FBRyxPQUFPLFNBQVMsS0FBSyxJQUFJLEtBQU0sS0FBSyxHQUFHLEtBQUssS0FBSyxRQUFRLEdBQUc7QUFBQTtBQUU3RSxTQUFPLFNBQVMsSUFBSSxNQUFNLElBQUk7QUFBQTtBQW1EaEMsc0JBQXVCO0FBQ3JCLFNBQU8sUUFBTyxzQkFDVixhQUNBO0FBQUE7QUFHTixzQkFBdUIsTUFBTSxRQUFRO0FBQ25DLE1BQUksZUFBZSxRQUFRO0FBQ3pCLFVBQU0sSUFBSSxXQUFXO0FBQUE7QUFFdkIsTUFBSSxRQUFPLHFCQUFxQjtBQUU5QixXQUFPLElBQUksV0FBVztBQUN0QixTQUFLLFlBQVksUUFBTztBQUFBLFNBQ25CO0FBRUwsUUFBSSxTQUFTLE1BQU07QUFDakIsYUFBTyxJQUFJLFFBQU87QUFBQTtBQUVwQixTQUFLLFNBQVM7QUFBQTtBQUdoQixTQUFPO0FBQUE7QUFhVCxpQkFBaUIsS0FBSyxrQkFBa0IsUUFBUTtBQUM5QyxNQUFJLENBQUMsUUFBTyx1QkFBdUIsQ0FBRSxpQkFBZ0IsVUFBUztBQUM1RCxXQUFPLElBQUksUUFBTyxLQUFLLGtCQUFrQjtBQUFBO0FBSTNDLE1BQUksT0FBTyxRQUFRLFVBQVU7QUFDM0IsUUFBSSxPQUFPLHFCQUFxQixVQUFVO0FBQ3hDLFlBQU0sSUFBSSxNQUNSO0FBQUE7QUFHSixXQUFPLFlBQVksTUFBTTtBQUFBO0FBRTNCLFNBQU8sS0FBSyxNQUFNLEtBQUssa0JBQWtCO0FBQUE7QUFXM0MsY0FBZSxNQUFNLE9BQU8sa0JBQWtCLFFBQVE7QUFDcEQsTUFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixVQUFNLElBQUksVUFBVTtBQUFBO0FBR3RCLE1BQUksT0FBTyxnQkFBZ0IsZUFBZSxpQkFBaUIsYUFBYTtBQUN0RSxXQUFPLGdCQUFnQixNQUFNLE9BQU8sa0JBQWtCO0FBQUE7QUFHeEQsTUFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixXQUFPLFdBQVcsTUFBTSxPQUFPO0FBQUE7QUFHakMsU0FBTyxXQUFXLE1BQU07QUFBQTtBQW9CMUIsb0JBQXFCLE1BQU07QUFDekIsTUFBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixVQUFNLElBQUksVUFBVTtBQUFBLGFBQ1gsT0FBTyxHQUFHO0FBQ25CLFVBQU0sSUFBSSxXQUFXO0FBQUE7QUFBQTtBQUl6QixlQUFnQixNQUFNLE1BQU0sT0FBTSxVQUFVO0FBQzFDLGFBQVc7QUFDWCxNQUFJLFFBQVEsR0FBRztBQUNiLFdBQU8sYUFBYSxNQUFNO0FBQUE7QUFFNUIsTUFBSSxVQUFTLFFBQVc7QUFJdEIsV0FBTyxPQUFPLGFBQWEsV0FDdkIsYUFBYSxNQUFNLE1BQU0sS0FBSyxPQUFNLFlBQ3BDLGFBQWEsTUFBTSxNQUFNLEtBQUs7QUFBQTtBQUVwQyxTQUFPLGFBQWEsTUFBTTtBQUFBO0FBVzVCLHFCQUFzQixNQUFNLE1BQU07QUFDaEMsYUFBVztBQUNYLFNBQU8sYUFBYSxNQUFNLE9BQU8sSUFBSSxJQUFJLFFBQVEsUUFBUTtBQUN6RCxNQUFJLENBQUMsUUFBTyxxQkFBcUI7QUFDL0IsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM3QixXQUFLLEtBQUs7QUFBQTtBQUFBO0FBR2QsU0FBTztBQUFBO0FBZ0JULG9CQUFxQixNQUFNLFFBQVEsVUFBVTtBQUMzQyxNQUFJLE9BQU8sYUFBYSxZQUFZLGFBQWEsSUFBSTtBQUNuRCxlQUFXO0FBQUE7QUFHYixNQUFJLENBQUMsUUFBTyxXQUFXLFdBQVc7QUFDaEMsVUFBTSxJQUFJLFVBQVU7QUFBQTtBQUd0QixNQUFJLFNBQVMsV0FBVyxRQUFRLFlBQVk7QUFDNUMsU0FBTyxhQUFhLE1BQU07QUFFMUIsTUFBSSxTQUFTLEtBQUssTUFBTSxRQUFRO0FBRWhDLE1BQUksV0FBVyxRQUFRO0FBSXJCLFdBQU8sS0FBSyxNQUFNLEdBQUc7QUFBQTtBQUd2QixTQUFPO0FBQUE7QUFHVCx1QkFBd0IsTUFBTSxPQUFPO0FBQ25DLE1BQUksU0FBUyxNQUFNLFNBQVMsSUFBSSxJQUFJLFFBQVEsTUFBTSxVQUFVO0FBQzVELFNBQU8sYUFBYSxNQUFNO0FBQzFCLFdBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxLQUFLLEdBQUc7QUFDbEMsU0FBSyxLQUFLLE1BQU0sS0FBSztBQUFBO0FBRXZCLFNBQU87QUFBQTtBQUdULHlCQUEwQixNQUFNLE9BQU8sWUFBWSxRQUFRO0FBQ3pELFFBQU07QUFFTixNQUFJLGFBQWEsS0FBSyxNQUFNLGFBQWEsWUFBWTtBQUNuRCxVQUFNLElBQUksV0FBVztBQUFBO0FBR3ZCLE1BQUksTUFBTSxhQUFhLGFBQWMsV0FBVSxJQUFJO0FBQ2pELFVBQU0sSUFBSSxXQUFXO0FBQUE7QUFHdkIsTUFBSSxlQUFlLFVBQWEsV0FBVyxRQUFXO0FBQ3BELFlBQVEsSUFBSSxXQUFXO0FBQUEsYUFDZCxXQUFXLFFBQVc7QUFDL0IsWUFBUSxJQUFJLFdBQVcsT0FBTztBQUFBLFNBQ3pCO0FBQ0wsWUFBUSxJQUFJLFdBQVcsT0FBTyxZQUFZO0FBQUE7QUFHNUMsTUFBSSxRQUFPLHFCQUFxQjtBQUU5QixXQUFPO0FBQ1AsU0FBSyxZQUFZLFFBQU87QUFBQSxTQUNuQjtBQUVMLFdBQU8sY0FBYyxNQUFNO0FBQUE7QUFFN0IsU0FBTztBQUFBO0FBR1Qsb0JBQXFCLE1BQU0sS0FBSztBQUM5QixNQUFJLGlCQUFpQixNQUFNO0FBQ3pCLFFBQUksTUFBTSxRQUFRLElBQUksVUFBVTtBQUNoQyxXQUFPLGFBQWEsTUFBTTtBQUUxQixRQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLGFBQU87QUFBQTtBQUdULFFBQUksS0FBSyxNQUFNLEdBQUcsR0FBRztBQUNyQixXQUFPO0FBQUE7QUFHVCxNQUFJLEtBQUs7QUFDUCxRQUFLLE9BQU8sZ0JBQWdCLGVBQ3hCLElBQUksa0JBQWtCLGVBQWdCLFlBQVksS0FBSztBQUN6RCxVQUFJLE9BQU8sSUFBSSxXQUFXLFlBQVksTUFBTSxJQUFJLFNBQVM7QUFDdkQsZUFBTyxhQUFhLE1BQU07QUFBQTtBQUU1QixhQUFPLGNBQWMsTUFBTTtBQUFBO0FBRzdCLFFBQUksSUFBSSxTQUFTLFlBQVksU0FBUSxJQUFJLE9BQU87QUFDOUMsYUFBTyxjQUFjLE1BQU0sSUFBSTtBQUFBO0FBQUE7QUFJbkMsUUFBTSxJQUFJLFVBQVU7QUFBQTtBQUd0QixpQkFBa0IsUUFBUTtBQUd4QixNQUFJLFVBQVUsY0FBYztBQUMxQixVQUFNLElBQUksV0FBVyw0REFDYSxhQUFhLFNBQVMsTUFBTTtBQUFBO0FBRWhFLFNBQU8sU0FBUztBQUFBO0FBVWxCLDBCQUEyQixHQUFHO0FBQzVCLFNBQU8sQ0FBQyxDQUFFLE1BQUssUUFBUSxFQUFFO0FBQUE7QUEyRTNCLG9CQUFxQixRQUFRLFVBQVU7QUFDckMsTUFBSSxpQkFBaUIsU0FBUztBQUM1QixXQUFPLE9BQU87QUFBQTtBQUVoQixNQUFJLE9BQU8sZ0JBQWdCLGVBQWUsT0FBTyxZQUFZLFdBQVcsY0FDbkUsYUFBWSxPQUFPLFdBQVcsa0JBQWtCLGNBQWM7QUFDakUsV0FBTyxPQUFPO0FBQUE7QUFFaEIsTUFBSSxPQUFPLFdBQVcsVUFBVTtBQUM5QixhQUFTLEtBQUs7QUFBQTtBQUdoQixNQUFJLE1BQU0sT0FBTztBQUNqQixNQUFJLFFBQVE7QUFBRyxXQUFPO0FBR3RCLE1BQUksY0FBYztBQUNsQixhQUFTO0FBQ1AsWUFBUTtBQUFBLFdBQ0Q7QUFBQSxXQUNBO0FBQUEsV0FDQTtBQUNILGVBQU87QUFBQSxXQUNKO0FBQUEsV0FDQTtBQUFBLFdBQ0E7QUFDSCxlQUFPLFlBQVksUUFBUTtBQUFBLFdBQ3hCO0FBQUEsV0FDQTtBQUFBLFdBQ0E7QUFBQSxXQUNBO0FBQ0gsZUFBTyxNQUFNO0FBQUEsV0FDVjtBQUNILGVBQU8sUUFBUTtBQUFBLFdBQ1o7QUFDSCxlQUFPLGNBQWMsUUFBUTtBQUFBO0FBRTdCLFlBQUk7QUFBYSxpQkFBTyxZQUFZLFFBQVE7QUFDNUMsbUJBQVksTUFBSyxVQUFVO0FBQzNCLHNCQUFjO0FBQUE7QUFBQTtBQUFBO0FBTXRCLHNCQUF1QixVQUFVLE9BQU8sS0FBSztBQUMzQyxNQUFJLGNBQWM7QUFTbEIsTUFBSSxVQUFVLFVBQWEsUUFBUSxHQUFHO0FBQ3BDLFlBQVE7QUFBQTtBQUlWLE1BQUksUUFBUSxLQUFLLFFBQVE7QUFDdkIsV0FBTztBQUFBO0FBR1QsTUFBSSxRQUFRLFVBQWEsTUFBTSxLQUFLLFFBQVE7QUFDMUMsVUFBTSxLQUFLO0FBQUE7QUFHYixNQUFJLE9BQU8sR0FBRztBQUNaLFdBQU87QUFBQTtBQUlULFdBQVM7QUFDVCxhQUFXO0FBRVgsTUFBSSxPQUFPLE9BQU87QUFDaEIsV0FBTztBQUFBO0FBR1QsTUFBSSxDQUFDO0FBQVUsZUFBVztBQUUxQixTQUFPLE1BQU07QUFDWCxZQUFRO0FBQUEsV0FDRDtBQUNILGVBQU8sU0FBUyxNQUFNLE9BQU87QUFBQSxXQUUxQjtBQUFBLFdBQ0E7QUFDSCxlQUFPLFVBQVUsTUFBTSxPQUFPO0FBQUEsV0FFM0I7QUFDSCxlQUFPLFdBQVcsTUFBTSxPQUFPO0FBQUEsV0FFNUI7QUFBQSxXQUNBO0FBQ0gsZUFBTyxZQUFZLE1BQU0sT0FBTztBQUFBLFdBRTdCO0FBQ0gsZUFBTyxZQUFZLE1BQU0sT0FBTztBQUFBLFdBRTdCO0FBQUEsV0FDQTtBQUFBLFdBQ0E7QUFBQSxXQUNBO0FBQ0gsZUFBTyxhQUFhLE1BQU0sT0FBTztBQUFBO0FBR2pDLFlBQUk7QUFBYSxnQkFBTSxJQUFJLFVBQVUsdUJBQXVCO0FBQzVELG1CQUFZLFlBQVcsSUFBSTtBQUMzQixzQkFBYztBQUFBO0FBQUE7QUFBQTtBQVN0QixjQUFlLEdBQUcsR0FBRyxHQUFHO0FBQ3RCLE1BQUksSUFBSSxFQUFFO0FBQ1YsSUFBRSxLQUFLLEVBQUU7QUFDVCxJQUFFLEtBQUs7QUFBQTtBQW1JVCw4QkFBK0IsUUFBUSxLQUFLLFlBQVksVUFBVSxLQUFLO0FBRXJFLE1BQUksT0FBTyxXQUFXO0FBQUcsV0FBTztBQUdoQyxNQUFJLE9BQU8sZUFBZSxVQUFVO0FBQ2xDLGVBQVc7QUFDWCxpQkFBYTtBQUFBLGFBQ0osYUFBYSxZQUFZO0FBQ2xDLGlCQUFhO0FBQUEsYUFDSixhQUFhLGFBQWE7QUFDbkMsaUJBQWE7QUFBQTtBQUVmLGVBQWEsQ0FBQztBQUNkLE1BQUksTUFBTSxhQUFhO0FBRXJCLGlCQUFhLE1BQU0sSUFBSyxPQUFPLFNBQVM7QUFBQTtBQUkxQyxNQUFJLGFBQWE7QUFBRyxpQkFBYSxPQUFPLFNBQVM7QUFDakQsTUFBSSxjQUFjLE9BQU8sUUFBUTtBQUMvQixRQUFJO0FBQUssYUFBTztBQUFBO0FBQ1gsbUJBQWEsT0FBTyxTQUFTO0FBQUEsYUFDekIsYUFBYSxHQUFHO0FBQ3pCLFFBQUk7QUFBSyxtQkFBYTtBQUFBO0FBQ2pCLGFBQU87QUFBQTtBQUlkLE1BQUksT0FBTyxRQUFRLFVBQVU7QUFDM0IsVUFBTSxRQUFPLEtBQUssS0FBSztBQUFBO0FBSXpCLE1BQUksaUJBQWlCLE1BQU07QUFFekIsUUFBSSxJQUFJLFdBQVcsR0FBRztBQUNwQixhQUFPO0FBQUE7QUFFVCxXQUFPLGFBQWEsUUFBUSxLQUFLLFlBQVksVUFBVTtBQUFBLGFBQzlDLE9BQU8sUUFBUSxVQUFVO0FBQ2xDLFVBQU0sTUFBTTtBQUNaLFFBQUksUUFBTyx1QkFDUCxPQUFPLFdBQVcsVUFBVSxZQUFZLFlBQVk7QUFDdEQsVUFBSSxLQUFLO0FBQ1AsZUFBTyxXQUFXLFVBQVUsUUFBUSxLQUFLLFFBQVEsS0FBSztBQUFBLGFBQ2pEO0FBQ0wsZUFBTyxXQUFXLFVBQVUsWUFBWSxLQUFLLFFBQVEsS0FBSztBQUFBO0FBQUE7QUFHOUQsV0FBTyxhQUFhLFFBQVEsQ0FBRSxNQUFPLFlBQVksVUFBVTtBQUFBO0FBRzdELFFBQU0sSUFBSSxVQUFVO0FBQUE7QUFHdEIsc0JBQXVCLEtBQUssS0FBSyxZQUFZLFVBQVUsS0FBSztBQUMxRCxNQUFJLFlBQVk7QUFDaEIsTUFBSSxZQUFZLElBQUk7QUFDcEIsTUFBSSxZQUFZLElBQUk7QUFFcEIsTUFBSSxhQUFhLFFBQVc7QUFDMUIsZUFBVyxPQUFPLFVBQVU7QUFDNUIsUUFBSSxhQUFhLFVBQVUsYUFBYSxXQUNwQyxhQUFhLGFBQWEsYUFBYSxZQUFZO0FBQ3JELFVBQUksSUFBSSxTQUFTLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFDcEMsZUFBTztBQUFBO0FBRVQsa0JBQVk7QUFDWixtQkFBYTtBQUNiLG1CQUFhO0FBQ2Isb0JBQWM7QUFBQTtBQUFBO0FBSWxCLGlCQUFlLEtBQUssSUFBRztBQUNyQixRQUFJLGNBQWMsR0FBRztBQUNuQixhQUFPLElBQUk7QUFBQSxXQUNOO0FBQ0wsYUFBTyxJQUFJLGFBQWEsS0FBSTtBQUFBO0FBQUE7QUFJaEMsTUFBSTtBQUNKLE1BQUksS0FBSztBQUNQLFFBQUksYUFBYTtBQUNqQixTQUFLLElBQUksWUFBWSxJQUFJLFdBQVcsS0FBSztBQUN2QyxVQUFJLE1BQUssS0FBSyxPQUFPLE1BQUssS0FBSyxlQUFlLEtBQUssSUFBSSxJQUFJLGFBQWE7QUFDdEUsWUFBSSxlQUFlO0FBQUksdUJBQWE7QUFDcEMsWUFBSSxJQUFJLGFBQWEsTUFBTTtBQUFXLGlCQUFPLGFBQWE7QUFBQSxhQUNyRDtBQUNMLFlBQUksZUFBZTtBQUFJLGVBQUssSUFBSTtBQUNoQyxxQkFBYTtBQUFBO0FBQUE7QUFBQSxTQUdaO0FBQ0wsUUFBSSxhQUFhLFlBQVk7QUFBVyxtQkFBYSxZQUFZO0FBQ2pFLFNBQUssSUFBSSxZQUFZLEtBQUssR0FBRyxLQUFLO0FBQ2hDLFVBQUksUUFBUTtBQUNaLGVBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxLQUFLO0FBQ2xDLFlBQUksTUFBSyxLQUFLLElBQUksT0FBTyxNQUFLLEtBQUssSUFBSTtBQUNyQyxrQkFBUTtBQUNSO0FBQUE7QUFBQTtBQUdKLFVBQUk7QUFBTyxlQUFPO0FBQUE7QUFBQTtBQUl0QixTQUFPO0FBQUE7QUFlVCxrQkFBbUIsS0FBSyxRQUFRLFFBQVEsUUFBUTtBQUM5QyxXQUFTLE9BQU8sV0FBVztBQUMzQixNQUFJLFlBQVksSUFBSSxTQUFTO0FBQzdCLE1BQUksQ0FBQyxRQUFRO0FBQ1gsYUFBUztBQUFBLFNBQ0o7QUFDTCxhQUFTLE9BQU87QUFDaEIsUUFBSSxTQUFTLFdBQVc7QUFDdEIsZUFBUztBQUFBO0FBQUE7QUFLYixNQUFJLFNBQVMsT0FBTztBQUNwQixNQUFJLFNBQVMsTUFBTTtBQUFHLFVBQU0sSUFBSSxVQUFVO0FBRTFDLE1BQUksU0FBUyxTQUFTLEdBQUc7QUFDdkIsYUFBUyxTQUFTO0FBQUE7QUFFcEIsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUMvQixRQUFJLFNBQVMsU0FBUyxPQUFPLE9BQU8sSUFBSSxHQUFHLElBQUk7QUFDL0MsUUFBSSxNQUFNO0FBQVMsYUFBTztBQUMxQixRQUFJLFNBQVMsS0FBSztBQUFBO0FBRXBCLFNBQU87QUFBQTtBQUdULG1CQUFvQixLQUFLLFFBQVEsUUFBUSxRQUFRO0FBQy9DLFNBQU8sV0FBVyxZQUFZLFFBQVEsSUFBSSxTQUFTLFNBQVMsS0FBSyxRQUFRO0FBQUE7QUFHM0Usb0JBQXFCLEtBQUssUUFBUSxRQUFRLFFBQVE7QUFDaEQsU0FBTyxXQUFXLGFBQWEsU0FBUyxLQUFLLFFBQVE7QUFBQTtBQUd2RCxxQkFBc0IsS0FBSyxRQUFRLFFBQVEsUUFBUTtBQUNqRCxTQUFPLFdBQVcsS0FBSyxRQUFRLFFBQVE7QUFBQTtBQUd6QyxxQkFBc0IsS0FBSyxRQUFRLFFBQVEsUUFBUTtBQUNqRCxTQUFPLFdBQVcsY0FBYyxTQUFTLEtBQUssUUFBUTtBQUFBO0FBR3hELG1CQUFvQixLQUFLLFFBQVEsUUFBUSxRQUFRO0FBQy9DLFNBQU8sV0FBVyxlQUFlLFFBQVEsSUFBSSxTQUFTLFNBQVMsS0FBSyxRQUFRO0FBQUE7QUFrRjlFLHFCQUFzQixLQUFLLE9BQU8sS0FBSztBQUNyQyxNQUFJLFVBQVUsS0FBSyxRQUFRLElBQUksUUFBUTtBQUNyQyxXQUFPLGNBQWM7QUFBQSxTQUNoQjtBQUNMLFdBQU8sY0FBYyxJQUFJLE1BQU0sT0FBTztBQUFBO0FBQUE7QUFJMUMsbUJBQW9CLEtBQUssT0FBTyxLQUFLO0FBQ25DLFFBQU0sS0FBSyxJQUFJLElBQUksUUFBUTtBQUMzQixNQUFJLE1BQU07QUFFVixNQUFJLElBQUk7QUFDUixTQUFPLElBQUksS0FBSztBQUNkLFFBQUksWUFBWSxJQUFJO0FBQ3BCLFFBQUksWUFBWTtBQUNoQixRQUFJLG1CQUFvQixZQUFZLE1BQVEsSUFDdkMsWUFBWSxNQUFRLElBQ3BCLFlBQVksTUFBUSxJQUNyQjtBQUVKLFFBQUksSUFBSSxvQkFBb0IsS0FBSztBQUMvQixVQUFJLFlBQVksV0FBVyxZQUFZO0FBRXZDLGNBQVE7QUFBQSxhQUNEO0FBQ0gsY0FBSSxZQUFZLEtBQU07QUFDcEIsd0JBQVk7QUFBQTtBQUVkO0FBQUEsYUFDRztBQUNILHVCQUFhLElBQUksSUFBSTtBQUNyQixjQUFLLGNBQWEsU0FBVSxLQUFNO0FBQ2hDLDRCQUFpQixhQUFZLE9BQVMsSUFBTyxhQUFhO0FBQzFELGdCQUFJLGdCQUFnQixLQUFNO0FBQ3hCLDBCQUFZO0FBQUE7QUFBQTtBQUdoQjtBQUFBLGFBQ0c7QUFDSCx1QkFBYSxJQUFJLElBQUk7QUFDckIsc0JBQVksSUFBSSxJQUFJO0FBQ3BCLGNBQUssY0FBYSxTQUFVLE9BQVMsYUFBWSxTQUFVLEtBQU07QUFDL0QsNEJBQWlCLGFBQVksT0FBUSxLQUFPLGNBQWEsT0FBUyxJQUFPLFlBQVk7QUFDckYsZ0JBQUksZ0JBQWdCLFFBQVUsaUJBQWdCLFNBQVUsZ0JBQWdCLFFBQVM7QUFDL0UsMEJBQVk7QUFBQTtBQUFBO0FBR2hCO0FBQUEsYUFDRztBQUNILHVCQUFhLElBQUksSUFBSTtBQUNyQixzQkFBWSxJQUFJLElBQUk7QUFDcEIsdUJBQWEsSUFBSSxJQUFJO0FBQ3JCLGNBQUssY0FBYSxTQUFVLE9BQVMsYUFBWSxTQUFVLE9BQVMsY0FBYSxTQUFVLEtBQU07QUFDL0YsNEJBQWlCLGFBQVksT0FBUSxLQUFRLGNBQWEsT0FBUyxLQUFPLGFBQVksT0FBUyxJQUFPLGFBQWE7QUFDbkgsZ0JBQUksZ0JBQWdCLFNBQVUsZ0JBQWdCLFNBQVU7QUFDdEQsMEJBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU10QixRQUFJLGNBQWMsTUFBTTtBQUd0QixrQkFBWTtBQUNaLHlCQUFtQjtBQUFBLGVBQ1YsWUFBWSxPQUFRO0FBRTdCLG1CQUFhO0FBQ2IsVUFBSSxLQUFLLGNBQWMsS0FBSyxPQUFRO0FBQ3BDLGtCQUFZLFFBQVMsWUFBWTtBQUFBO0FBR25DLFFBQUksS0FBSztBQUNULFNBQUs7QUFBQTtBQUdQLFNBQU8sc0JBQXNCO0FBQUE7QUFRL0IsK0JBQWdDLFlBQVk7QUFDMUMsTUFBSSxNQUFNLFdBQVc7QUFDckIsTUFBSSxPQUFPLHNCQUFzQjtBQUMvQixXQUFPLE9BQU8sYUFBYSxNQUFNLFFBQVE7QUFBQTtBQUkzQyxNQUFJLE1BQU07QUFDVixNQUFJLElBQUk7QUFDUixTQUFPLElBQUksS0FBSztBQUNkLFdBQU8sT0FBTyxhQUFhLE1BQ3pCLFFBQ0EsV0FBVyxNQUFNLEdBQUcsS0FBSztBQUFBO0FBRzdCLFNBQU87QUFBQTtBQUdULG9CQUFxQixLQUFLLE9BQU8sS0FBSztBQUNwQyxNQUFJLE1BQU07QUFDVixRQUFNLEtBQUssSUFBSSxJQUFJLFFBQVE7QUFFM0IsV0FBUyxJQUFJLE9BQU8sSUFBSSxLQUFLLEVBQUUsR0FBRztBQUNoQyxXQUFPLE9BQU8sYUFBYSxJQUFJLEtBQUs7QUFBQTtBQUV0QyxTQUFPO0FBQUE7QUFHVCxxQkFBc0IsS0FBSyxPQUFPLEtBQUs7QUFDckMsTUFBSSxNQUFNO0FBQ1YsUUFBTSxLQUFLLElBQUksSUFBSSxRQUFRO0FBRTNCLFdBQVMsSUFBSSxPQUFPLElBQUksS0FBSyxFQUFFLEdBQUc7QUFDaEMsV0FBTyxPQUFPLGFBQWEsSUFBSTtBQUFBO0FBRWpDLFNBQU87QUFBQTtBQUdULGtCQUFtQixLQUFLLE9BQU8sS0FBSztBQUNsQyxNQUFJLE1BQU0sSUFBSTtBQUVkLE1BQUksQ0FBQyxTQUFTLFFBQVE7QUFBRyxZQUFRO0FBQ2pDLE1BQUksQ0FBQyxPQUFPLE1BQU0sS0FBSyxNQUFNO0FBQUssVUFBTTtBQUV4QyxNQUFJLE1BQU07QUFDVixXQUFTLElBQUksT0FBTyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQ2hDLFdBQU8sTUFBTSxJQUFJO0FBQUE7QUFFbkIsU0FBTztBQUFBO0FBR1Qsc0JBQXVCLEtBQUssT0FBTyxLQUFLO0FBQ3RDLE1BQUksUUFBUSxJQUFJLE1BQU0sT0FBTztBQUM3QixNQUFJLE1BQU07QUFDVixXQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDeEMsV0FBTyxPQUFPLGFBQWEsTUFBTSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQUE7QUFFdkQsU0FBTztBQUFBO0FBMENULHFCQUFzQixRQUFRLEtBQUssUUFBUTtBQUN6QyxNQUFLLFNBQVMsTUFBTyxLQUFLLFNBQVM7QUFBRyxVQUFNLElBQUksV0FBVztBQUMzRCxNQUFJLFNBQVMsTUFBTTtBQUFRLFVBQU0sSUFBSSxXQUFXO0FBQUE7QUErSmxELGtCQUFtQixLQUFLLE9BQU8sUUFBUSxLQUFLLEtBQUssS0FBSztBQUNwRCxNQUFJLENBQUMsaUJBQWlCO0FBQU0sVUFBTSxJQUFJLFVBQVU7QUFDaEQsTUFBSSxRQUFRLE9BQU8sUUFBUTtBQUFLLFVBQU0sSUFBSSxXQUFXO0FBQ3JELE1BQUksU0FBUyxNQUFNLElBQUk7QUFBUSxVQUFNLElBQUksV0FBVztBQUFBO0FBa0R0RCwyQkFBNEIsS0FBSyxPQUFPLFFBQVEsY0FBYztBQUM1RCxNQUFJLFFBQVE7QUFBRyxZQUFRLFFBQVMsUUFBUTtBQUN4QyxXQUFTLElBQUksR0FBRyxJQUFJLEtBQUssSUFBSSxJQUFJLFNBQVMsUUFBUSxJQUFJLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDaEUsUUFBSSxTQUFTLEtBQU0sU0FBUyxPQUFTLElBQUssZ0JBQWUsSUFBSSxJQUFJLFFBQzlELGdCQUFlLElBQUksSUFBSSxLQUFLO0FBQUE7QUFBQTtBQThCbkMsMkJBQTRCLEtBQUssT0FBTyxRQUFRLGNBQWM7QUFDNUQsTUFBSSxRQUFRO0FBQUcsWUFBUSxhQUFhLFFBQVE7QUFDNUMsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLElBQUksSUFBSSxTQUFTLFFBQVEsSUFBSSxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ2hFLFFBQUksU0FBUyxLQUFNLFVBQVcsZ0JBQWUsSUFBSSxJQUFJLEtBQUssSUFBSztBQUFBO0FBQUE7QUFtSm5FLHNCQUF1QixLQUFLLE9BQU8sUUFBUSxLQUFLLEtBQUssS0FBSztBQUN4RCxNQUFJLFNBQVMsTUFBTSxJQUFJO0FBQVEsVUFBTSxJQUFJLFdBQVc7QUFDcEQsTUFBSSxTQUFTO0FBQUcsVUFBTSxJQUFJLFdBQVc7QUFBQTtBQUd2QyxvQkFBcUIsS0FBSyxPQUFPLFFBQVEsY0FBYyxVQUFVO0FBQy9ELE1BQUksQ0FBQyxVQUFVO0FBQ2IsaUJBQWEsS0FBSyxPQUFPLFFBQVE7QUFBQTtBQUVuQyxRQUFNLEtBQUssT0FBTyxRQUFRLGNBQWMsSUFBSTtBQUM1QyxTQUFPLFNBQVM7QUFBQTtBQVdsQixxQkFBc0IsS0FBSyxPQUFPLFFBQVEsY0FBYyxVQUFVO0FBQ2hFLE1BQUksQ0FBQyxVQUFVO0FBQ2IsaUJBQWEsS0FBSyxPQUFPLFFBQVE7QUFBQTtBQUVuQyxRQUFNLEtBQUssT0FBTyxRQUFRLGNBQWMsSUFBSTtBQUM1QyxTQUFPLFNBQVM7QUFBQTtBQWdJbEIscUJBQXNCLEtBQUs7QUFFekIsUUFBTSxXQUFXLEtBQUssUUFBUSxtQkFBbUI7QUFFakQsTUFBSSxJQUFJLFNBQVM7QUFBRyxXQUFPO0FBRTNCLFNBQU8sSUFBSSxTQUFTLE1BQU0sR0FBRztBQUMzQixVQUFNLE1BQU07QUFBQTtBQUVkLFNBQU87QUFBQTtBQUdULG9CQUFxQixLQUFLO0FBQ3hCLE1BQUksSUFBSTtBQUFNLFdBQU8sSUFBSTtBQUN6QixTQUFPLElBQUksUUFBUSxjQUFjO0FBQUE7QUFHbkMsZUFBZ0IsR0FBRztBQUNqQixNQUFJLElBQUk7QUFBSSxXQUFPLE1BQU0sRUFBRSxTQUFTO0FBQ3BDLFNBQU8sRUFBRSxTQUFTO0FBQUE7QUFHcEIscUJBQXNCLFFBQVEsT0FBTztBQUNuQyxVQUFRLFNBQVM7QUFDakIsTUFBSTtBQUNKLE1BQUksU0FBUyxPQUFPO0FBQ3BCLE1BQUksZ0JBQWdCO0FBQ3BCLE1BQUksUUFBUTtBQUVaLFdBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDL0IsZ0JBQVksT0FBTyxXQUFXO0FBRzlCLFFBQUksWUFBWSxTQUFVLFlBQVksT0FBUTtBQUU1QyxVQUFJLENBQUMsZUFBZTtBQUVsQixZQUFJLFlBQVksT0FBUTtBQUV0QixjQUFLLFVBQVMsS0FBSztBQUFJLGtCQUFNLEtBQUssS0FBTSxLQUFNO0FBQzlDO0FBQUEsbUJBQ1MsSUFBSSxNQUFNLFFBQVE7QUFFM0IsY0FBSyxVQUFTLEtBQUs7QUFBSSxrQkFBTSxLQUFLLEtBQU0sS0FBTTtBQUM5QztBQUFBO0FBSUYsd0JBQWdCO0FBRWhCO0FBQUE7QUFJRixVQUFJLFlBQVksT0FBUTtBQUN0QixZQUFLLFVBQVMsS0FBSztBQUFJLGdCQUFNLEtBQUssS0FBTSxLQUFNO0FBQzlDLHdCQUFnQjtBQUNoQjtBQUFBO0FBSUYsa0JBQWEsaUJBQWdCLFNBQVUsS0FBSyxZQUFZLFNBQVU7QUFBQSxlQUN6RCxlQUFlO0FBRXhCLFVBQUssVUFBUyxLQUFLO0FBQUksY0FBTSxLQUFLLEtBQU0sS0FBTTtBQUFBO0FBR2hELG9CQUFnQjtBQUdoQixRQUFJLFlBQVksS0FBTTtBQUNwQixVQUFLLFVBQVMsS0FBSztBQUFHO0FBQ3RCLFlBQU0sS0FBSztBQUFBLGVBQ0YsWUFBWSxNQUFPO0FBQzVCLFVBQUssVUFBUyxLQUFLO0FBQUc7QUFDdEIsWUFBTSxLQUNKLGFBQWEsSUFBTSxLQUNuQixZQUFZLEtBQU87QUFBQSxlQUVaLFlBQVksT0FBUztBQUM5QixVQUFLLFVBQVMsS0FBSztBQUFHO0FBQ3RCLFlBQU0sS0FDSixhQUFhLEtBQU0sS0FDbkIsYUFBYSxJQUFNLEtBQU8sS0FDMUIsWUFBWSxLQUFPO0FBQUEsZUFFWixZQUFZLFNBQVU7QUFDL0IsVUFBSyxVQUFTLEtBQUs7QUFBRztBQUN0QixZQUFNLEtBQ0osYUFBYSxLQUFPLEtBQ3BCLGFBQWEsS0FBTSxLQUFPLEtBQzFCLGFBQWEsSUFBTSxLQUFPLEtBQzFCLFlBQVksS0FBTztBQUFBLFdBRWhCO0FBQ0wsWUFBTSxJQUFJLE1BQU07QUFBQTtBQUFBO0FBSXBCLFNBQU87QUFBQTtBQUdULHNCQUF1QixLQUFLO0FBQzFCLE1BQUksWUFBWTtBQUNoQixXQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFLEdBQUc7QUFFbkMsY0FBVSxLQUFLLElBQUksV0FBVyxLQUFLO0FBQUE7QUFFckMsU0FBTztBQUFBO0FBR1Qsd0JBQXlCLEtBQUssT0FBTztBQUNuQyxNQUFJLEdBQUcsSUFBSTtBQUNYLE1BQUksWUFBWTtBQUNoQixXQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDbkMsUUFBSyxVQUFTLEtBQUs7QUFBRztBQUV0QixRQUFJLElBQUksV0FBVztBQUNuQixTQUFLLEtBQUs7QUFDVixTQUFLLElBQUk7QUFDVCxjQUFVLEtBQUs7QUFDZixjQUFVLEtBQUs7QUFBQTtBQUdqQixTQUFPO0FBQUE7QUFJVCx1QkFBd0IsS0FBSztBQUMzQixTQUFPLFlBQVksWUFBWTtBQUFBO0FBR2pDLG9CQUFxQixLQUFLLEtBQUssUUFBUSxRQUFRO0FBQzdDLFdBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDL0IsUUFBSyxJQUFJLFVBQVUsSUFBSSxVQUFZLEtBQUssSUFBSTtBQUFTO0FBQ3JELFFBQUksSUFBSSxVQUFVLElBQUk7QUFBQTtBQUV4QixTQUFPO0FBQUE7QUFHVCxlQUFnQixLQUFLO0FBQ25CLFNBQU8sUUFBUTtBQUFBO0FBT2pCLGtCQUFrQixLQUFLO0FBQ3JCLFNBQU8sT0FBTyxRQUFTLEVBQUMsQ0FBQyxJQUFJLGFBQWEsYUFBYSxRQUFRLGFBQWE7QUFBQTtBQUc5RSxzQkFBdUIsS0FBSztBQUMxQixTQUFPLENBQUMsQ0FBQyxJQUFJLGVBQWUsT0FBTyxJQUFJLFlBQVksYUFBYSxjQUFjLElBQUksWUFBWSxTQUFTO0FBQUE7QUFJekcsc0JBQXVCLEtBQUs7QUFDMUIsU0FBTyxPQUFPLElBQUksZ0JBQWdCLGNBQWMsT0FBTyxJQUFJLFVBQVUsY0FBYyxhQUFhLElBQUksTUFBTSxHQUFHO0FBQUE7QUF6N0QvRyxJQUFJLFFBQ0EsV0FDQSxLQUNBLFFBZ01BLFVBRUEsVUFXQSxtQkFpQ0EsYUE2NUJBLHNCQTJvQkE7QUF6eERKO0FBQUE7QUFBQTtBQUFBLElBQUksU0FBUztBQUNiLElBQUksWUFBWTtBQUNoQixJQUFJLE1BQU0sT0FBTyxlQUFlLGNBQWMsYUFBYTtBQUMzRCxJQUFJLFNBQVM7QUFnTWIsSUFBSSxXQUFXLEdBQUc7QUFFbEIsSUFBSSxXQUFVLE1BQU0sV0FBVyxTQUFVLEtBQUs7QUFDNUMsYUFBTyxTQUFTLEtBQUssUUFBUTtBQUFBO0FBRy9CLEFBT0EsSUFBSSxvQkFBb0I7QUEwQnhCLFlBQU8sc0JBQXNCLFdBQU8sd0JBQXdCLFNBQ3hELFdBQU8sc0JBQ1A7QUFLSixJQUFJLGNBQWM7QUFzRGxCLFlBQU8sV0FBVztBQUdsQixZQUFPLFdBQVcsU0FBVSxLQUFLO0FBQy9CLFVBQUksWUFBWSxRQUFPO0FBQ3ZCLGFBQU87QUFBQTtBQTJCVCxZQUFPLE9BQU8sU0FBVSxPQUFPLGtCQUFrQixRQUFRO0FBQ3ZELGFBQU8sS0FBSyxNQUFNLE9BQU8sa0JBQWtCO0FBQUE7QUFHN0MsUUFBSSxRQUFPLHFCQUFxQjtBQUM5QixjQUFPLFVBQVUsWUFBWSxXQUFXO0FBQ3hDLGNBQU8sWUFBWTtBQUFBO0FBK0JyQixZQUFPLFFBQVEsU0FBVSxNQUFNLE9BQU0sVUFBVTtBQUM3QyxhQUFPLE1BQU0sTUFBTSxNQUFNLE9BQU07QUFBQTtBQWlCakMsWUFBTyxjQUFjLFNBQVUsTUFBTTtBQUNuQyxhQUFPLFlBQVksTUFBTTtBQUFBO0FBSzNCLFlBQU8sa0JBQWtCLFNBQVUsTUFBTTtBQUN2QyxhQUFPLFlBQVksTUFBTTtBQUFBO0FBZ0gzQixZQUFPLFdBQVc7QUFLbEIsWUFBTyxVQUFVLGlCQUFrQixHQUFHLEdBQUc7QUFDdkMsVUFBSSxDQUFDLGlCQUFpQixNQUFNLENBQUMsaUJBQWlCLElBQUk7QUFDaEQsY0FBTSxJQUFJLFVBQVU7QUFBQTtBQUd0QixVQUFJLE1BQU07QUFBRyxlQUFPO0FBRXBCLFVBQUksSUFBSSxFQUFFO0FBQ1YsVUFBSSxJQUFJLEVBQUU7QUFFVixlQUFTLElBQUksR0FBRyxNQUFNLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLLEVBQUUsR0FBRztBQUNsRCxZQUFJLEVBQUUsT0FBTyxFQUFFLElBQUk7QUFDakIsY0FBSSxFQUFFO0FBQ04sY0FBSSxFQUFFO0FBQ047QUFBQTtBQUFBO0FBSUosVUFBSSxJQUFJO0FBQUcsZUFBTztBQUNsQixVQUFJLElBQUk7QUFBRyxlQUFPO0FBQ2xCLGFBQU87QUFBQTtBQUdULFlBQU8sYUFBYSxvQkFBcUIsVUFBVTtBQUNqRCxjQUFRLE9BQU8sVUFBVTtBQUFBLGFBQ2xCO0FBQUEsYUFDQTtBQUFBLGFBQ0E7QUFBQSxhQUNBO0FBQUEsYUFDQTtBQUFBLGFBQ0E7QUFBQSxhQUNBO0FBQUEsYUFDQTtBQUFBLGFBQ0E7QUFBQSxhQUNBO0FBQUEsYUFDQTtBQUNILGlCQUFPO0FBQUE7QUFFUCxpQkFBTztBQUFBO0FBQUE7QUFJYixZQUFPLFNBQVMsZ0JBQWlCLE1BQU0sUUFBUTtBQUM3QyxVQUFJLENBQUMsU0FBUSxPQUFPO0FBQ2xCLGNBQU0sSUFBSSxVQUFVO0FBQUE7QUFHdEIsVUFBSSxLQUFLLFdBQVcsR0FBRztBQUNyQixlQUFPLFFBQU8sTUFBTTtBQUFBO0FBR3RCLFVBQUk7QUFDSixVQUFJLFdBQVcsUUFBVztBQUN4QixpQkFBUztBQUNULGFBQUssSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEVBQUUsR0FBRztBQUNoQyxvQkFBVSxLQUFLLEdBQUc7QUFBQTtBQUFBO0FBSXRCLFVBQUksU0FBUyxRQUFPLFlBQVk7QUFDaEMsVUFBSSxNQUFNO0FBQ1YsV0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBQ2hDLFlBQUksTUFBTSxLQUFLO0FBQ2YsWUFBSSxDQUFDLGlCQUFpQixNQUFNO0FBQzFCLGdCQUFNLElBQUksVUFBVTtBQUFBO0FBRXRCLFlBQUksS0FBSyxRQUFRO0FBQ2pCLGVBQU8sSUFBSTtBQUFBO0FBRWIsYUFBTztBQUFBO0FBOENULFlBQU8sYUFBYTtBQTBFcEIsWUFBTyxVQUFVLFlBQVk7QUFRN0IsWUFBTyxVQUFVLFNBQVMsa0JBQW1CO0FBQzNDLFVBQUksTUFBTSxLQUFLO0FBQ2YsVUFBSSxNQUFNLE1BQU0sR0FBRztBQUNqQixjQUFNLElBQUksV0FBVztBQUFBO0FBRXZCLGVBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDL0IsYUFBSyxNQUFNLEdBQUcsSUFBSTtBQUFBO0FBRXBCLGFBQU87QUFBQTtBQUdULFlBQU8sVUFBVSxTQUFTLGtCQUFtQjtBQUMzQyxVQUFJLE1BQU0sS0FBSztBQUNmLFVBQUksTUFBTSxNQUFNLEdBQUc7QUFDakIsY0FBTSxJQUFJLFdBQVc7QUFBQTtBQUV2QixlQUFTLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSyxHQUFHO0FBQy9CLGFBQUssTUFBTSxHQUFHLElBQUk7QUFDbEIsYUFBSyxNQUFNLElBQUksR0FBRyxJQUFJO0FBQUE7QUFFeEIsYUFBTztBQUFBO0FBR1QsWUFBTyxVQUFVLFNBQVMsa0JBQW1CO0FBQzNDLFVBQUksTUFBTSxLQUFLO0FBQ2YsVUFBSSxNQUFNLE1BQU0sR0FBRztBQUNqQixjQUFNLElBQUksV0FBVztBQUFBO0FBRXZCLGVBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDL0IsYUFBSyxNQUFNLEdBQUcsSUFBSTtBQUNsQixhQUFLLE1BQU0sSUFBSSxHQUFHLElBQUk7QUFDdEIsYUFBSyxNQUFNLElBQUksR0FBRyxJQUFJO0FBQ3RCLGFBQUssTUFBTSxJQUFJLEdBQUcsSUFBSTtBQUFBO0FBRXhCLGFBQU87QUFBQTtBQUdULFlBQU8sVUFBVSxXQUFXLHFCQUFxQjtBQUMvQyxVQUFJLFNBQVMsS0FBSyxTQUFTO0FBQzNCLFVBQUksV0FBVztBQUFHLGVBQU87QUFDekIsVUFBSSxVQUFVLFdBQVc7QUFBRyxlQUFPLFVBQVUsTUFBTSxHQUFHO0FBQ3RELGFBQU8sYUFBYSxNQUFNLE1BQU07QUFBQTtBQUdsQyxZQUFPLFVBQVUsU0FBUyxnQkFBaUIsR0FBRztBQUM1QyxVQUFJLENBQUMsaUJBQWlCO0FBQUksY0FBTSxJQUFJLFVBQVU7QUFDOUMsVUFBSSxTQUFTO0FBQUcsZUFBTztBQUN2QixhQUFPLFFBQU8sUUFBUSxNQUFNLE9BQU87QUFBQTtBQUdyQyxZQUFPLFVBQVUsVUFBVSxvQkFBb0I7QUFDN0MsVUFBSSxNQUFNO0FBQ1YsVUFBSSxNQUFNO0FBQ1YsVUFBSSxLQUFLLFNBQVMsR0FBRztBQUNuQixjQUFNLEtBQUssU0FBUyxPQUFPLEdBQUcsS0FBSyxNQUFNLFNBQVMsS0FBSztBQUN2RCxZQUFJLEtBQUssU0FBUztBQUFLLGlCQUFPO0FBQUE7QUFFaEMsYUFBTyxhQUFhLE1BQU07QUFBQTtBQUc1QixZQUFPLFVBQVUsVUFBVSxrQkFBa0IsUUFBUSxPQUFPLEtBQUssV0FBVyxTQUFTO0FBQ25GLFVBQUksQ0FBQyxpQkFBaUIsU0FBUztBQUM3QixjQUFNLElBQUksVUFBVTtBQUFBO0FBR3RCLFVBQUksVUFBVSxRQUFXO0FBQ3ZCLGdCQUFRO0FBQUE7QUFFVixVQUFJLFFBQVEsUUFBVztBQUNyQixjQUFNLFNBQVMsT0FBTyxTQUFTO0FBQUE7QUFFakMsVUFBSSxjQUFjLFFBQVc7QUFDM0Isb0JBQVk7QUFBQTtBQUVkLFVBQUksWUFBWSxRQUFXO0FBQ3pCLGtCQUFVLEtBQUs7QUFBQTtBQUdqQixVQUFJLFFBQVEsS0FBSyxNQUFNLE9BQU8sVUFBVSxZQUFZLEtBQUssVUFBVSxLQUFLLFFBQVE7QUFDOUUsY0FBTSxJQUFJLFdBQVc7QUFBQTtBQUd2QixVQUFJLGFBQWEsV0FBVyxTQUFTLEtBQUs7QUFDeEMsZUFBTztBQUFBO0FBRVQsVUFBSSxhQUFhLFNBQVM7QUFDeEIsZUFBTztBQUFBO0FBRVQsVUFBSSxTQUFTLEtBQUs7QUFDaEIsZUFBTztBQUFBO0FBR1QsaUJBQVc7QUFDWCxlQUFTO0FBQ1QscUJBQWU7QUFDZixtQkFBYTtBQUViLFVBQUksU0FBUztBQUFRLGVBQU87QUFFNUIsVUFBSSxJQUFJLFVBQVU7QUFDbEIsVUFBSSxJQUFJLE1BQU07QUFDZCxVQUFJLE1BQU0sS0FBSyxJQUFJLEdBQUc7QUFFdEIsVUFBSSxXQUFXLEtBQUssTUFBTSxXQUFXO0FBQ3JDLFVBQUksYUFBYSxPQUFPLE1BQU0sT0FBTztBQUVyQyxlQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzVCLFlBQUksU0FBUyxPQUFPLFdBQVcsSUFBSTtBQUNqQyxjQUFJLFNBQVM7QUFDYixjQUFJLFdBQVc7QUFDZjtBQUFBO0FBQUE7QUFJSixVQUFJLElBQUk7QUFBRyxlQUFPO0FBQ2xCLFVBQUksSUFBSTtBQUFHLGVBQU87QUFDbEIsYUFBTztBQUFBO0FBNkhULFlBQU8sVUFBVSxXQUFXLGtCQUFtQixLQUFLLFlBQVksVUFBVTtBQUN4RSxhQUFPLEtBQUssUUFBUSxLQUFLLFlBQVksY0FBYztBQUFBO0FBR3JELFlBQU8sVUFBVSxVQUFVLGlCQUFrQixLQUFLLFlBQVksVUFBVTtBQUN0RSxhQUFPLHFCQUFxQixNQUFNLEtBQUssWUFBWSxVQUFVO0FBQUE7QUFHL0QsWUFBTyxVQUFVLGNBQWMscUJBQXNCLEtBQUssWUFBWSxVQUFVO0FBQzlFLGFBQU8scUJBQXFCLE1BQU0sS0FBSyxZQUFZLFVBQVU7QUFBQTtBQWtEL0QsWUFBTyxVQUFVLFFBQVEsZ0JBQWdCLFFBQVEsUUFBUSxRQUFRLFVBQVU7QUFFekUsVUFBSSxXQUFXLFFBQVc7QUFDeEIsbUJBQVc7QUFDWCxpQkFBUyxLQUFLO0FBQ2QsaUJBQVM7QUFBQSxpQkFFQSxXQUFXLFVBQWEsT0FBTyxXQUFXLFVBQVU7QUFDN0QsbUJBQVc7QUFDWCxpQkFBUyxLQUFLO0FBQ2QsaUJBQVM7QUFBQSxpQkFFQSxTQUFTLFNBQVM7QUFDM0IsaUJBQVMsU0FBUztBQUNsQixZQUFJLFNBQVMsU0FBUztBQUNwQixtQkFBUyxTQUFTO0FBQ2xCLGNBQUksYUFBYTtBQUFXLHVCQUFXO0FBQUEsZUFDbEM7QUFDTCxxQkFBVztBQUNYLG1CQUFTO0FBQUE7QUFBQSxhQUdOO0FBQ0wsY0FBTSxJQUFJLE1BQ1I7QUFBQTtBQUlKLFVBQUksWUFBWSxLQUFLLFNBQVM7QUFDOUIsVUFBSSxXQUFXLFVBQWEsU0FBUztBQUFXLGlCQUFTO0FBRXpELFVBQUssT0FBTyxTQUFTLEtBQU0sVUFBUyxLQUFLLFNBQVMsTUFBTyxTQUFTLEtBQUssUUFBUTtBQUM3RSxjQUFNLElBQUksV0FBVztBQUFBO0FBR3ZCLFVBQUksQ0FBQztBQUFVLG1CQUFXO0FBRTFCLFVBQUksY0FBYztBQUNsQixpQkFBUztBQUNQLGdCQUFRO0FBQUEsZUFDRDtBQUNILG1CQUFPLFNBQVMsTUFBTSxRQUFRLFFBQVE7QUFBQSxlQUVuQztBQUFBLGVBQ0E7QUFDSCxtQkFBTyxVQUFVLE1BQU0sUUFBUSxRQUFRO0FBQUEsZUFFcEM7QUFDSCxtQkFBTyxXQUFXLE1BQU0sUUFBUSxRQUFRO0FBQUEsZUFFckM7QUFBQSxlQUNBO0FBQ0gsbUJBQU8sWUFBWSxNQUFNLFFBQVEsUUFBUTtBQUFBLGVBRXRDO0FBRUgsbUJBQU8sWUFBWSxNQUFNLFFBQVEsUUFBUTtBQUFBLGVBRXRDO0FBQUEsZUFDQTtBQUFBLGVBQ0E7QUFBQSxlQUNBO0FBQ0gsbUJBQU8sVUFBVSxNQUFNLFFBQVEsUUFBUTtBQUFBO0FBR3ZDLGdCQUFJO0FBQWEsb0JBQU0sSUFBSSxVQUFVLHVCQUF1QjtBQUM1RCx1QkFBWSxNQUFLLFVBQVU7QUFDM0IsMEJBQWM7QUFBQTtBQUFBO0FBQUE7QUFLdEIsWUFBTyxVQUFVLFNBQVMsa0JBQW1CO0FBQzNDLGFBQU87QUFBQSxRQUNMLE1BQU07QUFBQSxRQUNOLE1BQU0sTUFBTSxVQUFVLE1BQU0sS0FBSyxLQUFLLFFBQVEsTUFBTTtBQUFBO0FBQUE7QUF3RnhELElBQUksdUJBQXVCO0FBOEQzQixZQUFPLFVBQVUsUUFBUSxlQUFnQixPQUFPLEtBQUs7QUFDbkQsVUFBSSxNQUFNLEtBQUs7QUFDZixjQUFRLENBQUMsQ0FBQztBQUNWLFlBQU0sUUFBUSxTQUFZLE1BQU0sQ0FBQyxDQUFDO0FBRWxDLFVBQUksUUFBUSxHQUFHO0FBQ2IsaUJBQVM7QUFDVCxZQUFJLFFBQVE7QUFBRyxrQkFBUTtBQUFBLGlCQUNkLFFBQVEsS0FBSztBQUN0QixnQkFBUTtBQUFBO0FBR1YsVUFBSSxNQUFNLEdBQUc7QUFDWCxlQUFPO0FBQ1AsWUFBSSxNQUFNO0FBQUcsZ0JBQU07QUFBQSxpQkFDVixNQUFNLEtBQUs7QUFDcEIsY0FBTTtBQUFBO0FBR1IsVUFBSSxNQUFNO0FBQU8sY0FBTTtBQUV2QixVQUFJO0FBQ0osVUFBSSxRQUFPLHFCQUFxQjtBQUM5QixpQkFBUyxLQUFLLFNBQVMsT0FBTztBQUM5QixlQUFPLFlBQVksUUFBTztBQUFBLGFBQ3JCO0FBQ0wsWUFBSSxXQUFXLE1BQU07QUFDckIsaUJBQVMsSUFBSSxRQUFPLFVBQVU7QUFDOUIsaUJBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxFQUFFLEdBQUc7QUFDakMsaUJBQU8sS0FBSyxLQUFLLElBQUk7QUFBQTtBQUFBO0FBSXpCLGFBQU87QUFBQTtBQVdULFlBQU8sVUFBVSxhQUFhLG9CQUFxQixRQUFRLGFBQVksVUFBVTtBQUMvRSxlQUFTLFNBQVM7QUFDbEIsb0JBQWEsY0FBYTtBQUMxQixVQUFJLENBQUM7QUFBVSxvQkFBWSxRQUFRLGFBQVksS0FBSztBQUVwRCxVQUFJLE1BQU0sS0FBSztBQUNmLFVBQUksTUFBTTtBQUNWLFVBQUksSUFBSTtBQUNSLGFBQU8sRUFBRSxJQUFJLGVBQWUsUUFBTyxNQUFRO0FBQ3pDLGVBQU8sS0FBSyxTQUFTLEtBQUs7QUFBQTtBQUc1QixhQUFPO0FBQUE7QUFHVCxZQUFPLFVBQVUsYUFBYSxvQkFBcUIsUUFBUSxhQUFZLFVBQVU7QUFDL0UsZUFBUyxTQUFTO0FBQ2xCLG9CQUFhLGNBQWE7QUFDMUIsVUFBSSxDQUFDLFVBQVU7QUFDYixvQkFBWSxRQUFRLGFBQVksS0FBSztBQUFBO0FBR3ZDLFVBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUMxQixVQUFJLE1BQU07QUFDVixhQUFPLGNBQWEsS0FBTSxRQUFPLE1BQVE7QUFDdkMsZUFBTyxLQUFLLFNBQVMsRUFBRSxlQUFjO0FBQUE7QUFHdkMsYUFBTztBQUFBO0FBR1QsWUFBTyxVQUFVLFlBQVksbUJBQW9CLFFBQVEsVUFBVTtBQUNqRSxVQUFJLENBQUM7QUFBVSxvQkFBWSxRQUFRLEdBQUcsS0FBSztBQUMzQyxhQUFPLEtBQUs7QUFBQTtBQUdkLFlBQU8sVUFBVSxlQUFlLHNCQUF1QixRQUFRLFVBQVU7QUFDdkUsVUFBSSxDQUFDO0FBQVUsb0JBQVksUUFBUSxHQUFHLEtBQUs7QUFDM0MsYUFBTyxLQUFLLFVBQVcsS0FBSyxTQUFTLE1BQU07QUFBQTtBQUc3QyxZQUFPLFVBQVUsZUFBZSxzQkFBdUIsUUFBUSxVQUFVO0FBQ3ZFLFVBQUksQ0FBQztBQUFVLG9CQUFZLFFBQVEsR0FBRyxLQUFLO0FBQzNDLGFBQVEsS0FBSyxXQUFXLElBQUssS0FBSyxTQUFTO0FBQUE7QUFHN0MsWUFBTyxVQUFVLGVBQWUsc0JBQXVCLFFBQVEsVUFBVTtBQUN2RSxVQUFJLENBQUM7QUFBVSxvQkFBWSxRQUFRLEdBQUcsS0FBSztBQUUzQyxhQUFTLE1BQUssVUFDVCxLQUFLLFNBQVMsTUFBTSxJQUNwQixLQUFLLFNBQVMsTUFBTSxNQUNwQixLQUFLLFNBQVMsS0FBSztBQUFBO0FBRzFCLFlBQU8sVUFBVSxlQUFlLHNCQUF1QixRQUFRLFVBQVU7QUFDdkUsVUFBSSxDQUFDO0FBQVUsb0JBQVksUUFBUSxHQUFHLEtBQUs7QUFFM0MsYUFBUSxLQUFLLFVBQVUsV0FDbkIsTUFBSyxTQUFTLE1BQU0sS0FDckIsS0FBSyxTQUFTLE1BQU0sSUFDckIsS0FBSyxTQUFTO0FBQUE7QUFHbEIsWUFBTyxVQUFVLFlBQVksbUJBQW9CLFFBQVEsYUFBWSxVQUFVO0FBQzdFLGVBQVMsU0FBUztBQUNsQixvQkFBYSxjQUFhO0FBQzFCLFVBQUksQ0FBQztBQUFVLG9CQUFZLFFBQVEsYUFBWSxLQUFLO0FBRXBELFVBQUksTUFBTSxLQUFLO0FBQ2YsVUFBSSxNQUFNO0FBQ1YsVUFBSSxJQUFJO0FBQ1IsYUFBTyxFQUFFLElBQUksZUFBZSxRQUFPLE1BQVE7QUFDekMsZUFBTyxLQUFLLFNBQVMsS0FBSztBQUFBO0FBRTVCLGFBQU87QUFFUCxVQUFJLE9BQU87QUFBSyxlQUFPLEtBQUssSUFBSSxHQUFHLElBQUk7QUFFdkMsYUFBTztBQUFBO0FBR1QsWUFBTyxVQUFVLFlBQVksbUJBQW9CLFFBQVEsYUFBWSxVQUFVO0FBQzdFLGVBQVMsU0FBUztBQUNsQixvQkFBYSxjQUFhO0FBQzFCLFVBQUksQ0FBQztBQUFVLG9CQUFZLFFBQVEsYUFBWSxLQUFLO0FBRXBELFVBQUksSUFBSTtBQUNSLFVBQUksTUFBTTtBQUNWLFVBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUMxQixhQUFPLElBQUksS0FBTSxRQUFPLE1BQVE7QUFDOUIsZUFBTyxLQUFLLFNBQVMsRUFBRSxLQUFLO0FBQUE7QUFFOUIsYUFBTztBQUVQLFVBQUksT0FBTztBQUFLLGVBQU8sS0FBSyxJQUFJLEdBQUcsSUFBSTtBQUV2QyxhQUFPO0FBQUE7QUFHVCxZQUFPLFVBQVUsV0FBVyxrQkFBbUIsUUFBUSxVQUFVO0FBQy9ELFVBQUksQ0FBQztBQUFVLG9CQUFZLFFBQVEsR0FBRyxLQUFLO0FBQzNDLFVBQUksQ0FBRSxNQUFLLFVBQVU7QUFBTyxlQUFRLEtBQUs7QUFDekMsYUFBUyxPQUFPLEtBQUssVUFBVSxLQUFLO0FBQUE7QUFHdEMsWUFBTyxVQUFVLGNBQWMscUJBQXNCLFFBQVEsVUFBVTtBQUNyRSxVQUFJLENBQUM7QUFBVSxvQkFBWSxRQUFRLEdBQUcsS0FBSztBQUMzQyxVQUFJLE1BQU0sS0FBSyxVQUFXLEtBQUssU0FBUyxNQUFNO0FBQzlDLGFBQVEsTUFBTSxRQUFVLE1BQU0sYUFBYTtBQUFBO0FBRzdDLFlBQU8sVUFBVSxjQUFjLHFCQUFzQixRQUFRLFVBQVU7QUFDckUsVUFBSSxDQUFDO0FBQVUsb0JBQVksUUFBUSxHQUFHLEtBQUs7QUFDM0MsVUFBSSxNQUFNLEtBQUssU0FBUyxLQUFNLEtBQUssV0FBVztBQUM5QyxhQUFRLE1BQU0sUUFBVSxNQUFNLGFBQWE7QUFBQTtBQUc3QyxZQUFPLFVBQVUsY0FBYyxxQkFBc0IsUUFBUSxVQUFVO0FBQ3JFLFVBQUksQ0FBQztBQUFVLG9CQUFZLFFBQVEsR0FBRyxLQUFLO0FBRTNDLGFBQVEsS0FBSyxVQUNWLEtBQUssU0FBUyxNQUFNLElBQ3BCLEtBQUssU0FBUyxNQUFNLEtBQ3BCLEtBQUssU0FBUyxNQUFNO0FBQUE7QUFHekIsWUFBTyxVQUFVLGNBQWMscUJBQXNCLFFBQVEsVUFBVTtBQUNyRSxVQUFJLENBQUM7QUFBVSxvQkFBWSxRQUFRLEdBQUcsS0FBSztBQUUzQyxhQUFRLEtBQUssV0FBVyxLQUNyQixLQUFLLFNBQVMsTUFBTSxLQUNwQixLQUFLLFNBQVMsTUFBTSxJQUNwQixLQUFLLFNBQVM7QUFBQTtBQUduQixZQUFPLFVBQVUsY0FBYyxxQkFBc0IsUUFBUSxVQUFVO0FBQ3JFLFVBQUksQ0FBQztBQUFVLG9CQUFZLFFBQVEsR0FBRyxLQUFLO0FBQzNDLGFBQU8sS0FBSyxNQUFNLFFBQVEsTUFBTSxJQUFJO0FBQUE7QUFHdEMsWUFBTyxVQUFVLGNBQWMscUJBQXNCLFFBQVEsVUFBVTtBQUNyRSxVQUFJLENBQUM7QUFBVSxvQkFBWSxRQUFRLEdBQUcsS0FBSztBQUMzQyxhQUFPLEtBQUssTUFBTSxRQUFRLE9BQU8sSUFBSTtBQUFBO0FBR3ZDLFlBQU8sVUFBVSxlQUFlLHNCQUF1QixRQUFRLFVBQVU7QUFDdkUsVUFBSSxDQUFDO0FBQVUsb0JBQVksUUFBUSxHQUFHLEtBQUs7QUFDM0MsYUFBTyxLQUFLLE1BQU0sUUFBUSxNQUFNLElBQUk7QUFBQTtBQUd0QyxZQUFPLFVBQVUsZUFBZSxzQkFBdUIsUUFBUSxVQUFVO0FBQ3ZFLFVBQUksQ0FBQztBQUFVLG9CQUFZLFFBQVEsR0FBRyxLQUFLO0FBQzNDLGFBQU8sS0FBSyxNQUFNLFFBQVEsT0FBTyxJQUFJO0FBQUE7QUFTdkMsWUFBTyxVQUFVLGNBQWMscUJBQXNCLE9BQU8sUUFBUSxhQUFZLFVBQVU7QUFDeEYsY0FBUSxDQUFDO0FBQ1QsZUFBUyxTQUFTO0FBQ2xCLG9CQUFhLGNBQWE7QUFDMUIsVUFBSSxDQUFDLFVBQVU7QUFDYixZQUFJLFdBQVcsS0FBSyxJQUFJLEdBQUcsSUFBSSxlQUFjO0FBQzdDLGlCQUFTLE1BQU0sT0FBTyxRQUFRLGFBQVksVUFBVTtBQUFBO0FBR3RELFVBQUksTUFBTTtBQUNWLFVBQUksSUFBSTtBQUNSLFdBQUssVUFBVSxRQUFRO0FBQ3ZCLGFBQU8sRUFBRSxJQUFJLGVBQWUsUUFBTyxNQUFRO0FBQ3pDLGFBQUssU0FBUyxLQUFNLFFBQVEsTUFBTztBQUFBO0FBR3JDLGFBQU8sU0FBUztBQUFBO0FBR2xCLFlBQU8sVUFBVSxjQUFjLHFCQUFzQixPQUFPLFFBQVEsYUFBWSxVQUFVO0FBQ3hGLGNBQVEsQ0FBQztBQUNULGVBQVMsU0FBUztBQUNsQixvQkFBYSxjQUFhO0FBQzFCLFVBQUksQ0FBQyxVQUFVO0FBQ2IsWUFBSSxXQUFXLEtBQUssSUFBSSxHQUFHLElBQUksZUFBYztBQUM3QyxpQkFBUyxNQUFNLE9BQU8sUUFBUSxhQUFZLFVBQVU7QUFBQTtBQUd0RCxVQUFJLElBQUksY0FBYTtBQUNyQixVQUFJLE1BQU07QUFDVixXQUFLLFNBQVMsS0FBSyxRQUFRO0FBQzNCLGFBQU8sRUFBRSxLQUFLLEtBQU0sUUFBTyxNQUFRO0FBQ2pDLGFBQUssU0FBUyxLQUFNLFFBQVEsTUFBTztBQUFBO0FBR3JDLGFBQU8sU0FBUztBQUFBO0FBR2xCLFlBQU8sVUFBVSxhQUFhLG9CQUFxQixPQUFPLFFBQVEsVUFBVTtBQUMxRSxjQUFRLENBQUM7QUFDVCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxDQUFDO0FBQVUsaUJBQVMsTUFBTSxPQUFPLFFBQVEsR0FBRyxLQUFNO0FBQ3RELFVBQUksQ0FBQyxRQUFPO0FBQXFCLGdCQUFRLEtBQUssTUFBTTtBQUNwRCxXQUFLLFVBQVcsUUFBUTtBQUN4QixhQUFPLFNBQVM7QUFBQTtBQVdsQixZQUFPLFVBQVUsZ0JBQWdCLHVCQUF3QixPQUFPLFFBQVEsVUFBVTtBQUNoRixjQUFRLENBQUM7QUFDVCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxDQUFDO0FBQVUsaUJBQVMsTUFBTSxPQUFPLFFBQVEsR0FBRyxPQUFRO0FBQ3hELFVBQUksUUFBTyxxQkFBcUI7QUFDOUIsYUFBSyxVQUFXLFFBQVE7QUFDeEIsYUFBSyxTQUFTLEtBQU0sVUFBVTtBQUFBLGFBQ3pCO0FBQ0wsMEJBQWtCLE1BQU0sT0FBTyxRQUFRO0FBQUE7QUFFekMsYUFBTyxTQUFTO0FBQUE7QUFHbEIsWUFBTyxVQUFVLGdCQUFnQix1QkFBd0IsT0FBTyxRQUFRLFVBQVU7QUFDaEYsY0FBUSxDQUFDO0FBQ1QsZUFBUyxTQUFTO0FBQ2xCLFVBQUksQ0FBQztBQUFVLGlCQUFTLE1BQU0sT0FBTyxRQUFRLEdBQUcsT0FBUTtBQUN4RCxVQUFJLFFBQU8scUJBQXFCO0FBQzlCLGFBQUssVUFBVyxVQUFVO0FBQzFCLGFBQUssU0FBUyxLQUFNLFFBQVE7QUFBQSxhQUN2QjtBQUNMLDBCQUFrQixNQUFNLE9BQU8sUUFBUTtBQUFBO0FBRXpDLGFBQU8sU0FBUztBQUFBO0FBVWxCLFlBQU8sVUFBVSxnQkFBZ0IsdUJBQXdCLE9BQU8sUUFBUSxVQUFVO0FBQ2hGLGNBQVEsQ0FBQztBQUNULGVBQVMsU0FBUztBQUNsQixVQUFJLENBQUM7QUFBVSxpQkFBUyxNQUFNLE9BQU8sUUFBUSxHQUFHLFlBQVk7QUFDNUQsVUFBSSxRQUFPLHFCQUFxQjtBQUM5QixhQUFLLFNBQVMsS0FBTSxVQUFVO0FBQzlCLGFBQUssU0FBUyxLQUFNLFVBQVU7QUFDOUIsYUFBSyxTQUFTLEtBQU0sVUFBVTtBQUM5QixhQUFLLFVBQVcsUUFBUTtBQUFBLGFBQ25CO0FBQ0wsMEJBQWtCLE1BQU0sT0FBTyxRQUFRO0FBQUE7QUFFekMsYUFBTyxTQUFTO0FBQUE7QUFHbEIsWUFBTyxVQUFVLGdCQUFnQix1QkFBd0IsT0FBTyxRQUFRLFVBQVU7QUFDaEYsY0FBUSxDQUFDO0FBQ1QsZUFBUyxTQUFTO0FBQ2xCLFVBQUksQ0FBQztBQUFVLGlCQUFTLE1BQU0sT0FBTyxRQUFRLEdBQUcsWUFBWTtBQUM1RCxVQUFJLFFBQU8scUJBQXFCO0FBQzlCLGFBQUssVUFBVyxVQUFVO0FBQzFCLGFBQUssU0FBUyxLQUFNLFVBQVU7QUFDOUIsYUFBSyxTQUFTLEtBQU0sVUFBVTtBQUM5QixhQUFLLFNBQVMsS0FBTSxRQUFRO0FBQUEsYUFDdkI7QUFDTCwwQkFBa0IsTUFBTSxPQUFPLFFBQVE7QUFBQTtBQUV6QyxhQUFPLFNBQVM7QUFBQTtBQUdsQixZQUFPLFVBQVUsYUFBYSxvQkFBcUIsT0FBTyxRQUFRLGFBQVksVUFBVTtBQUN0RixjQUFRLENBQUM7QUFDVCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxDQUFDLFVBQVU7QUFDYixZQUFJLFFBQVEsS0FBSyxJQUFJLEdBQUcsSUFBSSxjQUFhO0FBRXpDLGlCQUFTLE1BQU0sT0FBTyxRQUFRLGFBQVksUUFBUSxHQUFHLENBQUM7QUFBQTtBQUd4RCxVQUFJLElBQUk7QUFDUixVQUFJLE1BQU07QUFDVixVQUFJLE1BQU07QUFDVixXQUFLLFVBQVUsUUFBUTtBQUN2QixhQUFPLEVBQUUsSUFBSSxlQUFlLFFBQU8sTUFBUTtBQUN6QyxZQUFJLFFBQVEsS0FBSyxRQUFRLEtBQUssS0FBSyxTQUFTLElBQUksT0FBTyxHQUFHO0FBQ3hELGdCQUFNO0FBQUE7QUFFUixhQUFLLFNBQVMsS0FBTyxTQUFRLE9BQVEsS0FBSyxNQUFNO0FBQUE7QUFHbEQsYUFBTyxTQUFTO0FBQUE7QUFHbEIsWUFBTyxVQUFVLGFBQWEsb0JBQXFCLE9BQU8sUUFBUSxhQUFZLFVBQVU7QUFDdEYsY0FBUSxDQUFDO0FBQ1QsZUFBUyxTQUFTO0FBQ2xCLFVBQUksQ0FBQyxVQUFVO0FBQ2IsWUFBSSxRQUFRLEtBQUssSUFBSSxHQUFHLElBQUksY0FBYTtBQUV6QyxpQkFBUyxNQUFNLE9BQU8sUUFBUSxhQUFZLFFBQVEsR0FBRyxDQUFDO0FBQUE7QUFHeEQsVUFBSSxJQUFJLGNBQWE7QUFDckIsVUFBSSxNQUFNO0FBQ1YsVUFBSSxNQUFNO0FBQ1YsV0FBSyxTQUFTLEtBQUssUUFBUTtBQUMzQixhQUFPLEVBQUUsS0FBSyxLQUFNLFFBQU8sTUFBUTtBQUNqQyxZQUFJLFFBQVEsS0FBSyxRQUFRLEtBQUssS0FBSyxTQUFTLElBQUksT0FBTyxHQUFHO0FBQ3hELGdCQUFNO0FBQUE7QUFFUixhQUFLLFNBQVMsS0FBTyxTQUFRLE9BQVEsS0FBSyxNQUFNO0FBQUE7QUFHbEQsYUFBTyxTQUFTO0FBQUE7QUFHbEIsWUFBTyxVQUFVLFlBQVksbUJBQW9CLE9BQU8sUUFBUSxVQUFVO0FBQ3hFLGNBQVEsQ0FBQztBQUNULGVBQVMsU0FBUztBQUNsQixVQUFJLENBQUM7QUFBVSxpQkFBUyxNQUFNLE9BQU8sUUFBUSxHQUFHLEtBQU07QUFDdEQsVUFBSSxDQUFDLFFBQU87QUFBcUIsZ0JBQVEsS0FBSyxNQUFNO0FBQ3BELFVBQUksUUFBUTtBQUFHLGdCQUFRLE1BQU8sUUFBUTtBQUN0QyxXQUFLLFVBQVcsUUFBUTtBQUN4QixhQUFPLFNBQVM7QUFBQTtBQUdsQixZQUFPLFVBQVUsZUFBZSxzQkFBdUIsT0FBTyxRQUFRLFVBQVU7QUFDOUUsY0FBUSxDQUFDO0FBQ1QsZUFBUyxTQUFTO0FBQ2xCLFVBQUksQ0FBQztBQUFVLGlCQUFTLE1BQU0sT0FBTyxRQUFRLEdBQUcsT0FBUTtBQUN4RCxVQUFJLFFBQU8scUJBQXFCO0FBQzlCLGFBQUssVUFBVyxRQUFRO0FBQ3hCLGFBQUssU0FBUyxLQUFNLFVBQVU7QUFBQSxhQUN6QjtBQUNMLDBCQUFrQixNQUFNLE9BQU8sUUFBUTtBQUFBO0FBRXpDLGFBQU8sU0FBUztBQUFBO0FBR2xCLFlBQU8sVUFBVSxlQUFlLHNCQUF1QixPQUFPLFFBQVEsVUFBVTtBQUM5RSxjQUFRLENBQUM7QUFDVCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxDQUFDO0FBQVUsaUJBQVMsTUFBTSxPQUFPLFFBQVEsR0FBRyxPQUFRO0FBQ3hELFVBQUksUUFBTyxxQkFBcUI7QUFDOUIsYUFBSyxVQUFXLFVBQVU7QUFDMUIsYUFBSyxTQUFTLEtBQU0sUUFBUTtBQUFBLGFBQ3ZCO0FBQ0wsMEJBQWtCLE1BQU0sT0FBTyxRQUFRO0FBQUE7QUFFekMsYUFBTyxTQUFTO0FBQUE7QUFHbEIsWUFBTyxVQUFVLGVBQWUsc0JBQXVCLE9BQU8sUUFBUSxVQUFVO0FBQzlFLGNBQVEsQ0FBQztBQUNULGVBQVMsU0FBUztBQUNsQixVQUFJLENBQUM7QUFBVSxpQkFBUyxNQUFNLE9BQU8sUUFBUSxHQUFHLFlBQVk7QUFDNUQsVUFBSSxRQUFPLHFCQUFxQjtBQUM5QixhQUFLLFVBQVcsUUFBUTtBQUN4QixhQUFLLFNBQVMsS0FBTSxVQUFVO0FBQzlCLGFBQUssU0FBUyxLQUFNLFVBQVU7QUFDOUIsYUFBSyxTQUFTLEtBQU0sVUFBVTtBQUFBLGFBQ3pCO0FBQ0wsMEJBQWtCLE1BQU0sT0FBTyxRQUFRO0FBQUE7QUFFekMsYUFBTyxTQUFTO0FBQUE7QUFHbEIsWUFBTyxVQUFVLGVBQWUsc0JBQXVCLE9BQU8sUUFBUSxVQUFVO0FBQzlFLGNBQVEsQ0FBQztBQUNULGVBQVMsU0FBUztBQUNsQixVQUFJLENBQUM7QUFBVSxpQkFBUyxNQUFNLE9BQU8sUUFBUSxHQUFHLFlBQVk7QUFDNUQsVUFBSSxRQUFRO0FBQUcsZ0JBQVEsYUFBYSxRQUFRO0FBQzVDLFVBQUksUUFBTyxxQkFBcUI7QUFDOUIsYUFBSyxVQUFXLFVBQVU7QUFDMUIsYUFBSyxTQUFTLEtBQU0sVUFBVTtBQUM5QixhQUFLLFNBQVMsS0FBTSxVQUFVO0FBQzlCLGFBQUssU0FBUyxLQUFNLFFBQVE7QUFBQSxhQUN2QjtBQUNMLDBCQUFrQixNQUFNLE9BQU8sUUFBUTtBQUFBO0FBRXpDLGFBQU8sU0FBUztBQUFBO0FBZ0JsQixZQUFPLFVBQVUsZUFBZSxzQkFBdUIsT0FBTyxRQUFRLFVBQVU7QUFDOUUsYUFBTyxXQUFXLE1BQU0sT0FBTyxRQUFRLE1BQU07QUFBQTtBQUcvQyxZQUFPLFVBQVUsZUFBZSxzQkFBdUIsT0FBTyxRQUFRLFVBQVU7QUFDOUUsYUFBTyxXQUFXLE1BQU0sT0FBTyxRQUFRLE9BQU87QUFBQTtBQVdoRCxZQUFPLFVBQVUsZ0JBQWdCLHVCQUF3QixPQUFPLFFBQVEsVUFBVTtBQUNoRixhQUFPLFlBQVksTUFBTSxPQUFPLFFBQVEsTUFBTTtBQUFBO0FBR2hELFlBQU8sVUFBVSxnQkFBZ0IsdUJBQXdCLE9BQU8sUUFBUSxVQUFVO0FBQ2hGLGFBQU8sWUFBWSxNQUFNLE9BQU8sUUFBUSxPQUFPO0FBQUE7QUFJakQsWUFBTyxVQUFVLE9BQU8sY0FBZSxRQUFRLGFBQWEsT0FBTyxLQUFLO0FBQ3RFLFVBQUksQ0FBQztBQUFPLGdCQUFRO0FBQ3BCLFVBQUksQ0FBQyxPQUFPLFFBQVE7QUFBRyxjQUFNLEtBQUs7QUFDbEMsVUFBSSxlQUFlLE9BQU87QUFBUSxzQkFBYyxPQUFPO0FBQ3ZELFVBQUksQ0FBQztBQUFhLHNCQUFjO0FBQ2hDLFVBQUksTUFBTSxLQUFLLE1BQU07QUFBTyxjQUFNO0FBR2xDLFVBQUksUUFBUTtBQUFPLGVBQU87QUFDMUIsVUFBSSxPQUFPLFdBQVcsS0FBSyxLQUFLLFdBQVc7QUFBRyxlQUFPO0FBR3JELFVBQUksY0FBYyxHQUFHO0FBQ25CLGNBQU0sSUFBSSxXQUFXO0FBQUE7QUFFdkIsVUFBSSxRQUFRLEtBQUssU0FBUyxLQUFLO0FBQVEsY0FBTSxJQUFJLFdBQVc7QUFDNUQsVUFBSSxNQUFNO0FBQUcsY0FBTSxJQUFJLFdBQVc7QUFHbEMsVUFBSSxNQUFNLEtBQUs7QUFBUSxjQUFNLEtBQUs7QUFDbEMsVUFBSSxPQUFPLFNBQVMsY0FBYyxNQUFNLE9BQU87QUFDN0MsY0FBTSxPQUFPLFNBQVMsY0FBYztBQUFBO0FBR3RDLFVBQUksTUFBTSxNQUFNO0FBQ2hCLFVBQUk7QUFFSixVQUFJLFNBQVMsVUFBVSxRQUFRLGVBQWUsY0FBYyxLQUFLO0FBRS9ELGFBQUssSUFBSSxNQUFNLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUM3QixpQkFBTyxJQUFJLGVBQWUsS0FBSyxJQUFJO0FBQUE7QUFBQSxpQkFFNUIsTUFBTSxPQUFRLENBQUMsUUFBTyxxQkFBcUI7QUFFcEQsYUFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUN4QixpQkFBTyxJQUFJLGVBQWUsS0FBSyxJQUFJO0FBQUE7QUFBQSxhQUVoQztBQUNMLG1CQUFXLFVBQVUsSUFBSSxLQUN2QixRQUNBLEtBQUssU0FBUyxPQUFPLFFBQVEsTUFDN0I7QUFBQTtBQUlKLGFBQU87QUFBQTtBQU9ULFlBQU8sVUFBVSxPQUFPLGNBQWUsS0FBSyxPQUFPLEtBQUssVUFBVTtBQUVoRSxVQUFJLE9BQU8sUUFBUSxVQUFVO0FBQzNCLFlBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0IscUJBQVc7QUFDWCxrQkFBUTtBQUNSLGdCQUFNLEtBQUs7QUFBQSxtQkFDRixPQUFPLFFBQVEsVUFBVTtBQUNsQyxxQkFBVztBQUNYLGdCQUFNLEtBQUs7QUFBQTtBQUViLFlBQUksSUFBSSxXQUFXLEdBQUc7QUFDcEIsY0FBSSxPQUFPLElBQUksV0FBVztBQUMxQixjQUFJLE9BQU8sS0FBSztBQUNkLGtCQUFNO0FBQUE7QUFBQTtBQUdWLFlBQUksYUFBYSxVQUFhLE9BQU8sYUFBYSxVQUFVO0FBQzFELGdCQUFNLElBQUksVUFBVTtBQUFBO0FBRXRCLFlBQUksT0FBTyxhQUFhLFlBQVksQ0FBQyxRQUFPLFdBQVcsV0FBVztBQUNoRSxnQkFBTSxJQUFJLFVBQVUsdUJBQXVCO0FBQUE7QUFBQSxpQkFFcEMsT0FBTyxRQUFRLFVBQVU7QUFDbEMsY0FBTSxNQUFNO0FBQUE7QUFJZCxVQUFJLFFBQVEsS0FBSyxLQUFLLFNBQVMsU0FBUyxLQUFLLFNBQVMsS0FBSztBQUN6RCxjQUFNLElBQUksV0FBVztBQUFBO0FBR3ZCLFVBQUksT0FBTyxPQUFPO0FBQ2hCLGVBQU87QUFBQTtBQUdULGNBQVEsVUFBVTtBQUNsQixZQUFNLFFBQVEsU0FBWSxLQUFLLFNBQVMsUUFBUTtBQUVoRCxVQUFJLENBQUM7QUFBSyxjQUFNO0FBRWhCLFVBQUk7QUFDSixVQUFJLE9BQU8sUUFBUSxVQUFVO0FBQzNCLGFBQUssSUFBSSxPQUFPLElBQUksS0FBSyxFQUFFLEdBQUc7QUFDNUIsZUFBSyxLQUFLO0FBQUE7QUFBQSxhQUVQO0FBQ0wsWUFBSSxRQUFRLGlCQUFpQixPQUN6QixNQUNBLFlBQVksSUFBSSxRQUFPLEtBQUssVUFBVTtBQUMxQyxZQUFJLE1BQU0sTUFBTTtBQUNoQixhQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sT0FBTyxFQUFFLEdBQUc7QUFDaEMsZUFBSyxJQUFJLFNBQVMsTUFBTSxJQUFJO0FBQUE7QUFBQTtBQUloQyxhQUFPO0FBQUE7QUFNVCxJQUFJLG9CQUFvQjtBQUFBO0FBQUE7OztBQ3J4RHhCLHNCQUFzQjtBQUNwQixPQUFLLE9BQU87QUFDWixPQUFLLE9BQU87QUFDWixPQUFLLFNBQVM7QUFBQTtBQVBoQixJQUVPO0FBRlA7QUFBQTtBQUFBO0FBQUE7QUFFQSxJQUFPLHNCQUFRO0FBUWYsZUFBVyxVQUFVLE9BQU8sU0FBVSxHQUFHO0FBQ3ZDLFVBQUksU0FBUSxFQUFFLE1BQU0sR0FBRyxNQUFNO0FBQzdCLFVBQUksS0FBSyxTQUFTO0FBQUcsYUFBSyxLQUFLLE9BQU87QUFBQTtBQUFXLGFBQUssT0FBTztBQUM3RCxXQUFLLE9BQU87QUFDWixRQUFFLEtBQUs7QUFBQTtBQUdULGVBQVcsVUFBVSxVQUFVLFNBQVUsR0FBRztBQUMxQyxVQUFJLFNBQVEsRUFBRSxNQUFNLEdBQUcsTUFBTSxLQUFLO0FBQ2xDLFVBQUksS0FBSyxXQUFXO0FBQUcsYUFBSyxPQUFPO0FBQ25DLFdBQUssT0FBTztBQUNaLFFBQUUsS0FBSztBQUFBO0FBR1QsZUFBVyxVQUFVLFFBQVEsV0FBWTtBQUN2QyxVQUFJLEtBQUssV0FBVztBQUFHO0FBQ3ZCLFVBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEIsVUFBSSxLQUFLLFdBQVc7QUFBRyxhQUFLLE9BQU8sS0FBSyxPQUFPO0FBQUE7QUFBVSxhQUFLLE9BQU8sS0FBSyxLQUFLO0FBQy9FLFFBQUUsS0FBSztBQUNQLGFBQU87QUFBQTtBQUdULGVBQVcsVUFBVSxRQUFRLFdBQVk7QUFDdkMsV0FBSyxPQUFPLEtBQUssT0FBTztBQUN4QixXQUFLLFNBQVM7QUFBQTtBQUdoQixlQUFXLFVBQVUsT0FBTyxTQUFVLEdBQUc7QUFDdkMsVUFBSSxLQUFLLFdBQVc7QUFBRyxlQUFPO0FBQzlCLFVBQUksSUFBSSxLQUFLO0FBQ2IsVUFBSSxNQUFNLEtBQUssRUFBRTtBQUNqQixhQUFPLElBQUksRUFBRSxNQUFNO0FBQ2pCLGVBQU8sSUFBSSxFQUFFO0FBQUE7QUFDZCxhQUFPO0FBQUE7QUFHVixlQUFXLFVBQVUsU0FBUyxTQUFVLEdBQUc7QUFDekMsVUFBSSxLQUFLLFdBQVc7QUFBRyxlQUFPLFFBQU8sTUFBTTtBQUMzQyxVQUFJLEtBQUssV0FBVztBQUFHLGVBQU8sS0FBSyxLQUFLO0FBQ3hDLFVBQUksTUFBTSxRQUFPLFlBQVksTUFBTTtBQUNuQyxVQUFJLElBQUksS0FBSztBQUNiLFVBQUksSUFBSTtBQUNSLGFBQU8sR0FBRztBQUNSLFVBQUUsS0FBSyxLQUFLLEtBQUs7QUFDakIsYUFBSyxFQUFFLEtBQUs7QUFDWixZQUFJLEVBQUU7QUFBQTtBQUVSLGFBQU87QUFBQTtBQUFBO0FBQUE7OztBQzFCVCx3QkFBd0IsVUFBVTtBQUNoQyxNQUFJLFlBQVksQ0FBQyxpQkFBaUIsV0FBVztBQUMzQyxVQUFNLElBQUksTUFBTSx1QkFBdUI7QUFBQTtBQUFBO0FBWXBDLHVCQUF1QixVQUFVO0FBQ3RDLE9BQUssV0FBWSxhQUFZLFFBQVEsY0FBYyxRQUFRLFFBQVE7QUFDbkUsaUJBQWU7QUFDZixVQUFRLEtBQUs7QUFBQSxTQUNOO0FBRUgsV0FBSyxnQkFBZ0I7QUFDckI7QUFBQSxTQUNHO0FBQUEsU0FDQTtBQUVILFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssdUJBQXVCO0FBQzVCO0FBQUEsU0FDRztBQUVILFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssdUJBQXVCO0FBQzVCO0FBQUE7QUFFQSxXQUFLLFFBQVE7QUFDYjtBQUFBO0FBS0osT0FBSyxhQUFhLElBQUksUUFBTztBQUU3QixPQUFLLGVBQWU7QUFFcEIsT0FBSyxhQUFhO0FBQUE7QUFvSXBCLDBCQUEwQixRQUFRO0FBQ2hDLFNBQU8sT0FBTyxTQUFTLEtBQUs7QUFBQTtBQUc5QixtQ0FBbUMsUUFBUTtBQUN6QyxPQUFLLGVBQWUsT0FBTyxTQUFTO0FBQ3BDLE9BQUssYUFBYSxLQUFLLGVBQWUsSUFBSTtBQUFBO0FBRzVDLG9DQUFvQyxRQUFRO0FBQzFDLE9BQUssZUFBZSxPQUFPLFNBQVM7QUFDcEMsT0FBSyxhQUFhLEtBQUssZUFBZSxJQUFJO0FBQUE7QUExTjVDLElBc0JJO0FBdEJKO0FBQUE7QUFBQTtBQXFCQTtBQUNBLElBQUksbUJBQW1CLFFBQU8sY0FDekIsU0FBUyxVQUFVO0FBQ2pCLGNBQVEsWUFBWSxTQUFTO0FBQUEsYUFDdEI7QUFBQSxhQUFZO0FBQUEsYUFBYTtBQUFBLGFBQWM7QUFBQSxhQUFjO0FBQUEsYUFBZTtBQUFBLGFBQWU7QUFBQSxhQUFhO0FBQUEsYUFBYztBQUFBLGFBQWdCO0FBQUEsYUFBaUI7QUFBTyxpQkFBTztBQUFBO0FBQ3pKLGlCQUFPO0FBQUE7QUFBQTtBQThEekIsa0JBQWMsVUFBVSxRQUFRLFNBQVMsUUFBUTtBQUMvQyxVQUFJLFVBQVU7QUFFZCxhQUFPLEtBQUssWUFBWTtBQUV0QixZQUFJLFlBQWEsT0FBTyxVQUFVLEtBQUssYUFBYSxLQUFLLGVBQ3JELEtBQUssYUFBYSxLQUFLLGVBQ3ZCLE9BQU87QUFHWCxlQUFPLEtBQUssS0FBSyxZQUFZLEtBQUssY0FBYyxHQUFHO0FBQ25ELGFBQUssZ0JBQWdCO0FBRXJCLFlBQUksS0FBSyxlQUFlLEtBQUssWUFBWTtBQUV2QyxpQkFBTztBQUFBO0FBSVQsaUJBQVMsT0FBTyxNQUFNLFdBQVcsT0FBTztBQUd4QyxrQkFBVSxLQUFLLFdBQVcsTUFBTSxHQUFHLEtBQUssWUFBWSxTQUFTLEtBQUs7QUFHbEUsWUFBSSxXQUFXLFFBQVEsV0FBVyxRQUFRLFNBQVM7QUFDbkQsWUFBSSxZQUFZLFNBQVUsWUFBWSxPQUFRO0FBQzVDLGVBQUssY0FBYyxLQUFLO0FBQ3hCLG9CQUFVO0FBQ1Y7QUFBQTtBQUVGLGFBQUssZUFBZSxLQUFLLGFBQWE7QUFHdEMsWUFBSSxPQUFPLFdBQVcsR0FBRztBQUN2QixpQkFBTztBQUFBO0FBRVQ7QUFBQTtBQUlGLFdBQUsscUJBQXFCO0FBRTFCLFVBQUksTUFBTSxPQUFPO0FBQ2pCLFVBQUksS0FBSyxZQUFZO0FBRW5CLGVBQU8sS0FBSyxLQUFLLFlBQVksR0FBRyxPQUFPLFNBQVMsS0FBSyxjQUFjO0FBQ25FLGVBQU8sS0FBSztBQUFBO0FBR2QsaUJBQVcsT0FBTyxTQUFTLEtBQUssVUFBVSxHQUFHO0FBRTdDLFVBQUksTUFBTSxRQUFRLFNBQVM7QUFDM0IsVUFBSSxXQUFXLFFBQVEsV0FBVztBQUVsQyxVQUFJLFlBQVksU0FBVSxZQUFZLE9BQVE7QUFDNUMsWUFBSSxPQUFPLEtBQUs7QUFDaEIsYUFBSyxjQUFjO0FBQ25CLGFBQUssZ0JBQWdCO0FBQ3JCLGFBQUssV0FBVyxLQUFLLEtBQUssWUFBWSxNQUFNLEdBQUc7QUFDL0MsZUFBTyxLQUFLLEtBQUssWUFBWSxHQUFHLEdBQUc7QUFDbkMsZUFBTyxRQUFRLFVBQVUsR0FBRztBQUFBO0FBSTlCLGFBQU87QUFBQTtBQU9ULGtCQUFjLFVBQVUsdUJBQXVCLFNBQVMsUUFBUTtBQUU5RCxVQUFJLElBQUssT0FBTyxVQUFVLElBQUssSUFBSSxPQUFPO0FBSTFDLGFBQU8sSUFBSSxHQUFHLEtBQUs7QUFDakIsWUFBSSxJQUFJLE9BQU8sT0FBTyxTQUFTO0FBSy9CLFlBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFNO0FBQzVCLGVBQUssYUFBYTtBQUNsQjtBQUFBO0FBSUYsWUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLElBQU07QUFDNUIsZUFBSyxhQUFhO0FBQ2xCO0FBQUE7QUFJRixZQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssSUFBTTtBQUM1QixlQUFLLGFBQWE7QUFDbEI7QUFBQTtBQUFBO0FBR0osV0FBSyxlQUFlO0FBQUE7QUFHdEIsa0JBQWMsVUFBVSxNQUFNLFNBQVMsUUFBUTtBQUM3QyxVQUFJLE1BQU07QUFDVixVQUFJLFVBQVUsT0FBTztBQUNuQixjQUFNLEtBQUssTUFBTTtBQUVuQixVQUFJLEtBQUssY0FBYztBQUNyQixZQUFJLEtBQUssS0FBSztBQUNkLFlBQUksTUFBTSxLQUFLO0FBQ2YsWUFBSSxNQUFNLEtBQUs7QUFDZixlQUFPLElBQUksTUFBTSxHQUFHLElBQUksU0FBUztBQUFBO0FBR25DLGFBQU87QUFBQTtBQUFBO0FBQUE7OztBQzlMVCwwQkFBeUIsU0FBUyxPQUFPLElBQUk7QUFHM0MsTUFBSSxPQUFPLFFBQVEsb0JBQW9CLFlBQVk7QUFDakQsV0FBTyxRQUFRLGdCQUFnQixPQUFPO0FBQUEsU0FDakM7QUFLTCxRQUFJLENBQUMsUUFBUSxXQUFXLENBQUMsUUFBUSxRQUFRO0FBQ3ZDLGNBQVEsR0FBRyxPQUFPO0FBQUEsYUFDWCxNQUFNLFFBQVEsUUFBUSxRQUFRO0FBQ3JDLGNBQVEsUUFBUSxPQUFPLFFBQVE7QUFBQTtBQUUvQixjQUFRLFFBQVEsU0FBUyxDQUFDLElBQUksUUFBUSxRQUFRO0FBQUE7QUFBQTtBQUdwRCx3QkFBd0IsU0FBUyxNQUFNO0FBQ3JDLFNBQU8sUUFBUSxVQUFVLE1BQU07QUFBQTtBQUVqQyx1QkFBdUIsVUFBUyxRQUFRO0FBRXRDLGFBQVUsWUFBVztBQUlyQixPQUFLLGFBQWEsQ0FBQyxDQUFDLFNBQVE7QUFFNUIsTUFBSSxrQkFBa0I7QUFBUSxTQUFLLGFBQWEsS0FBSyxjQUFjLENBQUMsQ0FBQyxTQUFRO0FBSTdFLE1BQUksTUFBTSxTQUFRO0FBQ2xCLE1BQUksYUFBYSxLQUFLLGFBQWEsS0FBSyxLQUFLO0FBQzdDLE9BQUssZ0JBQWdCLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFHOUMsT0FBSyxnQkFBZ0IsQ0FBRSxDQUFDLEtBQUs7QUFLN0IsT0FBSyxTQUFTLElBQUk7QUFDbEIsT0FBSyxTQUFTO0FBQ2QsT0FBSyxRQUFRO0FBQ2IsT0FBSyxhQUFhO0FBQ2xCLE9BQUssVUFBVTtBQUNmLE9BQUssUUFBUTtBQUNiLE9BQUssYUFBYTtBQUNsQixPQUFLLFVBQVU7QUFNZixPQUFLLE9BQU87QUFJWixPQUFLLGVBQWU7QUFDcEIsT0FBSyxrQkFBa0I7QUFDdkIsT0FBSyxvQkFBb0I7QUFDekIsT0FBSyxrQkFBa0I7QUFLdkIsT0FBSyxrQkFBa0IsU0FBUSxtQkFBbUI7QUFJbEQsT0FBSyxTQUFTO0FBR2QsT0FBSyxhQUFhO0FBR2xCLE9BQUssY0FBYztBQUVuQixPQUFLLFVBQVU7QUFDZixPQUFLLFdBQVc7QUFDaEIsTUFBSSxTQUFRLFVBQVU7QUFDcEIsU0FBSyxVQUFVLElBQUksY0FBYyxTQUFRO0FBQ3pDLFNBQUssV0FBVyxTQUFRO0FBQUE7QUFBQTtBQUlyQixrQkFBa0IsVUFBUztBQUVoQyxNQUFJLENBQUUsaUJBQWdCO0FBQVcsV0FBTyxJQUFJLFNBQVM7QUFFckQsT0FBSyxpQkFBaUIsSUFBSSxjQUFjLFVBQVM7QUFHakQsT0FBSyxXQUFXO0FBRWhCLE1BQUksWUFBVyxPQUFPLFNBQVEsU0FBUztBQUFZLFNBQUssUUFBUSxTQUFRO0FBRXhFLGlCQUFhLEtBQUs7QUFBQTtBQStCcEIsMEJBQTBCLFFBQVEsT0FBTyxPQUFPLFVBQVUsWUFBWTtBQUNwRSxNQUFJLEtBQUssYUFBYSxPQUFPO0FBQzdCLE1BQUksSUFBSTtBQUNOLFdBQU8sS0FBSyxTQUFTO0FBQUEsYUFDWixVQUFVLE1BQU07QUFDekIsVUFBTSxVQUFVO0FBQ2hCLGVBQVcsUUFBUTtBQUFBLGFBQ1YsTUFBTSxjQUFjLFNBQVMsTUFBTSxTQUFTLEdBQUc7QUFDeEQsUUFBSSxNQUFNLFNBQVMsQ0FBQyxZQUFZO0FBQzlCLFVBQUksSUFBSSxJQUFJLE1BQU07QUFDbEIsYUFBTyxLQUFLLFNBQVM7QUFBQSxlQUNaLE1BQU0sY0FBYyxZQUFZO0FBQ3pDLFVBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsYUFBTyxLQUFLLFNBQVM7QUFBQSxXQUNoQjtBQUNMLFVBQUk7QUFDSixVQUFJLE1BQU0sV0FBVyxDQUFDLGNBQWMsQ0FBQyxVQUFVO0FBQzdDLGdCQUFRLE1BQU0sUUFBUSxNQUFNO0FBQzVCLGtCQUFVLENBQUMsTUFBTSxjQUFjLE1BQU0sV0FBVztBQUFBO0FBR2xELFVBQUksQ0FBQztBQUFZLGNBQU0sVUFBVTtBQUlqQyxVQUFJLENBQUMsU0FBUztBQUVaLFlBQUksTUFBTSxXQUFXLE1BQU0sV0FBVyxLQUFLLENBQUMsTUFBTSxNQUFNO0FBQ3RELGlCQUFPLEtBQUssUUFBUTtBQUNwQixpQkFBTyxLQUFLO0FBQUEsZUFDUDtBQUVMLGdCQUFNLFVBQVUsTUFBTSxhQUFhLElBQUksTUFBTTtBQUM3QyxjQUFJO0FBQVksa0JBQU0sT0FBTyxRQUFRO0FBQUE7QUFBWSxrQkFBTSxPQUFPLEtBQUs7QUFFbkUsY0FBSSxNQUFNO0FBQWMseUJBQWE7QUFBQTtBQUFBO0FBSXpDLG9CQUFjLFFBQVE7QUFBQTtBQUFBLGFBRWYsQ0FBQyxZQUFZO0FBQ3RCLFVBQU0sVUFBVTtBQUFBO0FBR2xCLFNBQU8sYUFBYTtBQUFBO0FBVXRCLHNCQUFzQixPQUFPO0FBQzNCLFNBQU8sQ0FBQyxNQUFNLFNBQVUsT0FBTSxnQkFBZ0IsTUFBTSxTQUFTLE1BQU0saUJBQWlCLE1BQU0sV0FBVztBQUFBO0FBWXZHLGlDQUFpQyxHQUFHO0FBQ2xDLE1BQUksS0FBSyxTQUFTO0FBQ2hCLFFBQUk7QUFBQSxTQUNDO0FBR0w7QUFDQSxTQUFLLE1BQU07QUFDWCxTQUFLLE1BQU07QUFDWCxTQUFLLE1BQU07QUFDWCxTQUFLLE1BQU07QUFDWCxTQUFLLE1BQU07QUFDWDtBQUFBO0FBRUYsU0FBTztBQUFBO0FBS1QsdUJBQXVCLEdBQUcsT0FBTztBQUMvQixNQUFJLEtBQUssS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNO0FBQU8sV0FBTztBQUN4RCxNQUFJLE1BQU07QUFBWSxXQUFPO0FBQzdCLE1BQUksTUFBTSxHQUFHO0FBRVgsUUFBSSxNQUFNLFdBQVcsTUFBTTtBQUFRLGFBQU8sTUFBTSxPQUFPLEtBQUssS0FBSztBQUFBO0FBQVksYUFBTyxNQUFNO0FBQUE7QUFHNUYsTUFBSSxJQUFJLE1BQU07QUFBZSxVQUFNLGdCQUFnQix3QkFBd0I7QUFDM0UsTUFBSSxLQUFLLE1BQU07QUFBUSxXQUFPO0FBRTlCLE1BQUksQ0FBQyxNQUFNLE9BQU87QUFDaEIsVUFBTSxlQUFlO0FBQ3JCLFdBQU87QUFBQTtBQUVULFNBQU8sTUFBTTtBQUFBO0FBd0dmLHNCQUFzQixPQUFPLE9BQU87QUFDbEMsTUFBSSxLQUFLO0FBQ1QsTUFBSSxDQUFDLE9BQU8sU0FBUyxVQUFVLE9BQU8sVUFBVSxZQUFZLFVBQVUsUUFBUSxVQUFVLFVBQWEsQ0FBQyxNQUFNLFlBQVk7QUFDdEgsU0FBSyxJQUFJLFVBQVU7QUFBQTtBQUVyQixTQUFPO0FBQUE7QUFHVCxvQkFBb0IsUUFBUSxPQUFPO0FBQ2pDLE1BQUksTUFBTTtBQUFPO0FBQ2pCLE1BQUksTUFBTSxTQUFTO0FBQ2pCLFFBQUksUUFBUSxNQUFNLFFBQVE7QUFDMUIsUUFBSSxTQUFTLE1BQU0sUUFBUTtBQUN6QixZQUFNLE9BQU8sS0FBSztBQUNsQixZQUFNLFVBQVUsTUFBTSxhQUFhLElBQUksTUFBTTtBQUFBO0FBQUE7QUFHakQsUUFBTSxRQUFRO0FBR2QsZUFBYTtBQUFBO0FBTWYsc0JBQXNCLFFBQVE7QUFDNUIsTUFBSSxRQUFRLE9BQU87QUFDbkIsUUFBTSxlQUFlO0FBQ3JCLE1BQUksQ0FBQyxNQUFNLGlCQUFpQjtBQUMxQixVQUFNLGdCQUFnQixNQUFNO0FBQzVCLFVBQU0sa0JBQWtCO0FBQ3hCLFFBQUksTUFBTTtBQUFNLGVBQVMsZUFBZTtBQUFBO0FBQWEsb0JBQWM7QUFBQTtBQUFBO0FBSXZFLHVCQUF1QixRQUFRO0FBQzdCLFFBQU07QUFDTixTQUFPLEtBQUs7QUFDWixPQUFLO0FBQUE7QUFTUCx1QkFBdUIsUUFBUSxPQUFPO0FBQ3BDLE1BQUksQ0FBQyxNQUFNLGFBQWE7QUFDdEIsVUFBTSxjQUFjO0FBQ3BCLGFBQVMsZ0JBQWdCLFFBQVE7QUFBQTtBQUFBO0FBSXJDLHdCQUF3QixRQUFRLE9BQU87QUFDckMsTUFBSSxNQUFNLE1BQU07QUFDaEIsU0FBTyxDQUFDLE1BQU0sV0FBVyxDQUFDLE1BQU0sV0FBVyxDQUFDLE1BQU0sU0FBUyxNQUFNLFNBQVMsTUFBTSxlQUFlO0FBQzdGLFVBQU07QUFDTixXQUFPLEtBQUs7QUFDWixRQUFJLFFBQVEsTUFBTTtBQUVoQjtBQUFBO0FBQVcsWUFBTSxNQUFNO0FBQUE7QUFFM0IsUUFBTSxjQUFjO0FBQUE7QUErSXRCLHFCQUFxQixLQUFLO0FBQ3hCLFNBQU8sV0FBWTtBQUNqQixRQUFJLFFBQVEsSUFBSTtBQUNoQixVQUFNLGVBQWUsTUFBTTtBQUMzQixRQUFJLE1BQU07QUFBWSxZQUFNO0FBQzVCLFFBQUksTUFBTSxlQUFlLEtBQUssSUFBSSxVQUFVLFFBQVEsUUFBUTtBQUMxRCxZQUFNLFVBQVU7QUFDaEIsV0FBSztBQUFBO0FBQUE7QUFBQTtBQStFWCwwQkFBMEIsT0FBTTtBQUM5QixRQUFNO0FBQ04sUUFBSyxLQUFLO0FBQUE7QUFlWixnQkFBZ0IsUUFBUSxPQUFPO0FBQzdCLE1BQUksQ0FBQyxNQUFNLGlCQUFpQjtBQUMxQixVQUFNLGtCQUFrQjtBQUN4QixhQUFTLFNBQVMsUUFBUTtBQUFBO0FBQUE7QUFJOUIsaUJBQWlCLFFBQVEsT0FBTztBQUM5QixNQUFJLENBQUMsTUFBTSxTQUFTO0FBQ2xCLFVBQU07QUFDTixXQUFPLEtBQUs7QUFBQTtBQUdkLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sYUFBYTtBQUNuQixTQUFPLEtBQUs7QUFDWixPQUFLO0FBQ0wsTUFBSSxNQUFNLFdBQVcsQ0FBQyxNQUFNO0FBQVMsV0FBTyxLQUFLO0FBQUE7QUFhbkQsY0FBYyxRQUFRO0FBQ3BCLE1BQUksUUFBUSxPQUFPO0FBQ25CLFFBQU0sUUFBUSxNQUFNO0FBQ3BCLFNBQU8sTUFBTSxXQUFXLE9BQU8sV0FBVyxNQUFNO0FBQUE7QUFBQTtBQXlFbEQsa0JBQWtCLEdBQUcsT0FBTztBQUUxQixNQUFJLE1BQU0sV0FBVztBQUFHLFdBQU87QUFFL0IsTUFBSTtBQUNKLE1BQUksTUFBTTtBQUFZLFVBQU0sTUFBTSxPQUFPO0FBQUEsV0FBaUIsQ0FBQyxLQUFLLEtBQUssTUFBTSxRQUFRO0FBRWpGLFFBQUksTUFBTTtBQUFTLFlBQU0sTUFBTSxPQUFPLEtBQUs7QUFBQSxhQUFhLE1BQU0sT0FBTyxXQUFXO0FBQUcsWUFBTSxNQUFNLE9BQU8sS0FBSztBQUFBO0FBQVUsWUFBTSxNQUFNLE9BQU8sT0FBTyxNQUFNO0FBQ3JKLFVBQU0sT0FBTztBQUFBLFNBQ1I7QUFFTCxVQUFNLGdCQUFnQixHQUFHLE1BQU0sUUFBUSxNQUFNO0FBQUE7QUFHL0MsU0FBTztBQUFBO0FBTVQseUJBQXlCLEdBQUcsTUFBTSxZQUFZO0FBQzVDLE1BQUk7QUFDSixNQUFJLElBQUksS0FBSyxLQUFLLEtBQUssUUFBUTtBQUU3QixVQUFNLEtBQUssS0FBSyxLQUFLLE1BQU0sR0FBRztBQUM5QixTQUFLLEtBQUssT0FBTyxLQUFLLEtBQUssS0FBSyxNQUFNO0FBQUEsYUFDN0IsTUFBTSxLQUFLLEtBQUssS0FBSyxRQUFRO0FBRXRDLFVBQU0sS0FBSztBQUFBLFNBQ047QUFFTCxVQUFNLGFBQWEscUJBQXFCLEdBQUcsUUFBUSxlQUFlLEdBQUc7QUFBQTtBQUV2RSxTQUFPO0FBQUE7QUFPVCw4QkFBOEIsR0FBRyxNQUFNO0FBQ3JDLE1BQUksSUFBSSxLQUFLO0FBQ2IsTUFBSSxJQUFJO0FBQ1IsTUFBSSxNQUFNLEVBQUU7QUFDWixPQUFLLElBQUk7QUFDVCxTQUFPLElBQUksRUFBRSxNQUFNO0FBQ2pCLFFBQUksTUFBTSxFQUFFO0FBQ1osUUFBSSxLQUFLLElBQUksSUFBSSxTQUFTLElBQUksU0FBUztBQUN2QyxRQUFJLE9BQU8sSUFBSTtBQUFRLGFBQU87QUFBQTtBQUFTLGFBQU8sSUFBSSxNQUFNLEdBQUc7QUFDM0QsU0FBSztBQUNMLFFBQUksTUFBTSxHQUFHO0FBQ1gsVUFBSSxPQUFPLElBQUksUUFBUTtBQUNyQixVQUFFO0FBQ0YsWUFBSSxFQUFFO0FBQU0sZUFBSyxPQUFPLEVBQUU7QUFBQTtBQUFVLGVBQUssT0FBTyxLQUFLLE9BQU87QUFBQSxhQUN2RDtBQUNMLGFBQUssT0FBTztBQUNaLFVBQUUsT0FBTyxJQUFJLE1BQU07QUFBQTtBQUVyQjtBQUFBO0FBRUYsTUFBRTtBQUFBO0FBRUosT0FBSyxVQUFVO0FBQ2YsU0FBTztBQUFBO0FBTVQsd0JBQXdCLEdBQUcsTUFBTTtBQUMvQixNQUFJLE1BQU0sT0FBTyxZQUFZO0FBQzdCLE1BQUksSUFBSSxLQUFLO0FBQ2IsTUFBSSxJQUFJO0FBQ1IsSUFBRSxLQUFLLEtBQUs7QUFDWixPQUFLLEVBQUUsS0FBSztBQUNaLFNBQU8sSUFBSSxFQUFFLE1BQU07QUFDakIsUUFBSSxNQUFNLEVBQUU7QUFDWixRQUFJLEtBQUssSUFBSSxJQUFJLFNBQVMsSUFBSSxTQUFTO0FBQ3ZDLFFBQUksS0FBSyxLQUFLLElBQUksU0FBUyxHQUFHLEdBQUc7QUFDakMsU0FBSztBQUNMLFFBQUksTUFBTSxHQUFHO0FBQ1gsVUFBSSxPQUFPLElBQUksUUFBUTtBQUNyQixVQUFFO0FBQ0YsWUFBSSxFQUFFO0FBQU0sZUFBSyxPQUFPLEVBQUU7QUFBQTtBQUFVLGVBQUssT0FBTyxLQUFLLE9BQU87QUFBQSxhQUN2RDtBQUNMLGFBQUssT0FBTztBQUNaLFVBQUUsT0FBTyxJQUFJLE1BQU07QUFBQTtBQUVyQjtBQUFBO0FBRUYsTUFBRTtBQUFBO0FBRUosT0FBSyxVQUFVO0FBQ2YsU0FBTztBQUFBO0FBR1QscUJBQXFCLFFBQVE7QUFDM0IsTUFBSSxRQUFRLE9BQU87QUFJbkIsTUFBSSxNQUFNLFNBQVM7QUFBRyxVQUFNLElBQUksTUFBTTtBQUV0QyxNQUFJLENBQUMsTUFBTSxZQUFZO0FBQ3JCLFVBQU0sUUFBUTtBQUNkLGFBQVMsZUFBZSxPQUFPO0FBQUE7QUFBQTtBQUluQyx1QkFBdUIsT0FBTyxRQUFRO0FBRXBDLE1BQUksQ0FBQyxNQUFNLGNBQWMsTUFBTSxXQUFXLEdBQUc7QUFDM0MsVUFBTSxhQUFhO0FBQ25CLFdBQU8sV0FBVztBQUNsQixXQUFPLEtBQUs7QUFBQTtBQUFBO0FBSWhCLGlCQUFpQixJQUFJLEdBQUc7QUFDdEIsV0FBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDekMsTUFBRSxHQUFHLElBQUk7QUFBQTtBQUFBO0FBSWIsa0JBQWlCLElBQUksR0FBRztBQUN0QixXQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUN6QyxRQUFJLEdBQUcsT0FBTztBQUFHLGFBQU87QUFBQTtBQUUxQixTQUFPO0FBQUE7QUE5M0JULElBV0ksT0F3TUE7QUFuTko7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFHQSxhQUFTLGdCQUFnQjtBQVF6QixJQUFJLFFBQVEsU0FBUztBQUNyQixxQkFBUyxVQUFVO0FBNEduQixhQUFTLFVBQVUsT0FBTyxTQUFVLE9BQU8sVUFBVTtBQUNuRCxVQUFJLFFBQVEsS0FBSztBQUVqQixVQUFJLENBQUMsTUFBTSxjQUFjLE9BQU8sVUFBVSxVQUFVO0FBQ2xELG1CQUFXLFlBQVksTUFBTTtBQUM3QixZQUFJLGFBQWEsTUFBTSxVQUFVO0FBQy9CLGtCQUFRLE9BQU8sS0FBSyxPQUFPO0FBQzNCLHFCQUFXO0FBQUE7QUFBQTtBQUlmLGFBQU8saUJBQWlCLE1BQU0sT0FBTyxPQUFPLFVBQVU7QUFBQTtBQUl4RCxhQUFTLFVBQVUsVUFBVSxTQUFVLE9BQU87QUFDNUMsVUFBSSxRQUFRLEtBQUs7QUFDakIsYUFBTyxpQkFBaUIsTUFBTSxPQUFPLE9BQU8sSUFBSTtBQUFBO0FBR2xELGFBQVMsVUFBVSxXQUFXLFdBQVk7QUFDeEMsYUFBTyxLQUFLLGVBQWUsWUFBWTtBQUFBO0FBK0R6QyxhQUFTLFVBQVUsY0FBYyxTQUFVLEtBQUs7QUFDOUMsV0FBSyxlQUFlLFVBQVUsSUFBSSxjQUFjO0FBQ2hELFdBQUssZUFBZSxXQUFXO0FBQy9CLGFBQU87QUFBQTtBQUlULElBQUksVUFBVTtBQXVDZCxhQUFTLFVBQVUsT0FBTyxTQUFVLEdBQUc7QUFDckMsWUFBTSxRQUFRO0FBQ2QsVUFBSSxTQUFTLEdBQUc7QUFDaEIsVUFBSSxRQUFRLEtBQUs7QUFDakIsVUFBSSxRQUFRO0FBRVosVUFBSSxNQUFNO0FBQUcsY0FBTSxrQkFBa0I7QUFLckMsVUFBSSxNQUFNLEtBQUssTUFBTSxnQkFBaUIsT0FBTSxVQUFVLE1BQU0saUJBQWlCLE1BQU0sUUFBUTtBQUN6RixjQUFNLHNCQUFzQixNQUFNLFFBQVEsTUFBTTtBQUNoRCxZQUFJLE1BQU0sV0FBVyxLQUFLLE1BQU07QUFBTyxzQkFBWTtBQUFBO0FBQVcsdUJBQWE7QUFDM0UsZUFBTztBQUFBO0FBR1QsVUFBSSxjQUFjLEdBQUc7QUFHckIsVUFBSSxNQUFNLEtBQUssTUFBTSxPQUFPO0FBQzFCLFlBQUksTUFBTSxXQUFXO0FBQUcsc0JBQVk7QUFDcEMsZUFBTztBQUFBO0FBMEJULFVBQUksU0FBUyxNQUFNO0FBQ25CLFlBQU0saUJBQWlCO0FBR3ZCLFVBQUksTUFBTSxXQUFXLEtBQUssTUFBTSxTQUFTLElBQUksTUFBTSxlQUFlO0FBQ2hFLGlCQUFTO0FBQ1QsY0FBTSw4QkFBOEI7QUFBQTtBQUt0QyxVQUFJLE1BQU0sU0FBUyxNQUFNLFNBQVM7QUFDaEMsaUJBQVM7QUFDVCxjQUFNLG9CQUFvQjtBQUFBLGlCQUNqQixRQUFRO0FBQ2pCLGNBQU07QUFDTixjQUFNLFVBQVU7QUFDaEIsY0FBTSxPQUFPO0FBRWIsWUFBSSxNQUFNLFdBQVc7QUFBRyxnQkFBTSxlQUFlO0FBRTdDLGFBQUssTUFBTSxNQUFNO0FBQ2pCLGNBQU0sT0FBTztBQUdiLFlBQUksQ0FBQyxNQUFNO0FBQVMsY0FBSSxjQUFjLE9BQU87QUFBQTtBQUcvQyxVQUFJO0FBQ0osVUFBSSxJQUFJO0FBQUcsY0FBTSxTQUFTLEdBQUc7QUFBQTtBQUFZLGNBQU07QUFFL0MsVUFBSSxRQUFRLE1BQU07QUFDaEIsY0FBTSxlQUFlO0FBQ3JCLFlBQUk7QUFBQSxhQUNDO0FBQ0wsY0FBTSxVQUFVO0FBQUE7QUFHbEIsVUFBSSxNQUFNLFdBQVcsR0FBRztBQUd0QixZQUFJLENBQUMsTUFBTTtBQUFPLGdCQUFNLGVBQWU7QUFHdkMsWUFBSSxVQUFVLEtBQUssTUFBTTtBQUFPLHNCQUFZO0FBQUE7QUFHOUMsVUFBSSxRQUFRO0FBQU0sYUFBSyxLQUFLLFFBQVE7QUFFcEMsYUFBTztBQUFBO0FBMEVULGFBQVMsVUFBVSxRQUFRLFNBQVUsR0FBRztBQUN0QyxXQUFLLEtBQUssU0FBUyxJQUFJLE1BQU07QUFBQTtBQUcvQixhQUFTLFVBQVUsT0FBTyxTQUFVLE1BQU0sVUFBVTtBQUNsRCxVQUFJLE1BQU07QUFDVixVQUFJLFFBQVEsS0FBSztBQUVqQixjQUFRLE1BQU07QUFBQSxhQUNQO0FBQ0gsZ0JBQU0sUUFBUTtBQUNkO0FBQUEsYUFDRztBQUNILGdCQUFNLFFBQVEsQ0FBQyxNQUFNLE9BQU87QUFDNUI7QUFBQTtBQUVBLGdCQUFNLE1BQU0sS0FBSztBQUNqQjtBQUFBO0FBRUosWUFBTSxjQUFjO0FBQ3BCLFlBQU0seUJBQXlCLE1BQU0sWUFBWTtBQUVqRCxVQUFJLFFBQVMsQ0FBQyxZQUFZLFNBQVMsUUFBUTtBQUUzQyxVQUFJLFFBQVEsUUFBUSxTQUFRO0FBQzVCLFVBQUksTUFBTTtBQUFZLGlCQUFTO0FBQUE7QUFBWSxZQUFJLEtBQUssT0FBTztBQUUzRCxXQUFLLEdBQUcsVUFBVTtBQUNsQix3QkFBa0IsVUFBVTtBQUMxQixjQUFNO0FBQ04sWUFBSSxhQUFhLEtBQUs7QUFDcEI7QUFBQTtBQUFBO0FBSUosd0JBQWlCO0FBQ2YsY0FBTTtBQUNOLGFBQUs7QUFBQTtBQU9QLFVBQUksVUFBVSxZQUFZO0FBQzFCLFdBQUssR0FBRyxTQUFTO0FBRWpCLFVBQUksWUFBWTtBQUNoQix5QkFBbUI7QUFDakIsY0FBTTtBQUVOLGFBQUssZUFBZSxTQUFTO0FBQzdCLGFBQUssZUFBZSxVQUFVO0FBQzlCLGFBQUssZUFBZSxTQUFTO0FBQzdCLGFBQUssZUFBZSxTQUFTO0FBQzdCLGFBQUssZUFBZSxVQUFVO0FBQzlCLFlBQUksZUFBZSxPQUFPO0FBQzFCLFlBQUksZUFBZSxPQUFPO0FBQzFCLFlBQUksZUFBZSxRQUFRO0FBRTNCLG9CQUFZO0FBT1osWUFBSSxNQUFNLGNBQWUsRUFBQyxLQUFLLGtCQUFrQixLQUFLLGVBQWU7QUFBWTtBQUFBO0FBT25GLFVBQUksc0JBQXNCO0FBQzFCLFVBQUksR0FBRyxRQUFRO0FBQ2Ysc0JBQWdCLE9BQU87QUFDckIsY0FBTTtBQUNOLDhCQUFzQjtBQUN0QixZQUFJLE1BQU0sS0FBSyxNQUFNO0FBQ3JCLFlBQUksQUFBVSxRQUFWLFNBQWlCLENBQUMscUJBQXFCO0FBS3pDLGNBQUssT0FBTSxlQUFlLEtBQUssTUFBTSxVQUFVLFFBQVEsTUFBTSxhQUFhLEtBQUssU0FBUSxNQUFNLE9BQU8sVUFBVSxPQUFPLENBQUMsV0FBVztBQUMvSCxrQkFBTSwrQkFBK0IsSUFBSSxlQUFlO0FBQ3hELGdCQUFJLGVBQWU7QUFDbkIsa0NBQXNCO0FBQUE7QUFFeEIsY0FBSTtBQUFBO0FBQUE7QUFNUix1QkFBaUIsSUFBSTtBQUNuQixjQUFNLFdBQVc7QUFDakI7QUFDQSxhQUFLLGVBQWUsU0FBUztBQUM3QixZQUFJLGVBQWMsTUFBTSxhQUFhO0FBQUcsZUFBSyxLQUFLLFNBQVM7QUFBQTtBQUk3RCx1QkFBZ0IsTUFBTSxTQUFTO0FBRy9CLHlCQUFtQjtBQUNqQixhQUFLLGVBQWUsVUFBVTtBQUM5QjtBQUFBO0FBRUYsV0FBSyxLQUFLLFNBQVM7QUFDbkIsMEJBQW9CO0FBQ2xCLGNBQU07QUFDTixhQUFLLGVBQWUsU0FBUztBQUM3QjtBQUFBO0FBRUYsV0FBSyxLQUFLLFVBQVU7QUFFcEIsd0JBQWtCO0FBQ2hCLGNBQU07QUFDTixZQUFJLE9BQU87QUFBQTtBQUliLFdBQUssS0FBSyxRQUFRO0FBR2xCLFVBQUksQ0FBQyxNQUFNLFNBQVM7QUFDbEIsY0FBTTtBQUNOLFlBQUk7QUFBQTtBQUdOLGFBQU87QUFBQTtBQWVULGFBQVMsVUFBVSxTQUFTLFNBQVUsTUFBTTtBQUMxQyxVQUFJLFFBQVEsS0FBSztBQUdqQixVQUFJLE1BQU0sZUFBZTtBQUFHLGVBQU87QUFHbkMsVUFBSSxNQUFNLGVBQWUsR0FBRztBQUUxQixZQUFJLFFBQVEsU0FBUyxNQUFNO0FBQU8saUJBQU87QUFFekMsWUFBSSxDQUFDO0FBQU0saUJBQU8sTUFBTTtBQUd4QixjQUFNLFFBQVE7QUFDZCxjQUFNLGFBQWE7QUFDbkIsY0FBTSxVQUFVO0FBQ2hCLFlBQUk7QUFBTSxlQUFLLEtBQUssVUFBVTtBQUM5QixlQUFPO0FBQUE7QUFLVCxVQUFJLENBQUMsTUFBTTtBQUVULFlBQUksUUFBUSxNQUFNO0FBQ2xCLFlBQUksTUFBTSxNQUFNO0FBQ2hCLGNBQU0sUUFBUTtBQUNkLGNBQU0sYUFBYTtBQUNuQixjQUFNLFVBQVU7QUFFaEIsaUJBQVMsS0FBSyxHQUFHLEtBQUssS0FBSyxNQUFNO0FBQy9CLGdCQUFNLElBQUksS0FBSyxVQUFVO0FBQUE7QUFDMUIsZUFBTztBQUFBO0FBSVYsVUFBSSxJQUFJLFNBQVEsTUFBTSxPQUFPO0FBQzdCLFVBQUksTUFBTTtBQUFJLGVBQU87QUFFckIsWUFBTSxNQUFNLE9BQU8sR0FBRztBQUN0QixZQUFNLGNBQWM7QUFDcEIsVUFBSSxNQUFNLGVBQWU7QUFBRyxjQUFNLFFBQVEsTUFBTSxNQUFNO0FBRXRELFdBQUssS0FBSyxVQUFVO0FBRXBCLGFBQU87QUFBQTtBQUtULGFBQVMsVUFBVSxLQUFLLFNBQVUsSUFBSSxJQUFJO0FBQ3hDLFVBQUksTUFBTSxlQUFhLFVBQVUsR0FBRyxLQUFLLE1BQU0sSUFBSTtBQUVuRCxVQUFJLE9BQU8sUUFBUTtBQUVqQixZQUFJLEtBQUssZUFBZSxZQUFZO0FBQU8sZUFBSztBQUFBLGlCQUN2QyxPQUFPLFlBQVk7QUFDNUIsWUFBSSxRQUFRLEtBQUs7QUFDakIsWUFBSSxDQUFDLE1BQU0sY0FBYyxDQUFDLE1BQU0sbUJBQW1CO0FBQ2pELGdCQUFNLG9CQUFvQixNQUFNLGVBQWU7QUFDL0MsZ0JBQU0sa0JBQWtCO0FBQ3hCLGNBQUksQ0FBQyxNQUFNLFNBQVM7QUFDbEIscUJBQVMsa0JBQWtCO0FBQUEscUJBQ2xCLE1BQU0sUUFBUTtBQUN2Qix5QkFBYSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBS3pCLGFBQU87QUFBQTtBQUVULGFBQVMsVUFBVSxjQUFjLFNBQVMsVUFBVTtBQVNwRCxhQUFTLFVBQVUsU0FBUyxXQUFZO0FBQ3RDLFVBQUksUUFBUSxLQUFLO0FBQ2pCLFVBQUksQ0FBQyxNQUFNLFNBQVM7QUFDbEIsY0FBTTtBQUNOLGNBQU0sVUFBVTtBQUNoQixlQUFPLE1BQU07QUFBQTtBQUVmLGFBQU87QUFBQTtBQXVCVCxhQUFTLFVBQVUsUUFBUSxXQUFZO0FBQ3JDLFlBQU0seUJBQXlCLEtBQUssZUFBZTtBQUNuRCxVQUFJLEFBQVUsS0FBSyxlQUFlLFlBQTlCLE9BQXVDO0FBQ3pDLGNBQU07QUFDTixhQUFLLGVBQWUsVUFBVTtBQUM5QixhQUFLLEtBQUs7QUFBQTtBQUVaLGFBQU87QUFBQTtBQVlULGFBQVMsVUFBVSxPQUFPLFNBQVUsUUFBUTtBQUMxQyxVQUFJLFFBQVEsS0FBSztBQUNqQixVQUFJLFNBQVM7QUFFYixVQUFJLFFBQU87QUFDWCxhQUFPLEdBQUcsT0FBTyxXQUFZO0FBQzNCLGNBQU07QUFDTixZQUFJLE1BQU0sV0FBVyxDQUFDLE1BQU0sT0FBTztBQUNqQyxjQUFJLFFBQVEsTUFBTSxRQUFRO0FBQzFCLGNBQUksU0FBUyxNQUFNO0FBQVEsa0JBQUssS0FBSztBQUFBO0FBR3ZDLGNBQUssS0FBSztBQUFBO0FBR1osYUFBTyxHQUFHLFFBQVEsU0FBVSxPQUFPO0FBQ2pDLGNBQU07QUFDTixZQUFJLE1BQU07QUFBUyxrQkFBUSxNQUFNLFFBQVEsTUFBTTtBQUcvQyxZQUFJLE1BQU0sY0FBZSxXQUFVLFFBQVEsVUFBVTtBQUFZO0FBQUEsaUJBQWdCLENBQUMsTUFBTSxjQUFlLEVBQUMsU0FBUyxDQUFDLE1BQU07QUFBUztBQUVqSSxZQUFJLE1BQU0sTUFBSyxLQUFLO0FBQ3BCLFlBQUksQ0FBQyxLQUFLO0FBQ1IsbUJBQVM7QUFDVCxpQkFBTztBQUFBO0FBQUE7QUFNWCxlQUFTLEtBQUssUUFBUTtBQUNwQixZQUFJLEtBQUssT0FBTyxVQUFhLE9BQU8sT0FBTyxPQUFPLFlBQVk7QUFDNUQsZUFBSyxLQUFLLFNBQVUsUUFBUTtBQUMxQixtQkFBTyxXQUFZO0FBQ2pCLHFCQUFPLE9BQU8sUUFBUSxNQUFNLFFBQVE7QUFBQTtBQUFBLFlBRXRDO0FBQUE7QUFBQTtBQUtOLFVBQUksU0FBUyxDQUFDLFNBQVMsU0FBUyxXQUFXLFNBQVM7QUFDcEQsY0FBUSxRQUFRLFNBQVUsSUFBSTtBQUM1QixlQUFPLEdBQUcsSUFBSSxNQUFLLEtBQUssS0FBSyxPQUFNO0FBQUE7QUFLckMsWUFBSyxRQUFRLFNBQVUsR0FBRztBQUN4QixjQUFNLGlCQUFpQjtBQUN2QixZQUFJLFFBQVE7QUFDVixtQkFBUztBQUNULGlCQUFPO0FBQUE7QUFBQTtBQUlYLGFBQU87QUFBQTtBQUlULGFBQVMsWUFBWTtBQUFBO0FBQUE7OztBQzN1QnJCLGVBQWU7QUFBQTtBQUVmLGtCQUFrQixPQUFPLFVBQVUsSUFBSTtBQUNyQyxPQUFLLFFBQVE7QUFDYixPQUFLLFdBQVc7QUFDaEIsT0FBSyxXQUFXO0FBQ2hCLE9BQUssT0FBTztBQUFBO0FBR2QsdUJBQXVCLFVBQVMsUUFBUTtBQUN0QyxTQUFPLGVBQWUsTUFBTSxVQUFVO0FBQUEsSUFDcEMsS0FBSyxVQUFVLFdBQVk7QUFDekIsYUFBTyxLQUFLO0FBQUEsT0FDWDtBQUFBO0FBRUwsYUFBVSxZQUFXO0FBSXJCLE9BQUssYUFBYSxDQUFDLENBQUMsU0FBUTtBQUU1QixNQUFJLGtCQUFrQjtBQUFRLFNBQUssYUFBYSxLQUFLLGNBQWMsQ0FBQyxDQUFDLFNBQVE7QUFLN0UsTUFBSSxNQUFNLFNBQVE7QUFDbEIsTUFBSSxhQUFhLEtBQUssYUFBYSxLQUFLLEtBQUs7QUFDN0MsT0FBSyxnQkFBZ0IsT0FBTyxRQUFRLElBQUksTUFBTTtBQUc5QyxPQUFLLGdCQUFnQixDQUFFLENBQUMsS0FBSztBQUU3QixPQUFLLFlBQVk7QUFFakIsT0FBSyxTQUFTO0FBRWQsT0FBSyxRQUFRO0FBRWIsT0FBSyxXQUFXO0FBS2hCLE1BQUksV0FBVyxTQUFRLGtCQUFrQjtBQUN6QyxPQUFLLGdCQUFnQixDQUFDO0FBS3RCLE9BQUssa0JBQWtCLFNBQVEsbUJBQW1CO0FBS2xELE9BQUssU0FBUztBQUdkLE9BQUssVUFBVTtBQUdmLE9BQUssU0FBUztBQU1kLE9BQUssT0FBTztBQUtaLE9BQUssbUJBQW1CO0FBR3hCLE9BQUssVUFBVSxTQUFVLElBQUk7QUFDM0IsWUFBUSxRQUFRO0FBQUE7QUFJbEIsT0FBSyxVQUFVO0FBR2YsT0FBSyxXQUFXO0FBRWhCLE9BQUssa0JBQWtCO0FBQ3ZCLE9BQUssc0JBQXNCO0FBSTNCLE9BQUssWUFBWTtBQUlqQixPQUFLLGNBQWM7QUFHbkIsT0FBSyxlQUFlO0FBR3BCLE9BQUssdUJBQXVCO0FBSTVCLE9BQUsscUJBQXFCLElBQUksY0FBYztBQUFBO0FBY3ZDLGtCQUFrQixVQUFTO0FBSWhDLE1BQUksQ0FBRSxpQkFBZ0IsYUFBYSxDQUFFLGlCQUFnQjtBQUFTLFdBQU8sSUFBSSxTQUFTO0FBRWxGLE9BQUssaUJBQWlCLElBQUksY0FBYyxVQUFTO0FBR2pELE9BQUssV0FBVztBQUVoQixNQUFJLFVBQVM7QUFDWCxRQUFJLE9BQU8sU0FBUSxVQUFVO0FBQVksV0FBSyxTQUFTLFNBQVE7QUFFL0QsUUFBSSxPQUFPLFNBQVEsV0FBVztBQUFZLFdBQUssVUFBVSxTQUFRO0FBQUE7QUFHbkUsZUFBYSxLQUFLO0FBQUE7QUFRcEIsdUJBQXVCLFFBQVEsSUFBSTtBQUNqQyxNQUFJLEtBQUssSUFBSSxNQUFNO0FBRW5CLFNBQU8sS0FBSyxTQUFTO0FBQ3JCLFdBQVMsSUFBSTtBQUFBO0FBUWYsb0JBQW9CLFFBQVEsT0FBTyxPQUFPLElBQUk7QUFDNUMsTUFBSSxRQUFRO0FBQ1osTUFBSSxLQUFLO0FBSVQsTUFBSSxVQUFVLE1BQU07QUFDbEIsU0FBSyxJQUFJLFVBQVU7QUFBQSxhQUNWLENBQUMsUUFBTyxTQUFTLFVBQVUsT0FBTyxVQUFVLFlBQVksVUFBVSxVQUFhLENBQUMsTUFBTSxZQUFZO0FBQzNHLFNBQUssSUFBSSxVQUFVO0FBQUE7QUFFckIsTUFBSSxJQUFJO0FBQ04sV0FBTyxLQUFLLFNBQVM7QUFDckIsYUFBUyxJQUFJO0FBQ2IsWUFBUTtBQUFBO0FBRVYsU0FBTztBQUFBO0FBZ0RULHFCQUFxQixPQUFPLE9BQU8sVUFBVTtBQUMzQyxNQUFJLENBQUMsTUFBTSxjQUFjLE1BQU0sa0JBQWtCLFNBQVMsT0FBTyxVQUFVLFVBQVU7QUFDbkYsWUFBUSxRQUFPLEtBQUssT0FBTztBQUFBO0FBRTdCLFNBQU87QUFBQTtBQU1ULHVCQUF1QixRQUFRLE9BQU8sT0FBTyxVQUFVLElBQUk7QUFDekQsVUFBUSxZQUFZLE9BQU8sT0FBTztBQUVsQyxNQUFJLFFBQU8sU0FBUztBQUFRLGVBQVc7QUFDdkMsTUFBSSxNQUFNLE1BQU0sYUFBYSxJQUFJLE1BQU07QUFFdkMsUUFBTSxVQUFVO0FBRWhCLE1BQUksTUFBTSxNQUFNLFNBQVMsTUFBTTtBQUUvQixNQUFJLENBQUM7QUFBSyxVQUFNLFlBQVk7QUFFNUIsTUFBSSxNQUFNLFdBQVcsTUFBTSxRQUFRO0FBQ2pDLFFBQUksT0FBTyxNQUFNO0FBQ2pCLFVBQU0sc0JBQXNCLElBQUksU0FBUyxPQUFPLFVBQVU7QUFDMUQsUUFBSSxNQUFNO0FBQ1IsV0FBSyxPQUFPLE1BQU07QUFBQSxXQUNiO0FBQ0wsWUFBTSxrQkFBa0IsTUFBTTtBQUFBO0FBRWhDLFVBQU0sd0JBQXdCO0FBQUEsU0FDekI7QUFDTCxZQUFRLFFBQVEsT0FBTyxPQUFPLEtBQUssT0FBTyxVQUFVO0FBQUE7QUFHdEQsU0FBTztBQUFBO0FBR1QsaUJBQWlCLFFBQVEsT0FBTyxRQUFRLEtBQUssT0FBTyxVQUFVLElBQUk7QUFDaEUsUUFBTSxXQUFXO0FBQ2pCLFFBQU0sVUFBVTtBQUNoQixRQUFNLFVBQVU7QUFDaEIsUUFBTSxPQUFPO0FBQ2IsTUFBSTtBQUFRLFdBQU8sUUFBUSxPQUFPLE1BQU07QUFBQTtBQUFjLFdBQU8sT0FBTyxPQUFPLFVBQVUsTUFBTTtBQUMzRixRQUFNLE9BQU87QUFBQTtBQUdmLHNCQUFzQixRQUFRLE9BQU8sTUFBTSxJQUFJLElBQUk7QUFDakQsSUFBRSxNQUFNO0FBQ1IsTUFBSTtBQUFNLGFBQVMsSUFBSTtBQUFBO0FBQVMsT0FBRztBQUVuQyxTQUFPLGVBQWUsZUFBZTtBQUNyQyxTQUFPLEtBQUssU0FBUztBQUFBO0FBR3ZCLDRCQUE0QixPQUFPO0FBQ2pDLFFBQU0sVUFBVTtBQUNoQixRQUFNLFVBQVU7QUFDaEIsUUFBTSxVQUFVLE1BQU07QUFDdEIsUUFBTSxXQUFXO0FBQUE7QUFHbkIsaUJBQWlCLFFBQVEsSUFBSTtBQUMzQixNQUFJLFFBQVEsT0FBTztBQUNuQixNQUFJLE9BQU8sTUFBTTtBQUNqQixNQUFJLEtBQUssTUFBTTtBQUVmLHFCQUFtQjtBQUVuQixNQUFJO0FBQUksaUJBQWEsUUFBUSxPQUFPLE1BQU0sSUFBSTtBQUFBLE9BQVM7QUFFckQsUUFBSSxXQUFXLFdBQVc7QUFFMUIsUUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLFVBQVUsQ0FBQyxNQUFNLG9CQUFvQixNQUFNLGlCQUFpQjtBQUNsRixrQkFBWSxRQUFRO0FBQUE7QUFHdEIsUUFBSSxNQUFNO0FBRU4sZUFBUyxZQUFZLFFBQVEsT0FBTyxVQUFVO0FBQUEsV0FFM0M7QUFDSCxpQkFBVyxRQUFRLE9BQU8sVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUs1QyxvQkFBb0IsUUFBUSxPQUFPLFVBQVUsSUFBSTtBQUMvQyxNQUFJLENBQUM7QUFBVSxpQkFBYSxRQUFRO0FBQ3BDLFFBQU07QUFDTjtBQUNBLGNBQVksUUFBUTtBQUFBO0FBTXRCLHNCQUFzQixRQUFRLE9BQU87QUFDbkMsTUFBSSxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVc7QUFDekMsVUFBTSxZQUFZO0FBQ2xCLFdBQU8sS0FBSztBQUFBO0FBQUE7QUFLaEIscUJBQXFCLFFBQVEsT0FBTztBQUNsQyxRQUFNLG1CQUFtQjtBQUN6QixNQUFJLFNBQVEsTUFBTTtBQUVsQixNQUFJLE9BQU8sV0FBVyxVQUFTLE9BQU0sTUFBTTtBQUV6QyxRQUFJLElBQUksTUFBTTtBQUNkLFFBQUksU0FBUyxJQUFJLE1BQU07QUFDdkIsUUFBSSxTQUFTLE1BQU07QUFDbkIsV0FBTyxRQUFRO0FBRWYsUUFBSSxRQUFRO0FBQ1osV0FBTyxRQUFPO0FBQ1osYUFBTyxTQUFTO0FBQ2hCLGVBQVEsT0FBTTtBQUNkLGVBQVM7QUFBQTtBQUdYLFlBQVEsUUFBUSxPQUFPLE1BQU0sTUFBTSxRQUFRLFFBQVEsSUFBSSxPQUFPO0FBSTlELFVBQU07QUFDTixVQUFNLHNCQUFzQjtBQUM1QixRQUFJLE9BQU8sTUFBTTtBQUNmLFlBQU0scUJBQXFCLE9BQU87QUFDbEMsYUFBTyxPQUFPO0FBQUEsV0FDVDtBQUNMLFlBQU0scUJBQXFCLElBQUksY0FBYztBQUFBO0FBQUEsU0FFMUM7QUFFTCxXQUFPLFFBQU87QUFDWixVQUFJLFFBQVEsT0FBTTtBQUNsQixVQUFJLFdBQVcsT0FBTTtBQUNyQixVQUFJLEtBQUssT0FBTTtBQUNmLFVBQUksTUFBTSxNQUFNLGFBQWEsSUFBSSxNQUFNO0FBRXZDLGNBQVEsUUFBUSxPQUFPLE9BQU8sS0FBSyxPQUFPLFVBQVU7QUFDcEQsZUFBUSxPQUFNO0FBS2QsVUFBSSxNQUFNLFNBQVM7QUFDakI7QUFBQTtBQUFBO0FBSUosUUFBSSxXQUFVO0FBQU0sWUFBTSxzQkFBc0I7QUFBQTtBQUdsRCxRQUFNLHVCQUF1QjtBQUM3QixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLG1CQUFtQjtBQUFBO0FBaUMzQixvQkFBb0IsT0FBTztBQUN6QixTQUFPLE1BQU0sVUFBVSxNQUFNLFdBQVcsS0FBSyxNQUFNLG9CQUFvQixRQUFRLENBQUMsTUFBTSxZQUFZLENBQUMsTUFBTTtBQUFBO0FBRzNHLG1CQUFtQixRQUFRLE9BQU87QUFDaEMsTUFBSSxDQUFDLE1BQU0sYUFBYTtBQUN0QixVQUFNLGNBQWM7QUFDcEIsV0FBTyxLQUFLO0FBQUE7QUFBQTtBQUloQixxQkFBcUIsUUFBUSxPQUFPO0FBQ2xDLE1BQUksT0FBTyxXQUFXO0FBQ3RCLE1BQUksTUFBTTtBQUNSLFFBQUksTUFBTSxjQUFjLEdBQUc7QUFDekIsZ0JBQVUsUUFBUTtBQUNsQixZQUFNLFdBQVc7QUFDakIsYUFBTyxLQUFLO0FBQUEsV0FDUDtBQUNMLGdCQUFVLFFBQVE7QUFBQTtBQUFBO0FBR3RCLFNBQU87QUFBQTtBQUdULHFCQUFxQixRQUFRLE9BQU8sSUFBSTtBQUN0QyxRQUFNLFNBQVM7QUFDZixjQUFZLFFBQVE7QUFDcEIsTUFBSSxJQUFJO0FBQ04sUUFBSSxNQUFNO0FBQVUsZUFBUztBQUFBO0FBQVMsYUFBTyxLQUFLLFVBQVU7QUFBQTtBQUU5RCxRQUFNLFFBQVE7QUFDZCxTQUFPLFdBQVc7QUFBQTtBQUtwQix1QkFBdUIsT0FBTztBQUM1QixNQUFJLFFBQVE7QUFFWixPQUFLLE9BQU87QUFDWixPQUFLLFFBQVE7QUFFYixPQUFLLFNBQVMsU0FBVSxLQUFLO0FBQzNCLFFBQUksU0FBUSxNQUFNO0FBQ2xCLFVBQU0sUUFBUTtBQUNkLFdBQU8sUUFBTztBQUNaLFVBQUksS0FBSyxPQUFNO0FBQ2YsWUFBTTtBQUNOLFNBQUc7QUFDSCxlQUFRLE9BQU07QUFBQTtBQUVoQixRQUFJLE1BQU0sb0JBQW9CO0FBQzVCLFlBQU0sbUJBQW1CLE9BQU87QUFBQSxXQUMzQjtBQUNMLFlBQU0scUJBQXFCO0FBQUE7QUFBQTtBQUFBO0FBL2RqQztBQUFBO0FBQUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEEsYUFBUyxnQkFBZ0I7QUFJekIscUJBQVMsVUFBVTtBQTZHbkIsa0JBQWMsVUFBVSxZQUFZLGtDQUFrQztBQUNwRSxVQUFJLFVBQVUsS0FBSztBQUNuQixVQUFJLE1BQU07QUFDVixhQUFPLFNBQVM7QUFDZCxZQUFJLEtBQUs7QUFDVCxrQkFBVSxRQUFRO0FBQUE7QUFFcEIsYUFBTztBQUFBO0FBeUJULGFBQVMsVUFBVSxPQUFPLFdBQVk7QUFDcEMsV0FBSyxLQUFLLFNBQVMsSUFBSSxNQUFNO0FBQUE7QUFrQy9CLGFBQVMsVUFBVSxRQUFRLFNBQVUsT0FBTyxVQUFVLElBQUk7QUFDeEQsVUFBSSxRQUFRLEtBQUs7QUFDakIsVUFBSSxNQUFNO0FBRVYsVUFBSSxPQUFPLGFBQWEsWUFBWTtBQUNsQyxhQUFLO0FBQ0wsbUJBQVc7QUFBQTtBQUdiLFVBQUksUUFBTyxTQUFTO0FBQVEsbUJBQVc7QUFBQSxlQUFrQixDQUFDO0FBQVUsbUJBQVcsTUFBTTtBQUVyRixVQUFJLE9BQU8sT0FBTztBQUFZLGFBQUs7QUFFbkMsVUFBSSxNQUFNO0FBQU8sc0JBQWMsTUFBTTtBQUFBLGVBQWEsV0FBVyxNQUFNLE9BQU8sT0FBTyxLQUFLO0FBQ3BGLGNBQU07QUFDTixjQUFNLGNBQWMsTUFBTSxPQUFPLE9BQU8sVUFBVTtBQUFBO0FBR3BELGFBQU87QUFBQTtBQUdULGFBQVMsVUFBVSxPQUFPLFdBQVk7QUFDcEMsVUFBSSxRQUFRLEtBQUs7QUFFakIsWUFBTTtBQUFBO0FBR1IsYUFBUyxVQUFVLFNBQVMsV0FBWTtBQUN0QyxVQUFJLFFBQVEsS0FBSztBQUVqQixVQUFJLE1BQU0sUUFBUTtBQUNoQixjQUFNO0FBRU4sWUFBSSxDQUFDLE1BQU0sV0FBVyxDQUFDLE1BQU0sVUFBVSxDQUFDLE1BQU0sWUFBWSxDQUFDLE1BQU0sb0JBQW9CLE1BQU07QUFBaUIsc0JBQVksTUFBTTtBQUFBO0FBQUE7QUFJbEksYUFBUyxVQUFVLHFCQUFxQiw0QkFBNEIsVUFBVTtBQUU1RSxVQUFJLE9BQU8sYUFBYTtBQUFVLG1CQUFXLFNBQVM7QUFDdEQsVUFBSSxDQUFFLEVBQUMsT0FBTyxRQUFRLFNBQVMsU0FBUyxVQUFVLFVBQVUsUUFBUSxTQUFTLFdBQVcsWUFBWSxPQUFPLFFBQVMsWUFBVyxJQUFJLGlCQUFpQjtBQUFLLGNBQU0sSUFBSSxVQUFVLHVCQUF1QjtBQUNwTSxXQUFLLGVBQWUsa0JBQWtCO0FBQ3RDLGFBQU87QUFBQTtBQXFLVCxhQUFTLFVBQVUsU0FBUyxTQUFVLE9BQU8sVUFBVSxJQUFJO0FBQ3pELFNBQUcsSUFBSSxNQUFNO0FBQUE7QUFHZixhQUFTLFVBQVUsVUFBVTtBQUU3QixhQUFTLFVBQVUsTUFBTSxTQUFVLE9BQU8sVUFBVSxJQUFJO0FBQ3RELFVBQUksUUFBUSxLQUFLO0FBRWpCLFVBQUksT0FBTyxVQUFVLFlBQVk7QUFDL0IsYUFBSztBQUNMLGdCQUFRO0FBQ1IsbUJBQVc7QUFBQSxpQkFDRixPQUFPLGFBQWEsWUFBWTtBQUN6QyxhQUFLO0FBQ0wsbUJBQVc7QUFBQTtBQUdiLFVBQUksVUFBVSxRQUFRLFVBQVU7QUFBVyxhQUFLLE1BQU0sT0FBTztBQUc3RCxVQUFJLE1BQU0sUUFBUTtBQUNoQixjQUFNLFNBQVM7QUFDZixhQUFLO0FBQUE7QUFJUCxVQUFJLENBQUMsTUFBTSxVQUFVLENBQUMsTUFBTTtBQUFVLG9CQUFZLE1BQU0sT0FBTztBQUFBO0FBQUE7QUFBQTs7O0FDdFoxRCxnQkFBZ0IsVUFBUztBQUM5QixNQUFJLENBQUUsaUJBQWdCO0FBQVMsV0FBTyxJQUFJLE9BQU87QUFFakQsV0FBUyxLQUFLLE1BQU07QUFDcEIsV0FBUyxLQUFLLE1BQU07QUFFcEIsTUFBSSxZQUFXLFNBQVEsYUFBYTtBQUFPLFNBQUssV0FBVztBQUUzRCxNQUFJLFlBQVcsU0FBUSxhQUFhO0FBQU8sU0FBSyxXQUFXO0FBRTNELE9BQUssZ0JBQWdCO0FBQ3JCLE1BQUksWUFBVyxTQUFRLGtCQUFrQjtBQUFPLFNBQUssZ0JBQWdCO0FBRXJFLE9BQUssS0FBSyxPQUFPO0FBQUE7QUFJbkIsaUJBQWlCO0FBR2YsTUFBSSxLQUFLLGlCQUFpQixLQUFLLGVBQWU7QUFBTztBQUlyRCxXQUFTLFNBQVM7QUFBQTtBQUdwQixpQkFBaUIsT0FBTTtBQUNyQixRQUFLO0FBQUE7QUEzQ1AsSUFTSSxNQUVFLFFBREc7QUFWVDtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBLHFCQUFTLFFBQVE7QUFFakIsSUFBSSxPQUFPLE9BQU8sS0FBSyxTQUFTO0FBQ2hDLFNBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDaEMsZUFBUyxLQUFLO0FBQ2xCLFVBQUksQ0FBQyxPQUFPLFVBQVU7QUFBUyxlQUFPLFVBQVUsVUFBVSxTQUFTLFVBQVU7QUFBQTtBQUFBO0FBQUE7OztBQ3FDL0Usd0JBQXdCLFFBQVE7QUFDOUIsT0FBSyxpQkFBaUIsU0FBVSxJQUFJLE1BQU07QUFDeEMsV0FBTyxlQUFlLFFBQVEsSUFBSTtBQUFBO0FBR3BDLE9BQUssZ0JBQWdCO0FBQ3JCLE9BQUssZUFBZTtBQUNwQixPQUFLLFVBQVU7QUFDZixPQUFLLGFBQWE7QUFDbEIsT0FBSyxnQkFBZ0I7QUFBQTtBQUd2Qix3QkFBd0IsUUFBUSxJQUFJLE1BQU07QUFDeEMsTUFBSSxLQUFLLE9BQU87QUFDaEIsS0FBRyxlQUFlO0FBRWxCLE1BQUksS0FBSyxHQUFHO0FBRVosTUFBSSxDQUFDO0FBQUksV0FBTyxPQUFPLEtBQUssU0FBUyxJQUFJLE1BQU07QUFFL0MsS0FBRyxhQUFhO0FBQ2hCLEtBQUcsVUFBVTtBQUViLE1BQUksU0FBUyxRQUFRLFNBQVM7QUFBVyxXQUFPLEtBQUs7QUFFckQsS0FBRztBQUVILE1BQUksS0FBSyxPQUFPO0FBQ2hCLEtBQUcsVUFBVTtBQUNiLE1BQUksR0FBRyxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsZUFBZTtBQUNuRCxXQUFPLE1BQU0sR0FBRztBQUFBO0FBQUE7QUFJYixtQkFBbUIsVUFBUztBQUNqQyxNQUFJLENBQUUsaUJBQWdCO0FBQVksV0FBTyxJQUFJLFVBQVU7QUFFdkQsU0FBTyxLQUFLLE1BQU07QUFFbEIsT0FBSyxrQkFBa0IsSUFBSSxlQUFlO0FBRzFDLE1BQUksU0FBUztBQUdiLE9BQUssZUFBZSxlQUFlO0FBS25DLE9BQUssZUFBZSxPQUFPO0FBRTNCLE1BQUksVUFBUztBQUNYLFFBQUksT0FBTyxTQUFRLGNBQWM7QUFBWSxXQUFLLGFBQWEsU0FBUTtBQUV2RSxRQUFJLE9BQU8sU0FBUSxVQUFVO0FBQVksV0FBSyxTQUFTLFNBQVE7QUFBQTtBQUdqRSxPQUFLLEtBQUssYUFBYSxXQUFZO0FBQ2pDLFFBQUksT0FBTyxLQUFLLFdBQVc7QUFBWSxXQUFLLE9BQU8sU0FBVSxJQUFJO0FBQy9ELGFBQUssUUFBUTtBQUFBO0FBQUE7QUFDUCxXQUFLO0FBQUE7QUFBQTtBQWtEakIsY0FBYyxRQUFRLElBQUk7QUFDeEIsTUFBSTtBQUFJLFdBQU8sT0FBTyxLQUFLLFNBQVM7QUFJcEMsTUFBSSxLQUFLLE9BQU87QUFDaEIsTUFBSSxLQUFLLE9BQU87QUFFaEIsTUFBSSxHQUFHO0FBQVEsVUFBTSxJQUFJLE1BQU07QUFFL0IsTUFBSSxHQUFHO0FBQWMsVUFBTSxJQUFJLE1BQU07QUFFckMsU0FBTyxPQUFPLEtBQUs7QUFBQTtBQTVLckI7QUFBQTtBQUFBO0FBMkNBO0FBR0E7QUFDQSxxQkFBUyxXQUFXO0FBbUVwQixjQUFVLFVBQVUsT0FBTyxTQUFVLE9BQU8sVUFBVTtBQUNwRCxXQUFLLGdCQUFnQixnQkFBZ0I7QUFDckMsYUFBTyxPQUFPLFVBQVUsS0FBSyxLQUFLLE1BQU0sT0FBTztBQUFBO0FBYWpELGNBQVUsVUFBVSxhQUFhLFNBQVUsT0FBTyxVQUFVLElBQUk7QUFDOUQsWUFBTSxJQUFJLE1BQU07QUFBQTtBQUdsQixjQUFVLFVBQVUsU0FBUyxTQUFVLE9BQU8sVUFBVSxJQUFJO0FBQzFELFVBQUksS0FBSyxLQUFLO0FBQ2QsU0FBRyxVQUFVO0FBQ2IsU0FBRyxhQUFhO0FBQ2hCLFNBQUcsZ0JBQWdCO0FBQ25CLFVBQUksQ0FBQyxHQUFHLGNBQWM7QUFDcEIsWUFBSSxLQUFLLEtBQUs7QUFDZCxZQUFJLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsU0FBUyxHQUFHO0FBQWUsZUFBSyxNQUFNLEdBQUc7QUFBQTtBQUFBO0FBTzNGLGNBQVUsVUFBVSxRQUFRLFNBQVUsR0FBRztBQUN2QyxVQUFJLEtBQUssS0FBSztBQUVkLFVBQUksR0FBRyxlQUFlLFFBQVEsR0FBRyxXQUFXLENBQUMsR0FBRyxjQUFjO0FBQzVELFdBQUcsZUFBZTtBQUNsQixhQUFLLFdBQVcsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHO0FBQUEsYUFDL0M7QUFHTCxXQUFHLGdCQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUN0SmhCLHFCQUFxQixVQUFTO0FBQ25DLE1BQUksQ0FBRSxpQkFBZ0I7QUFBYyxXQUFPLElBQUksWUFBWTtBQUUzRCxZQUFVLEtBQUssTUFBTTtBQUFBO0FBVHZCO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQSxxQkFBUyxhQUFhO0FBUXRCLGdCQUFZLFVBQVUsYUFBYSxTQUFVLE9BQU8sVUFBVSxJQUFJO0FBQ2hFLFNBQUcsTUFBTTtBQUFBO0FBQUE7QUFBQTs7O0FDYlg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF3QkEsa0JBQWtCO0FBQ2hCLGlCQUFHLEtBQUs7QUFBQTtBQXpCVixJQWtCTztBQWxCUDtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFTLFFBQVE7QUFDakIsV0FBTyxXQUFXO0FBQ2xCLFdBQU8sV0FBVztBQUNsQixXQUFPLFNBQVM7QUFDaEIsV0FBTyxZQUFZO0FBQ25CLFdBQU8sY0FBYztBQUdyQixXQUFPLFNBQVM7QUFFaEIsSUFBTyxpQkFBUTtBQVVmLFdBQU8sVUFBVSxPQUFPLFNBQVMsTUFBTSxVQUFTO0FBQzlDLFVBQUksU0FBUztBQUViLHNCQUFnQixPQUFPO0FBQ3JCLFlBQUksS0FBSyxVQUFVO0FBQ2pCLGNBQUksQUFBVSxLQUFLLE1BQU0sV0FBckIsU0FBK0IsT0FBTyxPQUFPO0FBQy9DLG1CQUFPO0FBQUE7QUFBQTtBQUFBO0FBS2IsYUFBTyxHQUFHLFFBQVE7QUFFbEIseUJBQW1CO0FBQ2pCLFlBQUksT0FBTyxZQUFZLE9BQU8sUUFBUTtBQUNwQyxpQkFBTztBQUFBO0FBQUE7QUFJWCxXQUFLLEdBQUcsU0FBUztBQUlqQixVQUFJLENBQUMsS0FBSyxZQUFhLEVBQUMsWUFBVyxTQUFRLFFBQVEsUUFBUTtBQUN6RCxlQUFPLEdBQUcsT0FBTztBQUNqQixlQUFPLEdBQUcsU0FBUztBQUFBO0FBR3JCLFVBQUksV0FBVztBQUNmLHdCQUFpQjtBQUNmLFlBQUk7QUFBVTtBQUNkLG1CQUFXO0FBRVgsYUFBSztBQUFBO0FBSVAseUJBQW1CO0FBQ2pCLFlBQUk7QUFBVTtBQUNkLG1CQUFXO0FBRVgsWUFBSSxPQUFPLEtBQUssWUFBWTtBQUFZLGVBQUs7QUFBQTtBQUkvQyx1QkFBaUIsSUFBSTtBQUNuQjtBQUNBLFlBQUksZUFBRyxjQUFjLE1BQU0sYUFBYSxHQUFHO0FBQ3pDLGdCQUFNO0FBQUE7QUFBQTtBQUlWLGFBQU8sR0FBRyxTQUFTO0FBQ25CLFdBQUssR0FBRyxTQUFTO0FBR2pCLHlCQUFtQjtBQUNqQixlQUFPLGVBQWUsUUFBUTtBQUM5QixhQUFLLGVBQWUsU0FBUztBQUU3QixlQUFPLGVBQWUsT0FBTztBQUM3QixlQUFPLGVBQWUsU0FBUztBQUUvQixlQUFPLGVBQWUsU0FBUztBQUMvQixhQUFLLGVBQWUsU0FBUztBQUU3QixlQUFPLGVBQWUsT0FBTztBQUM3QixlQUFPLGVBQWUsU0FBUztBQUUvQixhQUFLLGVBQWUsU0FBUztBQUFBO0FBRy9CLGFBQU8sR0FBRyxPQUFPO0FBQ2pCLGFBQU8sR0FBRyxTQUFTO0FBRW5CLFdBQUssR0FBRyxTQUFTO0FBRWpCLFdBQUssS0FBSyxRQUFRO0FBR2xCLGFBQU87QUFBQTtBQUFBO0FBQUE7OztBQzVHVDtBQUFBO0FBQUE7QUFDQSxRQUFNLFdBQVc7QUFFakIsUUFBSSxZQUFZLFNBQVMsU0FBUztBQUM5QixhQUFPLFVBQVUsU0FBUztBQUMxQixlQUFTLEtBQUssVUFBVTtBQUNwQixlQUFPLFFBQVEsS0FBSyxTQUFTO0FBQUE7QUFBQSxlQUUxQixVQUFXO0FBQ2xCLGFBQU8sVUFBVTtBQUFBO0FBQUE7QUFBQTs7O0FDVHJCO0FBQUE7QUFBQTtBQVNBO0FBRUEsUUFBSSxNQUF1QztBQUN6QyxNQUFDLFlBQVc7QUFDZDtBQUVBLFlBQUksVUFBUTtBQUNaLFlBQUksVUFBVTtBQUNkLFlBQUksU0FBUztBQUdiLFlBQUksZUFBZTtBQUtuQix3Q0FBZ0MsTUFBTTtBQUNwQyxjQUFJLE1BQU0sMkRBQTJEO0FBRXJFLG1CQUFTLEtBQUksR0FBRyxLQUFJLFVBQVUsUUFBUSxNQUFLO0FBQ3pDLG1CQUFPLGFBQWEsbUJBQW1CLFVBQVU7QUFBQTtBQUduRCxpQkFBTywyQkFBMkIsT0FBTyxhQUFhLE1BQU07QUFBQTtBQUc5RCxZQUFJLHVCQUF1QixRQUFNO0FBT2pDLHNCQUFjLFNBQVE7QUFDcEI7QUFDRSxxQkFBUyxPQUFPLFVBQVUsUUFBUSxPQUFPLElBQUksTUFBTSxPQUFPLElBQUksT0FBTyxJQUFJLElBQUksT0FBTyxHQUFHLE9BQU8sTUFBTSxRQUFRO0FBQzFHLG1CQUFLLE9BQU8sS0FBSyxVQUFVO0FBQUE7QUFHN0IseUJBQWEsUUFBUSxTQUFRO0FBQUE7QUFBQTtBQUdqQyx1QkFBZSxTQUFRO0FBQ3JCO0FBQ0UscUJBQVMsUUFBUSxVQUFVLFFBQVEsT0FBTyxJQUFJLE1BQU0sUUFBUSxJQUFJLFFBQVEsSUFBSSxJQUFJLFFBQVEsR0FBRyxRQUFRLE9BQU8sU0FBUztBQUNqSCxtQkFBSyxRQUFRLEtBQUssVUFBVTtBQUFBO0FBRzlCLHlCQUFhLFNBQVMsU0FBUTtBQUFBO0FBQUE7QUFJbEMsOEJBQXNCLE9BQU8sU0FBUSxNQUFNO0FBR3pDO0FBQ0UsZ0JBQUksMEJBQXlCLHFCQUFxQjtBQUNsRCxnQkFBSSxRQUFRLHdCQUF1QjtBQUVuQyxnQkFBSSxVQUFVLElBQUk7QUFDaEIseUJBQVU7QUFDVixxQkFBTyxLQUFLLE9BQU8sQ0FBQztBQUFBO0FBR3RCLGdCQUFJLGlCQUFpQixLQUFLLElBQUksU0FBVSxNQUFNO0FBQzVDLHFCQUFPLEtBQUs7QUFBQTtBQUdkLDJCQUFlLFFBQVEsY0FBYztBQUlyQyxxQkFBUyxVQUFVLE1BQU0sS0FBSyxRQUFRLFFBQVEsU0FBUztBQUFBO0FBQUE7QUFTM0QsWUFBSSxxQkFBcUI7QUFDekIsWUFBSSxvQkFBb0I7QUFDeEIsWUFBSSxzQkFBc0I7QUFDMUIsWUFBSSx5QkFBeUI7QUFDN0IsWUFBSSxzQkFBc0I7QUFDMUIsWUFBSSxzQkFBc0I7QUFDMUIsWUFBSSxxQkFBcUI7QUFDekIsWUFBSSx5QkFBeUI7QUFDN0IsWUFBSSxzQkFBc0I7QUFDMUIsWUFBSSwyQkFBMkI7QUFDL0IsWUFBSSxrQkFBa0I7QUFDdEIsWUFBSSxrQkFBa0I7QUFDdEIsWUFBSSxtQkFBbUI7QUFDdkIsWUFBSSwwQkFBMEI7QUFDOUIsWUFBSSx5QkFBeUI7QUFDN0IsWUFBSSxtQkFBbUI7QUFDdkIsWUFBSSx1QkFBdUI7QUFDM0IsWUFBSSxnQ0FBZ0M7QUFDcEMsWUFBSSx1QkFBdUI7QUFDM0IsWUFBSSwyQkFBMkI7QUFFL0IsWUFBSSxPQUFPLFdBQVcsY0FBYyxPQUFPLEtBQUs7QUFDOUMsY0FBSSxZQUFZLE9BQU87QUFDdkIsK0JBQXFCLFVBQVU7QUFDL0IsOEJBQW9CLFVBQVU7QUFDOUIsZ0NBQXNCLFVBQVU7QUFDaEMsbUNBQXlCLFVBQVU7QUFDbkMsZ0NBQXNCLFVBQVU7QUFDaEMsZ0NBQXNCLFVBQVU7QUFDaEMsK0JBQXFCLFVBQVU7QUFDL0IsbUNBQXlCLFVBQVU7QUFDbkMsZ0NBQXNCLFVBQVU7QUFDaEMscUNBQTJCLFVBQVU7QUFDckMsNEJBQWtCLFVBQVU7QUFDNUIsNEJBQWtCLFVBQVU7QUFDNUIsNkJBQW1CLFVBQVU7QUFDN0Isb0NBQTBCLFVBQVU7QUFDcEMsbUNBQXlCLFVBQVU7QUFDbkMsNkJBQW1CLFVBQVU7QUFDN0IsaUNBQXVCLFVBQVU7QUFDakMsMENBQWdDLFVBQVU7QUFDMUMsaUNBQXVCLFVBQVU7QUFDakMscUNBQTJCLFVBQVU7QUFBQTtBQUd2QyxnQ0FBd0IsV0FBVyxXQUFXLGFBQWE7QUFDekQsY0FBSSxlQUFlLFVBQVUsZUFBZSxVQUFVLFFBQVE7QUFDOUQsaUJBQU8sVUFBVSxlQUFnQixrQkFBaUIsS0FBSyxjQUFjLE1BQU0sZUFBZSxNQUFNO0FBQUE7QUFHbEcsZ0NBQXdCLE1BQU07QUFDNUIsaUJBQU8sS0FBSyxlQUFlO0FBQUE7QUFHN0Isa0NBQTBCLE1BQU07QUFDOUIsY0FBSSxRQUFRLE1BQU07QUFFaEIsbUJBQU87QUFBQTtBQUdUO0FBQ0UsZ0JBQUksT0FBTyxLQUFLLFFBQVEsVUFBVTtBQUNoQyxvQkFBTTtBQUFBO0FBQUE7QUFJVixjQUFJLE9BQU8sU0FBUyxZQUFZO0FBQzlCLG1CQUFPLEtBQUssZUFBZSxLQUFLLFFBQVE7QUFBQTtBQUcxQyxjQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLG1CQUFPO0FBQUE7QUFHVCxrQkFBUTtBQUFBLGlCQUNEO0FBQ0gscUJBQU87QUFBQSxpQkFFSjtBQUNILHFCQUFPO0FBQUEsaUJBRUo7QUFDSCxxQkFBTztBQUFBLGlCQUVKO0FBQ0gscUJBQU87QUFBQSxpQkFFSjtBQUNILHFCQUFPO0FBQUEsaUJBRUo7QUFDSCxxQkFBTztBQUFBO0FBR1gsY0FBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixvQkFBUSxLQUFLO0FBQUEsbUJBQ047QUFDSCxvQkFBSSxVQUFVO0FBQ2QsdUJBQU8sZUFBZSxXQUFXO0FBQUEsbUJBRTlCO0FBQ0gsb0JBQUksV0FBVztBQUNmLHVCQUFPLGVBQWUsU0FBUyxZQUFZO0FBQUEsbUJBRXhDO0FBQ0gsdUJBQU8sZUFBZSxNQUFNLEtBQUssUUFBUTtBQUFBLG1CQUV0QztBQUNILHVCQUFPLGlCQUFpQixLQUFLO0FBQUEsbUJBRTFCO0FBQ0gsdUJBQU8saUJBQWlCLEtBQUs7QUFBQSxtQkFFMUIsaUJBQ0g7QUFDRSxvQkFBSSxnQkFBZ0I7QUFDcEIsb0JBQUksVUFBVSxjQUFjO0FBQzVCLG9CQUFJLFFBQU8sY0FBYztBQUV6QixvQkFBSTtBQUNGLHlCQUFPLGlCQUFpQixNQUFLO0FBQUEseUJBQ3RCLEdBQVA7QUFDQSx5QkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTWpCLGlCQUFPO0FBQUE7QUFLVCxZQUFJLCtCQUErQjtBQU1uQyxZQUFJLGdCQUFnQjtBQUNwQixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUk7QUFDSixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUk7QUFDSixZQUFJO0FBRUosK0JBQXVCO0FBQUE7QUFFdkIsb0JBQVkscUJBQXFCO0FBQ2pDLCtCQUF1QjtBQUNyQjtBQUNFLGdCQUFJLGtCQUFrQixHQUFHO0FBRXZCLHdCQUFVLFFBQVE7QUFDbEIseUJBQVcsUUFBUTtBQUNuQix5QkFBVyxRQUFRO0FBQ25CLDBCQUFZLFFBQVE7QUFDcEIsMEJBQVksUUFBUTtBQUNwQixtQ0FBcUIsUUFBUTtBQUM3Qiw2QkFBZSxRQUFRO0FBRXZCLGtCQUFJLFFBQVE7QUFBQSxnQkFDVixjQUFjO0FBQUEsZ0JBQ2QsWUFBWTtBQUFBLGdCQUNaLE9BQU87QUFBQSxnQkFDUCxVQUFVO0FBQUE7QUFHWixxQkFBTyxpQkFBaUIsU0FBUztBQUFBLGdCQUMvQixNQUFNO0FBQUEsZ0JBQ04sS0FBSztBQUFBLGdCQUNMLE1BQU07QUFBQSxnQkFDTixPQUFPO0FBQUEsZ0JBQ1AsT0FBTztBQUFBLGdCQUNQLGdCQUFnQjtBQUFBLGdCQUNoQixVQUFVO0FBQUE7QUFBQTtBQUtkO0FBQUE7QUFBQTtBQUdKLGdDQUF3QjtBQUN0QjtBQUNFO0FBRUEsZ0JBQUksa0JBQWtCLEdBQUc7QUFFdkIsa0JBQUksUUFBUTtBQUFBLGdCQUNWLGNBQWM7QUFBQSxnQkFDZCxZQUFZO0FBQUEsZ0JBQ1osVUFBVTtBQUFBO0FBR1oscUJBQU8saUJBQWlCLFNBQVM7QUFBQSxnQkFDL0IsS0FBSyxRQUFRLElBQUksT0FBTztBQUFBLGtCQUN0QixPQUFPO0FBQUE7QUFBQSxnQkFFVCxNQUFNLFFBQVEsSUFBSSxPQUFPO0FBQUEsa0JBQ3ZCLE9BQU87QUFBQTtBQUFBLGdCQUVULE1BQU0sUUFBUSxJQUFJLE9BQU87QUFBQSxrQkFDdkIsT0FBTztBQUFBO0FBQUEsZ0JBRVQsT0FBTyxRQUFRLElBQUksT0FBTztBQUFBLGtCQUN4QixPQUFPO0FBQUE7QUFBQSxnQkFFVCxPQUFPLFFBQVEsSUFBSSxPQUFPO0FBQUEsa0JBQ3hCLE9BQU87QUFBQTtBQUFBLGdCQUVULGdCQUFnQixRQUFRLElBQUksT0FBTztBQUFBLGtCQUNqQyxPQUFPO0FBQUE7QUFBQSxnQkFFVCxVQUFVLFFBQVEsSUFBSSxPQUFPO0FBQUEsa0JBQzNCLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFNYixnQkFBSSxnQkFBZ0IsR0FBRztBQUNyQixvQkFBTTtBQUFBO0FBQUE7QUFBQTtBQUtaLFlBQUkseUJBQXlCLHFCQUFxQjtBQUNsRCxZQUFJO0FBQ0osK0NBQXVDLE1BQU0sUUFBUSxTQUFTO0FBQzVEO0FBQ0UsZ0JBQUksV0FBVyxRQUFXO0FBRXhCLGtCQUFJO0FBQ0Ysc0JBQU07QUFBQSx1QkFDQyxHQUFQO0FBQ0Esb0JBQUksUUFBUSxFQUFFLE1BQU0sT0FBTyxNQUFNO0FBQ2pDLHlCQUFTLFNBQVMsTUFBTSxNQUFNO0FBQUE7QUFBQTtBQUtsQyxtQkFBTyxPQUFPLFNBQVM7QUFBQTtBQUFBO0FBRzNCLFlBQUksVUFBVTtBQUNkLFlBQUk7QUFFSjtBQUNFLGNBQUksa0JBQWtCLE9BQU8sWUFBWSxhQUFhLFVBQVU7QUFDaEUsZ0NBQXNCLElBQUk7QUFBQTtBQUc1Qiw4Q0FBc0MsSUFBSSxXQUFXO0FBRW5ELGNBQUksQ0FBQyxNQUFNLFNBQVM7QUFDbEIsbUJBQU87QUFBQTtBQUdUO0FBQ0UsZ0JBQUksUUFBUSxvQkFBb0IsSUFBSTtBQUVwQyxnQkFBSSxVQUFVLFFBQVc7QUFDdkIscUJBQU87QUFBQTtBQUFBO0FBSVgsY0FBSTtBQUNKLG9CQUFVO0FBQ1YsY0FBSSw0QkFBNEIsTUFBTTtBQUV0QyxnQkFBTSxvQkFBb0I7QUFDMUIsY0FBSTtBQUVKO0FBQ0UsaUNBQXFCLHVCQUF1QjtBQUc1QyxtQ0FBdUIsVUFBVTtBQUNqQztBQUFBO0FBR0YsY0FBSTtBQUVGLGdCQUFJLFdBQVc7QUFFYixrQkFBSSxPQUFPLFdBQVk7QUFDckIsc0JBQU07QUFBQTtBQUlSLHFCQUFPLGVBQWUsS0FBSyxXQUFXLFNBQVM7QUFBQSxnQkFDN0MsS0FBSyxXQUFZO0FBR2Ysd0JBQU07QUFBQTtBQUFBO0FBSVYsa0JBQUksT0FBTyxZQUFZLFlBQVksUUFBUSxXQUFXO0FBR3BELG9CQUFJO0FBQ0YsMEJBQVEsVUFBVSxNQUFNO0FBQUEseUJBQ2pCLEdBQVA7QUFDQSw0QkFBVTtBQUFBO0FBR1osd0JBQVEsVUFBVSxJQUFJLElBQUk7QUFBQSxxQkFDckI7QUFDTCxvQkFBSTtBQUNGLHVCQUFLO0FBQUEseUJBQ0UsR0FBUDtBQUNBLDRCQUFVO0FBQUE7QUFHWixtQkFBRyxLQUFLLEtBQUs7QUFBQTtBQUFBLG1CQUVWO0FBQ0wsa0JBQUk7QUFDRixzQkFBTTtBQUFBLHVCQUNDLEdBQVA7QUFDQSwwQkFBVTtBQUFBO0FBR1o7QUFBQTtBQUFBLG1CQUVLLFFBQVA7QUFFQSxnQkFBSSxVQUFVLFdBQVcsT0FBTyxPQUFPLFVBQVUsVUFBVTtBQUd6RCxrQkFBSSxjQUFjLE9BQU8sTUFBTSxNQUFNO0FBQ3JDLGtCQUFJLGVBQWUsUUFBUSxNQUFNLE1BQU07QUFDdkMsa0JBQUksSUFBSSxZQUFZLFNBQVM7QUFDN0Isa0JBQUksSUFBSSxhQUFhLFNBQVM7QUFFOUIscUJBQU8sS0FBSyxLQUFLLEtBQUssS0FBSyxZQUFZLE9BQU8sYUFBYSxJQUFJO0FBTzdEO0FBQUE7QUFHRixxQkFBTyxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSztBQUdqQyxvQkFBSSxZQUFZLE9BQU8sYUFBYSxJQUFJO0FBTXRDLHNCQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDdEIsdUJBQUc7QUFDRDtBQUNBO0FBR0EsMEJBQUksSUFBSSxLQUFLLFlBQVksT0FBTyxhQUFhLElBQUk7QUFFL0MsNEJBQUksU0FBUyxPQUFPLFlBQVksR0FBRyxRQUFRLFlBQVk7QUFFdkQ7QUFDRSw4QkFBSSxPQUFPLE9BQU8sWUFBWTtBQUM1QixnREFBb0IsSUFBSSxJQUFJO0FBQUE7QUFBQTtBQUtoQywrQkFBTztBQUFBO0FBQUEsNkJBRUYsS0FBSyxLQUFLLEtBQUs7QUFBQTtBQUcxQjtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUlOO0FBQ0Esc0JBQVU7QUFFVjtBQUNFLHFDQUF1QixVQUFVO0FBQ2pDO0FBQUE7QUFHRixrQkFBTSxvQkFBb0I7QUFBQTtBQUk1QixjQUFJLE9BQU8sS0FBSyxHQUFHLGVBQWUsR0FBRyxPQUFPO0FBQzVDLGNBQUksaUJBQWlCLE9BQU8sOEJBQThCLFFBQVE7QUFFbEU7QUFDRSxnQkFBSSxPQUFPLE9BQU8sWUFBWTtBQUM1QixrQ0FBb0IsSUFBSSxJQUFJO0FBQUE7QUFBQTtBQUloQyxpQkFBTztBQUFBO0FBRVQsZ0RBQXdDLElBQUksUUFBUSxTQUFTO0FBQzNEO0FBQ0UsbUJBQU8sNkJBQTZCLElBQUk7QUFBQTtBQUFBO0FBSTVDLGlDQUF5QixXQUFXO0FBQ2xDLGNBQUksWUFBWSxVQUFVO0FBQzFCLGlCQUFPLENBQUMsQ0FBRSxjQUFhLFVBQVU7QUFBQTtBQUduQyxzREFBOEMsTUFBTSxRQUFRLFNBQVM7QUFFbkUsY0FBSSxRQUFRLE1BQU07QUFDaEIsbUJBQU87QUFBQTtBQUdULGNBQUksT0FBTyxTQUFTLFlBQVk7QUFDOUI7QUFDRSxxQkFBTyw2QkFBNkIsTUFBTSxnQkFBZ0I7QUFBQTtBQUFBO0FBSTlELGNBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsbUJBQU8sOEJBQThCO0FBQUE7QUFHdkMsa0JBQVE7QUFBQSxpQkFDRDtBQUNILHFCQUFPLDhCQUE4QjtBQUFBLGlCQUVsQztBQUNILHFCQUFPLDhCQUE4QjtBQUFBO0FBR3pDLGNBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsb0JBQVEsS0FBSztBQUFBLG1CQUNOO0FBQ0gsdUJBQU8sK0JBQStCLEtBQUs7QUFBQSxtQkFFeEM7QUFFSCx1QkFBTyxxQ0FBcUMsS0FBSyxNQUFNLFFBQVE7QUFBQSxtQkFFNUQ7QUFDSCx1QkFBTywrQkFBK0IsS0FBSztBQUFBLG1CQUV4QyxpQkFDSDtBQUNFLG9CQUFJLGdCQUFnQjtBQUNwQixvQkFBSSxVQUFVLGNBQWM7QUFDNUIsb0JBQUksUUFBTyxjQUFjO0FBRXpCLG9CQUFJO0FBRUYseUJBQU8scUNBQXFDLE1BQUssVUFBVSxRQUFRO0FBQUEseUJBQzVELEdBQVA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtWLGlCQUFPO0FBQUE7QUFHVCxZQUFJLHFCQUFxQjtBQUN6QixZQUFJLHlCQUF5QixxQkFBcUI7QUFFbEQsK0NBQXVDLFNBQVM7QUFDOUM7QUFDRSxnQkFBSSxTQUFTO0FBQ1gsa0JBQUksUUFBUSxRQUFRO0FBQ3BCLGtCQUFJLFFBQVEscUNBQXFDLFFBQVEsTUFBTSxRQUFRLFNBQVMsUUFBUSxNQUFNLE9BQU87QUFDckcscUNBQXVCLG1CQUFtQjtBQUFBLG1CQUNyQztBQUNMLHFDQUF1QixtQkFBbUI7QUFBQTtBQUFBO0FBQUE7QUFLaEQsZ0NBQXdCLFdBQVcsUUFBUSxVQUFVLGVBQWUsU0FBUztBQUMzRTtBQUVFLGdCQUFJLE1BQU0sU0FBUyxLQUFLLEtBQUssT0FBTyxVQUFVO0FBRTlDLHFCQUFTLGdCQUFnQixXQUFXO0FBQ2xDLGtCQUFJLElBQUksV0FBVyxlQUFlO0FBQ2hDLG9CQUFJLFVBQVU7QUFJZCxvQkFBSTtBQUdGLHNCQUFJLE9BQU8sVUFBVSxrQkFBa0IsWUFBWTtBQUNqRCx3QkFBSSxNQUFNLE1BQU8sa0JBQWlCLGlCQUFpQixPQUFPLFdBQVcsWUFBWSxlQUFlLCtGQUFvRyxPQUFPLFVBQVUsZ0JBQWdCO0FBQ3JPLHdCQUFJLE9BQU87QUFDWCwwQkFBTTtBQUFBO0FBR1IsNEJBQVUsVUFBVSxjQUFjLFFBQVEsY0FBYyxlQUFlLFVBQVUsTUFBTTtBQUFBLHlCQUNoRixJQUFQO0FBQ0EsNEJBQVU7QUFBQTtBQUdaLG9CQUFJLFdBQVcsQ0FBRSxvQkFBbUIsUUFBUTtBQUMxQyxnREFBOEI7QUFFOUIsd0JBQU0sNFJBQXFULGlCQUFpQixlQUFlLFVBQVUsY0FBYyxPQUFPO0FBRTFYLGdEQUE4QjtBQUFBO0FBR2hDLG9CQUFJLG1CQUFtQixTQUFTLENBQUUsU0FBUSxXQUFXLHFCQUFxQjtBQUd4RSxxQ0FBbUIsUUFBUSxXQUFXO0FBQ3RDLGdEQUE4QjtBQUU5Qix3QkFBTSxzQkFBc0IsVUFBVSxRQUFRO0FBRTlDLGdEQUE4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPeEMsWUFBSTtBQUVKO0FBQ0UsOENBQW9DLElBQUk7QUFBQTtBQUcxQyxZQUFJLGNBQWM7QUFFbEI7QUFDRSxpQkFBTyxPQUFPO0FBQUE7QUFHaEIsNkJBQXFCLE1BQU0sU0FBUztBQUNsQyxjQUFJLGVBQWUsS0FBSztBQUV4QixjQUFJLENBQUMsY0FBYztBQUNqQixtQkFBTztBQUFBO0FBR1QsY0FBSSxnQkFBZ0I7QUFFcEIsbUJBQVMsZUFBZSxjQUFjO0FBQ3BDLDBCQUFjLGVBQWUsUUFBUTtBQUFBO0FBR3ZDLGlCQUFPO0FBQUE7QUFHVCxtQ0FBMkIsV0FBVyxRQUFRLFVBQVU7QUFDdEQ7QUFDRSwyQkFBZSxXQUFXLFFBQVEsVUFBVTtBQUFBO0FBQUE7QUFJaEQsdUNBQStCLFNBQVMsVUFBVTtBQUtoRCxtQkFBUyxLQUFJLFFBQVEsZUFBZSxHQUFHLE1BQUssVUFBVSxNQUFLO0FBSXpELG9CQUFRLE1BQUssUUFBUTtBQUNyQixvQkFBUSxlQUFlLEtBQUk7QUFBQTtBQUFBO0FBRy9CLGdDQUF3QixNQUFNLFNBQVMsVUFBVSxTQUFTO0FBQ3hELGNBQUksU0FBUztBQUNYLGdCQUFJLGNBQWMsS0FBSztBQUV2QjtBQUNFLGtCQUFJLGlCQUFpQixNQUFNO0FBQ3pCLG9CQUFJLFVBQ0osZ0JBQWdCLFFBQVEsZ0JBQWdCLFVBQWEsWUFBWSxhQUFhLHNCQUFzQixZQUFZLGFBQWE7QUFFN0gsb0JBQUksQ0FBQyxXQUFXLENBQUMsa0NBQWtDLElBQUksT0FBTztBQUM1RCxvREFBa0MsSUFBSTtBQUN0QyxzQkFBSSxXQUFXO0FBRWYsc0JBQUksZ0JBQWdCLFFBQVc7QUFDN0IsK0JBQVc7QUFBQSw2QkFDRixPQUFPLGdCQUFnQixVQUFVO0FBQzFDLCtCQUFXLDhCQUE4QixPQUFPLGNBQWM7QUFBQSw2QkFDckQsWUFBWSxhQUFhLHFCQUFxQjtBQUN2RCwrQkFBVztBQUFBLDZCQUNGLFlBQVksYUFBYSxRQUFXO0FBRTdDLCtCQUFXO0FBQUEseUJBQ047QUFDTCwrQkFBVyxpREFBaUQsT0FBTyxLQUFLLGFBQWEsS0FBSyxRQUFRO0FBQUE7QUFHcEcsd0JBQU0sMEhBQStILGlCQUFpQixTQUFTLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFLbEwsZ0JBQUksT0FBTyxnQkFBZ0IsWUFBWSxnQkFBZ0IsTUFBTTtBQUMzRCxvQ0FBc0IsYUFBYTtBQUNuQyxxQkFBTyxZQUFZO0FBQUE7QUFHckI7QUFDRSxrQkFBSSxnQkFBZ0IsWUFBWSxNQUFNO0FBRXRDO0FBQ0Usb0JBQUksS0FBSyxjQUFjO0FBQ3JCLG9DQUFrQixLQUFLLGNBQWMsZUFBZTtBQUFBO0FBQUE7QUFJeEQscUJBQU87QUFBQTtBQUFBLGlCQUVKO0FBQ0w7QUFDRSxrQkFBSSxpQkFBaUIsWUFBWSxNQUFNO0FBRXZDO0FBQ0Usb0JBQUksS0FBSyxjQUFjO0FBQ3JCLG9DQUFrQixLQUFLLGNBQWMsZ0JBQWdCO0FBQUE7QUFBQTtBQUl6RCxxQkFBTztBQUFBO0FBQUE7QUFBQTtBQUtiLFlBQUkseUJBQXlCLElBQUksWUFBWTtBQUU3QyxpQkFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLEtBQUs7QUFDM0IsaUNBQXVCLEtBQUssSUFBSTtBQUFBO0FBR2xDLCtCQUF1QixNQUFNO0FBRTdCLHlEQUFpRDtBQUMvQyxjQUFJLFdBQVc7QUFDZixjQUFJLFVBQVUsU0FBUztBQUN2QixjQUFJLFVBQVUsVUFBVTtBQUV4QixjQUFJLENBQUUsWUFBVyxRQUFVO0FBQ3pCO0FBQ0Usb0JBQU0sTUFBTztBQUFBO0FBQUE7QUFJakIsY0FBSSxXQUFXLElBQUksWUFBWTtBQUMvQixtQkFBUyxJQUFJO0FBQ2IsbUNBQXlCO0FBQ3pCLGlDQUF1QixLQUFLLFVBQVU7QUFFdEMsbUJBQVMsS0FBSyxTQUFTLEtBQUssVUFBVSxHQUFHLE1BQU07QUFDN0MsbUNBQXVCLE1BQU0sS0FBSztBQUFBO0FBR3BDLGlDQUF1QixVQUFVLEtBQUs7QUFDdEMsaUJBQU87QUFBQTtBQUdULGlDQUF5QjtBQUN2QixjQUFJLFNBQVMsdUJBQXVCO0FBRXBDLGNBQUksV0FBVyxHQUFHO0FBQ2hCLG1CQUFPO0FBQUE7QUFHVCxpQ0FBdUIsS0FBSyx1QkFBdUI7QUFDbkQsaUJBQU87QUFBQTtBQUVULDhCQUFzQixJQUFJO0FBQ3hCLGlDQUF1QixNQUFNLHVCQUF1QjtBQUNwRCxpQ0FBdUIsS0FBSztBQUFBO0FBSzlCLFlBQUksV0FBVztBQUdmLFlBQUksU0FBUztBQUtiLFlBQUksb0JBQW9CO0FBSXhCLFlBQUksVUFBVTtBQUtkLFlBQUkscUJBQXFCO0FBR3pCLFlBQUksVUFBVTtBQUdkLFlBQUksbUJBQW1CO0FBR3ZCLFlBQUksNEJBQTRCO0FBR2hDLFlBQUksc0JBQXNCLDRCQUE0QjtBQUN0RCxZQUFJLHNCQUFzQjtBQUMxQixZQUFJLDZCQUE2QixJQUFJLE9BQU8sT0FBTyw0QkFBNEIsT0FBTyxzQkFBc0I7QUFDNUcsWUFBSSxrQkFBaUIsT0FBTyxVQUFVO0FBQ3RDLFlBQUksNEJBQTRCO0FBQ2hDLFlBQUksOEJBQThCO0FBQ2xDLHFDQUE2QixlQUFlO0FBQzFDLGNBQUksZ0JBQWUsS0FBSyw2QkFBNkIsZ0JBQWdCO0FBQ25FLG1CQUFPO0FBQUE7QUFHVCxjQUFJLGdCQUFlLEtBQUssMkJBQTJCLGdCQUFnQjtBQUNqRSxtQkFBTztBQUFBO0FBR1QsY0FBSSwyQkFBMkIsS0FBSyxnQkFBZ0I7QUFDbEQsd0NBQTRCLGlCQUFpQjtBQUM3QyxtQkFBTztBQUFBO0FBR1Qsb0NBQTBCLGlCQUFpQjtBQUUzQztBQUNFLGtCQUFNLGdDQUFnQztBQUFBO0FBR3hDLGlCQUFPO0FBQUE7QUFFVCx1Q0FBK0IsTUFBTSxjQUFjLHNCQUFzQjtBQUN2RSxjQUFJLGlCQUFpQixNQUFNO0FBQ3pCLG1CQUFPLGFBQWEsU0FBUztBQUFBO0FBRy9CLGNBQUksc0JBQXNCO0FBQ3hCLG1CQUFPO0FBQUE7QUFHVCxjQUFJLEtBQUssU0FBUyxLQUFNLE1BQUssT0FBTyxPQUFPLEtBQUssT0FBTyxRQUFTLE1BQUssT0FBTyxPQUFPLEtBQUssT0FBTyxNQUFNO0FBQ25HLG1CQUFPO0FBQUE7QUFHVCxpQkFBTztBQUFBO0FBRVQsa0RBQTBDLE1BQU0sT0FBTyxjQUFjLHNCQUFzQjtBQUN6RixjQUFJLGlCQUFpQixRQUFRLGFBQWEsU0FBUyxVQUFVO0FBQzNELG1CQUFPO0FBQUE7QUFHVCxrQkFBUSxPQUFPO0FBQUEsaUJBQ1I7QUFBQSxpQkFFQTtBQUVILHFCQUFPO0FBQUEsaUJBRUosV0FDSDtBQUNFLGtCQUFJLHNCQUFzQjtBQUN4Qix1QkFBTztBQUFBO0FBR1Qsa0JBQUksaUJBQWlCLE1BQU07QUFDekIsdUJBQU8sQ0FBQyxhQUFhO0FBQUEscUJBQ2hCO0FBQ0wsb0JBQUksVUFBUyxLQUFLLGNBQWMsTUFBTSxHQUFHO0FBQ3pDLHVCQUFPLFlBQVcsV0FBVyxZQUFXO0FBQUE7QUFBQTtBQUFBO0FBSzVDLHFCQUFPO0FBQUE7QUFBQTtBQUdiLHVDQUErQixNQUFNLE9BQU8sY0FBYyxzQkFBc0I7QUFDOUUsY0FBSSxVQUFVLFFBQVEsT0FBTyxVQUFVLGFBQWE7QUFDbEQsbUJBQU87QUFBQTtBQUdULGNBQUksaUNBQWlDLE1BQU0sT0FBTyxjQUFjLHVCQUF1QjtBQUNyRixtQkFBTztBQUFBO0FBR1QsY0FBSSxzQkFBc0I7QUFDeEIsbUJBQU87QUFBQTtBQUdULGNBQUksaUJBQWlCLE1BQU07QUFFekIsb0JBQVEsYUFBYTtBQUFBLG1CQUNkO0FBQ0gsdUJBQU8sQ0FBQztBQUFBLG1CQUVMO0FBQ0gsdUJBQU8sVUFBVTtBQUFBLG1CQUVkO0FBQ0gsdUJBQU8sTUFBTTtBQUFBLG1CQUVWO0FBQ0gsdUJBQU8sTUFBTSxVQUFVLFFBQVE7QUFBQTtBQUFBO0FBSXJDLGlCQUFPO0FBQUE7QUFFVCxpQ0FBeUIsTUFBTTtBQUM3QixpQkFBTyxXQUFXLGVBQWUsUUFBUSxXQUFXLFFBQVE7QUFBQTtBQUc5RCxvQ0FBNEIsTUFBTSxNQUFNLGlCQUFpQixlQUFlLG9CQUFvQixjQUFhLG1CQUFtQjtBQUMxSCxlQUFLLGtCQUFrQixTQUFTLHFCQUFxQixTQUFTLFdBQVcsU0FBUztBQUNsRixlQUFLLGdCQUFnQjtBQUNyQixlQUFLLHFCQUFxQjtBQUMxQixlQUFLLGtCQUFrQjtBQUN2QixlQUFLLGVBQWU7QUFDcEIsZUFBSyxPQUFPO0FBQ1osZUFBSyxjQUFjO0FBQ25CLGVBQUssb0JBQW9CO0FBQUE7QUFNM0IsWUFBSSxhQUFhO0FBRWpCLFlBQUksZ0JBQWdCO0FBQUEsVUFBQztBQUFBLFVBQVk7QUFBQSxVQUdqQztBQUFBLFVBQWdCO0FBQUEsVUFBa0I7QUFBQSxVQUFhO0FBQUEsVUFBa0M7QUFBQSxVQUE0QjtBQUFBO0FBQzdHLHNCQUFjLFFBQVEsU0FBVSxNQUFNO0FBQ3BDLHFCQUFXLFFBQVEsSUFBSSxtQkFBbUIsTUFBTSxVQUFVLE9BQzFELE1BQ0EsTUFDQSxPQUNBO0FBQUE7QUFJRixTQUFDLENBQUMsaUJBQWlCLG1CQUFtQixDQUFDLGFBQWEsVUFBVSxDQUFDLFdBQVcsUUFBUSxDQUFDLGFBQWEsZUFBZSxRQUFRLFNBQVUsTUFBTTtBQUNySSxjQUFJLE9BQU8sS0FBSyxJQUNaLGdCQUFnQixLQUFLO0FBQ3pCLHFCQUFXLFFBQVEsSUFBSSxtQkFBbUIsTUFBTSxRQUFRLE9BQ3hELGVBQ0EsTUFDQSxPQUNBO0FBQUE7QUFLRixTQUFDLG1CQUFtQixhQUFhLGNBQWMsU0FBUyxRQUFRLFNBQVUsTUFBTTtBQUM5RSxxQkFBVyxRQUFRLElBQUksbUJBQW1CLE1BQU0sbUJBQW1CLE9BQ25FLEtBQUssZUFDTCxNQUNBLE9BQ0E7QUFBQTtBQU1GLFNBQUMsZUFBZSw2QkFBNkIsYUFBYSxpQkFBaUIsUUFBUSxTQUFVLE1BQU07QUFDakcscUJBQVcsUUFBUSxJQUFJLG1CQUFtQixNQUFNLG1CQUFtQixPQUNuRSxNQUNBLE1BQ0EsT0FDQTtBQUFBO0FBR0Y7QUFBQSxVQUFDO0FBQUEsVUFBbUI7QUFBQSxVQUVwQjtBQUFBLFVBQWE7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVc7QUFBQSxVQUFTO0FBQUEsVUFBWTtBQUFBLFVBQTJCO0FBQUEsVUFBeUI7QUFBQSxVQUFrQjtBQUFBLFVBQVU7QUFBQSxVQUFRO0FBQUEsVUFBWTtBQUFBLFVBQWM7QUFBQSxVQUFRO0FBQUEsVUFBZTtBQUFBLFVBQVk7QUFBQSxVQUFZO0FBQUEsVUFBWTtBQUFBLFVBQVU7QUFBQSxVQUM1UDtBQUFBLFVBQWEsUUFBUSxTQUFVLE1BQU07QUFDbkMscUJBQVcsUUFBUSxJQUFJLG1CQUFtQixNQUFNLFNBQVMsT0FDekQsS0FBSyxlQUNMLE1BQ0EsT0FDQTtBQUFBO0FBSUY7QUFBQSxVQUFDO0FBQUEsVUFFRDtBQUFBLFVBQVk7QUFBQSxVQUFTO0FBQUEsVUFHbkIsUUFBUSxTQUFVLE1BQU07QUFDeEIscUJBQVcsUUFBUSxJQUFJLG1CQUFtQixNQUFNLFNBQVMsTUFDekQsTUFDQSxNQUNBLE9BQ0E7QUFBQTtBQUlGO0FBQUEsVUFBQztBQUFBLFVBQVc7QUFBQSxVQUdWLFFBQVEsU0FBVSxNQUFNO0FBQ3hCLHFCQUFXLFFBQVEsSUFBSSxtQkFBbUIsTUFBTSxvQkFBb0IsT0FDcEUsTUFDQSxNQUNBLE9BQ0E7QUFBQTtBQUdGO0FBQUEsVUFBQztBQUFBLFVBQVE7QUFBQSxVQUFRO0FBQUEsVUFBUTtBQUFBLFVBR3ZCLFFBQVEsU0FBVSxNQUFNO0FBQ3hCLHFCQUFXLFFBQVEsSUFBSSxtQkFBbUIsTUFBTSxrQkFBa0IsT0FDbEUsTUFDQSxNQUNBLE9BQ0E7QUFBQTtBQUdGLFNBQUMsV0FBVyxTQUFTLFFBQVEsU0FBVSxNQUFNO0FBQzNDLHFCQUFXLFFBQVEsSUFBSSxtQkFBbUIsTUFBTSxTQUFTLE9BQ3pELEtBQUssZUFDTCxNQUNBLE9BQ0E7QUFBQTtBQUVGLFlBQUksV0FBVztBQUVmLFlBQUksYUFBYSxTQUFVLE9BQU87QUFDaEMsaUJBQU8sTUFBTSxHQUFHO0FBQUE7QUFRbEI7QUFBQSxVQUFDO0FBQUEsVUFBaUI7QUFBQSxVQUFzQjtBQUFBLFVBQWU7QUFBQSxVQUFrQjtBQUFBLFVBQWM7QUFBQSxVQUFhO0FBQUEsVUFBYTtBQUFBLFVBQXVCO0FBQUEsVUFBK0I7QUFBQSxVQUFpQjtBQUFBLFVBQW1CO0FBQUEsVUFBcUI7QUFBQSxVQUFxQjtBQUFBLFVBQWdCO0FBQUEsVUFBYTtBQUFBLFVBQWU7QUFBQSxVQUFpQjtBQUFBLFVBQWU7QUFBQSxVQUFhO0FBQUEsVUFBb0I7QUFBQSxVQUFnQjtBQUFBLFVBQWM7QUFBQSxVQUFnQjtBQUFBLFVBQWU7QUFBQSxVQUFjO0FBQUEsVUFBZ0M7QUFBQSxVQUE4QjtBQUFBLFVBQWU7QUFBQSxVQUFrQjtBQUFBLFVBQW1CO0FBQUEsVUFBa0I7QUFBQSxVQUFrQjtBQUFBLFVBQWM7QUFBQSxVQUFjO0FBQUEsVUFBZ0I7QUFBQSxVQUFxQjtBQUFBLFVBQXNCO0FBQUEsVUFBZTtBQUFBLFVBQVk7QUFBQSxVQUFrQjtBQUFBLFVBQW9CO0FBQUEsVUFBbUI7QUFBQSxVQUFjO0FBQUEsVUFBZ0I7QUFBQSxVQUEwQjtBQUFBLFVBQTJCO0FBQUEsVUFBb0I7QUFBQSxVQUFxQjtBQUFBLFVBQWtCO0FBQUEsVUFBbUI7QUFBQSxVQUFxQjtBQUFBLFVBQWtCO0FBQUEsVUFBZ0I7QUFBQSxVQUFlO0FBQUEsVUFBbUI7QUFBQSxVQUFrQjtBQUFBLFVBQXNCO0FBQUEsVUFBdUI7QUFBQSxVQUFnQjtBQUFBLFVBQWlCO0FBQUEsVUFBZ0I7QUFBQSxVQUFnQjtBQUFBLFVBQWE7QUFBQSxVQUFpQjtBQUFBLFVBQWtCO0FBQUEsVUFBaUI7QUFBQSxVQUFjO0FBQUEsVUFBaUI7QUFBQSxVQUFpQjtBQUFBLFVBQWdCO0FBQUEsVUFBZ0I7QUFBQSxVQUFlO0FBQUEsVUFHdHdDLFFBQVEsU0FBVSxlQUFlO0FBQ2pDLGNBQUksT0FBTyxjQUFjLFFBQVEsVUFBVTtBQUMzQyxxQkFBVyxRQUFRLElBQUksbUJBQW1CLE1BQU0sUUFBUSxPQUN4RCxlQUFlLE1BQ2YsT0FDQTtBQUFBO0FBR0Y7QUFBQSxVQUFDO0FBQUEsVUFBaUI7QUFBQSxVQUFpQjtBQUFBLFVBQWM7QUFBQSxVQUFjO0FBQUEsVUFBZTtBQUFBLFVBRzVFLFFBQVEsU0FBVSxlQUFlO0FBQ2pDLGNBQUksT0FBTyxjQUFjLFFBQVEsVUFBVTtBQUMzQyxxQkFBVyxRQUFRLElBQUksbUJBQW1CLE1BQU0sUUFBUSxPQUN4RCxlQUFlLGdDQUFnQyxPQUMvQztBQUFBO0FBR0Y7QUFBQSxVQUFDO0FBQUEsVUFBWTtBQUFBLFVBQVk7QUFBQSxVQUd2QixRQUFRLFNBQVUsZUFBZTtBQUNqQyxjQUFJLE9BQU8sY0FBYyxRQUFRLFVBQVU7QUFDM0MscUJBQVcsUUFBUSxJQUFJLG1CQUFtQixNQUFNLFFBQVEsT0FDeEQsZUFBZSx3Q0FBd0MsT0FDdkQ7QUFBQTtBQUtGLFNBQUMsWUFBWSxlQUFlLFFBQVEsU0FBVSxlQUFlO0FBQzNELHFCQUFXLGlCQUFpQixJQUFJLG1CQUFtQixlQUFlLFFBQVEsT0FDMUUsY0FBYyxlQUNkLE1BQ0EsT0FDQTtBQUFBO0FBSUYsWUFBSSxZQUFZO0FBQ2hCLG1CQUFXLGFBQWEsSUFBSSxtQkFBbUIsYUFBYSxRQUFRLE9BQ3BFLGNBQWMsZ0NBQWdDLE1BQzlDO0FBQ0EsU0FBQyxPQUFPLFFBQVEsVUFBVSxjQUFjLFFBQVEsU0FBVSxlQUFlO0FBQ3ZFLHFCQUFXLGlCQUFpQixJQUFJLG1CQUFtQixlQUFlLFFBQVEsT0FDMUUsY0FBYyxlQUNkLE1BQ0EsTUFDQTtBQUFBO0FBYUYsWUFBSSx1QkFBdUI7QUFDM0IsWUFBSSxVQUFVO0FBRWQsNkJBQXFCLEtBQUs7QUFDeEI7QUFDRSxnQkFBSSxDQUFDLFdBQVcscUJBQXFCLEtBQUssTUFBTTtBQUM5Qyx3QkFBVTtBQUVWLG9CQUFNLDhOQUF3TyxLQUFLLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFXblEsWUFBSSxrQkFBa0I7QUFTdEIsNEJBQW9CLFFBQVE7QUFDMUIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLFFBQVEsZ0JBQWdCLEtBQUs7QUFFakMsY0FBSSxDQUFDLE9BQU87QUFDVixtQkFBTztBQUFBO0FBR1QsY0FBSTtBQUNKLGNBQUksT0FBTztBQUNYLGNBQUk7QUFDSixjQUFJLFlBQVk7QUFFaEIsZUFBSyxRQUFRLE1BQU0sT0FBTyxRQUFRLElBQUksUUFBUSxTQUFTO0FBQ3JELG9CQUFRLElBQUksV0FBVztBQUFBLG1CQUNoQjtBQUVILDBCQUFTO0FBQ1Q7QUFBQSxtQkFFRztBQUVILDBCQUFTO0FBQ1Q7QUFBQSxtQkFFRztBQUVILDBCQUFTO0FBRVQ7QUFBQSxtQkFFRztBQUVILDBCQUFTO0FBQ1Q7QUFBQSxtQkFFRztBQUVILDBCQUFTO0FBQ1Q7QUFBQTtBQUdBO0FBQUE7QUFHSixnQkFBSSxjQUFjLE9BQU87QUFDdkIsc0JBQVEsSUFBSSxVQUFVLFdBQVc7QUFBQTtBQUduQyx3QkFBWSxRQUFRO0FBQ3BCLG9CQUFRO0FBQUE7QUFHVixpQkFBTyxjQUFjLFFBQVEsT0FBTyxJQUFJLFVBQVUsV0FBVyxTQUFTO0FBQUE7QUFXeEUsc0NBQThCLE1BQU07QUFDbEMsY0FBSSxPQUFPLFNBQVMsYUFBYSxPQUFPLFNBQVMsVUFBVTtBQUl6RCxtQkFBTyxLQUFLO0FBQUE7QUFHZCxpQkFBTyxXQUFXO0FBQUE7QUFVcEIsK0NBQXVDLE9BQU87QUFDNUMsaUJBQU8sTUFBTSxxQkFBcUIsU0FBUztBQUFBO0FBRzdDLHVDQUErQjtBQUM3QixpQkFBTyxzQkFBc0I7QUFBQTtBQVUvQix5Q0FBaUMsTUFBTSxPQUFPO0FBQzVDLGNBQUksZUFBZSxnQkFBZ0I7QUFFbkMsY0FBSSxTQUFTLFdBQVcsc0JBQXNCLE1BQU0sY0FBYyxRQUFRO0FBQ3hFLG1CQUFPO0FBQUE7QUFHVCxjQUFJLHNCQUFzQixNQUFNLE9BQU8sY0FBYyxRQUFRO0FBQzNELG1CQUFPO0FBQUE7QUFHVCxjQUFJLGlCQUFpQixNQUFNO0FBQ3pCLGdCQUFJLGdCQUFnQixhQUFhO0FBQ2pDLGdCQUFJLE9BQU8sYUFBYTtBQUV4QixnQkFBSSxTQUFTLFdBQVcsU0FBUyxzQkFBc0IsVUFBVSxNQUFNO0FBQ3JFLHFCQUFPLGdCQUFnQjtBQUFBLG1CQUNsQjtBQUNMLGtCQUFJLGFBQWEsYUFBYTtBQUM1Qix3QkFBUSxLQUFLO0FBQ2IsNEJBQVk7QUFBQTtBQUdkLHFCQUFPLGdCQUFnQixNQUFNLDhCQUE4QjtBQUFBO0FBQUEscUJBRXBELG9CQUFvQixPQUFPO0FBQ3BDLG1CQUFPLE9BQU8sTUFBTSw4QkFBOEI7QUFBQTtBQUdwRCxpQkFBTztBQUFBO0FBVVQsZ0RBQXdDLE1BQU0sT0FBTztBQUNuRCxjQUFJLENBQUMsb0JBQW9CLFNBQVMsU0FBUyxNQUFNO0FBQy9DLG1CQUFPO0FBQUE7QUFHVCxpQkFBTyxPQUFPLE1BQU0sOEJBQThCO0FBQUE7QUFPcEQsb0JBQVksR0FBRyxHQUFHO0FBQ2hCLGlCQUFPLE1BQU0sS0FBTSxPQUFNLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxNQUFNLEtBQUssTUFBTTtBQUFBO0FBSXJFLFlBQUksV0FBVyxPQUFPLE9BQU8sT0FBTyxhQUFhLE9BQU8sS0FBSztBQUU3RCxZQUFJLDhCQUE4QjtBQUNsQyxZQUFJLDBCQUEwQjtBQUM5QixZQUFJLHFCQUFxQjtBQUV6QixZQUFJLGFBQWE7QUFFakIsWUFBSSwrQkFBK0I7QUFFbkMsWUFBSSxxQkFBcUI7QUFFekIsWUFBSSxvQkFBb0I7QUFDeEIsWUFBSSxrQkFBa0I7QUFDdEIsWUFBSSx3QkFBd0I7QUFFNUIsWUFBSTtBQUVKLHNEQUE4QztBQUM1QyxjQUFJLENBQUUsaUNBQWdDLE9BQU87QUFDM0M7QUFDRSxvQkFBTSxNQUFPO0FBQUE7QUFBQTtBQUlqQjtBQUNFLGdCQUFJLHVCQUF1QjtBQUN6QixvQkFBTTtBQUFBO0FBQUE7QUFJVixpQkFBTztBQUFBO0FBR1Qsb0NBQTRCLFVBQVUsVUFBVTtBQUM5QyxjQUFJLGFBQWEsTUFBTTtBQUNyQjtBQUNFLG9CQUFNLDRLQUFzTDtBQUFBO0FBRzlMLG1CQUFPO0FBQUE7QUFHVDtBQUdFLGdCQUFJLFNBQVMsV0FBVyxTQUFTLFFBQVE7QUFDdkMsb0JBQU0sc0pBQXFLLHNCQUFzQixNQUFNLFNBQVMsS0FBSyxRQUFRLEtBQUssTUFBTSxTQUFTLEtBQUssUUFBUTtBQUFBO0FBQUE7QUFJbFEsbUJBQVMsS0FBSSxHQUFHLEtBQUksU0FBUyxVQUFVLEtBQUksU0FBUyxRQUFRLE1BQUs7QUFDL0QsZ0JBQUksU0FBUyxTQUFTLEtBQUksU0FBUyxNQUFLO0FBQ3RDO0FBQUE7QUFHRixtQkFBTztBQUFBO0FBR1QsaUJBQU87QUFBQTtBQUdULDhCQUFzQjtBQUNwQixjQUFJLG9CQUFvQixHQUFHO0FBQ3pCO0FBQ0U7QUFDRSxzQkFBTSxNQUFPO0FBQUE7QUFBQTtBQUFBO0FBS25CLGlCQUFPO0FBQUEsWUFDTCxlQUFlO0FBQUEsWUFDZixPQUFPO0FBQUEsWUFDUCxNQUFNO0FBQUE7QUFBQTtBQUlWLDRDQUFvQztBQUNsQyxjQUFJLHVCQUF1QixNQUFNO0FBRS9CLGdCQUFJLDRCQUE0QixNQUFNO0FBQ3BDLDJCQUFhO0FBQ2Isd0NBQTBCLHFCQUFxQjtBQUFBLG1CQUMxQztBQUVMLDJCQUFhO0FBQ2IsbUNBQXFCO0FBQUE7QUFBQSxpQkFFbEI7QUFDTCxnQkFBSSxtQkFBbUIsU0FBUyxNQUFNO0FBQ3BDLDJCQUFhO0FBRWIsbUNBQXFCLG1CQUFtQixPQUFPO0FBQUEsbUJBQzFDO0FBRUwsMkJBQWE7QUFDYixtQ0FBcUIsbUJBQW1CO0FBQUE7QUFBQTtBQUk1QyxpQkFBTztBQUFBO0FBR1QsbUNBQTJCLG1CQUFtQjtBQUM1Qyx3Q0FBOEI7QUFFOUI7QUFDRSxvQ0FBd0I7QUFBQTtBQUFBO0FBUzVCLDZCQUFxQixXQUFXLE9BQU8sVUFBVSxjQUFjO0FBRzdELGlCQUFPLDhCQUE4QjtBQUtuQywyQ0FBK0I7QUFDL0IsaUNBQXFCO0FBRXJCLGlDQUFxQjtBQUNyQix1QkFBVyxVQUFVLE9BQU87QUFBQTtBQUc5QjtBQUNBLGlCQUFPO0FBQUE7QUFHVCxtQ0FBMkI7QUFDekI7QUFDRSxvQ0FBd0I7QUFBQTtBQUcxQix3Q0FBOEI7QUFDOUIseUNBQStCO0FBQy9CLG9DQUEwQjtBQUMxQiw4QkFBb0I7QUFDcEIsK0JBQXFCO0FBQ3JCLCtCQUFxQjtBQUFBO0FBR3ZCLDZCQUFxQixTQUFTLGNBQWM7QUFDMUMsY0FBSSxXQUFXLHVCQUF1QjtBQUN0QyxnQ0FBc0IsU0FBUztBQUUvQjtBQUNFLGdCQUFJLHVCQUF1QjtBQUN6QixvQkFBTTtBQUFBO0FBQUE7QUFJVixpQkFBTyxRQUFRO0FBQUE7QUFHakIsNkJBQW9CLFNBQVMsY0FBYztBQUN6QztBQUNFLG1DQUF1QjtBQUFBO0FBR3pCO0FBQ0EsY0FBSSxXQUFXLHVCQUF1QjtBQUN0QyxnQ0FBc0IsU0FBUztBQUMvQixpQkFBTyxRQUFRO0FBQUE7QUFHakIsbUNBQTJCLE9BQU8sUUFBUTtBQUV4QyxpQkFBTyxPQUFPLFdBQVcsYUFBYSxPQUFPLFNBQVM7QUFBQTtBQUd4RCwyQkFBa0IsY0FBYztBQUM5QjtBQUNFLG1DQUF1QjtBQUFBO0FBR3pCLGlCQUFPLFdBQVcsbUJBQ2xCO0FBQUE7QUFFRiw0QkFBb0IsU0FBUyxZQUFZLE9BQU07QUFDN0M7QUFDRSxnQkFBSSxZQUFZLG1CQUFtQjtBQUNqQyxxQ0FBdUI7QUFBQTtBQUFBO0FBSTNCLHdDQUE4QjtBQUM5QiwrQkFBcUI7QUFFckIsY0FBSSxZQUFZO0FBR2QsZ0JBQUksU0FBUSxtQkFBbUI7QUFDL0IsZ0JBQUksV0FBVyxPQUFNO0FBRXJCLGdCQUFJLHVCQUF1QixNQUFNO0FBRS9CLGtCQUFJLHlCQUF5QixtQkFBbUIsSUFBSTtBQUVwRCxrQkFBSSwyQkFBMkIsUUFBVztBQUN4QyxtQ0FBbUIsT0FBTztBQUMxQixvQkFBSSxXQUFXLG1CQUFtQjtBQUNsQyxvQkFBSSxTQUFTO0FBRWIsbUJBQUc7QUFJRCxzQkFBSSxTQUFTLE9BQU87QUFFcEI7QUFDRSw0Q0FBd0I7QUFBQTtBQUcxQiw2QkFBVyxRQUFRLFVBQVU7QUFFN0I7QUFDRSw0Q0FBd0I7QUFBQTtBQUcxQiwyQkFBUyxPQUFPO0FBQUEseUJBQ1QsV0FBVztBQUVwQixtQ0FBbUIsZ0JBQWdCO0FBQ25DLHVCQUFPLENBQUMsVUFBVTtBQUFBO0FBQUE7QUFJdEIsbUJBQU8sQ0FBQyxtQkFBbUIsZUFBZTtBQUFBLGlCQUNyQztBQUNMO0FBQ0Usc0NBQXdCO0FBQUE7QUFHMUIsZ0JBQUk7QUFFSixnQkFBSSxZQUFZLG1CQUFtQjtBQUVqQyw2QkFBZSxPQUFPLGVBQWUsYUFBYSxlQUFlO0FBQUEsbUJBQzVEO0FBQ0wsNkJBQWUsVUFBUyxTQUFZLE1BQUssY0FBYztBQUFBO0FBR3pEO0FBQ0Usc0NBQXdCO0FBQUE7QUFHMUIsK0JBQW1CLGdCQUFnQjtBQUVuQyxnQkFBSSxTQUFTLG1CQUFtQixRQUFRO0FBQUEsY0FDdEMsTUFBTTtBQUFBLGNBQ04sVUFBVTtBQUFBO0FBR1osZ0JBQUksWUFBWSxPQUFPLFdBQVcsZUFBZSxLQUFLLE1BQU0sNkJBQTZCO0FBRXpGLG1CQUFPLENBQUMsbUJBQW1CLGVBQWU7QUFBQTtBQUFBO0FBSTlDLDBCQUFpQixZQUFZLE1BQU07QUFDakMsd0NBQThCO0FBQzlCLCtCQUFxQjtBQUNyQixjQUFJLFdBQVcsU0FBUyxTQUFZLE9BQU87QUFFM0MsY0FBSSx1QkFBdUIsTUFBTTtBQUMvQixnQkFBSSxZQUFZLG1CQUFtQjtBQUVuQyxnQkFBSSxjQUFjLE1BQU07QUFDdEIsa0JBQUksYUFBYSxNQUFNO0FBQ3JCLG9CQUFJLFdBQVcsVUFBVTtBQUV6QixvQkFBSSxtQkFBbUIsVUFBVSxXQUFXO0FBQzFDLHlCQUFPLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU16QjtBQUNFLG9DQUF3QjtBQUFBO0FBRzFCLGNBQUksWUFBWTtBQUVoQjtBQUNFLG9DQUF3QjtBQUFBO0FBRzFCLDZCQUFtQixnQkFBZ0IsQ0FBQyxXQUFXO0FBQy9DLGlCQUFPO0FBQUE7QUFHVCx5QkFBZ0IsY0FBYztBQUM1Qix3Q0FBOEI7QUFDOUIsK0JBQXFCO0FBQ3JCLGNBQUksY0FBYyxtQkFBbUI7QUFFckMsY0FBSSxnQkFBZ0IsTUFBTTtBQUN4QixnQkFBSSxNQUFNO0FBQUEsY0FDUixTQUFTO0FBQUE7QUFHWDtBQUNFLHFCQUFPLEtBQUs7QUFBQTtBQUdkLCtCQUFtQixnQkFBZ0I7QUFDbkMsbUJBQU87QUFBQSxpQkFDRjtBQUNMLG1CQUFPO0FBQUE7QUFBQTtBQUlYLGtDQUF5QixRQUFRLFFBQVE7QUFDdkM7QUFDRSxtQ0FBdUI7QUFFdkIsa0JBQU07QUFBQTtBQUFBO0FBSVYsZ0NBQXdCLG1CQUFtQixRQUFPLFFBQVE7QUFDeEQsY0FBSSxDQUFFLHFCQUFvQixrQkFBa0I7QUFDMUM7QUFDRSxvQkFBTSxNQUFPO0FBQUE7QUFBQTtBQUlqQixjQUFJLHNCQUFzQiw2QkFBNkI7QUFJckQsMkNBQStCO0FBQy9CLGdCQUFJLFNBQVM7QUFBQSxjQUNYO0FBQUEsY0FDQSxNQUFNO0FBQUE7QUFHUixnQkFBSSx1QkFBdUIsTUFBTTtBQUMvQixtQ0FBcUIsSUFBSTtBQUFBO0FBRzNCLGdCQUFJLHlCQUF5QixtQkFBbUIsSUFBSTtBQUVwRCxnQkFBSSwyQkFBMkIsUUFBVztBQUN4QyxpQ0FBbUIsSUFBSSxRQUFPO0FBQUEsbUJBQ3pCO0FBRUwsa0JBQUksd0JBQXdCO0FBRTVCLHFCQUFPLHNCQUFzQixTQUFTLE1BQU07QUFDMUMsd0NBQXdCLHNCQUFzQjtBQUFBO0FBR2hELG9DQUFzQixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBS25DLDhCQUFxQixVQUFVLE1BQU07QUFDbkMsaUJBQU8sU0FBUSxXQUFZO0FBQ3pCLG1CQUFPO0FBQUEsYUFDTjtBQUFBO0FBS0wsa0NBQTBCLFFBQVEsYUFBYSxXQUFXO0FBQ3hEO0FBQ0EsaUJBQU8sWUFBWSxPQUFPO0FBQUE7QUFHNUIsa0NBQTBCLE9BQU87QUFDL0I7QUFDQSxpQkFBTztBQUFBO0FBR1Qsa0NBQXlCO0FBQ3ZCO0FBRUEsY0FBSSxrQkFBa0IsU0FBVSxVQUFVO0FBQ3hDO0FBQUE7QUFHRixpQkFBTyxDQUFDLGlCQUFpQjtBQUFBO0FBRzNCLHVDQUErQjtBQUM3QixpQkFBUSx3QkFBdUIsb0JBQW9CLE1BQU0sT0FBUSx3QkFBdUIsWUFBWSxTQUFTO0FBQUE7QUFHL0cseUJBQWdCO0FBQUE7QUFFaEIsWUFBSSx5QkFBeUI7QUFDN0IsMkNBQW1DLFVBQVU7QUFDM0MsbUNBQXlCO0FBQUE7QUFFM0IsWUFBSSxhQUFhO0FBQUEsVUFDZjtBQUFBLFVBQ0EsWUFBWTtBQUFBLFVBQ1osU0FBUztBQUFBLFVBQ1Q7QUFBQSxVQUNBLFFBQVE7QUFBQSxVQUNSLFVBQVU7QUFBQSxVQUNWLGlCQUFpQjtBQUFBLFVBQ2pCLGFBQWE7QUFBQSxVQUViLHFCQUFxQjtBQUFBLFVBRXJCLFdBQVc7QUFBQSxVQUVYLGVBQWU7QUFBQSxVQUNmO0FBQUEsVUFDQSxlQUFlO0FBQUEsVUFDZjtBQUFBLFVBRUE7QUFBQTtBQUdGLFlBQUksaUJBQWlCO0FBQ3JCLFlBQUksaUJBQWlCO0FBQ3JCLFlBQUksZ0JBQWdCO0FBQ3BCLFlBQUksYUFBYTtBQUFBLFVBQ2YsTUFBTTtBQUFBLFVBQ04sUUFBUTtBQUFBLFVBQ1IsS0FBSztBQUFBO0FBR1AsdUNBQStCLE1BQU07QUFDbkMsa0JBQVE7QUFBQSxpQkFDRDtBQUNILHFCQUFPO0FBQUEsaUJBRUo7QUFDSCxxQkFBTztBQUFBO0FBR1AscUJBQU87QUFBQTtBQUFBO0FBR2IsbUNBQTJCLGlCQUFpQixNQUFNO0FBQ2hELGNBQUksbUJBQW1CLFFBQVEsb0JBQW9CLGdCQUFnQjtBQUVqRSxtQkFBTyxzQkFBc0I7QUFBQTtBQUcvQixjQUFJLG9CQUFvQixpQkFBaUIsU0FBUyxpQkFBaUI7QUFFakUsbUJBQU87QUFBQTtBQUlULGlCQUFPO0FBQUE7QUFHVCxZQUFJLG1CQUFtQjtBQUFBLFVBQ3JCLFFBQVE7QUFBQSxVQUNSLFVBQVU7QUFBQSxVQUNWLE9BQU87QUFBQSxVQUNQLFFBQVE7QUFBQSxVQUNSLE9BQU87QUFBQSxVQUNQLE9BQU87QUFBQSxVQUNQLFFBQVE7QUFBQTtBQUVWLDJDQUFtQyxTQUFTLE9BQU87QUFDakQ7QUFDRSxnQkFBSSxDQUFFLGtCQUFpQixNQUFNLFNBQVMsTUFBTSxZQUFZLE1BQU0sV0FBVyxNQUFNLFlBQVksTUFBTSxZQUFZLE1BQU0sU0FBUyxPQUFPO0FBQ2pJLG9CQUFNO0FBQUE7QUFHUixnQkFBSSxDQUFFLE9BQU0sWUFBWSxNQUFNLFlBQVksTUFBTSxZQUFZLE1BQU0sV0FBVyxPQUFPO0FBQ2xGLG9CQUFNO0FBQUE7QUFBQTtBQUFBO0FBT1osWUFBSSxtQkFBbUI7QUFBQSxVQUNyQixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixJQUFJO0FBQUEsVUFDSixLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxJQUFJO0FBQUEsVUFDSixLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUE7QUFNUCxZQUFJLGtCQUFrQixRQUFRO0FBQUEsVUFDNUIsVUFBVTtBQUFBLFdBQ1Q7QUFFSCxZQUFJLE9BQU87QUFFWCxrQ0FBMEIsS0FBSyxPQUFPO0FBQ3BDLGNBQUksQ0FBQyxPQUFPO0FBQ1Y7QUFBQTtBQUlGLGNBQUksZ0JBQWdCLE1BQU07QUFDeEIsZ0JBQUksQ0FBRSxPQUFNLFlBQVksUUFBUSxNQUFNLDJCQUEyQixPQUFPO0FBQ3RFO0FBQ0Usc0JBQU0sTUFBTyxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBS3pCLGNBQUksTUFBTSwyQkFBMkIsTUFBTTtBQUN6QyxnQkFBSSxDQUFFLE9BQU0sWUFBWSxPQUFPO0FBQzdCO0FBQ0Usc0JBQU0sTUFBTztBQUFBO0FBQUE7QUFJakIsZ0JBQUksQ0FBRSxRQUFPLE1BQU0sNEJBQTRCLFlBQVksUUFBUSxNQUFNLDBCQUEwQjtBQUNqRztBQUNFLHNCQUFNLE1BQU87QUFBQTtBQUFBO0FBQUE7QUFLbkI7QUFDRSxnQkFBSSxDQUFDLE1BQU0sa0NBQWtDLE1BQU0sbUJBQW1CLE1BQU0sWUFBWSxNQUFNO0FBQzVGLG9CQUFNO0FBQUE7QUFBQTtBQUlWLGNBQUksQ0FBRSxPQUFNLFNBQVMsUUFBUSxPQUFPLE1BQU0sVUFBVSxXQUFXO0FBQzdEO0FBQ0Usb0JBQU0sTUFBTztBQUFBO0FBQUE7QUFBQTtBQVFuQixZQUFJLG1CQUFtQjtBQUFBLFVBQ3JCLHlCQUF5QjtBQUFBLFVBQ3pCLG1CQUFtQjtBQUFBLFVBQ25CLGtCQUFrQjtBQUFBLFVBQ2xCLGtCQUFrQjtBQUFBLFVBQ2xCLFNBQVM7QUFBQSxVQUNULGNBQWM7QUFBQSxVQUNkLGlCQUFpQjtBQUFBLFVBQ2pCLGFBQWE7QUFBQSxVQUNiLFNBQVM7QUFBQSxVQUNULE1BQU07QUFBQSxVQUNOLFVBQVU7QUFBQSxVQUNWLGNBQWM7QUFBQSxVQUNkLFlBQVk7QUFBQSxVQUNaLGNBQWM7QUFBQSxVQUNkLFdBQVc7QUFBQSxVQUNYLFVBQVU7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULFlBQVk7QUFBQSxVQUNaLGFBQWE7QUFBQSxVQUNiLGNBQWM7QUFBQSxVQUNkLFlBQVk7QUFBQSxVQUNaLGVBQWU7QUFBQSxVQUNmLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFVBQ2pCLFlBQVk7QUFBQSxVQUNaLFdBQVc7QUFBQSxVQUNYLFlBQVk7QUFBQSxVQUNaLFNBQVM7QUFBQSxVQUNULE9BQU87QUFBQSxVQUNQLFNBQVM7QUFBQSxVQUNULFNBQVM7QUFBQSxVQUNULFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLE1BQU07QUFBQSxVQUVOLGFBQWE7QUFBQSxVQUNiLGNBQWM7QUFBQSxVQUNkLGFBQWE7QUFBQSxVQUNiLGlCQUFpQjtBQUFBLFVBQ2pCLGtCQUFrQjtBQUFBLFVBQ2xCLGtCQUFrQjtBQUFBLFVBQ2xCLGVBQWU7QUFBQSxVQUNmLGFBQWE7QUFBQTtBQVNmLDJCQUFtQixTQUFRLEtBQUs7QUFDOUIsaUJBQU8sVUFBUyxJQUFJLE9BQU8sR0FBRyxnQkFBZ0IsSUFBSSxVQUFVO0FBQUE7QUFROUQsWUFBSSxXQUFXLENBQUMsVUFBVSxNQUFNLE9BQU87QUFHdkMsZUFBTyxLQUFLLGtCQUFrQixRQUFRLFNBQVUsTUFBTTtBQUNwRCxtQkFBUyxRQUFRLFNBQVUsU0FBUTtBQUNqQyw2QkFBaUIsVUFBVSxTQUFRLFNBQVMsaUJBQWlCO0FBQUE7QUFBQTtBQWNqRSxxQ0FBNkIsTUFBTSxPQUFPLGtCQUFrQjtBQVUxRCxjQUFJLFVBQVUsU0FBUyxRQUFRLE9BQU8sVUFBVSxhQUFhLFVBQVU7QUFFdkUsY0FBSSxTQUFTO0FBQ1gsbUJBQU87QUFBQTtBQUdULGNBQUksQ0FBQyxvQkFBb0IsT0FBTyxVQUFVLFlBQVksVUFBVSxLQUFLLENBQUUsa0JBQWlCLGVBQWUsU0FBUyxpQkFBaUIsUUFBUTtBQUN2SSxtQkFBTyxRQUFRO0FBQUE7QUFHakIsaUJBQVEsTUFBSyxPQUFPO0FBQUE7QUFHdEIsWUFBSSxtQkFBbUI7QUFDdkIsWUFBSSxZQUFZO0FBZWhCLG9DQUE0QixNQUFNO0FBQ2hDLGlCQUFPLEtBQUssUUFBUSxrQkFBa0IsT0FBTyxjQUFjLFFBQVEsV0FBVztBQUFBO0FBR2hGLG1DQUEyQixTQUFTLE9BQU87QUFDekMsY0FBSSxRQUFRLFFBQVEsU0FBUyxJQUFJO0FBQy9CLG1CQUFPLE9BQU8sTUFBTSxPQUFPO0FBQUE7QUFHN0Isa0JBQVE7QUFBQSxpQkFLRDtBQUFBLGlCQUNBO0FBQUEsaUJBQ0E7QUFBQSxpQkFDQTtBQUFBLGlCQUNBO0FBQUEsaUJBQ0E7QUFBQSxpQkFDQTtBQUFBLGlCQUNBO0FBQ0gscUJBQU87QUFBQTtBQUdQLHFCQUFPO0FBQUE7QUFBQTtBQUliLFlBQUksaUJBQWlCLFdBQVk7QUFBQTtBQUVqQztBQUVFLGNBQUksOEJBQThCO0FBQ2xDLGNBQUksY0FBYztBQUNsQixjQUFJLGdCQUFnQjtBQUVwQixjQUFJLG9DQUFvQztBQUN4QyxjQUFJLG1CQUFtQjtBQUN2QixjQUFJLG9CQUFvQjtBQUN4QixjQUFJLG9CQUFvQjtBQUN4QixjQUFJLHlCQUF5QjtBQUU3QixjQUFJLFdBQVcsU0FBVSxRQUFRO0FBQy9CLG1CQUFPLE9BQU8sUUFBUSxlQUFlLFNBQVUsR0FBRyxXQUFXO0FBQzNELHFCQUFPLFVBQVU7QUFBQTtBQUFBO0FBSXJCLGNBQUksMEJBQTBCLFNBQVUsTUFBTTtBQUM1QyxnQkFBSSxpQkFBaUIsZUFBZSxTQUFTLGlCQUFpQixPQUFPO0FBQ25FO0FBQUE7QUFHRiw2QkFBaUIsUUFBUTtBQUV6QixrQkFBTSxtREFBbUQsTUFHekQsU0FBUyxLQUFLLFFBQVEsYUFBYTtBQUFBO0FBR3JDLGNBQUksMkJBQTJCLFNBQVUsTUFBTTtBQUM3QyxnQkFBSSxpQkFBaUIsZUFBZSxTQUFTLGlCQUFpQixPQUFPO0FBQ25FO0FBQUE7QUFHRiw2QkFBaUIsUUFBUTtBQUV6QixrQkFBTSxtRUFBbUUsTUFBTSxLQUFLLE9BQU8sR0FBRyxnQkFBZ0IsS0FBSyxNQUFNO0FBQUE7QUFHM0gsY0FBSSw4QkFBOEIsU0FBVSxNQUFNLE9BQU87QUFDdkQsZ0JBQUksa0JBQWtCLGVBQWUsVUFBVSxrQkFBa0IsUUFBUTtBQUN2RTtBQUFBO0FBR0YsOEJBQWtCLFNBQVM7QUFFM0Isa0JBQU0sOEVBQW1GLE1BQU0sTUFBTSxRQUFRLG1DQUFtQztBQUFBO0FBR2xKLGNBQUksc0JBQXNCLFNBQVUsTUFBTSxPQUFPO0FBQy9DLGdCQUFJLG1CQUFtQjtBQUNyQjtBQUFBO0FBR0YsZ0NBQW9CO0FBRXBCLGtCQUFNLDhEQUE4RDtBQUFBO0FBR3RFLGNBQUksMkJBQTJCLFNBQVUsTUFBTSxPQUFPO0FBQ3BELGdCQUFJLHdCQUF3QjtBQUMxQjtBQUFBO0FBR0YscUNBQXlCO0FBRXpCLGtCQUFNLG1FQUFtRTtBQUFBO0FBRzNFLDJCQUFpQixTQUFVLE1BQU0sT0FBTztBQUN0QyxnQkFBSSxLQUFLLFFBQVEsT0FBTyxJQUFJO0FBQzFCLHNDQUF3QjtBQUFBLHVCQUNmLDRCQUE0QixLQUFLLE9BQU87QUFDakQsdUNBQXlCO0FBQUEsdUJBQ2hCLGtDQUFrQyxLQUFLLFFBQVE7QUFDeEQsMENBQTRCLE1BQU07QUFBQTtBQUdwQyxnQkFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixrQkFBSSxNQUFNLFFBQVE7QUFDaEIsb0NBQW9CLE1BQU07QUFBQSx5QkFDakIsQ0FBQyxTQUFTLFFBQVE7QUFDM0IseUNBQXlCLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU12QyxZQUFJLG1CQUFtQjtBQUV2QixZQUFJLGlCQUFpQjtBQUFBLFVBQ25CLGdCQUFnQjtBQUFBLFVBRWhCLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFVBRWpCLGVBQWU7QUFBQSxVQUVmLGdCQUFnQjtBQUFBLFVBRWhCLHFCQUFxQjtBQUFBLFVBQ3JCLGNBQWM7QUFBQSxVQUNkLHdCQUF3QjtBQUFBLFVBRXhCLHFCQUFxQjtBQUFBLFVBQ3JCLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGNBQWM7QUFBQSxVQUNkLGNBQWM7QUFBQSxVQUNkLGtCQUFrQjtBQUFBLFVBQ2xCLHdCQUF3QjtBQUFBLFVBQ3hCLG9CQUFvQjtBQUFBLFVBQ3BCLG9CQUFvQjtBQUFBLFVBQ3BCLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGFBQWE7QUFBQSxVQUNiLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGtCQUFrQjtBQUFBLFVBRWxCLGVBQWU7QUFBQSxVQUNmLGFBQWE7QUFBQSxVQUNiLGFBQWE7QUFBQSxVQUNiLGlCQUFpQjtBQUFBLFVBRWpCLG1CQUFtQjtBQUFBLFVBQ25CLGdCQUFnQjtBQUFBLFVBRWhCLHlCQUF5QjtBQUFBLFVBQ3pCLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFVBQ2pCLG9CQUFvQjtBQUFBLFVBQ3BCLHFCQUFxQjtBQUFBLFVBQ3JCLGVBQWU7QUFBQSxVQUNmLG1CQUFtQjtBQUFBLFVBQ25CLGFBQWE7QUFBQSxVQUNiLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGdCQUFnQjtBQUFBLFVBQ2hCLGdCQUFnQjtBQUFBO0FBR2xCLFlBQUksbUJBQW1CO0FBQ3ZCLFlBQUksUUFBUSxJQUFJLE9BQU8sY0FBYyxzQkFBc0I7QUFDM0QsWUFBSSxhQUFhLElBQUksT0FBTyxrQkFBa0Isc0JBQXNCO0FBQ3BFLFlBQUksbUJBQW1CLE9BQU8sVUFBVTtBQUV4QyxrQ0FBMEIsU0FBUyxNQUFNO0FBQ3ZDO0FBQ0UsZ0JBQUksaUJBQWlCLEtBQUssa0JBQWtCLFNBQVMsaUJBQWlCLE9BQU87QUFDM0UscUJBQU87QUFBQTtBQUdULGdCQUFJLFdBQVcsS0FBSyxPQUFPO0FBQ3pCLGtCQUFJLFdBQVcsVUFBVSxLQUFLLE1BQU0sR0FBRztBQUN2QyxrQkFBSSxjQUFjLGVBQWUsZUFBZSxZQUFZLFdBQVc7QUFHdkUsa0JBQUksZUFBZSxNQUFNO0FBQ3ZCLHNCQUFNLGlHQUFpRztBQUV2RyxpQ0FBaUIsUUFBUTtBQUN6Qix1QkFBTztBQUFBO0FBSVQsa0JBQUksU0FBUyxhQUFhO0FBQ3hCLHNCQUFNLG1EQUFtRCxNQUFNO0FBRS9ELGlDQUFpQixRQUFRO0FBQ3pCLHVCQUFPO0FBQUE7QUFBQTtBQUlYLGdCQUFJLE1BQU0sS0FBSyxPQUFPO0FBQ3BCLGtCQUFJLGlCQUFpQixLQUFLO0FBQzFCLGtCQUFJLGVBQWUsZUFBZSxlQUFlLGtCQUFrQixpQkFBaUI7QUFHcEYsa0JBQUksZ0JBQWdCLE1BQU07QUFDeEIsaUNBQWlCLFFBQVE7QUFDekIsdUJBQU87QUFBQTtBQUlULGtCQUFJLFNBQVMsY0FBYztBQUN6QixzQkFBTSxtREFBbUQsTUFBTTtBQUUvRCxpQ0FBaUIsUUFBUTtBQUN6Qix1QkFBTztBQUFBO0FBQUE7QUFBQTtBQUtiLGlCQUFPO0FBQUE7QUFHVCxzQ0FBOEIsTUFBTSxPQUFPO0FBQ3pDO0FBQ0UsZ0JBQUksZUFBZTtBQUVuQixxQkFBUyxPQUFPLE9BQU87QUFDckIsa0JBQUksVUFBVSxpQkFBaUIsTUFBTTtBQUVyQyxrQkFBSSxDQUFDLFNBQVM7QUFDWiw2QkFBYSxLQUFLO0FBQUE7QUFBQTtBQUl0QixnQkFBSSxvQkFBb0IsYUFBYSxJQUFJLFNBQVUsTUFBTTtBQUN2RCxxQkFBTyxNQUFNLE9BQU87QUFBQSxlQUNuQixLQUFLO0FBRVIsZ0JBQUksYUFBYSxXQUFXLEdBQUc7QUFDN0Isb0JBQU0sa0dBQXVHLG1CQUFtQjtBQUFBLHVCQUN2SCxhQUFhLFNBQVMsR0FBRztBQUNsQyxvQkFBTSxtR0FBd0csbUJBQW1CO0FBQUE7QUFBQTtBQUFBO0FBS3ZJLG9DQUE0QixNQUFNLE9BQU87QUFDdkMsY0FBSSxrQkFBa0IsTUFBTSxRQUFRO0FBQ2xDO0FBQUE7QUFHRiwrQkFBcUIsTUFBTTtBQUFBO0FBRzdCLFlBQUksbUJBQW1CO0FBQ3ZCLHNDQUE4QixNQUFNLE9BQU87QUFDekM7QUFDRSxnQkFBSSxTQUFTLFdBQVcsU0FBUyxjQUFjLFNBQVMsVUFBVTtBQUNoRTtBQUFBO0FBR0YsZ0JBQUksU0FBUyxRQUFRLE1BQU0sVUFBVSxRQUFRLENBQUMsa0JBQWtCO0FBQzlELGlDQUFtQjtBQUVuQixrQkFBSSxTQUFTLFlBQVksTUFBTSxVQUFVO0FBQ3ZDLHNCQUFNLDhLQUF3TDtBQUFBLHFCQUN6TDtBQUNMLHNCQUFNLDhJQUF3SjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU3RLLFlBQUksd0JBQXdCO0FBQUEsVUFFMUIsUUFBUTtBQUFBLFVBQ1IsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsV0FBVztBQUFBLFVBQ1gsUUFBUTtBQUFBLFVBQ1IsaUJBQWlCO0FBQUEsVUFDakIsS0FBSztBQUFBLFVBQ0wsSUFBSTtBQUFBLFVBQ0osT0FBTztBQUFBLFVBQ1AsZ0JBQWdCO0FBQUEsVUFDaEIsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsV0FBVztBQUFBLFVBQ1gsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsYUFBYTtBQUFBLFVBQ2IsYUFBYTtBQUFBLFVBQ2IsV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsaUJBQWlCO0FBQUEsVUFDakIsYUFBYTtBQUFBLFVBQ2IsVUFBVTtBQUFBLFVBQ1YsY0FBYztBQUFBLFVBQ2QsUUFBUTtBQUFBLFVBQ1IsYUFBYTtBQUFBLFVBQ2IseUJBQXlCO0FBQUEsVUFDekIsTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsZ0JBQWdCO0FBQUEsVUFDaEIsY0FBYztBQUFBLFVBQ2QsT0FBTztBQUFBLFVBQ1AsS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YseUJBQXlCO0FBQUEsVUFDekIsdUJBQXVCO0FBQUEsVUFDdkIsVUFBVTtBQUFBLFVBQ1YsV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsY0FBYztBQUFBLFVBQ2QsS0FBSztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1osYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsWUFBWTtBQUFBLFVBQ1osYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsTUFBTTtBQUFBLFVBQ04sSUFBSTtBQUFBLFVBQ0osV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsSUFBSTtBQUFBLFVBQ0osUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsVUFBVTtBQUFBLFVBQ1YsV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsS0FBSztBQUFBLFVBQ0wsV0FBVztBQUFBLFVBQ1gsT0FBTztBQUFBLFVBQ1AsWUFBWTtBQUFBLFVBQ1osUUFBUTtBQUFBLFVBQ1IsS0FBSztBQUFBLFVBQ0wsV0FBVztBQUFBLFVBQ1gsVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsWUFBWTtBQUFBLFVBQ1osTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsYUFBYTtBQUFBLFVBQ2IsYUFBYTtBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osVUFBVTtBQUFBLFVBQ1YsZ0JBQWdCO0FBQUEsVUFDaEIsS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFVBQ1osS0FBSztBQUFBLFVBQ0wsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBRU4sT0FBTztBQUFBLFVBQ1AsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsWUFBWTtBQUFBLFVBQ1osVUFBVTtBQUFBLFVBQ1YsbUJBQW1CO0FBQUEsVUFDbkIsc0JBQXNCO0FBQUEsVUFDdEIsY0FBYztBQUFBLFVBQ2QsWUFBWTtBQUFBLFVBQ1osV0FBVztBQUFBLFVBQ1gsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsUUFBUTtBQUFBLFVBQ1IsZUFBZTtBQUFBLFVBQ2YsZUFBZTtBQUFBLFVBQ2YsYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFVBQ1QsZUFBZTtBQUFBLFVBQ2YsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsYUFBYTtBQUFBLFVBQ2IsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sSUFBSTtBQUFBLFVBQ0osVUFBVTtBQUFBLFVBQ1YsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsZUFBZTtBQUFBLFVBQ2YsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsT0FBTztBQUFBLFVBQ1Asb0JBQW9CO0FBQUEsVUFDcEIsdUJBQXVCO0FBQUEsVUFDdkIsMkJBQTJCO0FBQUEsVUFDM0IsK0JBQStCO0FBQUEsVUFDL0IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsbUJBQW1CO0FBQUEsVUFDbkIsa0JBQWtCO0FBQUEsVUFDbEIsUUFBUTtBQUFBLFVBQ1IsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osR0FBRztBQUFBLFVBQ0gsVUFBVTtBQUFBLFVBQ1YsWUFBWTtBQUFBLFVBQ1osU0FBUztBQUFBLFVBQ1QsaUJBQWlCO0FBQUEsVUFDakIsV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1Qsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0wsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osVUFBVTtBQUFBLFVBQ1YsV0FBVztBQUFBLFVBQ1gsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsMkJBQTJCO0FBQUEsVUFDM0IsTUFBTTtBQUFBLFVBQ04sYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsV0FBVztBQUFBLFVBQ1gsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsb0JBQW9CO0FBQUEsVUFDcEIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsNEJBQTRCO0FBQUEsVUFDNUIsZ0NBQWdDO0FBQUEsVUFDaEMsMEJBQTBCO0FBQUEsVUFDMUIsOEJBQThCO0FBQUEsVUFDOUIsVUFBVTtBQUFBLFVBQ1YsbUJBQW1CO0FBQUEsVUFDbkIsZUFBZTtBQUFBLFVBQ2YsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsZUFBZTtBQUFBLFVBQ2YsY0FBYztBQUFBLFVBQ2Qsa0JBQWtCO0FBQUEsVUFDbEIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsS0FBSztBQUFBLFVBQ0wsSUFBSTtBQUFBLFVBQ0osUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osR0FBRztBQUFBLFVBQ0gsY0FBYztBQUFBLFVBQ2Qsa0JBQWtCO0FBQUEsVUFDbEIsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsWUFBWTtBQUFBLFVBQ1osVUFBVTtBQUFBLFVBQ1YsY0FBYztBQUFBLFVBQ2QsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsbUJBQW1CO0FBQUEsVUFDbkIsT0FBTztBQUFBLFVBQ1AsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsY0FBYztBQUFBLFVBQ2QsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsYUFBYTtBQUFBLFVBQ2IsYUFBYTtBQUFBLFVBQ2IsTUFBTTtBQUFBLFVBQ04sa0JBQWtCO0FBQUEsVUFDbEIsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFVBQ1osUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsYUFBYTtBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1Ysa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsbUJBQW1CO0FBQUEsVUFDbkIsc0JBQXNCO0FBQUEsVUFDdEIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1oscUJBQXFCO0FBQUEsVUFDckIsa0JBQWtCO0FBQUEsVUFDbEIsY0FBYztBQUFBLFVBQ2QsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsV0FBVztBQUFBLFVBQ1gsUUFBUTtBQUFBLFVBQ1IsZUFBZTtBQUFBLFVBQ2YscUJBQXFCO0FBQUEsVUFDckIsZ0JBQWdCO0FBQUEsVUFDaEIsVUFBVTtBQUFBLFVBQ1YsR0FBRztBQUFBLFVBQ0gsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04saUJBQWlCO0FBQUEsVUFDakIsb0JBQW9CO0FBQUEsVUFDcEIsYUFBYTtBQUFBLFVBQ2IsV0FBVztBQUFBLFVBQ1gsb0JBQW9CO0FBQUEsVUFDcEIsa0JBQWtCO0FBQUEsVUFDbEIsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osT0FBTztBQUFBLFVBQ1AsVUFBVTtBQUFBLFVBQ1YsTUFBTTtBQUFBLFVBQ04sZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1Qsa0JBQWtCO0FBQUEsVUFDbEIsa0JBQWtCO0FBQUEsVUFDbEIsT0FBTztBQUFBLFVBQ1AsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsYUFBYTtBQUFBLFVBQ2IsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsdUJBQXVCO0FBQUEsVUFDdkIsMEJBQTBCO0FBQUEsVUFDMUIsd0JBQXdCO0FBQUEsVUFDeEIsMkJBQTJCO0FBQUEsVUFDM0IsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsaUJBQWlCO0FBQUEsVUFDakIsb0JBQW9CO0FBQUEsVUFDcEIsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsa0JBQWtCO0FBQUEsVUFDbEIscUJBQXFCO0FBQUEsVUFDckIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsZ0NBQWdDO0FBQUEsVUFDaEMsMEJBQTBCO0FBQUEsVUFDMUIsY0FBYztBQUFBLFVBQ2QsZ0JBQWdCO0FBQUEsVUFDaEIsYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsZ0JBQWdCO0FBQUEsVUFDaEIsbUJBQW1CO0FBQUEsVUFDbkIsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsSUFBSTtBQUFBLFVBQ0osV0FBVztBQUFBLFVBQ1gsUUFBUTtBQUFBLFVBQ1IsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osbUJBQW1CO0FBQUEsVUFDbkIsc0JBQXNCO0FBQUEsVUFDdEIsb0JBQW9CO0FBQUEsVUFDcEIsdUJBQXVCO0FBQUEsVUFDdkIsU0FBUztBQUFBLFVBQ1QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsWUFBWTtBQUFBLFVBQ1osZ0JBQWdCO0FBQUEsVUFDaEIsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsUUFBUTtBQUFBLFVBQ1IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsY0FBYztBQUFBLFVBQ2QsYUFBYTtBQUFBLFVBQ2IsaUJBQWlCO0FBQUEsVUFDakIsYUFBYTtBQUFBLFVBQ2IsaUJBQWlCO0FBQUEsVUFDakIsVUFBVTtBQUFBLFVBQ1YsYUFBYTtBQUFBLFVBQ2IsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2Ysa0JBQWtCO0FBQUEsVUFDbEIsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsYUFBYTtBQUFBLFVBQ2IsZ0JBQWdCO0FBQUEsVUFDaEIsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osR0FBRztBQUFBLFVBQ0gsa0JBQWtCO0FBQUEsVUFDbEIsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsY0FBYztBQUFBLFVBQ2QsaUJBQWlCO0FBQUEsVUFDakIsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsV0FBVztBQUFBLFVBQ1gsY0FBYztBQUFBLFVBQ2QsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osT0FBTztBQUFBLFVBQ1AsYUFBYTtBQUFBLFVBQ2IsWUFBWTtBQUFBLFVBQ1osZUFBZTtBQUFBLFVBQ2YsVUFBVTtBQUFBLFVBQ1YsSUFBSTtBQUFBLFVBQ0osSUFBSTtBQUFBLFVBQ0osR0FBRztBQUFBLFVBQ0gsa0JBQWtCO0FBQUEsVUFDbEIsR0FBRztBQUFBLFVBQ0gsWUFBWTtBQUFBO0FBR2QsWUFBSSxxQkFBcUIsV0FBWTtBQUFBO0FBRXJDO0FBQ0UsY0FBSSxxQkFBcUI7QUFDekIsY0FBSSxrQkFBa0IsT0FBTyxVQUFV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
